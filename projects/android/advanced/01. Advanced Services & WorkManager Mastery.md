---
canonical_id: "android-advanced-project-01"
slug: "advanced-services-workmanager-mastery"
title: "Advanced Services & WorkManager Mastery"
description: "Master Android Services and WorkManager through a series of progressively challenging tasks. Build a production-ready background task management system with foreground services, bound services, job scheduling, and complex work chains."
level: "advanced"
topic: "android"
estimated_hours: 20
topics_covered: "Services, WorkManager, Foreground Services, Bound Services, Job Scheduling, Background Processing, Notification Management, Process Lifecycle"
prerequisites: ["android-intermediate-14", "android-intermediate-13"]
---

# Advanced Services & WorkManager Mastery Project

## Project Overview

Build a comprehensive **Background Task Management System** that demonstrates mastery of Android Services and WorkManager. This project consists of multiple challenges that progressively increase in complexity, testing your understanding of Android's background processing capabilities.

### Project Requirements

You will build an app that:
- Manages multiple types of background tasks
- Handles foreground services with persistent notifications
- Implements bound services for inter-process communication
- Uses WorkManager for scheduled and chained work
- Handles system constraints and battery optimization
- Manages process lifecycle and service binding
- Implements proper error handling and retry logic

### Prerequisites

Before starting, ensure you understand:
- Android Service lifecycle
- WorkManager fundamentals
- Notification channels and foreground services
- Process and thread management
- Android permissions and battery optimization

---

## Challenge 1: Basic Foreground Service Setup (Easy)

**Estimated Time:** 1 hour  
**Difficulty:** Easy  
**Status:** â¬œ Not Started

### Objective
Create a foreground service that runs continuously and displays a persistent notification.

### Requirements
1. Create a `ForegroundTaskService` that extends `Service`
2. Implement `onStartCommand()` to handle service start
3. Create a notification channel for Android 8.0+
4. Start the service as foreground with `startForeground()`
5. Display a notification showing service status
6. Handle service stop and cleanup

### Step-by-Step Instructions

#### Step 1.1: Create Notification Channel
```kotlin
// In Application class or MainActivity
private fun createNotificationChannel() {
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
        val channel = NotificationChannel(
            CHANNEL_ID,
            "Foreground Service Channel",
            NotificationManager.IMPORTANCE_LOW
        ).apply {
            description = "Channel for foreground service notifications"
        }
        val notificationManager = getSystemService(NotificationManager::class.java)
        notificationManager.createNotificationChannel(channel)
    }
}
```

#### Step 1.2: Create Foreground Service
```kotlin
class ForegroundTaskService : Service() {
    companion object {
        const val CHANNEL_ID = "ForegroundServiceChannel"
        const val NOTIFICATION_ID = 1
    }
    
    override fun onBind(intent: Intent?): IBinder? = null
    
    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
        // TODO: Create notification
        // TODO: Start foreground service
        return START_STICKY
    }
    
    override fun onDestroy() {
        super.onDestroy()
        // TODO: Cleanup resources
    }
}
```

#### Step 1.3: Start Service from Activity
```kotlin
val serviceIntent = Intent(this, ForegroundTaskService::class.java)
if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
    startForegroundService(serviceIntent)
} else {
    startService(serviceIntent)
}
```

### Hints
- Use `NotificationCompat.Builder` for compatibility
- Remember to request `FOREGROUND_SERVICE` permission in manifest
- Set `android:foregroundServiceType` for Android 14+

### Guide References
- [Android Services - Complete Guide](../../../android/02_intermediate/14.%20Android%20Services%20-%20Complete%20Guide.md) - Sections: Foreground Services, Notification Setup

### Completion Criteria
- [ ] Service starts as foreground successfully
- [ ] Notification appears and persists
- [ ] Service survives app backgrounding
- [ ] Service can be stopped properly

---

## Challenge 2: Service with Background Threading (Easy)

**Estimated Time:** 1.5 hours  
**Difficulty:** Easy  
**Status:** â¬œ Not Started

### Objective
Enhance the foreground service to perform background work on a separate thread without blocking the main thread.

### Requirements
1. Create a background thread using `HandlerThread`
2. Perform CPU-intensive work without blocking UI
3. Update notification with progress
4. Handle thread lifecycle properly
5. Implement proper thread cleanup

### Step-by-Step Instructions

#### Step 2.1: Create HandlerThread
```kotlin
class ForegroundTaskService : Service() {
    private var handlerThread: HandlerThread? = null
    private var serviceHandler: Handler? = null
    
    override fun onCreate() {
        super.onCreate()
        handlerThread = HandlerThread("ServiceBackgroundThread").apply {
            start()
        }
        serviceHandler = Handler(handlerThread?.looper!!)
    }
}
```

#### Step 2.2: Perform Background Work
```kotlin
private fun performBackgroundWork() {
    serviceHandler?.post {
        // TODO: Perform CPU-intensive work
        // TODO: Update notification with progress
        // TODO: Handle errors
    }
}
```

#### Step 2.3: Update Notification Progress
```kotlin
private fun updateNotification(progress: Int, max: Int) {
    val notification = NotificationCompat.Builder(this, CHANNEL_ID)
        .setContentTitle("Processing Tasks")
        .setContentText("Progress: $progress/$max")
        .setSmallIcon(R.drawable.ic_notification)
        .setProgress(max, progress, false)
        .build()
    
    val notificationManager = getSystemService(NotificationManager::class.java)
    notificationManager.notify(NOTIFICATION_ID, notification)
}
```

### Hints
- Use `HandlerThread` for background processing
- Remember to quit the looper in `onDestroy()`
- Use `setProgress()` for indeterminate progress if needed

### Guide References
- [Android Services - Complete Guide](../../../android/02_intermediate/14.%20Android%20Services%20-%20Complete%20Guide.md) - Sections: Background Threading
- [Threads & Processes in Android](../../../android/02_intermediate/19.%20Threads%20%26%20Processes%20in%20Android.md) - HandlerThread usage

### Completion Criteria
- [ ] Background work runs on separate thread
- [ ] UI remains responsive during work
- [ ] Progress updates appear in notification
- [ ] Thread cleanup happens properly

---

## Challenge 3: Bound Service with IPC (Medium)

**Estimated Time:** 2 hours  
**Difficulty:** Medium  
**Status:** â¬œ Not Started

### Objective
Create a bound service that allows activities to communicate with it through an AIDL interface or Messenger pattern.

### Requirements
1. Create a bound service with `Binder`
2. Implement interface for client communication
3. Handle multiple client bindings
4. Implement proper unbinding
5. Handle service lifecycle with bound clients

### Step-by-Step Instructions

#### Step 3.1: Create Binder Interface
```kotlin
interface TaskServiceBinder : IBinder {
    fun getTaskCount(): Int
    fun startTask(taskId: String): Boolean
    fun stopTask(taskId: String): Boolean
    fun getTaskStatus(taskId: String): TaskStatus?
}

enum class TaskStatus {
    PENDING, RUNNING, COMPLETED, FAILED
}
```

#### Step 3.2: Implement Bound Service
```kotlin
class BoundTaskService : Service() {
    private val binder = object : Binder() {
        fun getService(): BoundTaskService = this@BoundTaskService
    }
    
    private val activeTasks = mutableMapOf<String, TaskStatus>()
    
    override fun onBind(intent: Intent): IBinder {
        return binder
    }
    
    fun getTaskCount(): Int = activeTasks.size
    
    fun startTask(taskId: String): Boolean {
        // TODO: Implement task start logic
        // TODO: Update task status
        return true
    }
    
    fun stopTask(taskId: String): Boolean {
        // TODO: Implement task stop logic
        return true
    }
    
    fun getTaskStatus(taskId: String): TaskStatus? {
        return activeTasks[taskId]
    }
}
```

#### Step 3.3: Bind from Activity
```kotlin
class MainActivity : AppCompatActivity() {
    private var boundService: BoundTaskService? = null
    private var isBound = false
    
    private val connection = object : ServiceConnection {
        override fun onServiceConnected(name: ComponentName?, service: IBinder?) {
            val binder = service as BoundTaskService.LocalBinder
            boundService = binder.getService()
            isBound = true
        }
        
        override fun onServiceDisconnected(name: ComponentName?) {
            isBound = false
            boundService = null
        }
    }
    
    override fun onStart() {
        super.onStart()
        Intent(this, BoundTaskService::class.java).also { intent ->
            bindService(intent, connection, Context.BIND_AUTO_CREATE)
        }
    }
    
    override fun onStop() {
        super.onStop()
        if (isBound) {
            unbindService(connection)
            isBound = false
        }
    }
}
```

### Hints
- Use `BIND_AUTO_CREATE` for automatic service creation
- Always unbind in `onStop()` to prevent leaks
- Handle service disconnection gracefully

### Guide References
- [Android Services - Complete Guide](../../../android/02_intermediate/14.%20Android%20Services%20-%20Complete%20Guide.md) - Sections: Bound Services, IPC

### Completion Criteria
- [ ] Service binds successfully from activity
- [ ] Multiple activities can bind simultaneously
- [ ] Communication works bidirectionally
- [ ] Proper cleanup on unbind

---

## Challenge 4: WorkManager Basic Implementation (Medium)

**Estimated Time:** 2 hours  
**Difficulty:** Medium  
**Status:** â¬œ Not Started

### Objective
Implement WorkManager to schedule and execute background work with constraints.

### Requirements
1. Create a `Worker` class for background work
2. Define work constraints (network, battery, storage)
3. Schedule one-time and periodic work
4. Handle work completion and failure
5. Implement proper work cancellation

### Step-by-Step Instructions

#### Step 4.1: Create Worker Class
```kotlin
class DataSyncWorker(
    context: Context,
    params: WorkerParameters
) : CoroutineWorker(context, params) {
    
    override suspend fun doWork(): Result {
        return try {
            // TODO: Perform data synchronization
            // TODO: Handle network calls
            // TODO: Update local database
            Result.success()
        } catch (e: Exception) {
            if (runAttemptCount < 3) {
                Result.retry()
            } else {
                Result.failure()
            }
        }
    }
}
```

#### Step 4.2: Schedule Work with Constraints
```kotlin
val constraints = Constraints.Builder()
    .setRequiredNetworkType(NetworkType.CONNECTED)
    .setRequiresBatteryNotLow(true)
    .setRequiresStorageNotLow(true)
    .build()

val syncWork = OneTimeWorkRequestBuilder<DataSyncWorker>()
    .setConstraints(constraints)
    .setBackoffCriteria(
        BackoffPolicy.EXPONENTIAL,
        OneTimeWorkRequest.MIN_BACKOFF_MILLIS,
        TimeUnit.MILLISECONDS
    )
    .build()

WorkManager.getInstance(context).enqueue(syncWork)
```

#### Step 4.3: Observe Work Status
```kotlin
WorkManager.getInstance(context)
    .getWorkInfoByIdLiveData(syncWork.id)
    .observe(this) { workInfo ->
        when (workInfo?.state) {
            WorkInfo.State.ENQUEUED -> { /* Work queued */ }
            WorkInfo.State.RUNNING -> { /* Work running */ }
            WorkInfo.State.SUCCEEDED -> { /* Work completed */ }
            WorkInfo.State.FAILED -> { /* Work failed */ }
            WorkInfo.State.CANCELLED -> { /* Work cancelled */ }
            else -> { /* Unknown state */ }
        }
    }
```

### Hints
- Use `CoroutineWorker` for async work
- Set appropriate backoff policy for retries
- Handle constraint changes gracefully

### Guide References
- [WorkManager & Background Tasks](../../../android/02_intermediate/13.%20WorkManager%20%26%20Background%20Tasks.md) - Complete guide

### Completion Criteria
- [ ] Work executes with constraints met
- [ ] Work waits when constraints not met
- [ ] Retry logic works correctly
- [ ] Work status can be observed

---

## Challenge 5: WorkManager Chain with Data Passing (Medium)

**Estimated Time:** 2.5 hours  
**Difficulty:** Medium  
**Status:** â¬œ Not Started

### Objective
Create a chain of WorkManager workers that pass data between them and handle dependencies.

### Requirements
1. Create multiple workers in sequence
2. Pass data between workers using `Data` objects
3. Handle worker failures in chain
4. Implement parallel and sequential chains
5. Combine results from multiple workers

### Step-by-Step Instructions

#### Step 5.1: Create Worker Chain
```kotlin
// First worker - Fetch data
class FetchDataWorker(
    context: Context,
    params: WorkerParameters
) : CoroutineWorker(context, params) {
    
    override suspend fun doWork(): Result {
        val data = fetchDataFromApi()
        val outputData = workDataOf(
            "data" to data.toJsonString()
        )
        return Result.success(outputData)
    }
}

// Second worker - Process data
class ProcessDataWorker(
    context: Context,
    params: WorkerParameters
) : CoroutineWorker(context, params) {
    
    override suspend fun doWork(): Result {
        val inputData = inputData.getString("data")
        // TODO: Process data
        val processedData = processData(inputData)
        return Result.success(workDataOf("processed" to processedData))
    }
}

// Third worker - Save data
class SaveDataWorker(
    context: Context,
    params: WorkerParameters
) : CoroutineWorker(context, params) {
    
    override suspend fun doWork(): Result {
        val processedData = inputData.getString("processed")
        // TODO: Save to database
        saveToDatabase(processedData)
        return Result.success()
    }
}
```

#### Step 5.2: Chain Workers
```kotlin
val fetchWork = OneTimeWorkRequestBuilder<FetchDataWorker>().build()
val processWork = OneTimeWorkRequestBuilder<ProcessDataWorker>().build()
val saveWork = OneTimeWorkRequestBuilder<SaveDataWorker>().build()

WorkManager.getInstance(context)
    .beginWith(fetchWork)
    .then(processWork)
    .then(saveWork)
    .enqueue()
```

#### Step 5.3: Parallel Work Chain
```kotlin
val work1 = OneTimeWorkRequestBuilder<Worker1>().build()
val work2 = OneTimeWorkRequestBuilder<Worker2>().build()
val work3 = OneTimeWorkRequestBuilder<Worker3>().build()

WorkManager.getInstance(context)
    .beginWith(listOf(work1, work2))
    .then(work3)
    .enqueue()
```

### Hints
- Use `workDataOf()` for creating Data objects
- Chain stops if any worker fails
- Use `InputMerger` for combining parallel outputs

### Guide References
- [WorkManager & Background Tasks](../../../android/02_intermediate/13.%20WorkManager%20%26%20Background%20Tasks.md) - Sections: Work Chaining, Data Passing

### Completion Criteria
- [ ] Workers execute in correct order
- [ ] Data passes correctly between workers
- [ ] Chain handles failures appropriately
- [ ] Parallel workers work correctly

---

## Challenge 6: Foreground Service with WorkManager Integration (Hard)

**Estimated Time:** 3 hours  
**Difficulty:** Hard  
**Status:** â¬œ Not Started

### Objective
Integrate a foreground service with WorkManager to handle long-running tasks that require immediate execution.

### Requirements
1. Start foreground service from WorkManager
2. Handle service lifecycle with WorkManager
3. Update notification from WorkManager work
4. Handle service stop when work completes
5. Manage process priority correctly

### Step-by-Step Instructions

#### Step 6.1: Create Foreground Worker
```kotlin
class ForegroundSyncWorker(
    context: Context,
    params: WorkerParameters
) : CoroutineWorker(context, params) {
    
    override suspend fun doWork(): Result {
        setForeground(createForegroundInfo())
        
        return try {
            // TODO: Perform long-running work
            performLongRunningSync()
            Result.success()
        } catch (e: Exception) {
            Result.failure()
        }
    }
    
    private fun createForegroundInfo(): ForegroundInfo {
        val notification = createNotification()
        return ForegroundInfo(NOTIFICATION_ID, notification)
    }
    
    private fun createNotification(): Notification {
        // TODO: Create notification with progress
        return NotificationCompat.Builder(context, CHANNEL_ID)
            .setContentTitle("Syncing Data")
            .setContentText("Please wait...")
            .setSmallIcon(R.drawable.ic_sync)
            .build()
    }
}
```

#### Step 6.2: Update Notification During Work
```kotlin
override suspend fun doWork(): Result {
    setForeground(createForegroundInfo())
    
    val progress = MutableStateFlow(0)
    
    // Update notification with progress
    progress.collect { currentProgress ->
        val updatedNotification = createProgressNotification(currentProgress)
        setForeground(createForegroundInfo(updatedNotification))
    }
    
    return Result.success()
}
```

#### Step 6.3: Schedule Foreground Work
```kotlin
val foregroundWork = OneTimeWorkRequestBuilder<ForegroundSyncWorker>()
    .setExpedited(OutOfQuotaPolicy.RUN_AS_NON_EXPEDITED_WORK_REQUEST)
    .build()

WorkManager.getInstance(context).enqueue(foregroundWork)
```

### Hints
- Use `setForeground()` for foreground work
- Call `setForeground()` before doing work
- Handle `OutOfQuotaPolicy` for expedited work

### Guide References
- [WorkManager & Background Tasks](../../../android/02_intermediate/13.%20WorkManager%20%26%20Background%20Tasks.md) - Sections: Foreground Work
- [Android Services - Complete Guide](../../../android/02_intermediate/14.%20Android%20Services%20-%20Complete%20Guide.md) - Foreground Services

### Completion Criteria
- [ ] Foreground service starts from WorkManager
- [ ] Notification appears and updates
- [ ] Work completes successfully
- [ ] Service stops when work completes

---

## Challenge 7: Battery Optimization Handling (Hard)

**Estimated Time:** 2.5 hours  
**Difficulty:** Hard  
**Status:** â¬œ Not Started

### Objective
Handle battery optimization restrictions and implement workarounds for background execution limitations.

### Requirements
1. Check battery optimization status
2. Request battery optimization exemption
3. Handle Doze mode restrictions
4. Implement workarounds for background limits
5. Test on different Android versions

### Step-by-Step Instructions

#### Step 7.1: Check Battery Optimization
```kotlin
fun isBatteryOptimizationIgnored(context: Context): Boolean {
    val powerManager = context.getSystemService(Context.POWER_SERVICE) as PowerManager
    return powerManager.isIgnoringBatteryOptimizations(context.packageName)
}
```

#### Step 7.2: Request Exemption
```kotlin
fun requestBatteryOptimizationExemption(activity: Activity) {
    if (!isBatteryOptimizationIgnored(activity)) {
        val intent = Intent(Settings.ACTION_REQUEST_IGNORE_BATTERY_OPTIMIZATIONS).apply {
            data = Uri.parse("package:${activity.packageName}")
        }
        activity.startActivity(intent)
    }
}
```

#### Step 7.3: Handle Doze Mode
```kotlin
class DozeAwareWorker(
    context: Context,
    params: WorkerParameters
) : CoroutineWorker(context, params) {
    
    override suspend fun doWork(): Result {
        // Check if device is in doze mode
        val powerManager = applicationContext.getSystemService(Context.POWER_SERVICE) as PowerManager
        val isDeviceIdleMode = powerManager.isDeviceIdleMode
        
        if (isDeviceIdleMode) {
            // TODO: Schedule work for later or use foreground service
            return Result.retry()
        }
        
        // Perform work
        return performWork()
    }
}
```

#### Step 7.4: Use AlarmManager for Critical Work
```kotlin
fun scheduleCriticalWork(context: Context) {
    val alarmManager = context.getSystemService(Context.ALARM_SERVICE) as AlarmManager
    val intent = Intent(context, WorkReceiver::class.java)
    val pendingIntent = PendingIntent.getBroadcast(
        context,
        0,
        intent,
        PendingIntent.FLAG_IMMUTABLE
    )
    
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
        alarmManager.setExactAndAllowWhileIdle(
            AlarmManager.RTC_WAKEUP,
            System.currentTimeMillis() + 60000,
            pendingIntent
        )
    }
}
```

### Hints
- Test on Android 8.0+ for background limits
- Use foreground services for critical work
- Request permissions appropriately

### Guide References
- [Android Permissions](../../../android/02_intermediate/20.%20Android%20Permissions.md) - Battery optimization
- [AlarmManager & Scheduled Tasks](../../../android/02_intermediate/15.%20AlarmManager%20%26%20Scheduled%20Tasks.md) - Doze mode handling

### Completion Criteria
- [ ] Battery optimization status checked correctly
- [ ] Exemption request works
- [ ] Work executes despite restrictions
- [ ] Proper fallbacks implemented

---

## Challenge 8: Service Binding Across Processes (Hard)

**Estimated Time:** 3 hours  
**Difficulty:** Hard  
**Status:** â¬œ Not Started

### Objective
Implement a bound service that can be accessed from a separate process using AIDL or Messenger.

### Requirements
1. Create service in separate process
2. Define AIDL interface
3. Implement service stub
4. Bind from different process
5. Handle IPC data marshalling

### Step-by-Step Instructions

#### Step 8.1: Define AIDL Interface
```aidl
// ITaskService.aidl
package com.example.taskservice;

interface ITaskService {
    int getTaskCount();
    boolean startTask(String taskId);
    boolean stopTask(String taskId);
    String getTaskStatus(String taskId);
}
```

#### Step 8.2: Implement Service Stub
```kotlin
class RemoteTaskService : Service() {
    private val binder = object : ITaskService.Stub() {
        override fun getTaskCount(): Int {
            return activeTasks.size
        }
        
        override fun startTask(taskId: String): Boolean {
            // TODO: Start task
            return true
        }
        
        override fun stopTask(taskId: String): Boolean {
            // TODO: Stop task
            return true
        }
        
        override fun getTaskStatus(taskId: String): String {
            return activeTasks[taskId]?.name ?: "UNKNOWN"
        }
    }
    
    override fun onBind(intent: Intent): IBinder {
        return binder
    }
}
```

#### Step 8.3: Configure Separate Process
```xml
<service
    android:name=".RemoteTaskService"
    android:process=":remote"
    android:exported="true">
    <intent-filter>
        <action android:name="com.example.taskservice.ITaskService" />
    </intent-filter>
</service>
```

#### Step 8.4: Bind from Different Process
```kotlin
val intent = Intent().apply {
    component = ComponentName(
        "com.example.taskservice",
        "com.example.taskservice.RemoteTaskService"
    )
}

bindService(intent, connection, Context.BIND_AUTO_CREATE)
```

### Hints
- AIDL files must be in `aidl` directory
- Use `Parcelable` for complex data types
- Handle process death with `ServiceConnection.onServiceDisconnected()`

### Guide References
- [Android Services - Complete Guide](../../../android/02_intermediate/14.%20Android%20Services%20-%20Complete%20Guide.md) - Sections: AIDL, IPC
- [Threads & Processes in Android](../../../android/02_intermediate/19.%20Threads%20%26%20Processes%20in%20Android.md) - Process communication

### Completion Criteria
- [ ] Service runs in separate process
- [ ] AIDL interface works correctly
- [ ] Binding works across processes
- [ ] Data marshalling works

---

## Challenge 9: Complex WorkManager Chain with Error Recovery (Hard)

**Estimated Time:** 3.5 hours  
**Difficulty:** Hard  
**Status:** â¬œ Not Started

### Objective
Create a complex WorkManager chain with multiple parallel branches, error recovery, and conditional execution.

### Requirements
1. Create multi-branch work chain
2. Implement error recovery mechanisms
3. Handle conditional work execution
4. Combine results from multiple branches
5. Implement retry with exponential backoff

### Step-by-Step Instructions

#### Step 9.1: Create Complex Chain
```kotlin
// Parallel data fetching
val fetchUserWork = OneTimeWorkRequestBuilder<FetchUserWorker>().build()
val fetchSettingsWork = OneTimeWorkRequestBuilder<FetchSettingsWorker>().build()
val fetchConfigWork = OneTimeWorkRequestBuilder<FetchConfigWorker>().build()

// Processing workers
val processUserWork = OneTimeWorkRequestBuilder<ProcessUserWorker>().build()
val processSettingsWork = OneTimeWorkRequestBuilder<ProcessSettingsWorker>().build()

// Final aggregation
val aggregateWork = OneTimeWorkRequestBuilder<AggregateWorker>().build()

WorkManager.getInstance(context)
    .beginWith(listOf(fetchUserWork, fetchSettingsWork, fetchConfigWork))
    .then(listOf(processUserWork, processSettingsWork))
    .then(aggregateWork)
    .enqueue()
```

#### Step 9.2: Implement Error Recovery Worker
```kotlin
class ErrorRecoveryWorker(
    context: Context,
    params: WorkerParameters
) : CoroutineWorker(context, params) {
    
    override suspend fun doWork(): Result {
        val failedWorkId = inputData.getString("failed_work_id")
        
        return try {
            // TODO: Analyze failure
            // TODO: Retry with different strategy
            // TODO: Or mark as permanently failed
            Result.success()
        } catch (e: Exception) {
            Result.failure()
        }
    }
}
```

#### Step 9.3: Conditional Work Execution
```kotlin
class ConditionalWorker(
    context: Context,
    params: WorkerParameters
) : CoroutineWorker(context, params) {
    
    override suspend fun doWork(): Result {
        val shouldProceed = inputData.getBoolean("should_proceed", false)
        
        if (!shouldProceed) {
            // Skip this work
            return Result.success()
        }
        
        // Perform work
        return performWork()
    }
}
```

#### Step 9.4: Custom InputMerger
```kotlin
class CustomInputMerger : InputMerger {
    override fun merge(inputs: MutableList<Data>): Data {
        val output = Data.Builder()
        
        inputs.forEach { input ->
            input.keyValueMap.forEach { (key, value) ->
                output.put(key, value)
            }
        }
        
        return output.build()
    }
}
```

### Hints
- Use `InputMerger` for combining parallel outputs
- Implement proper error propagation
- Use tags for work identification

### Guide References
- [WorkManager & Background Tasks](../../../android/02_intermediate/13.%20WorkManager%20%26%20Background%20Tasks.md) - Sections: Advanced Chaining, Error Handling

### Completion Criteria
- [ ] Complex chain executes correctly
- [ ] Error recovery works
- [ ] Conditional execution works
- [ ] Results combine properly

---

## Challenge 10: Service Lifecycle Management with Process Death (Very Hard)

**Estimated Time:** 4 hours  
**Difficulty:** Very Hard  
**Status:** â¬œ Not Started

### Objective
Handle service lifecycle correctly when the process is killed by the system, including state persistence and recovery.

### Requirements
1. Persist service state
2. Handle process death gracefully
3. Restore state on service restart
4. Implement proper cleanup
5. Handle multiple service instances

### Step-by-Step Instructions

#### Step 10.1: Persist Service State
```kotlin
class StatefulService : Service() {
    private val stateFile = File(filesDir, "service_state.json")
    
    private fun saveState(state: ServiceState) {
        try {
            val json = Gson().toJson(state)
            stateFile.writeText(json)
        } catch (e: Exception) {
            Log.e(TAG, "Failed to save state", e)
        }
    }
    
    private fun loadState(): ServiceState? {
        return try {
            if (stateFile.exists()) {
                val json = stateFile.readText()
                Gson().fromJson(json, ServiceState::class.java)
            } else {
                null
            }
        } catch (e: Exception) {
            Log.e(TAG, "Failed to load state", e)
            null
        }
    }
}
```

#### Step 10.2: Handle Process Death
```kotlin
override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
    // Restore state if process was killed
    val savedState = loadState()
    if (savedState != null) {
        restoreState(savedState)
    }
    
    // Save state periodically
    startStateSaving()
    
    return START_STICKY // Restart service if killed
}
```

#### Step 10.3: Implement State Recovery
```kotlin
private fun restoreState(state: ServiceState) {
    // TODO: Restore active tasks
    // TODO: Restore progress
    // TODO: Restore configuration
    activeTasks.putAll(state.activeTasks)
    currentProgress = state.progress
}
```

#### Step 10.4: Handle Multiple Instances
```kotlin
companion object {
    private var instanceCount = AtomicInteger(0)
    private val instances = ConcurrentHashMap<Int, StatefulService>()
}

init {
    val instanceId = instanceCount.incrementAndGet()
    instances[instanceId] = this
}

override fun onDestroy() {
    instances.remove(instanceId)
    saveState(getCurrentState())
    super.onDestroy()
}
```

### Hints
- Use `START_STICKY` for automatic restart
- Save state to SharedPreferences or file
- Handle race conditions with multiple instances

### Guide References
- [Android Services - Complete Guide](../../../android/02_intermediate/14.%20Android%20Services%20-%20Complete%20Guide.md) - Sections: Lifecycle, Process Death
- [Object Lifecycle & References in Java](../../../android/02_intermediate/30.%20Object%20Lifecycle%20%26%20References%20in%20Java.md) - State management

### Completion Criteria
- [ ] State persists across process death
- [ ] State restores correctly
- [ ] Multiple instances handled
- [ ] No memory leaks

---

## Challenge 11: WorkManager with Custom Constraints (Very Hard)

**Estimated Time:** 3 hours  
**Difficulty:** Very Hard  
**Status:** â¬œ Not Started

### Objective
Create custom WorkManager constraints and implement constraint monitoring.

### Requirements
1. Create custom constraint class
2. Implement constraint checking
3. Monitor constraint changes
4. Handle constraint violations
5. Integrate with existing constraints

### Step-by-Step Instructions

#### Step 11.1: Create Custom Constraint
```kotlin
class CustomDatabaseConstraint(
    private val database: AppDatabase
) : Constraint {
    
    override fun isMet(): Boolean {
        // TODO: Check database state
        return database.isReady()
    }
    
    override fun getDefaultWorkerFactory(): WorkerFactory {
        return CustomWorkerFactory()
    }
}
```

#### Step 11.2: Implement Constraint Tracking
```kotlin
class ConstraintTrackingWorker(
    context: Context,
    params: WorkerParameters
) : CoroutineWorker(context, params) {
    
    override suspend fun doWork(): Result {
        val constraints = inputData.getStringArray("constraints") ?: emptyArray()
        
        constraints.forEach { constraintName ->
            when (constraintName) {
                "database_ready" -> {
                    if (!isDatabaseReady()) {
                        return Result.retry()
                    }
                }
                "api_available" -> {
                    if (!isApiAvailable()) {
                        return Result.retry()
                    }
                }
            }
        }
        
        return performWork()
    }
}
```

#### Step 11.3: Monitor Constraint Changes
```kotlin
class ConstraintMonitor {
    fun observeConstraints(
        constraints: List<Constraint>,
        callback: (Boolean) -> Unit
    ) {
        // TODO: Monitor constraint states
        // TODO: Notify when constraints change
    }
}
```

### Hints
- Extend `Constraint` class
- Use `WorkManager` constraint system
- Monitor system state changes

### Guide References
- [WorkManager & Background Tasks](../../../android/02_intermediate/13.%20WorkManager%20%26%20Background%20Tasks.md) - Sections: Custom Constraints

### Completion Criteria
- [ ] Custom constraints work
- [ ] Constraint monitoring works
- [ ] Work waits for constraints
- [ ] Integration with system constraints

---

## Challenge 12: Complete Integration - Production Ready System (Very Hard)

**Estimated Time:** 5 hours  
**Difficulty:** Very Hard  
**Status:** â¬œ Not Started

### Objective
Integrate all previous challenges into a production-ready background task management system.

### Requirements
1. Combine all services and WorkManager
2. Implement comprehensive error handling
3. Add logging and monitoring
4. Handle edge cases
5. Optimize for battery and performance
6. Add unit tests

### Step-by-Step Instructions

#### Step 12.1: Create Task Manager
```kotlin
class TaskManager(
    private val context: Context,
    private val workManager: WorkManager
) {
    fun scheduleTask(task: Task): String {
        // TODO: Determine best execution method
        // TODO: Foreground service for immediate
        // TODO: WorkManager for scheduled
        // TODO: Bound service for interactive
        return when (task.priority) {
            TaskPriority.CRITICAL -> scheduleForegroundTask(task)
            TaskPriority.HIGH -> scheduleWorkManagerTask(task)
            TaskPriority.NORMAL -> scheduleBackgroundTask(task)
        }
    }
    
    fun cancelTask(taskId: String) {
        // TODO: Cancel all related work
        // TODO: Stop services if needed
        // TODO: Cleanup resources
    }
}
```

#### Step 12.2: Implement Error Handling
```kotlin
class ErrorHandler {
    fun handleError(error: Throwable, context: TaskContext) {
        when (error) {
            is NetworkException -> {
                // Retry with exponential backoff
                scheduleRetry(context, exponentialBackoff())
            }
            is DatabaseException -> {
                // Mark as failed, log for manual review
                markAsFailed(context)
                logError(error)
            }
            is OutOfMemoryError -> {
                // Reduce work load, retry later
                reduceWorkload()
                scheduleRetry(context, fixedDelay(1.hour))
            }
        }
    }
}
```

#### Step 12.3: Add Monitoring
```kotlin
class TaskMonitor {
    fun trackTaskExecution(taskId: String, duration: Long, success: Boolean) {
        // TODO: Log metrics
        // TODO: Track performance
        // TODO: Alert on failures
    }
    
    fun getTaskStatistics(): TaskStatistics {
        // TODO: Return aggregated statistics
        return TaskStatistics(
            totalTasks = getTotalTasks(),
            successRate = getSuccessRate(),
            averageDuration = getAverageDuration()
        )
    }
}
```

#### Step 12.4: Optimize for Battery
```kotlin
class BatteryOptimizer {
    fun optimizeTaskSchedule(tasks: List<Task>) {
        // TODO: Batch tasks together
        // TODO: Schedule during charging
        // TODO: Reduce frequency when battery low
        val batchedTasks = batchTasks(tasks)
        scheduleDuringCharging(batchedTasks)
    }
}
```

### Hints
- Use dependency injection
- Implement proper logging
- Add analytics
- Test thoroughly

### Guide References
- All previous guides referenced
- [Performance Optimization](../../../android/03_advanced/03.%20Performance%20Profiling%20%26%20Memory%20Leaks.md)
- [Unit Testing in Android](../../../android/02_intermediate/28.%20Unit%20Testing%20in%20Android.md)

### Completion Criteria
- [ ] All components integrated
- [ ] Error handling comprehensive
- [ ] Monitoring in place
- [ ] Battery optimized
- [ ] Production ready

---

## Project Completion Checklist

### Easy Challenges
- [ ] Challenge 1: Basic Foreground Service Setup
- [ ] Challenge 2: Service with Background Threading

### Medium Challenges
- [ ] Challenge 3: Bound Service with IPC
- [ ] Challenge 4: WorkManager Basic Implementation
- [ ] Challenge 5: WorkManager Chain with Data Passing

### Hard Challenges
- [ ] Challenge 6: Foreground Service with WorkManager Integration
- [ ] Challenge 7: Battery Optimization Handling
- [ ] Challenge 8: Service Binding Across Processes

### Very Hard Challenges
- [ ] Challenge 9: Complex WorkManager Chain with Error Recovery
- [ ] Challenge 10: Service Lifecycle Management with Process Death
- [ ] Challenge 11: WorkManager with Custom Constraints
- [ ] Challenge 12: Complete Integration - Production Ready System

---

## Final Notes

This project is designed to be extremely challenging. Only developers with deep understanding of Android's background processing capabilities should be able to complete all challenges.

**Key Learning Outcomes:**
- Master foreground and background services
- Understand WorkManager deeply
- Handle process lifecycle correctly
- Implement production-ready background systems
- Optimize for battery and performance

**Estimated Total Time:** 20+ hours  
**Recommended:** Complete challenges in order, as they build upon each other.

Good luck! ðŸš€

