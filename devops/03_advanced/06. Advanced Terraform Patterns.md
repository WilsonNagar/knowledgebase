---
number: 6
title: "Advanced Terraform Patterns"
slug: "advanced-terraform-patterns"
level: "advanced"
tags: ["terraform", "iac", "advanced", "patterns", "modules", "workspaces"]
prerequisites: [2]
estimated_minutes: 120
contributors: []
canonical_id: "devops-advanced-06"
---

# Advanced Terraform Patterns

## Overview

Advanced Terraform patterns enable sophisticated infrastructure management, code reuse, and complex deployment scenarios. This guide covers advanced module patterns, workspace strategies, dynamic blocks, for_each and count, remote state management, terraform_remote_state, and production-ready patterns for large-scale infrastructure.

## Deep Explanation

### Advanced Module Patterns

#### Module Composition

**Composed Module**:
```hcl
# modules/application/main.tf
module "vpc" {
  source = "../vpc"
  
  vpc_cidr = var.vpc_cidr
  environment = var.environment
}

module "database" {
  source = "../database"
  
  vpc_id = module.vpc.vpc_id
  subnet_ids = module.vpc.private_subnet_ids
  environment = var.environment
}

module "compute" {
  source = "../compute"
  
  vpc_id = module.vpc.vpc_id
  subnet_ids = module.vpc.public_subnet_ids
  database_endpoint = module.database.endpoint
  environment = var.environment
}
```

#### Module Outputs as Inputs

**Output Chaining**:
```hcl
# modules/network/outputs.tf
output "vpc_id" {
  value = aws_vpc.main.id
}

output "subnet_ids" {
  value = aws_subnet.main[*].id
}

# modules/compute/main.tf
module "network" {
  source = "../network"
}

resource "aws_instance" "web" {
  subnet_id = module.network.subnet_ids[0]
  vpc_security_group_ids = [module.network.security_group_id]
}
```

### Dynamic Blocks

#### Dynamic Block Pattern

**Security Group with Dynamic Rules**:
```hcl
variable "ingress_rules" {
  type = list(object({
    from_port   = number
    to_port     = number
    protocol    = string
    cidr_blocks = list(string)
  }))
  default = []
}

resource "aws_security_group" "web" {
  name = "web-sg"
  
  dynamic "ingress" {
    for_each = var.ingress_rules
    content {
      from_port   = ingress.value.from_port
      to_port     = ingress.value.to_port
      protocol    = ingress.value.protocol
      cidr_blocks = ingress.value.cidr_blocks
    }
  }
}
```

**Usage**:
```hcl
module "web" {
  source = "./modules/web"
  
  ingress_rules = [
    {
      from_port   = 80
      to_port     = 80
      protocol    = "tcp"
      cidr_blocks = ["0.0.0.0/0"]
    },
    {
      from_port   = 443
      to_port     = 443
      protocol    = "tcp"
      cidr_blocks = ["0.0.0.0/0"]
    }
  ]
}
```

### for_each and count

#### for_each Pattern

**Multiple Resources**:
```hcl
variable "instances" {
  type = map(object({
    instance_type = string
    ami           = string
  }))
  default = {
    web1 = {
      instance_type = "t3.small"
      ami           = "ami-xxx"
    }
    web2 = {
      instance_type = "t3.medium"
      ami           = "ami-xxx"
    }
  }
}

resource "aws_instance" "web" {
  for_each = var.instances
  
  ami           = each.value.ami
  instance_type = each.value.instance_type
  
  tags = {
    Name = each.key
  }
}

# Reference
output "instance_ids" {
  value = {
    for k, v in aws_instance.web : k => v.id
  }
}
```

#### count Pattern

**Conditional Resources**:
```hcl
variable "create_database" {
  type    = bool
  default = true
}

resource "aws_db_instance" "main" {
  count = var.create_database ? 1 : 0
  
  engine         = "postgres"
  instance_class = "db.t3.micro"
  # ...
}

# Reference
output "database_endpoint" {
  value = var.create_database ? aws_db_instance.main[0].endpoint : null
}
```

### Workspace Strategies

#### Environment Workspaces

**Workspace Structure**:
```bash
# Create workspaces
terraform workspace new development
terraform workspace new staging
terraform workspace new production

# Select workspace
terraform workspace select production

# List workspaces
terraform workspace list
```

**Workspace-Aware Configuration**:
```hcl
locals {
  environment = terraform.workspace
  
  common_tags = {
    Environment = terraform.workspace
    ManagedBy   = "Terraform"
  }
  
  instance_count = {
    development = 1
    staging     = 2
    production  = 5
  }[terraform.workspace]
}

resource "aws_instance" "web" {
  count = local.instance_count
  
  tags = local.common_tags
}
```

### Remote State Management

#### S3 Backend with DynamoDB

**Backend Configuration**:
```hcl
terraform {
  backend "s3" {
    bucket         = "terraform-state-bucket"
    key            = "production/terraform.tfstate"
    region         = "us-east-1"
    encrypt        = true
    dynamodb_table = "terraform-locks"
    
    # Workspace key prefix
    workspace_key_prefix = "env:"
  }
}
```

**DynamoDB Lock Table**:
```hcl
resource "aws_dynamodb_table" "terraform_locks" {
  name           = "terraform-locks"
  billing_mode   = "PAY_PER_REQUEST"
  hash_key       = "LockID"
  
  attribute {
    name = "LockID"
    type = "S"
  }
  
  tags = {
    Name = "Terraform State Lock Table"
  }
}
```

#### terraform_remote_state

**Accessing Remote State**:
```hcl
# Network module outputs state
data "terraform_remote_state" "network" {
  backend = "s3"
  
  config = {
    bucket = "terraform-state-bucket"
    key    = "network/terraform.tfstate"
    region = "us-east-1"
  }
}

# Use remote state outputs
resource "aws_instance" "web" {
  subnet_id = data.terraform_remote_state.network.outputs.public_subnet_id
  vpc_id    = data.terraform_remote_state.network.outputs.vpc_id
}
```

### Advanced Module Patterns

#### Conditional Module Creation

```hcl
# modules/conditional/main.tf
variable "create_resource" {
  type    = bool
  default = true
}

resource "aws_instance" "conditional" {
  count = var.create_resource ? 1 : 0
  
  ami           = var.ami
  instance_type = var.instance_type
}

output "instance_id" {
  value = var.create_resource ? aws_instance.conditional[0].id : null
}
```

#### Module Dependencies

```hcl
# Explicit dependencies
module "network" {
  source = "./modules/network"
}

module "compute" {
  source = "./modules/compute"
  
  depends_on = [module.network]
  
  vpc_id = module.network.vpc_id
}
```

### Data Sources

#### Advanced Data Source Usage

**Filtering Resources**:
```hcl
# Find latest AMI
data "aws_ami" "latest" {
  most_recent = true
  owners      = ["amazon"]
  
  filter {
    name   = "name"
    values = ["amzn2-ami-hvm-*-x86_64-gp2"]
  }
  
  filter {
    name   = "virtualization-type"
    values = ["hvm"]
  }
}

resource "aws_instance" "web" {
  ami = data.aws_ami.latest.id
}
```

**Multiple Data Sources**:
```hcl
# Get availability zones
data "aws_availability_zones" "available" {
  state = "available"
}

# Create subnet per AZ
resource "aws_subnet" "main" {
  count = length(data.aws_availability_zones.available.names)
  
  availability_zone = data.aws_availability_zones.available.names[count.index]
  cidr_block        = cidrsubnet(var.vpc_cidr, 8, count.index)
  vpc_id            = aws_vpc.main.id
}
```

### Provisioners

#### Advanced Provisioner Patterns

**Null Resource with Provisioners**:
```hcl
resource "null_resource" "provision" {
  triggers = {
    instance_id = aws_instance.web.id
  }
  
  provisioner "local-exec" {
    command = "ansible-playbook -i ${aws_instance.web.public_ip}, playbook.yml"
  }
  
  provisioner "remote-exec" {
    inline = [
      "sudo yum update -y",
      "sudo yum install -y nginx",
      "sudo systemctl start nginx"
    ]
    
    connection {
      type        = "ssh"
      host        = aws_instance.web.public_ip
      user        = "ec2-user"
      private_key = file("~/.ssh/id_rsa")
    }
  }
}
```

### State Management

#### State Import

**Import Existing Resources**:
```bash
# Import resource
terraform import aws_instance.web i-1234567890abcdef0

# Import with configuration
terraform import \
  -var-file=production.tfvars \
  aws_instance.web i-1234567890abcdef0
```

#### State Manipulation

**Move Resources**:
```bash
# Move resource in state
terraform state mv aws_instance.old aws_instance.new

# Remove from state
terraform state rm aws_instance.unwanted
```

**List Resources**:
```bash
# List all resources
terraform state list

# Show resource
terraform state show aws_instance.web
```

### Advanced Patterns

#### Multi-Region Deployment

```hcl
# Provider aliases
provider "aws" {
  alias  = "us_east"
  region = "us-east-1"
}

provider "aws" {
  alias  = "us_west"
  region = "us-west-2"
}

# Resources in multiple regions
resource "aws_instance" "us_east" {
  provider = aws.us_east
  # ...
}

resource "aws_instance" "us_west" {
  provider = aws.us_west
  # ...
}
```

#### Conditional Providers

```hcl
variable "enable_europe" {
  type    = bool
  default = false
}

provider "aws" {
  alias  = "europe"
  region = "eu-west-1"
}

resource "aws_instance" "europe" {
  count    = var.enable_europe ? 1 : 0
  provider = aws.europe
  # ...
}
```

### Module Registry Patterns

#### Private Module Registry

**Module Structure**:
```
modules/
  vpc/
    main.tf
    variables.tf
    outputs.tf
    README.md
```

**Using Private Registry**:
```hcl
module "vpc" {
  source = "git::https://github.com/company/terraform-modules.git//vpc?ref=v1.0.0"
  
  vpc_cidr = "10.0.0.0/16"
}
```

### Complete Advanced Example

```hcl
# main.tf
terraform {
  required_version = ">= 1.0"
  
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 4.0"
    }
  }
  
  backend "s3" {
    bucket         = "terraform-state-prod"
    key            = "app/terraform.tfstate"
    region         = "us-east-1"
    encrypt        = true
    dynamodb_table = "terraform-locks"
  }
}

# Locals
locals {
  environment = terraform.workspace
  common_tags = {
    Environment = local.environment
    ManagedBy   = "Terraform"
    Project     = "myapp"
  }
  
  instance_config = {
    development = {
      instance_type = "t2.micro"
      count         = 1
    }
    staging = {
      instance_type = "t2.small"
      count         = 2
    }
    production = {
      instance_type = "t3.medium"
      count         = 5
    }
  }
  
  config = local.instance_config[local.environment]
}

# Data sources
data "aws_availability_zones" "available" {
  state = "available"
}

data "aws_ami" "latest" {
  most_recent = true
  owners      = ["amazon"]
  
  filter {
    name   = "name"
    values = ["amzn2-ami-hvm-*-x86_64-gp2"]
  }
}

# VPC Module
module "vpc" {
  source = "./modules/vpc"
  
  vpc_cidr             = var.vpc_cidr
  availability_zones   = data.aws_availability_zones.available.names
  enable_dns_hostnames = true
  enable_dns_support   = true
  
  tags = local.common_tags
}

# Security Group with dynamic rules
resource "aws_security_group" "web" {
  name_prefix = "web-${local.environment}-"
  vpc_id      = module.vpc.vpc_id
  
  dynamic "ingress" {
    for_each = var.ingress_rules
    content {
      from_port   = ingress.value.from_port
      to_port     = ingress.value.to_port
      protocol    = ingress.value.protocol
      cidr_blocks = ingress.value.cidr_blocks
    }
  }
  
  egress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
  }
  
  tags = merge(local.common_tags, {
    Name = "web-sg-${local.environment}"
  })
  
  lifecycle {
    create_before_destroy = true
  }
}

# Instances with for_each
resource "aws_instance" "web" {
  for_each = {
    for idx in range(local.config.count) : "web-${idx + 1}" => {
      subnet_idx = idx % length(module.vpc.public_subnet_ids)
    }
  }
  
  ami           = data.aws_ami.latest.id
  instance_type = local.config.instance_type
  subnet_id     = module.vpc.public_subnet_ids[each.value.subnet_idx]
  
  vpc_security_group_ids = [aws_security_group.web.id]
  
  user_data = templatefile("${path.module}/user-data.sh", {
    environment = local.environment
  })
  
  tags = merge(local.common_tags, {
    Name = "${each.key}-${local.environment}"
  })
  
  lifecycle {
    create_before_destroy = true
    ignore_changes = [ami]
  }
}

# Auto Scaling Group
resource "aws_autoscaling_group" "web" {
  name                = "web-asg-${local.environment}"
  vpc_zone_identifier = module.vpc.public_subnet_ids
  target_group_arns   = [aws_lb_target_group.web.arn]
  health_check_type   = "ELB"
  health_check_grace_period = 300
  
  min_size         = local.config.count
  max_size         = local.config.count * 2
  desired_capacity = local.config.count
  
  launch_template {
    id      = aws_launch_template.web.id
    version = "$Latest"
  }
  
  tag {
    key                 = "Name"
    value               = "web-asg-${local.environment}"
    propagate_at_launch = true
  }
  
  dynamic "tag" {
    for_each = local.common_tags
    content {
      key                 = tag.key
      value               = tag.value
      propagate_at_launch = true
    }
  }
}

# Outputs
output "instance_ids" {
  value = {
    for k, v in aws_instance.web : k => v.id
  }
}

output "vpc_id" {
  value = module.vpc.vpc_id
}

output "load_balancer_dns" {
  value = aws_lb.web.dns_name
}
```

## Hard Use-Case: Multi-Environment Module

### Problem

Create reusable module for multiple environments with different configurations.

### Solution: Flexible Module Design

```hcl
# modules/app/variables.tf
variable "environment" {
  type = string
}

variable "instance_config" {
  type = map(object({
    instance_type = string
    count         = number
  }))
}

variable "enable_database" {
  type    = bool
  default = true
}

# modules/app/main.tf
locals {
  config = var.instance_config[var.environment]
}

resource "aws_instance" "app" {
  count         = local.config.count
  instance_type = local.config.instance_type
  # ...
}

resource "aws_db_instance" "app" {
  count = var.enable_database ? 1 : 0
  # ...
}

# Usage
module "app_dev" {
  source = "./modules/app"
  
  environment = "development"
  instance_config = {
    development = {
      instance_type = "t2.micro"
      count         = 1
    }
    production = {
      instance_type = "t3.large"
      count         = 5
    }
  }
  enable_database = true
}
```

## Edge Cases and Pitfalls

### 1. State File Conflicts

**Problem**: Multiple people modifying state

**Solution**: Use remote state with locking

```hcl
backend "s3" {
  dynamodb_table = "terraform-locks"  # Enables locking
}
```

### 2. Module Version Pinning

**Problem**: Module changes break infrastructure

**Solution**: Pin module versions

```hcl
module "vpc" {
  source = "git::https://github.com/company/modules.git//vpc?ref=v1.2.3"
}
```

### 3. Circular Dependencies

**Problem**: Modules depend on each other

**Solution**: Restructure modules

```hcl
# BAD: Circular dependency
module "a" {
  source = "./a"
  b_id = module.b.id
}

module "b" {
  source = "./b"
  a_id = module.a.id
}

# GOOD: Shared module
module "shared" {
  source = "./shared"
}

module "a" {
  source = "./a"
  shared_id = module.shared.id
}

module "b" {
  source = "./b"
  shared_id = module.shared.id
}
```

## References and Further Reading

- [Terraform Best Practices](https://www.terraform.io/docs/cloud/guides/recommended-practices/index.html) - Best practices
- [Terraform Modules](https://www.terraform.io/docs/language/modules/index.html) - Module guide
- [Terraform Workspaces](https://www.terraform.io/docs/language/state/workspaces.html) - Workspace guide

## Quiz

### Question 1
What is the difference between for_each and count?

**A)** They're the same  
**B)** for_each uses map/set, count uses number  
**C)** count is better  
**D)** for_each doesn't work

**Answer: B** - `for_each` iterates over a map or set, while `count` uses a numeric value to create multiple instances.

### Question 2
What are dynamic blocks used for?

**A)** Creating resources dynamically  
**B)** Creating nested blocks conditionally  
**C)** Deleting resources  
**D)** Nothing

**Answer: B** - Dynamic blocks allow creating nested configuration blocks conditionally based on variables.

### Question 3
What is terraform_remote_state used for?

**A)** Storing state  
**B)** Accessing outputs from other Terraform configurations  
**C)** Deleting state  
**D)** Creating state

**Answer: B** - `terraform_remote_state` data source allows accessing outputs from other Terraform state files.

### Question 4
What is the purpose of Terraform workspaces?

**A)** Organizing code  
**B)** Managing multiple environments with same configuration  
**C)** Storing secrets  
**D)** Running Terraform

**Answer: B** - Workspaces allow managing multiple environments (dev, staging, prod) using the same configuration with different state files.

### Question 5
What should you use to prevent state file conflicts?

**A)** Local state  
**B)** Remote state with locking  
**C)** No state  
**D)** Multiple state files

**Answer: B** - Remote state with DynamoDB locking prevents multiple people from modifying state simultaneously.

## Related Topics

- [Terraform Fundamentals](../02_intermediate/02.%20Terraform%20Fundamentals.md) - Terraform basics
- [Multi-Cloud Strategies](../04_overachiever/02.%20Multi-Cloud%20Strategies.md) - Multi-cloud IaC

