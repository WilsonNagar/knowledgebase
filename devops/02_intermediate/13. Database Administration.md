---
number: 13
title: "Database Administration"
slug: "database-administration"
level: "intermediate"
tags: ["database", "postgresql", "mysql", "mongodb", "backup", "performance", "administration"]
prerequisites: [1, 3]
estimated_minutes: 90
contributors: []
canonical_id: "devops-intermediate-13"
---

# Database Administration

## Overview

Database administration in DevOps involves managing database lifecycle, performance optimization, backup and recovery, security, and automation. This guide covers PostgreSQL, MySQL, MongoDB administration, backup strategies, performance tuning, monitoring, and database automation in CI/CD pipelines.

## Deep Explanation

### Database Administration Fundamentals

#### Key Responsibilities

- **Provisioning**: Create and configure databases
- **Backup & Recovery**: Ensure data safety
- **Performance Tuning**: Optimize queries and configuration
- **Security**: Manage access and encryption
- **Monitoring**: Track health and performance
- **Automation**: Automate routine tasks

### PostgreSQL Administration

#### Installation

**Docker**:
```bash
docker run -d \
  --name postgres \
  -e POSTGRES_PASSWORD=password \
  -e POSTGRES_DB=myapp \
  -p 5432:5432 \
  postgres:15
```

**Kubernetes**:
```yaml
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: postgres
spec:
  serviceName: postgres
  replicas: 1
  template:
    spec:
      containers:
      - name: postgres
        image: postgres:15
        env:
        - name: POSTGRES_PASSWORD
          valueFrom:
            secretKeyRef:
              name: postgres-secret
              key: password
        volumeMounts:
        - name: data
          mountPath: /var/lib/postgresql/data
  volumeClaimTemplates:
  - metadata:
      name: data
    spec:
      accessModes: ["ReadWriteOnce"]
      resources:
        requests:
          storage: 10Gi
```

#### User Management

**Create User**:
```sql
CREATE USER app_user WITH PASSWORD 'secure_password';
GRANT CONNECT ON DATABASE myapp TO app_user;
GRANT USAGE ON SCHEMA public TO app_user;
GRANT SELECT, INSERT, UPDATE, DELETE ON ALL TABLES IN SCHEMA public TO app_user;
```

**Role Management**:
```sql
CREATE ROLE readonly;
GRANT CONNECT ON DATABASE myapp TO readonly;
GRANT SELECT ON ALL TABLES IN SCHEMA public TO readonly;

GRANT readonly TO app_user;
```

#### Backup and Restore

**pg_dump**:
```bash
# Full database backup
pg_dump -h localhost -U postgres -d myapp -F c -f backup.dump

# Schema only
pg_dump -h localhost -U postgres -d myapp --schema-only -f schema.sql

# Data only
pg_dump -h localhost -U postgres -d myapp --data-only -f data.sql

# Specific tables
pg_dump -h localhost -U postgres -d myapp -t users -t orders -f tables.dump
```

**pg_restore**:
```bash
# Restore database
pg_restore -h localhost -U postgres -d myapp -c backup.dump

# Restore to new database
createdb -h localhost -U postgres newdb
pg_restore -h localhost -U postgres -d newdb backup.dump
```

**Automated Backup Script**:
```bash
#!/bin/bash
BACKUP_DIR="/backups/postgres"
DATE=$(date +%Y%m%d_%H%M%S)
DB_NAME="myapp"

# Create backup
pg_dump -h localhost -U postgres -d $DB_NAME -F c -f "$BACKUP_DIR/${DB_NAME}_${DATE}.dump"

# Compress
gzip "$BACKUP_DIR/${DB_NAME}_${DATE}.dump"

# Delete backups older than 30 days
find $BACKUP_DIR -name "*.dump.gz" -mtime +30 -delete
```

#### Performance Tuning

**Configuration**:
```sql
-- Check current settings
SHOW shared_buffers;
SHOW work_mem;
SHOW maintenance_work_mem;

-- Update settings
ALTER SYSTEM SET shared_buffers = '256MB';
ALTER SYSTEM SET work_mem = '16MB';
ALTER SYSTEM SET maintenance_work_mem = '64MB';
SELECT pg_reload_conf();
```

**Index Management**:
```sql
-- Create index
CREATE INDEX idx_users_email ON users(email);

-- Create partial index
CREATE INDEX idx_active_users ON users(email) WHERE active = true;

-- Analyze table
ANALYZE users;

-- Check index usage
SELECT * FROM pg_stat_user_indexes WHERE schemaname = 'public';
```

**Query Optimization**:
```sql
-- Explain query
EXPLAIN ANALYZE SELECT * FROM users WHERE email = 'user@example.com';

-- Enable query logging
ALTER DATABASE myapp SET log_min_duration_statement = 1000;  -- Log queries > 1s
```

### MySQL Administration

#### Installation

**Docker**:
```bash
docker run -d \
  --name mysql \
  -e MYSQL_ROOT_PASSWORD=password \
  -e MYSQL_DATABASE=myapp \
  -p 3306:3306 \
  mysql:8.0
```

#### User Management

**Create User**:
```sql
CREATE USER 'app_user'@'%' IDENTIFIED BY 'secure_password';
GRANT SELECT, INSERT, UPDATE, DELETE ON myapp.* TO 'app_user'@'%';
FLUSH PRIVILEGES;
```

#### Backup and Restore

**mysqldump**:
```bash
# Full database backup
mysqldump -h localhost -u root -p myapp > backup.sql

# Specific tables
mysqldump -h localhost -u root -p myapp users orders > tables.sql

# Backup with compression
mysqldump -h localhost -u root -p myapp | gzip > backup.sql.gz
```

**Restore**:
```bash
# Restore database
mysql -h localhost -u root -p myapp < backup.sql

# Restore compressed backup
gunzip < backup.sql.gz | mysql -h localhost -u root -p myapp
```

#### Performance Tuning

**Configuration**:
```sql
-- Check variables
SHOW VARIABLES LIKE 'innodb_buffer_pool_size';
SHOW VARIABLES LIKE 'max_connections';

-- Update in my.cnf
[mysqld]
innodb_buffer_pool_size = 1G
max_connections = 200
query_cache_size = 64M
```

**Index Management**:
```sql
-- Create index
CREATE INDEX idx_email ON users(email);

-- Show indexes
SHOW INDEXES FROM users;

-- Analyze table
ANALYZE TABLE users;
```

### MongoDB Administration

#### Installation

**Docker**:
```bash
docker run -d \
  --name mongodb \
  -e MONGO_INITDB_ROOT_USERNAME=admin \
  -e MONGO_INITDB_ROOT_PASSWORD=password \
  -p 27017:27017 \
  mongo:6.0
```

#### User Management

**Create User**:
```javascript
use myapp
db.createUser({
  user: "app_user",
  pwd: "secure_password",
  roles: [
    { role: "readWrite", db: "myapp" }
  ]
})
```

#### Backup and Restore

**mongodump**:
```bash
# Full database backup
mongodump --host localhost:27017 \
  --username admin \
  --password password \
  --authenticationDatabase admin \
  --db myapp \
  --out /backups/mongodb

# Specific collection
mongodump --host localhost:27017 \
  --db myapp \
  --collection users \
  --out /backups/mongodb
```

**mongorestore**:
```bash
# Restore database
mongorestore --host localhost:27017 \
  --username admin \
  --password password \
  --authenticationDatabase admin \
  --db myapp \
  /backups/mongodb/myapp
```

#### Performance Tuning

**Indexes**:
```javascript
// Create index
db.users.createIndex({ email: 1 })

// Create compound index
db.users.createIndex({ email: 1, active: 1 })

// Show indexes
db.users.getIndexes()

// Explain query
db.users.find({ email: "user@example.com" }).explain("executionStats")
```

### Database Monitoring

#### PostgreSQL Monitoring

**pg_stat_statements**:
```sql
-- Enable extension
CREATE EXTENSION pg_stat_statements;

-- View slow queries
SELECT 
  query,
  calls,
  total_exec_time,
  mean_exec_time,
  max_exec_time
FROM pg_stat_statements
ORDER BY total_exec_time DESC
LIMIT 10;
```

**Connection Monitoring**:
```sql
-- Active connections
SELECT count(*) FROM pg_stat_activity;

-- Connection details
SELECT 
  pid,
  usename,
  application_name,
  client_addr,
  state,
  query
FROM pg_stat_activity
WHERE state = 'active';
```

#### MySQL Monitoring

**Performance Schema**:
```sql
-- Enable performance schema
-- Check slow queries
SELECT * FROM performance_schema.events_statements_summary_by_digest
ORDER BY sum_timer_wait DESC
LIMIT 10;

-- Connection monitoring
SELECT * FROM performance_schema.threads;
```

**Slow Query Log**:
```sql
-- Enable slow query log
SET GLOBAL slow_query_log = 'ON';
SET GLOBAL long_query_time = 1;  -- Log queries > 1s
```

### Database Automation

#### Automated Backups

**Cron Job**:
```bash
# Crontab entry
0 2 * * * /usr/local/bin/backup_postgres.sh
```

**Kubernetes CronJob**:
```yaml
apiVersion: batch/v1
kind: CronJob
metadata:
  name: postgres-backup
spec:
  schedule: "0 2 * * *"
  jobTemplate:
    spec:
      template:
        spec:
          containers:
          - name: backup
            image: postgres:15
            command:
            - /bin/bash
            - -c
            - |
              pg_dump -h postgres -U postgres -d myapp -F c -f /backups/backup.dump
              gzip /backups/backup.dump
            volumeMounts:
            - name: backup-storage
              mountPath: /backups
          volumes:
          - name: backup-storage
            persistentVolumeClaim:
              claimName: backup-pvc
          restartPolicy: OnFailure
```

#### Database Migrations

**Flyway**:
```sql
-- V1__Create_users_table.sql
CREATE TABLE users (
  id SERIAL PRIMARY KEY,
  email VARCHAR(255) UNIQUE NOT NULL,
  name VARCHAR(255) NOT NULL,
  created_at TIMESTAMP DEFAULT NOW()
);
```

**Liquibase**:
```xml
<!-- changelog.xml -->
<databaseChangeLog>
  <changeSet id="1" author="dev">
    <createTable tableName="users">
      <column name="id" type="SERIAL">
        <constraints primaryKey="true"/>
      </column>
      <column name="email" type="VARCHAR(255)">
        <constraints nullable="false" unique="true"/>
      </column>
      <column name="name" type="VARCHAR(255)">
        <constraints nullable="false"/>
      </column>
    </createTable>
  </changeSet>
</databaseChangeLog>
```

### Security Best Practices

#### Encryption

**PostgreSQL SSL**:
```bash
# Enable SSL in postgresql.conf
ssl = on
ssl_cert_file = '/path/to/server.crt'
ssl_key_file = '/path/to/server.key'
```

**Connection String**:
```
postgresql://user:pass@host:5432/db?sslmode=require
```

#### Access Control

**Network Restrictions**:
```sql
-- PostgreSQL pg_hba.conf
host    myapp    app_user    10.0.0.0/8    md5
host    myapp    app_user    0.0.0.0/0    reject
```

**Least Privilege**:
```sql
-- Grant only necessary permissions
GRANT SELECT ON users TO readonly_user;
GRANT SELECT, INSERT, UPDATE ON orders TO app_user;
```

## Diagrams

### Database Administration Workflow

```mermaid
graph TB
    PROVISION[Provision Database]
    CONFIGURE[Configure]
    MONITOR[Monitor]
    BACKUP[Backup]
    OPTIMIZE[Optimize]
    
    PROVISION --> CONFIGURE
    CONFIGURE --> MONITOR
    MONITOR --> BACKUP
    MONITOR --> OPTIMIZE
    
    style PROVISION fill:#4caf50
    style MONITOR fill:#2196f3
    style BACKUP fill:#ff9800
```

## Real Code Examples

### Complete Database Administration Script

```bash
#!/bin/bash
# db_admin.sh

set -e

DB_TYPE=${1:-postgres}
DB_NAME=${2:-myapp}
BACKUP_DIR="/backups/${DB_TYPE}"

mkdir -p $BACKUP_DIR

case $DB_TYPE in
  postgres)
    echo "Backing up PostgreSQL database: $DB_NAME"
    pg_dump -h localhost -U postgres -d $DB_NAME -F c \
      -f "$BACKUP_DIR/${DB_NAME}_$(date +%Y%m%d_%H%M%S).dump"
    
    echo "Analyzing database"
    psql -h localhost -U postgres -d $DB_NAME -c "ANALYZE;"
    
    echo "Checking connections"
    psql -h localhost -U postgres -d $DB_NAME -c \
      "SELECT count(*) FROM pg_stat_activity;"
    ;;
    
  mysql)
    echo "Backing up MySQL database: $DB_NAME"
    mysqldump -h localhost -u root -p $DB_NAME | \
      gzip > "$BACKUP_DIR/${DB_NAME}_$(date +%Y%m%d_%H%M%S).sql.gz"
    
    echo "Optimizing tables"
    mysql -h localhost -u root -p $DB_NAME -e "OPTIMIZE TABLE users, orders;"
    ;;
    
  mongodb)
    echo "Backing up MongoDB database: $DB_NAME"
    mongodump --host localhost:27017 \
      --db $DB_NAME \
      --out "$BACKUP_DIR/${DB_NAME}_$(date +%Y%m%d_%H%M%S)"
    ;;
esac

echo "Database administration completed"
```

## Hard Use-Case: Database Migration Strategy

### Problem

Migrate production database from MySQL to PostgreSQL with zero downtime.

### Solution: Blue-Green Migration

**Phase 1: Setup PostgreSQL**:
```bash
# Setup PostgreSQL replica
# Use replication tools to sync data
```

**Phase 2: Dual Write**:
```python
# Application writes to both databases
def create_user(user_data):
    # Write to MySQL
    mysql_db.create_user(user_data)
    # Write to PostgreSQL
    postgres_db.create_user(user_data)
```

**Phase 3: Switch Reads**:
```python
# Gradually switch reads to PostgreSQL
def get_user(user_id):
    # Read from PostgreSQL
    return postgres_db.get_user(user_id)
```

**Phase 4: Complete Migration**:
```python
# Stop writing to MySQL
# Remove MySQL dependency
```

## Edge Cases and Pitfalls

### 1. Backup Failure

**Problem**: Backups fail silently

**Solution**: Monitor backup success

```bash
# Check backup success
if [ $? -eq 0 ]; then
  echo "Backup successful"
else
  echo "Backup failed" | mail -s "Backup Alert" admin@example.com
fi
```

### 2. Performance Degradation

**Problem**: Database slows down over time

**Solution**: Regular maintenance

```sql
-- PostgreSQL
VACUUM ANALYZE;

-- MySQL
OPTIMIZE TABLE users;
```

### 3. Connection Exhaustion

**Problem**: Too many connections

**Solution**: Connection pooling

```python
# Use connection pool
from sqlalchemy import create_engine
engine = create_engine(
    'postgresql://user:pass@host/db',
    pool_size=10,
    max_overflow=20
)
```

## References and Further Reading

- [PostgreSQL Documentation](https://www.postgresql.org/docs/) - PostgreSQL guide
- [MySQL Documentation](https://dev.mysql.com/doc/) - MySQL guide
- [MongoDB Documentation](https://docs.mongodb.com/) - MongoDB guide

## Quiz

### Question 1
What is pg_dump used for?

**A)** Restoring databases  
**B)** Backing up PostgreSQL databases  
**C)** Creating users  
**D)** Deleting databases

**Answer: B** - `pg_dump` is used to create backups of PostgreSQL databases.

### Question 2
What is the purpose of database indexes?

**A)** Store data  
**B)** Improve query performance  
**C)** Delete data  
**D)** Create tables

**Answer: B** - Indexes improve query performance by allowing faster data retrieval.

### Question 3
What should you do regularly for database maintenance?

**A)** Nothing  
**B)** Backup, analyze, optimize  
**C)** Delete data  
**D)** Restart database

**Answer: B** - Regular maintenance includes backups, analyzing tables, and optimizing performance.

### Question 4
What is connection pooling?

**A)** Creating many connections  
**B)** Reusing database connections efficiently  
**C)** Deleting connections  
**D)** Storing connections

**Answer: B** - Connection pooling reuses database connections to improve efficiency and prevent exhaustion.

### Question 5
What is the principle of least privilege in database security?

**A)** Grant all permissions  
**B)** Grant only necessary permissions  
**C)** No permissions  
**D)** All users same permissions

**Answer: B** - Least privilege means granting users only the minimum permissions they need to perform their tasks.

## Related Topics

- [Backup & Disaster Recovery](./14.%20Backup%20%26%20Disaster%20Recovery.md) - Backup strategies
- [Performance Optimization](../03_advanced/03.%20Performance%20Optimization.md) - Performance tuning
- [Security Fundamentals](./05.%20Security%20Fundamentals.md) - Database security

