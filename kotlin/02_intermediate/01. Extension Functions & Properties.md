---
number: 1
title: "Extension Functions & Properties"
slug: "extension-functions-and-properties"
level: "intermediate"
tags: ["kotlin", "extensions", "functions", "properties"]
prerequisites: [8]
estimated_minutes: 75
contributors: []
diagrams: []
examples: []
canonical_id: "kotlin-intermediate-01"
---

# Extension Functions & Properties

## Overview

Extension functions and properties allow you to add functionality to existing classes without modifying their source code or using inheritance. This is one of Kotlin's most powerful features for creating clean, readable APIs.

## Deep Explanation

### Extension Functions

#### Basic Syntax

```kotlin
fun String.removeSpaces(): String {
    return this.replace(" ", "")
}

val text = "Hello World"
println(text.removeSpaces())  // "HelloWorld"
```

#### How They Work

Extension functions are resolved **statically** - they don't modify the class, they're just syntactic sugar:

```kotlin
fun String.lastChar(): Char = this[this.length - 1]

// Under the hood, this becomes:
// fun lastChar(String receiver): Char = receiver[receiver.length - 1]
```

### Extension Properties

```kotlin
val String.lastChar: Char
    get() = this[this.length - 1]

val text = "Kotlin"
println(text.lastChar)  // 'n'

// Mutable extension property
var StringBuilder.lastChar: Char
    get() = this[this.length - 1]
    set(value) {
        this.setCharAt(this.length - 1, value)
    }
```

### Nullable Receivers

Extensions can be defined on nullable types:

```kotlin
fun String?.isNullOrEmpty(): Boolean {
    return this == null || this.isEmpty()
}

val str: String? = null
println(str.isNullOrEmpty())  // true
```

### Generic Extensions

```kotlin
fun <T> List<T>.secondOrNull(): T? {
    return if (this.size >= 2) this[1] else null
}

val list = listOf(1, 2, 3)
println(list.secondOrNull())  // 2
```

### Extension Scope

Extensions must be imported to use:

```kotlin
// File: StringExtensions.kt
fun String.removeSpaces(): String = this.replace(" ", "")

// File: Main.kt
import StringExtensions.removeSpaces  // Import extension
// Or
import StringExtensions.*  // Import all extensions
```

### Member vs Extension

Members always win:

```kotlin
class Example {
    fun print() = println("Member")
}

fun Example.print() = println("Extension")

val ex = Example()
ex.print()  // "Member" (member function wins)
```

### Examples

#### Example 1: Collection Extensions

```kotlin
fun <T> List<T>.second(): T {
    if (this.size < 2) throw NoSuchElementException()
    return this[1]
}

fun <T> List<T>.penultimate(): T {
    if (this.size < 2) throw NoSuchElementException()
    return this[this.size - 2]
}
```

#### Example 2: Date Extensions

```kotlin
import java.time.LocalDate

fun LocalDate.isWeekend(): Boolean {
    return this.dayOfWeek.value >= 6
}

fun LocalDate.daysUntil(other: LocalDate): Long {
    return java.time.temporal.ChronoUnit.DAYS.between(this, other)
}
```

## Summary

Extension functions and properties:
- Add functionality without modifying classes
- Resolved statically (no runtime overhead)
- Can work with nullable receivers
- Must be imported to use
- Members take precedence over extensions

## Next Steps

- Learn about generics
- Understand delegation
- Explore coroutines
- Master scope functions

