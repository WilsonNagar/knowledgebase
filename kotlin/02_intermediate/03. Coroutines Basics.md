---
number: 3
title: "Coroutines Basics"
slug: "coroutines-basics"
level: "intermediate"
tags: ["kotlin", "coroutines", "async", "concurrency"]
prerequisites: [2]
estimated_minutes: 120
contributors: []
diagrams: []
examples: []
canonical_id: "kotlin-intermediate-03"
---

# Coroutines Basics

## Overview

Coroutines are Kotlin's solution for asynchronous programming. They provide a way to write asynchronous code that looks synchronous, making it easier to handle concurrency, callbacks, and non-blocking operations.

## Deep Explanation

### What are Coroutines?

Coroutines are lightweight threads that can be suspended and resumed. They're more efficient than threads because:
- They don't block threads
- Thousands can run on a single thread
- They're cheaper to create and switch

### Basic Coroutine

```kotlin
import kotlinx.coroutines.*

fun main() = runBlocking {
    launch {
        delay(1000L)
        println("World!")
    }
    println("Hello,")
}
// Output: Hello, World!
```

### Suspending Functions

Functions that can be paused and resumed:

```kotlin
suspend fun fetchData(): String {
    delay(1000L)  // Simulate network call
    return "Data"
}
```

### Coroutine Builders

#### `launch`

Fire-and-forget coroutine:

```kotlin
launch {
    delay(1000L)
    println("Done")
}
```

#### `async`

Returns a `Deferred` value:

```kotlin
val deferred = async {
    delay(1000L)
    "Result"
}
val result = deferred.await()
```

#### `runBlocking`

Blocks until coroutine completes:

```kotlin
runBlocking {
    delay(1000L)
    println("Done")
}
```

### Coroutine Context & Dispatchers

```kotlin
// Default dispatcher (shared thread pool)
launch(Dispatchers.Default) {
    // CPU-intensive work
}

// Main dispatcher (UI thread on Android)
launch(Dispatchers.Main) {
    // Update UI
}

// IO dispatcher (for I/O operations)
launch(Dispatchers.IO) {
    // Network/File operations
}

// Unconfined (runs on current thread)
launch(Dispatchers.Unconfined) {
    // ...
}
```

### Examples

#### Example 1: Sequential vs Concurrent

```kotlin
// Sequential
suspend fun sequential() {
    val data1 = fetchData1()  // Waits
    val data2 = fetchData2()  // Then waits
    process(data1, data2)
}

// Concurrent
suspend fun concurrent() {
    val deferred1 = async { fetchData1() }
    val deferred2 = async { fetchData2() }
    val data1 = deferred1.await()
    val data2 = deferred2.await()
    process(data1, data2)
}
```

## Summary

Coroutines provide:
- Lightweight concurrency
- Suspending functions for async operations
- Multiple dispatchers for different use cases
- Structured concurrency

## Next Steps

- Learn advanced coroutines
- Understand Flow
- Master cancellation
- Explore channels

