---
number: 4
title: "Functions & Lambdas"
slug: "functions-and-lambdas"
level: "beginner"
tags: ["kotlin", "functions", "lambdas", "higher-order-functions"]
prerequisites: [3]
estimated_minutes: 90
contributors: []
diagrams: []
examples: []
canonical_id: "kotlin-beginner-04"
---

# Functions & Lambdas

## Overview

Functions are fundamental building blocks in Kotlin. This guide covers function declarations, parameters, return types, default arguments, named arguments, lambda expressions, and higher-order functions.

## Deep Explanation

### Function Declaration

#### Basic Function

```kotlin
fun greet(name: String): String {
    return "Hello, $name!"
}
```

#### Single Expression Function

```kotlin
fun add(a: Int, b: Int): Int = a + b

// Type inference
fun multiply(a: Int, b: Int) = a * b
```

#### Unit Return Type

```kotlin
fun printMessage(message: String): Unit {
    println(message)
}

// Unit can be omitted
fun printMessage(message: String) {
    println(message)
}
```

### Function Parameters

#### Default Arguments

```kotlin
fun greet(name: String, greeting: String = "Hello") {
    println("$greeting, $name!")
}

greet("Alice")                    // "Hello, Alice!"
greet("Bob", "Hi")                // "Hi, Bob!"
```

#### Named Arguments

```kotlin
fun createUser(name: String, age: Int, email: String = "") {
    // ...
}

createUser("Alice", 25)                              // Positional
createUser(name = "Alice", age = 25)                 // Named
createUser(age = 25, name = "Alice")                 // Order doesn't matter
createUser(name = "Alice", age = 25, email = "a@b.com")  // Mixed
```

#### Variable Arguments (Varargs)

```kotlin
fun sum(vararg numbers: Int): Int {
    return numbers.sum()
}

sum(1, 2, 3)           // 6
sum(1, 2, 3, 4, 5)     // 15

// Spread operator
val numbers = intArrayOf(1, 2, 3)
sum(*numbers)          // Spreads array as arguments
```

### Lambda Expressions

#### Basic Lambda

```kotlin
val add = { a: Int, b: Int -> a + b }
println(add(3, 5))  // 8
```

#### Lambda with Single Parameter

```kotlin
val square = { x: Int -> x * x }
val squareShort: (Int) -> Int = { it * it }  // 'it' for single parameter

println(square(5))        // 25
println(squareShort(5))   // 25
```

#### Lambda Types

```kotlin
val add: (Int, Int) -> Int = { a, b -> a + b }
val print: (String) -> Unit = { println(it) }
val isValid: (String) -> Boolean = { it.isNotEmpty() }
```

### Higher-Order Functions

Functions that take other functions as parameters or return functions:

#### Function as Parameter

```kotlin
fun calculate(x: Int, y: Int, operation: (Int, Int) -> Int): Int {
    return operation(x, y)
}

val sum = calculate(5, 3) { a, b -> a + b }      // 8
val product = calculate(5, 3) { a, b -> a * b }  // 15
```

#### Function as Return Value

```kotlin
fun getOperation(type: String): (Int, Int) -> Int {
    return when (type) {
        "add" -> { a, b -> a + b }
        "multiply" -> { a, b -> a * b }
        else -> { a, b -> a - b }
    }
}

val add = getOperation("add")
println(add(5, 3))  // 8
```

### Common Higher-Order Functions

#### `forEach`

```kotlin
val numbers = listOf(1, 2, 3, 4, 5)
numbers.forEach { println(it) }
numbers.forEachIndexed { index, value -> 
    println("$index: $value") 
}
```

#### `map`

```kotlin
val numbers = listOf(1, 2, 3, 4, 5)
val squares = numbers.map { it * it }  // [1, 4, 9, 16, 25]
val strings = numbers.map { "Number $it" }
```

#### `filter`

```kotlin
val numbers = listOf(1, 2, 3, 4, 5, 6)
val evens = numbers.filter { it % 2 == 0 }  // [2, 4, 6]
val positives = numbers.filter { it > 0 }
```

#### `reduce` & `fold`

```kotlin
val numbers = listOf(1, 2, 3, 4, 5)

// reduce: starts with first element
val sum = numbers.reduce { acc, n -> acc + n }  // 15

// fold: starts with initial value
val product = numbers.fold(1) { acc, n -> acc * n }  // 120
```

#### `any`, `all`, `none`

```kotlin
val numbers = listOf(1, 2, 3, 4, 5)

numbers.any { it > 3 }    // true (at least one)
numbers.all { it > 0 }    // true (all)
numbers.none { it < 0 }   // true (none)
```

#### `find` & `firstOrNull`

```kotlin
val numbers = listOf(1, 2, 3, 4, 5)

numbers.find { it > 3 }        // 4 (first matching)
numbers.firstOrNull { it > 10 } // null (no match)
```

### Function References

#### Method References

```kotlin
val numbers = listOf("1", "2", "3")
val ints = numbers.map(String::toInt)  // [1, 2, 3]

fun isEven(n: Int) = n % 2 == 0
val evens = numbers.map(String::toInt).filter(::isEven)
```

### Inline Functions

For performance optimization:

```kotlin
inline fun <T> measureTime(block: () -> T): T {
    val start = System.currentTimeMillis()
    val result = block()
    val end = System.currentTimeMillis()
    println("Time: ${end - start}ms")
    return result
}

val result = measureTime {
    // Expensive operation
    (1..1000000).sum()
}
```

### Extension Functions

Add functionality to existing classes:

```kotlin
fun String.removeSpaces(): String {
    return this.replace(" ", "")
}

val text = "Hello World"
println(text.removeSpaces())  // "HelloWorld"
```

### Infix Functions

```kotlin
infix fun Int.times(str: String) = str.repeat(this)

println(2 times "Hello")  // "HelloHello"
```

### Examples

#### Example 1: Custom Higher-Order Function

```kotlin
fun <T> List<T>.customFilter(predicate: (T) -> Boolean): List<T> {
    val result = mutableListOf<T>()
    for (item in this) {
        if (predicate(item)) {
            result.add(item)
        }
    }
    return result
}

val numbers = listOf(1, 2, 3, 4, 5)
val evens = numbers.customFilter { it % 2 == 0 }  // [2, 4]
```

#### Example 2: Function Composition

```kotlin
fun <A, B, C> compose(f: (B) -> C, g: (A) -> B): (A) -> C {
    return { x -> f(g(x)) }
}

val addOne = { x: Int -> x + 1 }
val multiplyByTwo = { x: Int -> x * 2 }
val addThenMultiply = compose(multiplyByTwo, addOne)

println(addThenMultiply(5))  // (5 + 1) * 2 = 12
```

#### Example 3: Currying

```kotlin
fun add(x: Int) = { y: Int -> x + y }

val addFive = add(5)
println(addFive(3))  // 8
```

## Summary

Kotlin functions are powerful and flexible:
- Default and named arguments reduce overloads
- Single-expression functions are concise
- Lambdas enable functional programming
- Higher-order functions are first-class citizens
- Extension functions add functionality without inheritance
- Inline functions optimize performance

## Next Steps

- Learn about classes and objects
- Understand null safety
- Explore collections
- Master extension functions

