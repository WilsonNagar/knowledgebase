---
number: 7
title: "Collections"
slug: "collections"
level: "beginner"
tags: ["kotlin", "collections", "lists", "sets", "maps"]
prerequisites: [6]
estimated_minutes: 90
contributors: []
diagrams: []
examples: []
canonical_id: "kotlin-beginner-07"
---

# Collections

## Overview

Kotlin provides rich collection APIs with both mutable and immutable collections. This guide covers Lists, Sets, Maps, and their common operations.

## Deep Explanation

### Collection Types

Kotlin distinguishes between **read-only** and **mutable** collections:

- **Read-only**: `List`, `Set`, `Map` (interface)
- **Mutable**: `MutableList`, `MutableSet`, `MutableMap` (interface)

### Lists

#### Creating Lists

```kotlin
// Read-only list
val list = listOf(1, 2, 3, 4, 5)
val emptyList = emptyList<Int>()

// Mutable list
val mutableList = mutableListOf(1, 2, 3)
val arrayList = arrayListOf(1, 2, 3)

// List with initializer
val squares = List(5) { it * it }  // [0, 1, 4, 9, 16]
```

#### List Operations

```kotlin
val list = listOf(1, 2, 3, 4, 5)

// Access
list[0]              // 1
list.first()          // 1
list.last()           // 5
list.getOrNull(10)    // null

// Size
list.size             // 5
list.isEmpty()        // false
list.isNotEmpty()     // true

// Contains
list.contains(3)      // true
3 in list            // true

// SubList
list.subList(1, 4)   // [2, 3, 4]
```

#### List Transformations

```kotlin
val list = listOf(1, 2, 3, 4, 5)

// Map
val doubled = list.map { it * 2 }  // [2, 4, 6, 8, 10]

// Filter
val evens = list.filter { it % 2 == 0 }  // [2, 4]

// Reduce
val sum = list.reduce { acc, n -> acc + n }  // 15

// Fold
val product = list.fold(1) { acc, n -> acc * n }  // 120

// FlatMap
val nested = listOf(listOf(1, 2), listOf(3, 4))
val flat = nested.flatMap { it }  // [1, 2, 3, 4]
```

### Sets

#### Creating Sets

```kotlin
// Read-only set
val set = setOf(1, 2, 3, 2, 1)  // [1, 2, 3] (duplicates removed)

// Mutable set
val mutableSet = mutableSetOf(1, 2, 3)
val hashSet = hashSetOf(1, 2, 3)
val linkedSet = linkedSetOf(1, 2, 3)
val sortedSet = sortedSetOf(3, 1, 2)  // [1, 2, 3] (sorted)
```

#### Set Operations

```kotlin
val set1 = setOf(1, 2, 3)
val set2 = setOf(3, 4, 5)

// Union
set1.union(set2)           // [1, 2, 3, 4, 5]

// Intersection
set1.intersect(set2)       // [3]

// Difference
set1 subtract set2         // [1, 2]
set1 - set2                // [1, 2]
```

### Maps

#### Creating Maps

```kotlin
// Read-only map
val map = mapOf("a" to 1, "b" to 2, "c" to 3)
val emptyMap = emptyMap<String, Int>()

// Mutable map
val mutableMap = mutableMapOf("a" to 1, "b" to 2)
val hashMap = hashMapOf("a" to 1, "b" to 2)
val linkedMap = linkedMapOf("a" to 1, "b" to 2)
```

#### Map Operations

```kotlin
val map = mapOf("a" to 1, "b" to 2, "c" to 3)

// Access
map["a"]                  // 1
map.getValue("a")          // 1 (throws if missing)
map.getOrDefault("d", 0)  // 0

// Keys and Values
map.keys                   // [a, b, c]
map.values                 // [1, 2, 3]
map.entries                // [a=1, b=2, c=3]

// Contains
map.containsKey("a")       // true
"a" in map                // true
map.containsValue(1)       // true
```

#### Map Transformations

```kotlin
val map = mapOf("a" to 1, "b" to 2, "c" to 3)

// Map keys/values
map.mapKeys { it.key.uppercase() }    // {A=1, B=2, C=3}
map.mapValues { it.value * 2 }        // {a=2, b=4, c=6}

// Filter
map.filter { it.value > 1 }           // {b=2, c=3}
map.filterKeys { it != "a" }          // {b=2, c=3}
map.filterValues { it % 2 == 0 }      // {b=2}
```

### Collection Operations

#### Filtering

```kotlin
val list = listOf(1, 2, 3, 4, 5, 6)

list.filter { it % 2 == 0 }           // [2, 4, 6]
list.filterNot { it % 2 == 0 }        // [1, 3, 5]
list.filterIndexed { i, _ -> i < 3 }  // [1, 2, 3]
list.filterNotNull()                  // Remove nulls
```

#### Mapping

```kotlin
val list = listOf(1, 2, 3)

list.map { it * 2 }                   // [2, 4, 6]
list.mapIndexed { i, v -> i * v }     // [0, 2, 6]
list.mapNotNull { if (it > 1) it else null }  // [2, 3]
```

#### Finding

```kotlin
val list = listOf(1, 2, 3, 4, 5)

list.find { it > 3 }                  // 4
list.firstOrNull { it > 10 }          // null
list.last { it < 5 }                  // 4
list.first()                           // 1
```

#### Aggregation

```kotlin
val list = listOf(1, 2, 3, 4, 5)

list.sum()                             // 15
list.average()                         // 3.0
list.minOrNull()                       // 1
list.maxOrNull()                       // 5
list.count { it % 2 == 0 }            // 2
```

#### Sorting

```kotlin
val list = listOf(3, 1, 4, 1, 5)

list.sorted()                          // [1, 1, 3, 4, 5]
list.sortedDescending()                // [5, 4, 3, 1, 1]
list.sortedBy { it }                   // Custom comparator
list.distinct()                        // [3, 1, 4, 5]
```

#### Grouping & Partitioning

```kotlin
val list = listOf(1, 2, 3, 4, 5, 6)

// Group by
list.groupBy { it % 2 }                // {1=[1,3,5], 0=[2,4,6]}

// Partition
val (evens, odds) = list.partition { it % 2 == 0 }
// evens = [2, 4, 6], odds = [1, 3, 5]
```

### Examples

#### Example 1: Processing User List

```kotlin
data class User(val id: Int, val name: String, val age: Int)

val users = listOf(
    User(1, "Alice", 25),
    User(2, "Bob", 30),
    User(3, "Charlie", 25)
)

// Group by age
val byAge = users.groupBy { it.age }

// Find oldest
val oldest = users.maxByOrNull { it.age }

// Filter active users
val adults = users.filter { it.age >= 18 }
```

#### Example 2: Word Frequency

```kotlin
val text = "hello world hello kotlin world"

val wordFreq = text.split(" ")
    .groupingBy { it }
    .eachCount()

// {hello=2, world=2, kotlin=1}
```

## Summary

Kotlin collections are powerful and type-safe:
- Read-only vs mutable collections
- Rich transformation operations
- Functional programming style
- Null-safe operations
- Efficient implementations

## Next Steps

- Learn about sequences and lazy evaluation
- Understand extension functions
- Explore generics
- Master coroutines

