---
number: 5
title: "Classes & Objects"
slug: "classes-and-objects"
level: "beginner"
tags: ["kotlin", "classes", "objects", "oop", "inheritance"]
prerequisites: [4]
estimated_minutes: 90
contributors: []
diagrams: []
examples: []
canonical_id: "kotlin-beginner-05"
---

# Classes & Objects

## Overview

Classes are the foundation of object-oriented programming in Kotlin. This guide covers class declarations, constructors, properties, inheritance, interfaces, abstract classes, and object declarations.

## Deep Explanation

### Class Declaration

#### Basic Class

```kotlin
class Person {
    var name: String = ""
    var age: Int = 0
}

val person = Person()
person.name = "Alice"
person.age = 25
```

#### Primary Constructor

```kotlin
class Person(val name: String, var age: Int)

val person = Person("Alice", 25)
println(person.name)  // "Alice"
```

#### Primary Constructor with Body

```kotlin
class Person(val name: String, var age: Int) {
    init {
        require(age >= 0) { "Age cannot be negative" }
    }
}
```

#### Secondary Constructor

```kotlin
class Person(val name: String, var age: Int) {
    constructor(name: String) : this(name, 0)
    constructor() : this("Unknown", 0)
}

val person1 = Person("Alice", 25)
val person2 = Person("Bob")
val person3 = Person()
```

### Properties

#### Property Getters & Setters

```kotlin
class Rectangle(val width: Int, val height: Int) {
    val area: Int
        get() = width * height
    
    var isSquare: Boolean = false
        get() = width == height
        set(value) {
            field = value
            // Custom setter logic
        }
}
```

#### Backing Fields

```kotlin
class Person {
    var name: String = ""
        set(value) {
            field = value.uppercase()
        }
}
```

### Visibility Modifiers

- `public`: Default, visible everywhere
- `private`: Visible only within the class
- `protected`: Visible in class and subclasses
- `internal`: Visible within the same module

```kotlin
class Example {
    public val publicProp = 1
    private val privateProp = 2
    protected val protectedProp = 3
    internal val internalProp = 4
}
```

### Data Classes

Automatically generate `equals()`, `hashCode()`, `toString()`, `copy()`, and component functions:

```kotlin
data class User(val id: Int, val name: String, val email: String)

val user1 = User(1, "Alice", "alice@example.com")
val user2 = User(1, "Alice", "alice@example.com")

println(user1 == user2)           // true (equals)
println(user1)                    // User(id=1, name=Alice, email=alice@example.com)
val user3 = user1.copy(name = "Bob")  // Creates copy with modified name

// Destructuring
val (id, name, email) = user1
```

### Inheritance

#### Open Classes

By default, classes are `final` (cannot be inherited). Use `open` to allow inheritance:

```kotlin
open class Animal(val name: String) {
    open fun makeSound() {
        println("Some sound")
    }
}

class Dog(name: String) : Animal(name) {
    override fun makeSound() {
        println("Woof!")
    }
}
```

#### Overriding

```kotlin
open class Shape {
    open fun draw() {
        println("Drawing shape")
    }
}

class Circle : Shape() {
    override fun draw() {
        println("Drawing circle")
    }
}
```

### Abstract Classes

```kotlin
abstract class Shape {
    abstract fun area(): Double
    
    fun printArea() {
        println("Area: ${area()}")
    }
}

class Circle(val radius: Double) : Shape() {
    override fun area(): Double {
        return Math.PI * radius * radius
    }
}
```

### Interfaces

```kotlin
interface Drawable {
    fun draw()
    
    fun defaultMethod() {
        println("Default implementation")
    }
}

interface Clickable {
    fun click()
}

class Button : Drawable, Clickable {
    override fun draw() {
        println("Drawing button")
    }
    
    override fun click() {
        println("Button clicked")
    }
}
```

### Object Declarations

Singleton pattern:

```kotlin
object DatabaseManager {
    fun connect() {
        println("Connecting to database")
    }
}

DatabaseManager.connect()
```

### Companion Objects

Static members:

```kotlin
class MyClass {
    companion object {
        const val CONSTANT = "Value"
        
        fun create(): MyClass {
            return MyClass()
        }
    }
}

println(MyClass.CONSTANT)
val instance = MyClass.create()
```

### Nested Classes

```kotlin
class Outer {
    private val outerProperty = "Outer"
    
    class Nested {
        fun accessOuter() {
            // Cannot access outerProperty
        }
    }
    
    inner class Inner {
        fun accessOuter() {
            println(outerProperty)  // Can access outer properties
        }
    }
}
```

### Sealed Classes

Restricted class hierarchies:

```kotlin
sealed class Result<out T> {
    data class Success<T>(val data: T) : Result<T>()
    data class Error(val message: String) : Result<Nothing>()
}

fun handleResult(result: Result<String>) {
    when (result) {
        is Result.Success -> println(result.data)
        is Result.Error -> println(result.message)
    }
}
```

### Examples

#### Example 1: Complete Class

```kotlin
class BankAccount(private var balance: Double) {
    fun deposit(amount: Double) {
        require(amount > 0) { "Amount must be positive" }
        balance += amount
    }
    
    fun withdraw(amount: Double): Boolean {
        require(amount > 0) { "Amount must be positive" }
        return if (balance >= amount) {
            balance -= amount
            true
        } else {
            false
        }
    }
    
    fun getBalance(): Double = balance
}
```

#### Example 2: Interface Implementation

```kotlin
interface Repository<T> {
    fun save(item: T)
    fun findById(id: Int): T?
    fun findAll(): List<T>
}

class UserRepository : Repository<User> {
    private val users = mutableListOf<User>()
    
    override fun save(item: User) {
        users.add(item)
    }
    
    override fun findById(id: Int): User? {
        return users.find { it.id == id }
    }
    
    override fun findAll(): List<User> {
        return users.toList()
    }
}
```

## Summary

Kotlin classes provide powerful OOP features:
- Primary and secondary constructors
- Properties with custom getters/setters
- Data classes reduce boilerplate
- Open classes enable inheritance
- Interfaces support multiple inheritance
- Object declarations for singletons
- Companion objects for static members
- Sealed classes for restricted hierarchies

## Next Steps

- Learn about null safety
- Understand collections
- Explore extension functions
- Master generics

