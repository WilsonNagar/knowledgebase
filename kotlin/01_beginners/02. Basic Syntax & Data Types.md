---
number: 2
title: "Basic Syntax & Data Types"
slug: "basic-syntax-and-data-types"
level: "beginner"
tags: ["kotlin", "syntax", "data-types", "variables", "fundamentals"]
prerequisites: [1]
estimated_minutes: 75
contributors: []
diagrams: []
examples: []
canonical_id: "kotlin-beginner-02"
---

# Basic Syntax & Data Types

## Overview

Understanding Kotlin's basic syntax and data types is fundamental to writing Kotlin code. This guide covers variables, constants, basic data types, type inference, and how Kotlin handles primitive types differently from Java.

## Deep Explanation

### Variables & Constants

#### `val` (Immutable)

`val` declares a read-only variable (like `final` in Java):

```kotlin
val name = "Kotlin"
val age = 25

// name = "Java"  // ❌ Error: val cannot be reassigned
```

#### `var` (Mutable)

`var` declares a mutable variable:

```kotlin
var count = 0
count = 10  // ✅ Allowed
```

**Best Practice**: Prefer `val` over `var` for immutability.

### Basic Data Types

Kotlin doesn't have primitive types like Java. Everything is an object, but the compiler optimizes them to primitives when possible.

#### Numbers

**Integers:**
```kotlin
val byte: Byte = 127        // 8 bits, -128 to 127
val short: Short = 32767    // 16 bits, -32768 to 32767
val int: Int = 2147483647   // 32 bits, -2^31 to 2^31-1
val long: Long = 9223372036854775807L  // 64 bits, suffix 'L'
```

**Floating Point:**
```kotlin
val float: Float = 3.14F     // 32 bits, suffix 'F'
val double: Double = 3.14159 // 64 bits (default)
```

**Type Inference:**
```kotlin
val number = 42        // Inferred as Int
val bigNumber = 42L    // Inferred as Long
val decimal = 3.14    // Inferred as Double
val floatDecimal = 3.14F  // Inferred as Float
```

**Underscores for Readability:**
```kotlin
val million = 1_000_000
val creditCard = 1234_5678_9012_3456L
```

#### Characters

```kotlin
val char: Char = 'A'
val unicodeChar: Char = '\u0041'  // Unicode character
```

**Note**: Characters are not numbers in Kotlin (unlike Java).

#### Booleans

```kotlin
val isTrue: Boolean = true
val isFalse: Boolean = false
```

### Strings

#### String Literals

**Escaped Strings:**
```kotlin
val text = "Hello\nWorld"  // Supports escape sequences
```

**Raw Strings (Triple Quotes):**
```kotlin
val multiline = """
    This is a
    multiline string
    with multiple lines
""".trimIndent()
```

#### String Templates

**Variable Interpolation:**
```kotlin
val name = "Kotlin"
val greeting = "Hello, $name!"  // "Hello, Kotlin!"
```

**Expression Interpolation:**
```kotlin
val a = 10
val b = 20
val sum = "Sum: ${a + b}"  // "Sum: 30"
```

**Complex Expressions:**
```kotlin
val user = User("Alice", 25)
val info = "Name: ${user.name}, Age: ${user.age}"
```

### Arrays

#### Array Creation

```kotlin
// Using arrayOf()
val numbers = arrayOf(1, 2, 3, 4, 5)

// Using Array constructor
val zeros = Array(5) { 0 }  // [0, 0, 0, 0, 0]
val squares = Array(5) { it * it }  // [0, 1, 4, 9, 16]

// Primitive arrays (more efficient)
val intArray = intArrayOf(1, 2, 3)
val charArray = charArrayOf('a', 'b', 'c')
```

#### Array Access

```kotlin
val numbers = arrayOf(1, 2, 3)
println(numbers[0])      // 1
numbers[0] = 10           // Modify element
println(numbers.size)     // 3
```

### Type System

#### Explicit Types

```kotlin
val name: String = "Kotlin"
val age: Int = 25
val price: Double = 19.99
```

#### Type Inference

```kotlin
val name = "Kotlin"      // Inferred as String
val age = 25            // Inferred as Int
val list = listOf(1, 2, 3)  // Inferred as List<Int>
```

#### Type Checking

```kotlin
fun checkType(obj: Any) {
    when (obj) {
        is String -> println("String: $obj")
        is Int -> println("Int: $obj")
        is Boolean -> println("Boolean: $obj")
        else -> println("Unknown type")
    }
}
```

### Type Casting

#### Safe Cast (`as?`)

```kotlin
val obj: Any = "Hello"
val str: String? = obj as? String  // Returns null if cast fails
```

#### Unsafe Cast (`as`)

```kotlin
val obj: Any = "Hello"
val str: String = obj as String  // Throws exception if cast fails
```

#### Smart Casts

```kotlin
fun process(obj: Any) {
    if (obj is String) {
        // obj is automatically cast to String
        println(obj.length)  // No explicit cast needed
    }
    
    when (obj) {
        is Int -> println(obj + 1)  // Smart cast
        is String -> println(obj.uppercase())  // Smart cast
    }
}
```

### Nullable Types

Kotlin distinguishes between nullable and non-nullable types:

```kotlin
var name: String = "Kotlin"        // Non-nullable
var nullableName: String? = null   // Nullable

// name = null  // ❌ Compilation error

// Safe call operator
val length = nullableName?.length  // Returns Int? (nullable)

// Elvis operator
val length = nullableName?.length ?: 0  // Returns Int (non-null)

// Not-null assertion (use carefully!)
val length = nullableName!!.length  // Throws exception if null
```

### Type Aliases

Create alternative names for types:

```kotlin
typealias UserId = Int
typealias ClickHandler = (String) -> Unit

fun processUserId(id: UserId) {
    // ...
}

val onClick: ClickHandler = { text -> println(text) }
```

### Any, Unit, Nothing

#### `Any`

Root of the type hierarchy (like `Object` in Java):

```kotlin
val any: Any = 42
val anyString: Any = "Hello"
```

#### `Unit`

Equivalent to `void` in Java (but it's a real type):

```kotlin
fun printHello(): Unit {
    println("Hello")
}
// Unit can be omitted
fun printHello() {
    println("Hello")
}
```

#### `Nothing`

Represents a value that never exists (used for functions that never return):

```kotlin
fun fail(): Nothing {
    throw RuntimeException("Error")
}

fun infiniteLoop(): Nothing {
    while (true) {
        // ...
    }
}
```

### Type Conversions

#### Explicit Conversions

Kotlin doesn't perform implicit conversions:

```kotlin
val byte: Byte = 1
// val int: Int = byte  // ❌ Error: type mismatch

// Explicit conversion required
val int: Int = byte.toInt()
val long: Long = int.toLong()
val float: Float = long.toFloat()
val double: Double = float.toDouble()
```

**Conversion Functions:**
- `toByte()`, `toShort()`, `toInt()`, `toLong()`
- `toFloat()`, `toDouble()`
- `toChar()`, `toString()`

### Constants

#### Compile-Time Constants (`const val`)

```kotlin
const val PI = 3.14159
const val MAX_SIZE = 100

// Must be:
// - Top-level or member of object/companion object
// - String or primitive type
// - No custom getter
```

#### Runtime Constants (`val`)

```kotlin
val currentTime = System.currentTimeMillis()  // Evaluated at runtime
```

### Examples

#### Example 1: Type Inference

```kotlin
fun main() {
    val name = "Kotlin"           // String
    val age = 25                  // Int
    val price = 19.99             // Double
    val isActive = true           // Boolean
    
    println("$name is $age years old, price: $$price, active: $isActive")
}
```

#### Example 2: String Templates

```kotlin
fun greetUser(name: String, age: Int) {
    val message = """
        Hello, $name!
        You are $age years old.
        Next year you'll be ${age + 1}.
    """.trimIndent()
    println(message)
}
```

#### Example 3: Arrays

```kotlin
fun processNumbers() {
    val numbers = intArrayOf(1, 2, 3, 4, 5)
    
    // Sum
    val sum = numbers.sum()
    
    // Average
    val average = numbers.average()
    
    // Filter
    val evens = numbers.filter { it % 2 == 0 }
    
    println("Sum: $sum, Average: $average, Evens: $evens")
}
```

## Summary

Kotlin's type system is designed for safety and conciseness. Key points:
- Use `val` for immutability, `var` for mutability
- Type inference reduces boilerplate
- Nullable types (`?`) provide null safety
- Smart casts eliminate explicit casting
- String templates make string formatting concise
- Arrays can be created with `arrayOf()` or constructors

## Next Steps

- Learn control flow (if, when, loops)
- Understand functions and lambdas
- Explore classes and objects
- Master null safety concepts

