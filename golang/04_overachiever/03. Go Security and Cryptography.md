---
number: 3
title: "Go Security and Cryptography"
slug: "go-security-and-cryptography"
level: "overachiever"
tags: ["go", "security", "cryptography", "encryption", "authentication"]
prerequisites: ["distributed-systems-in-go"]
estimated_minutes: 145
contributors: []
diagrams: []
examples: []
canonical_id: "golang-overachiever-03"
---

# Go Security and Cryptography

## Overview

This guide covers security best practices in Go, cryptographic operations, secure authentication and authorization, secure communication (TLS), handling secrets, and common security vulnerabilities and mitigations.

## Deep Explanation

### Cryptography

```go
import (
    "crypto/aes"
    "crypto/cipher"
    "crypto/rand"
    "crypto/sha256"
    "golang.org/x/crypto/bcrypt"
)

// Hashing
hash := sha256.Sum256([]byte("password"))

// Password hashing
hashed, _ := bcrypt.GenerateFromPassword([]byte("password"), bcrypt.DefaultCost)
err := bcrypt.CompareHashAndPassword(hashed, []byte("password"))

// AES encryption
block, _ := aes.NewCipher(key)
stream := cipher.NewCTR(block, iv)
stream.XORKeyStream(ciphertext, plaintext)
```

### TLS

```go
import (
    "crypto/tls"
    "net/http"
)

config := &tls.Config{
    MinVersion: tls.VersionTLS12,
    CipherSuites: []uint16{
        tls.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,
    },
}

server := &http.Server{
    TLSConfig: config,
}
```

## Real Code Examples

### Example: Secure Token Generation

```go
package main

import (
    "crypto/rand"
    "encoding/base64"
)

func GenerateSecureToken(length int) (string, error) {
    bytes := make([]byte, length)
    if _, err := rand.Read(bytes); err != nil {
        return "", err
    }
    return base64.URLEncoding.EncodeToString(bytes), nil
}
```

## Hard Use-Case: JWT Authentication System

### Problem Statement

Implement a secure JWT-based authentication system with token refresh and revocation.

### Solution

```go
package main

import (
    "time"
    "github.com/golang-jwt/jwt/v5"
)

type Claims struct {
    UserID string `json:"user_id"`
    jwt.RegisteredClaims
}

func GenerateToken(userID string, secret []byte) (string, error) {
    claims := Claims{
        UserID: userID,
        RegisteredClaims: jwt.RegisteredClaims{
            ExpiresAt: jwt.NewNumericDate(time.Now().Add(15 * time.Minute)),
            IssuedAt:  jwt.NewNumericDate(time.Now()),
        },
    }
    
    token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
    return token.SignedString(secret)
}

func ValidateToken(tokenString string, secret []byte) (*Claims, error) {
    token, err := jwt.ParseWithClaims(tokenString, &Claims{}, func(token *jwt.Token) (interface{}, error) {
        return secret, nil
    })
    
    if err != nil {
        return nil, err
    }
    
    if claims, ok := token.Claims.(*Claims); ok && token.Valid {
        return claims, nil
    }
    
    return nil, ErrInvalidToken
}
```

## References and Further Reading

- [Go crypto Package](https://pkg.go.dev/crypto)
- [OWASP Go Security](https://owasp.org/www-project-go/)

## Quiz

### Question 1
What is the recommended way to hash passwords in Go?

**A)** MD5  
**B)** SHA256  
**C)** bcrypt  
**D)** Plain text

**Answer: C** - bcrypt is designed for password hashing with built-in salting and cost factor.

## Related Topics

- [Distributed Systems in Go](./02.%20Distributed%20Systems%20in%20Go.md)
- [Cgo and Interfacing with C Libraries](./04.%20Cgo%20and%20Interfacing%20with%20C%20Libraries.md)

