---
number: 4
title: "Cgo and Interfacing with C Libraries"
slug: "cgo-and-interfacing-with-c-libraries"
level: "overachiever"
tags: ["go", "cgo", "c-libraries", "ffi", "interoperability"]
prerequisites: ["go-security-and-cryptography"]
estimated_minutes: 140
contributors: []
diagrams: []
examples: []
canonical_id: "golang-overachiever-04"
---

# Cgo and Interfacing with C Libraries

## Overview

This guide covers using Cgo to interface with C libraries, calling C functions from Go, passing data between Go and C, building C code with Go, performance considerations, and best practices for C interoperability.

## Deep Explanation

### Basic Cgo

```go
package main

/*
#include <stdio.h>
#include <stdlib.h>

void print_hello() {
    printf("Hello from C!\n");
}
*/
import "C"

func main() {
    C.print_hello()
}
```

### Calling C Functions

```go
/*
#include <math.h>
*/
import "C"

func main() {
    result := C.sqrt(16.0)
    fmt.Printf("Square root: %f\n", float64(result))
}
```

### Passing Data

```go
/*
#include <string.h>
*/
import "C"

func main() {
    goStr := "Hello"
    cStr := C.CString(goStr)
    defer C.free(unsafe.Pointer(cStr))
    
    C.some_c_function(cStr)
}
```

## Real Code Examples

### Example: Wrapping C Library

```go
package main

/*
#cgo CFLAGS: -I/usr/local/include
#cgo LDFLAGS: -L/usr/local/lib -lmylib
#include <mylib.h>
*/
import "C"

type MyLib struct{}

func NewMyLib() *MyLib {
    return &MyLib{}
}

func (lib *MyLib) DoSomething(input string) string {
    cInput := C.CString(input)
    defer C.free(unsafe.Pointer(cInput))
    
    cOutput := C.mylib_do_something(cInput)
    defer C.free(unsafe.Pointer(cOutput))
    
    return C.GoString(cOutput)
}
```

## Hard Use-Case: High-Performance C Binding

### Problem Statement

Create efficient bindings for a C library that processes large amounts of data, minimizing Go-C boundary crossings.

### Solution

```go
package main

/*
#include <stdint.h>

void process_batch(uint8_t* data, int length) {
    // Process data in C
}
*/
import "C"
import "unsafe"

func ProcessBatch(data []byte) {
    if len(data) == 0 {
        return
    }
    C.process_batch((*C.uint8_t)(unsafe.Pointer(&data[0])), C.int(len(data)))
}
```

## Edge Cases and Pitfalls

### Common Mistakes

1. **Memory Leaks**
```go
// Bad: Not freeing C memory
cStr := C.CString("hello")
// Never freed!

// Good: Always free
cStr := C.CString("hello")
defer C.free(unsafe.Pointer(cStr))
```

2. **Performance Overhead**
```go
// Bad: Many C calls in loop
for i := 0; i < 1000000; i++ {
    C.some_function()  // Expensive boundary crossing
}

// Good: Batch operations
C.process_batch(data)  // Single call
```

## References and Further Reading

- [Cgo Documentation](https://pkg.go.dev/cmd/cgo)
- [Cgo Tutorial](https://go.dev/blog/cgo)

## Quiz

### Question 1
What is the main performance consideration when using Cgo?

**A)** Memory usage  
**B)** Go-C boundary crossing overhead  
**C)** Compilation time  
**D)** Binary size

**Answer: B** - Crossing the Go-C boundary has overhead, so minimize the number of calls.

## Related Topics

- [Go Security and Cryptography](./03.%20Go%20Security%20and%20Cryptography.md)
- [Systems Programming in Go](../03_advanced/06.%20Systems%20Programming%20in%20Go.md)

