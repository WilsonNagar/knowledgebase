---
number: 4
title: "Go Error Handling and Defer"
slug: "go-error-handling-and-defer"
level: "beginner"
tags: ["go", "error-handling", "defer", "panic", "recover"]
prerequisites: ["go-object-oriented-programming"]
estimated_minutes: 90
contributors: []
diagrams: []
examples: []
canonical_id: "golang-beginner-04"
---

# Go Error Handling and Defer

## Overview

Go's error handling philosophy emphasizes explicit error checking over exceptions. This guide covers Go's error handling patterns, the `error` interface, error wrapping and unwrapping, the `defer` statement for cleanup, and `panic`/`recover` for exceptional situations. Understanding these concepts is crucial for writing robust, idiomatic Go code.

## Deep Explanation

### Error Interface

Go represents errors through the built-in `error` interface:

```go
type error interface {
    Error() string
}
```

#### Creating Errors

```go
import (
    "errors"
    "fmt"
)

// Simple error
err := errors.New("something went wrong")

// Formatted error
err := fmt.Errorf("user %d not found", userID)

// Error with context
err := fmt.Errorf("failed to connect: %w", connectionErr)
```

#### Custom Error Types

```go
// Custom error struct
type ValidationError struct {
    Field   string
    Message string
}

func (e *ValidationError) Error() string {
    return fmt.Sprintf("validation error on %s: %s", e.Field, e.Message)
}

// Error with additional methods
type NotFoundError struct {
    Resource string
    ID       string
}

func (e *NotFoundError) Error() string {
    return fmt.Sprintf("%s with id %s not found", e.Resource, e.ID)
}

func (e *NotFoundError) IsNotFound() bool {
    return true
}
```

### Error Handling Patterns

#### Explicit Error Checking

```go
// Always check errors
result, err := doSomething()
if err != nil {
    return err  // Propagate error
}

// Handle error locally
result, err := doSomething()
if err != nil {
    log.Printf("Error: %v", err)
    return defaultValue
}

// Multiple error checks
file, err := os.Open("data.txt")
if err != nil {
    return err
}
defer file.Close()

data, err := ioutil.ReadAll(file)
if err != nil {
    return err
}
```

#### Error Wrapping

```go
import "fmt"

// Wrap error with context
func processUser(userID int) error {
    user, err := getUser(userID)
    if err != nil {
        return fmt.Errorf("failed to process user %d: %w", userID, err)
    }
    // ...
    return nil
}

// Unwrap errors
if err != nil {
    if unwrapped := errors.Unwrap(err); unwrapped != nil {
        fmt.Println("Original error:", unwrapped)
    }
}
```

#### Error Comparison

```go
import (
    "errors"
    "os"
)

// Compare with errors.Is
if errors.Is(err, os.ErrNotExist) {
    // Handle file not found
}

// Compare with errors.As
var validationErr *ValidationError
if errors.As(err, &validationErr) {
    fmt.Println("Field:", validationErr.Field)
}
```

### Defer Statement

`defer` schedules a function call to execute when the surrounding function returns.

#### Basic Defer Usage

```go
// Defer executes in LIFO order
func example() {
    defer fmt.Println("Third")
    defer fmt.Println("Second")
    defer fmt.Println("First")
    // Output: First, Second, Third
}

// Common use case: resource cleanup
func readFile(filename string) error {
    file, err := os.Open(filename)
    if err != nil {
        return err
    }
    defer file.Close()  // Always closes, even on error
    
    // Use file...
    return nil
}
```

#### Defer with Arguments

```go
// Arguments evaluated immediately, function called later
func example() {
    i := 0
    defer fmt.Println(i)  // Prints 0 (value captured)
    i++
    // i is now 1, but defer prints 0
}

// Defer with function call
func example() {
    defer func() {
        fmt.Println("Deferred")
    }()
}
```

#### Defer for Mutex Unlocking

```go
var mu sync.Mutex

func criticalSection() {
    mu.Lock()
    defer mu.Unlock()  // Always unlocks
    
    // Critical code
}
```

#### Defer for Panic Recovery

```go
func safeFunction() {
    defer func() {
        if r := recover(); r != nil {
            fmt.Printf("Recovered from panic: %v\n", r)
        }
    }()
    
    // Code that might panic
    panic("something went wrong")
}
```

### Panic and Recover

`panic` stops normal execution and begins panicking. `recover` regains control of a panicking goroutine.

#### Panic

```go
// Panic with message
panic("unexpected error")

// Panic with error
panic(fmt.Errorf("error: %v", err))

// When to panic:
// - Programming errors (nil pointer, index out of bounds)
// - Impossible situations
// - Not for expected errors (use error return instead)
```

#### Recover

```go
// Recover only works in deferred functions
func mayPanic() {
    defer func() {
        if r := recover(); r != nil {
            fmt.Println("Recovered:", r)
        }
    }()
    
    panic("test panic")
}

// Recover returns the value passed to panic
func handlePanic() {
    defer func() {
        if r := recover(); r != nil {
            switch v := r.(type) {
            case string:
                fmt.Println("String panic:", v)
            case error:
                fmt.Println("Error panic:", v)
            default:
                fmt.Println("Unknown panic:", v)
            }
        }
    }()
    
    panic("error occurred")
}
```

## Real Code Examples

### Example: File Processor with Error Handling

```go
package main

import (
    "fmt"
    "io"
    "os"
    "path/filepath"
)

type FileProcessor struct {
    processed int
    errors    []error
}

func NewFileProcessor() *FileProcessor {
    return &FileProcessor{
        errors: make([]error, 0),
    }
}

func (fp *FileProcessor) ProcessFile(filename string) error {
    file, err := os.Open(filename)
    if err != nil {
        return fmt.Errorf("failed to open file %s: %w", filename, err)
    }
    defer file.Close()
    
    // Read file content
    content, err := io.ReadAll(file)
    if err != nil {
        return fmt.Errorf("failed to read file %s: %w", filename, err)
    }
    
    // Process content
    if err := fp.processContent(filename, content); err != nil {
        return fmt.Errorf("failed to process content of %s: %w", filename, err)
    }
    
    fp.processed++
    return nil
}

func (fp *FileProcessor) processContent(filename string, content []byte) error {
    // Simulate processing
    if len(content) == 0 {
        return fmt.Errorf("empty file")
    }
    return nil
}

func (fp *FileProcessor) ProcessDirectory(dir string) error {
    return filepath.Walk(dir, func(path string, info os.FileInfo, err error) error {
        if err != nil {
            fp.errors = append(fp.errors, fmt.Errorf("error accessing %s: %w", path, err))
            return nil  // Continue processing
        }
        
        if !info.IsDir() {
            if err := fp.ProcessFile(path); err != nil {
                fp.errors = append(fp.errors, err)
                // Continue processing other files
            }
        }
        return nil
    })
}

func (fp *FileProcessor) Stats() {
    fmt.Printf("Processed: %d files\n", fp.processed)
    fmt.Printf("Errors: %d\n", len(fp.errors))
    for i, err := range fp.errors {
        fmt.Printf("  Error %d: %v\n", i+1, err)
    }
}

func main() {
    processor := NewFileProcessor()
    
    if err := processor.ProcessDirectory("."); err != nil {
        fmt.Printf("Fatal error: %v\n", err)
        return
    }
    
    processor.Stats()
}
```

### Example: Database Transaction with Rollback

```go
package main

import (
    "fmt"
    "errors"
)

type DB struct {
    transactions []string
}

func (db *DB) Begin() *Transaction {
    return &Transaction{db: db, operations: make([]string, 0)}
}

type Transaction struct {
    db         *DB
    operations []string
    committed  bool
}

func (tx *Transaction) Execute(query string) error {
    if tx.committed {
        return errors.New("transaction already committed")
    }
    tx.operations = append(tx.operations, query)
    return nil
}

func (tx *Transaction) Commit() error {
    if tx.committed {
        return errors.New("transaction already committed")
    }
    
    // Apply all operations
    for _, op := range tx.operations {
        tx.db.transactions = append(tx.db.transactions, op)
    }
    
    tx.committed = true
    return nil
}

func (tx *Transaction) Rollback() {
    if !tx.committed {
        tx.operations = nil
    }
}

func (tx *Transaction) WithRollback(fn func(*Transaction) error) error {
    defer func() {
        if !tx.committed {
            tx.Rollback()
        }
    }()
    return fn(tx)
}

func main() {
    db := &DB{}
    
    // Transaction with automatic rollback on error
    tx := db.Begin()
    err := tx.WithRollback(func(tx *Transaction) error {
        if err := tx.Execute("INSERT INTO users VALUES (1)"); err != nil {
            return err
        }
        if err := tx.Execute("INSERT INTO users VALUES (2)"); err != nil {
            return err
        }
        return tx.Commit()
    })
    
    if err != nil {
        fmt.Printf("Transaction failed: %v\n", err)
    } else {
        fmt.Println("Transaction committed successfully")
    }
}
```

## Hard Use-Case: Robust HTTP Client with Retry Logic

### Problem Statement

Create an HTTP client that handles errors gracefully, implements retry logic with exponential backoff, and properly cleans up resources even when errors occur.

### Solution

```go
package main

import (
    "fmt"
    "io"
    "net/http"
    "time"
    "errors"
)

type RetryableError struct {
    Err      error
    Retryable bool
}

func (e *RetryableError) Error() string {
    return e.Err.Error()
}

func (e *RetryableError) Unwrap() error {
    return e.Err
}

type HTTPClient struct {
    client      *http.Client
    maxRetries  int
    baseDelay   time.Duration
}

func NewHTTPClient(maxRetries int, timeout time.Duration) *HTTPClient {
    return &HTTPClient{
        client: &http.Client{
            Timeout: timeout,
        },
        maxRetries: maxRetries,
        baseDelay:  1 * time.Second,
    }
}

func (c *HTTPClient) Get(url string) ([]byte, error) {
    var lastErr error
    
    for attempt := 0; attempt <= c.maxRetries; attempt++ {
        if attempt > 0 {
            delay := c.baseDelay * time.Duration(1<<uint(attempt-1))
            fmt.Printf("Retrying after %v (attempt %d/%d)\n", delay, attempt, c.maxRetries)
            time.Sleep(delay)
        }
        
        resp, err := c.doRequest(url)
        if err == nil {
            return resp, nil
        }
        
        lastErr = err
        
        // Check if error is retryable
        var retryErr *RetryableError
        if errors.As(err, &retryErr) && !retryErr.Retryable {
            return nil, err  // Don't retry non-retryable errors
        }
    }
    
    return nil, fmt.Errorf("failed after %d attempts: %w", c.maxRetries+1, lastErr)
}

func (c *HTTPClient) doRequest(url string) ([]byte, error) {
    req, err := http.NewRequest("GET", url, nil)
    if err != nil {
        return nil, &RetryableError{Err: err, Retryable: false}
    }
    
    resp, err := c.client.Do(req)
    if err != nil {
        return nil, &RetryableError{Err: err, Retryable: true}
    }
    defer resp.Body.Close()
    
    if resp.StatusCode >= 500 {
        return nil, &RetryableError{
            Err:       fmt.Errorf("server error: %d", resp.StatusCode),
            Retryable: true,
        }
    }
    
    if resp.StatusCode >= 400 {
        return nil, &RetryableError{
            Err:       fmt.Errorf("client error: %d", resp.StatusCode),
            Retryable: false,
        }
    }
    
    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return nil, &RetryableError{Err: err, Retryable: true}
    }
    
    return body, nil
}

func main() {
    client := NewHTTPClient(3, 5*time.Second)
    
    data, err := client.Get("https://api.example.com/data")
    if err != nil {
        fmt.Printf("Error: %v\n", err)
        return
    }
    
    fmt.Printf("Success: Received %d bytes\n", len(data))
}
```

## Edge Cases and Pitfalls

### Common Mistakes

1. **Ignoring Errors**
```go
// Bad: Ignoring error
file, _ := os.Open("data.txt")
defer file.Close()

// Good: Always handle errors
file, err := os.Open("data.txt")
if err != nil {
    return err
}
defer file.Close()
```

2. **Defer in Loops**
```go
// Bad: Defer accumulates in loop
for _, file := range files {
    f, _ := os.Open(file)
    defer f.Close()  // All defers execute at end of function
}

// Good: Use function or immediate cleanup
for _, file := range files {
    func() {
        f, err := os.Open(file)
        if err != nil {
            return
        }
        defer f.Close()
        // Process file
    }()
}
```

3. **Panic for Expected Errors**
```go
// Bad: Using panic for expected errors
func getUser(id int) *User {
    user := findUser(id)
    if user == nil {
        panic("user not found")  // Wrong!
    }
    return user
}

// Good: Return error
func getUser(id int) (*User, error) {
    user := findUser(id)
    if user == nil {
        return nil, fmt.Errorf("user %d not found", id)
    }
    return user, nil
}
```

4. **Error Wrapping Loss**
```go
// Bad: Losing original error context
if err != nil {
    return errors.New("operation failed")  // Lost original error
}

// Good: Wrap error with context
if err != nil {
    return fmt.Errorf("operation failed: %w", err)
}
```

## References and Further Reading

- [Go Error Handling](https://go.dev/blog/error-handling-and-go)
- [Go Defer, Panic, and Recover](https://go.dev/blog/defer-panic-and-recover)
- [Error Handling Best Practices](https://go.dev/doc/effective_go#errors)

## Quiz

### Question 1
What is the zero value of an error in Go?

**A)** ""  
**B)** nil  
**C)** error{}  
**D)** undefined

**Answer: B** - Errors are interfaces, and the zero value of an interface is nil.

### Question 2
When does a deferred function execute?

**A)** Immediately  
**B)** When the function returns  
**C)** At the end of the program  
**D)** Never

**Answer: B** - Deferred functions execute when the surrounding function returns, in LIFO order.

### Question 3
What should you use for expected error conditions?

**A)** panic  
**B)** error return values  
**C)** Both  
**D)** Neither

**Answer: B** - Use error return values for expected errors. Panic should only be used for truly exceptional, unrecoverable situations.

### Question 4
Can you recover from a panic in a different goroutine?

**A)** Yes, always  
**B)** No, recover only works in the same goroutine  
**C)** Only if you use channels  
**D)** Only in main function

**Answer: B** - Recover only works in the same goroutine where the panic occurred.

### Question 5
What does `errors.Is` do?

**A)** Checks if error is nil  
**B)** Compares error values using ==  
**C)** Checks if error chain contains target error  
**D)** Wraps an error

**Answer: C** - `errors.Is` unwraps the error chain and checks if any error in the chain matches the target.

## Related Topics

- [Go Object-Oriented Programming](./03.%20Go%20Object-Oriented%20Programming.md)
- [Go Packages and Modules](./05.%20Go%20Packages%20and%20Modules.md)
- [Go Concurrency Fundamentals](../02_intermediate/01.%20Go%20Concurrency%20Fundamentals.md)

