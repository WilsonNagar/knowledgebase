---
number: 1
title: "Go Language Fundamentals"
slug: "go-language-fundamentals"
level: "beginner"
tags: ["go", "fundamentals", "variables", "types", "operators", "control-flow", "functions"]
prerequisites: []
estimated_minutes: 90
contributors: []
diagrams: []
examples: []
canonical_id: "golang-beginner-01"
---

# Go Language Fundamentals

## Overview

Go is a statically typed, compiled programming language designed at Google. It combines the performance and safety of compiled languages with the simplicity and readability of interpreted languages. This comprehensive guide covers the fundamental building blocks of Go: variables, constants, data types, operators, expressions, control flow structures, and functions. Understanding these fundamentals is essential for writing idiomatic Go code.

## Deep Explanation

### Variables and Constants

#### Variables

Variables in Go are declared using the `var` keyword, and Go provides type inference through the `:=` short variable declaration syntax.

**Declaration Methods:**

```go
// Explicit type declaration
var name string = "Go"
var age int = 10

// Type inference
var name = "Go"
var age = 10

// Multiple variables
var (
    name string = "Go"
    age  int    = 10
)

// Short variable declaration (most common)
name := "Go"
age := 10

// Zero values
var count int        // 0
var name string      // ""
var active bool      // false
var price float64    // 0.0
```

**Key Points:**
- Variables declared but not used cause compilation errors
- Zero values are automatically assigned
- `:=` can only be used inside functions
- Variables can be redeclared in different scopes

#### Constants

Constants are declared using the `const` keyword and must be compile-time values.

```go
// Basic constants
const pi = 3.14159
const greeting = "Hello, World!"

// Typed constants
const maxUsers int = 1000

// Multiple constants
const (
    StatusOK    = 200
    StatusError = 500
)

// Iota (enum-like behavior)
const (
    Sunday = iota  // 0
    Monday         // 1
    Tuesday        // 2
    Wednesday      // 3
)

// Iota with expressions
const (
    KB = 1 << (10 * iota)  // 1024
    MB                      // 1048576
    GB                      // 1073741824
)
```

### Data Types

#### Basic Types

Go provides a rich set of built-in types:

**Numeric Types:**
```go
// Integers
var i8 int8    = -128 to 127
var i16 int16  = -32768 to 32767
var i32 int32  = -2147483648 to 2147483647
var i64 int64  = -9223372036854775808 to 9223372036854775807
var i int      // Platform-dependent (32 or 64 bits)

// Unsigned integers
var u8 uint8   = 0 to 255
var u16 uint16 = 0 to 65535
var u32 uint32 = 0 to 4294967295
var u64 uint64 = 0 to 18446744073709551615
var u uint     // Platform-dependent

// Floating point
var f32 float32 = IEEE-754 32-bit
var f64 float64 = IEEE-754 64-bit

// Complex numbers
var c64 complex64  = complex(float32, float32)
var c128 complex128 = complex(float64, float64)

// Byte and Rune
var b byte = uint8    // Alias for uint8
var r rune = int32    // Alias for int32 (Unicode code point)
```

**Boolean Type:**
```go
var active bool = true
var enabled bool = false
```

**String Type:**
```go
// Strings are immutable sequences of bytes
var s1 string = "Hello"
var s2 string = `Multiline
string
literal`

// String operations
name := "Go"
greeting := "Hello, " + name
length := len(greeting)
firstChar := greeting[0]  // byte value
```

#### Type Conversions

Go requires explicit type conversions:

```go
var i int = 42
var f float64 = float64(i)
var u uint = uint(f)

// String conversions
import "strconv"
numStr := "42"
num, err := strconv.Atoi(numStr)
str := strconv.Itoa(42)
```

### Operators and Expressions

#### Arithmetic Operators

```go
a, b := 10, 3

sum := a + b      // 13
diff := a - b     // 7
product := a * b  // 30
quotient := a / b // 3
remainder := a % b // 1

// Increment and decrement
a++  // a = a + 1
a--  // a = a - 1
```

#### Comparison Operators

```go
a, b := 10, 20

a == b  // false (equal)
a != b  // true  (not equal)
a < b   // true  (less than)
a <= b  // true  (less than or equal)
a > b   // false (greater than)
a >= b  // false (greater than or equal)
```

#### Logical Operators

```go
x, y := true, false

x && y  // false (AND)
x || y  // true  (OR)
!x      // false (NOT)
```

#### Bitwise Operators

```go
a, b := 5, 3  // 101, 011 in binary

a & b   // 1  (AND)
a | b   // 7  (OR)
a ^ b   // 6  (XOR)
^a      // -6 (NOT)
a << 1  // 10 (left shift)
a >> 1  // 2  (right shift)
```

#### Assignment Operators

```go
x := 10
x += 5   // x = x + 5
x -= 3   // x = x - 3
x *= 2   // x = x * 2
x /= 2   // x = x / 2
x %= 3   // x = x % 3
x &= 5   // x = x & 5
x |= 3   // x = x | 3
x ^= 2   // x = x ^ 2
x <<= 1  // x = x << 1
x >>= 1  // x = x >> 1
```

### Control Flow

#### If Statements

```go
// Basic if
if x > 0 {
    fmt.Println("Positive")
}

// If-else
if x > 0 {
    fmt.Println("Positive")
} else {
    fmt.Println("Non-positive")
}

// If-else if-else
if x > 0 {
    fmt.Println("Positive")
} else if x < 0 {
    fmt.Println("Negative")
} else {
    fmt.Println("Zero")
}

// If with initialization statement
if err := doSomething(); err != nil {
    return err
}

// Compact if with assignment
if result, err := compute(); err != nil {
    return err
} else {
    fmt.Println(result)
}
```

#### Switch Statements

```go
// Basic switch
switch day {
case "Monday":
    fmt.Println("Start of work week")
case "Friday":
    fmt.Println("TGIF!")
default:
    fmt.Println("Midweek")
}

// Switch with multiple values
switch day {
case "Saturday", "Sunday":
    fmt.Println("Weekend")
default:
    fmt.Println("Weekday")
}

// Switch without expression (like if-else chain)
switch {
case x < 0:
    fmt.Println("Negative")
case x == 0:
    fmt.Println("Zero")
default:
    fmt.Println("Positive")
}

// Switch with initialization
switch x := getValue(); x {
case 1:
    fmt.Println("One")
case 2:
    fmt.Println("Two")
}

// Type switch
var i interface{} = "hello"
switch v := i.(type) {
case int:
    fmt.Printf("Integer: %d\n", v)
case string:
    fmt.Printf("String: %s\n", v)
default:
    fmt.Println("Unknown type")
}
```

#### For Loops

```go
// Traditional for loop
for i := 0; i < 10; i++ {
    fmt.Println(i)
}

// While-style loop
i := 0
for i < 10 {
    fmt.Println(i)
    i++
}

// Infinite loop
for {
    // Break with condition
    if condition {
        break
    }
}

// Range over slice
numbers := []int{1, 2, 3, 4, 5}
for index, value := range numbers {
    fmt.Printf("Index: %d, Value: %d\n", index, value)
}

// Range over map
m := map[string]int{"a": 1, "b": 2}
for key, value := range m {
    fmt.Printf("Key: %s, Value: %d\n", key, value)
}

// Range over string (runes)
for i, r := range "Hello" {
    fmt.Printf("Index: %d, Rune: %c\n", i, r)
}

// Range over channel
ch := make(chan int)
go func() {
    ch <- 1
    ch <- 2
    close(ch)
}()
for value := range ch {
    fmt.Println(value)
}
```

#### Control Flow Keywords

```go
// Break
for i := 0; i < 10; i++ {
    if i == 5 {
        break  // Exit loop
    }
}

// Continue
for i := 0; i < 10; i++ {
    if i%2 == 0 {
        continue  // Skip to next iteration
    }
    fmt.Println(i)
}

// Labeled break/continue
OuterLoop:
for i := 0; i < 3; i++ {
    for j := 0; j < 3; j++ {
        if i == 1 && j == 1 {
            break OuterLoop  // Break outer loop
        }
    }
}
```

### Functions

#### Function Declaration

```go
// Basic function
func greet(name string) {
    fmt.Printf("Hello, %s!\n", name)
}

// Function with return value
func add(a, b int) int {
    return a + b
}

// Multiple return values
func divide(a, b float64) (float64, error) {
    if b == 0 {
        return 0, fmt.Errorf("division by zero")
    }
    return a / b, nil
}

// Named return values
func calculate(a, b int) (sum int, product int) {
    sum = a + b
    product = a * b
    return  // Naked return
}

// Variadic functions
func sum(numbers ...int) int {
    total := 0
    for _, num := range numbers {
        total += num
    }
    return total
}

// Function as value
var fn func(int, int) int = add
result := fn(3, 4)

// Anonymous functions
func() {
    fmt.Println("Anonymous function")
}()

// Function closures
func makeCounter() func() int {
    count := 0
    return func() int {
        count++
        return count
    }
}

counter := makeCounter()
fmt.Println(counter())  // 1
fmt.Println(counter())  // 2
```

#### Function Parameters

```go
// Value parameters (copies)
func modifyValue(x int) {
    x = 100  // Doesn't affect original
}

// Pointer parameters
func modifyPointer(x *int) {
    *x = 100  // Modifies original
}

// Slice/Map parameters (reference-like)
func modifySlice(s []int) {
    s[0] = 100  // Modifies original slice
}

// Function types
type Operation func(int, int) int

func applyOp(a, b int, op Operation) int {
    return op(a, b)
}
```

## Real Code Examples

### Example: Temperature Converter

```go
package main

import (
    "fmt"
    "strconv"
)

// Convert Celsius to Fahrenheit
func celsiusToFahrenheit(c float64) float64 {
    return (c * 9.0 / 5.0) + 32.0
}

// Convert Fahrenheit to Celsius
func fahrenheitToCelsius(f float64) float64 {
    return (f - 32.0) * 5.0 / 9.0
}

// Parse temperature from string
func parseTemperature(input string) (float64, error) {
    return strconv.ParseFloat(input, 64)
}

func main() {
    // Get user input
    var input string
    fmt.Print("Enter temperature: ")
    fmt.Scanln(&input)
    
    temp, err := parseTemperature(input)
    if err != nil {
        fmt.Printf("Error: %v\n", err)
        return
    }
    
    // Convert based on user choice
    var choice string
    fmt.Print("Convert to (F)ahrenheit or (C)elsius? ")
    fmt.Scanln(&choice)
    
    switch choice {
    case "F", "f":
        result := celsiusToFahrenheit(temp)
        fmt.Printf("%.2f째C = %.2f째F\n", temp, result)
    case "C", "c":
        result := fahrenheitToCelsius(temp)
        fmt.Printf("%.2f째F = %.2f째C\n", temp, result)
    default:
        fmt.Println("Invalid choice")
    }
}
```

### Example: Number Guessing Game

```go
package main

import (
    "fmt"
    "math/rand"
    "time"
)

func generateRandomNumber(min, max int) int {
    rand.Seed(time.Now().UnixNano())
    return rand.Intn(max-min+1) + min
}

func playGame() {
    target := generateRandomNumber(1, 100)
    attempts := 0
    maxAttempts := 7
    
    fmt.Println("Guess a number between 1 and 100!")
    
    for attempts < maxAttempts {
        attempts++
        var guess int
        fmt.Printf("Attempt %d/%d: Enter your guess: ", attempts, maxAttempts)
        fmt.Scanln(&guess)
        
        switch {
        case guess < target:
            fmt.Println("Too low!")
        case guess > target:
            fmt.Println("Too high!")
        default:
            fmt.Printf("Congratulations! You guessed it in %d attempts!\n", attempts)
            return
        }
    }
    
    fmt.Printf("Game over! The number was %d\n", target)
}

func main() {
    playGame()
}
```

## Hard Use-Case: Expression Evaluator

### Problem Statement

Build a simple arithmetic expression evaluator that can parse and evaluate expressions with addition, subtraction, multiplication, and division, handling operator precedence correctly.

### Solution

```go
package main

import (
    "fmt"
    "strconv"
    "strings"
    "unicode"
)

type TokenType int

const (
    NUMBER TokenType = iota
    PLUS
    MINUS
    MULTIPLY
    DIVIDE
    LPAREN
    RPAREN
    EOF
)

type Token struct {
    Type  TokenType
    Value string
}

type Lexer struct {
    input        string
    position     int
    currentChar  byte
}

func NewLexer(input string) *Lexer {
    l := &Lexer{input: strings.ReplaceAll(input, " ", "")}
    if len(l.input) > 0 {
        l.currentChar = l.input[0]
    }
    return l
}

func (l *Lexer) advance() {
    l.position++
    if l.position >= len(l.input) {
        l.currentChar = 0
    } else {
        l.currentChar = l.input[l.position]
    }
}

func (l *Lexer) skipWhitespace() {
    for l.currentChar != 0 && unicode.IsSpace(rune(l.currentChar)) {
        l.advance()
    }
}

func (l *Lexer) readNumber() string {
    result := ""
    for l.currentChar != 0 && unicode.IsDigit(rune(l.currentChar)) {
        result += string(l.currentChar)
        l.advance()
    }
    return result
}

func (l *Lexer) NextToken() Token {
    for l.currentChar != 0 {
        if unicode.IsSpace(rune(l.currentChar)) {
            l.skipWhitespace()
            continue
        }
        
        if unicode.IsDigit(rune(l.currentChar)) {
            return Token{NUMBER, l.readNumber()}
        }
        
        char := l.currentChar
        l.advance()
        
        switch char {
        case '+':
            return Token{PLUS, "+"}
        case '-':
            return Token{MINUS, "-"}
        case '*':
            return Token{MULTIPLY, "*"}
        case '/':
            return Token{DIVIDE, "/"}
        case '(':
            return Token{LPAREN, "("}
        case ')':
            return Token{RPAREN, ")"}
        default:
            return Token{EOF, ""}
        }
    }
    
    return Token{EOF, ""}
}

type Parser struct {
    lexer        *Lexer
    currentToken Token
}

func NewParser(lexer *Lexer) *Parser {
    p := &Parser{lexer: lexer}
    p.currentToken = p.lexer.NextToken()
    return p
}

func (p *Parser) eat(tokenType TokenType) {
    if p.currentToken.Type == tokenType {
        p.currentToken = p.lexer.NextToken()
    } else {
        panic(fmt.Sprintf("Unexpected token: %v", p.currentToken))
    }
}

func (p *Parser) factor() float64 {
    token := p.currentToken
    
    switch token.Type {
    case NUMBER:
        p.eat(NUMBER)
        val, _ := strconv.ParseFloat(token.Value, 64)
        return val
    case LPAREN:
        p.eat(LPAREN)
        result := p.expr()
        p.eat(RPAREN)
        return result
    case MINUS:
        p.eat(MINUS)
        return -p.factor()
    default:
        panic("Unexpected token in factor")
    }
}

func (p *Parser) term() float64 {
    result := p.factor()
    
    for p.currentToken.Type == MULTIPLY || p.currentToken.Type == DIVIDE {
        token := p.currentToken
        if token.Type == MULTIPLY {
            p.eat(MULTIPLY)
            result *= p.factor()
        } else {
            p.eat(DIVIDE)
            divisor := p.factor()
            if divisor == 0 {
                panic("Division by zero")
            }
            result /= divisor
        }
    }
    
    return result
}

func (p *Parser) expr() float64 {
    result := p.term()
    
    for p.currentToken.Type == PLUS || p.currentToken.Type == MINUS {
        token := p.currentToken
        if token.Type == PLUS {
            p.eat(PLUS)
            result += p.term()
        } else {
            p.eat(MINUS)
            result -= p.term()
        }
    }
    
    return result
}

func Evaluate(expression string) (float64, error) {
    defer func() {
        if r := recover(); r != nil {
            panic(fmt.Sprintf("Evaluation error: %v", r))
        }
    }()
    
    lexer := NewLexer(expression)
    parser := NewParser(lexer)
    return parser.expr(), nil
}

func main() {
    expressions := []string{
        "2 + 3 * 4",
        "(2 + 3) * 4",
        "10 / 2 - 3",
        "-5 + 10",
        "2 * 3 + 4 * 5",
    }
    
    for _, expr := range expressions {
        result, err := Evaluate(expr)
        if err != nil {
            fmt.Printf("Error evaluating '%s': %v\n", expr, err)
        } else {
            fmt.Printf("%s = %.2f\n", expr, result)
        }
    }
}
```

## Edge Cases and Pitfalls

### Common Mistakes

1. **Variable Shadowing**
```go
// Bad: Shadowing outer variable
x := 10
if true {
    x := 20  // Creates new variable, doesn't modify outer x
    fmt.Println(x)  // 20
}
fmt.Println(x)  // 10 (unchanged!)

// Good: Use assignment
x := 10
if true {
    x = 20  // Modifies outer x
    fmt.Println(x)  // 20
}
fmt.Println(x)  // 20
```

2. **Integer Division**
```go
// Bad: Integer division loses precision
result := 5 / 2  // 2, not 2.5

// Good: Use float division
result := 5.0 / 2.0  // 2.5
result := float64(5) / float64(2)  // 2.5
```

3. **String Immutability**
```go
// Bad: Can't modify string characters directly
s := "Hello"
s[0] = 'h'  // Compile error

// Good: Convert to []byte or []rune
s := "Hello"
bytes := []byte(s)
bytes[0] = 'h'
s = string(bytes)  // "hello"
```

4. **Unused Variables**
```go
// Bad: Unused variable causes compile error
x := 10
// x is never used

// Good: Use blank identifier
x := 10
_ = x  // Explicitly ignore
```

5. **Switch Fallthrough**
```go
// Bad: Unexpected fallthrough
switch x {
case 1:
    fmt.Println("One")
case 2:
    fmt.Println("Two")  // Falls through to default!
default:
    fmt.Println("Other")
}

// Good: Explicit fallthrough or separate cases
switch x {
case 1:
    fmt.Println("One")
case 2:
    fmt.Println("Two")
    fallthrough  // Explicit
default:
    fmt.Println("Other")
}
```

## References and Further Reading

- [Go Language Specification](https://go.dev/ref/spec)
- [Effective Go](https://go.dev/doc/effective_go)
- [Go by Example](https://gobyexample.com/)
- [A Tour of Go](https://go.dev/tour/)

## Quiz

### Question 1
What is the zero value for an `int` variable in Go?

**A)** nil  
**B)** 0  
**C)** -1  
**D)** undefined

**Answer: B** - All numeric types have zero value of 0 in Go.

### Question 2
What does the following code output?
```go
x := 5
y := x++
fmt.Println(y)
```

**A)** 5  
**B)** 6  
**C)** Compile error  
**D)** Runtime error

**Answer: C** - Go doesn't support post-increment expressions. You must use `x++` as a statement, not in an expression.

### Question 3
What is the result of `5 / 2` in Go?

**A)** 2.5  
**B)** 2  
**C)** 3  
**D)** Compile error

**Answer: B** - Integer division truncates the result. To get 2.5, you need `5.0 / 2.0` or `float64(5) / float64(2)`.

### Question 4
Which keyword is used to declare constants in Go?

**A)** `const`  
**B)** `constant`  
**C)** `final`  
**D)** `let`

**Answer: A** - The `const` keyword is used to declare constants in Go.

### Question 5
What happens if you declare a variable but don't use it?

**A)** Warning  
**B)** Compile error  
**C)** Runtime error  
**D)** Nothing

**Answer: B** - Go's compiler treats unused variables as errors to encourage clean code.

## Related Topics

- [Go Data Structures](./02.%20Go%20Data%20Structures.md)
- [Go Object-Oriented Programming](./03.%20Go%20Object-Oriented%20Programming.md)
- [Go Error Handling and Defer](./04.%20Go%20Error%20Handling%20and%20Defer.md)

