---
number: 5
title: "Go Packages and Modules"
slug: "go-packages-and-modules"
level: "beginner"
tags: ["go", "packages", "modules", "dependencies", "imports"]
prerequisites: ["go-error-handling-and-defer"]
estimated_minutes: 80
contributors: []
diagrams: []
examples: []
canonical_id: "golang-beginner-05"
---

# Go Packages and Modules

## Overview

Go's package system organizes code into reusable units, while modules manage dependencies and versioning. This guide covers package declaration and organization, import paths and aliases, module creation and management, dependency handling with `go.mod`, and best practices for structuring Go projects. Understanding packages and modules is essential for building maintainable Go applications.

## Deep Explanation

### Packages

A package is a collection of Go source files in the same directory that are compiled together.

#### Package Declaration

```go
// Every Go file starts with package declaration
package main  // Executable package

package mypackage  // Library package

// Package name should match directory name (except main)
```

#### Package Organization

```
project/
├── main.go           // package main
├── utils/
│   ├── string.go     // package utils
│   └── math.go       // package utils
└── models/
    └── user.go       // package models
```

#### Exported vs Unexported

```go
package utils

// Exported (capitalized) - accessible from other packages
func PublicFunction() {
    // ...
}

var PublicVariable = 10

// Unexported (lowercase) - only accessible within package
func privateFunction() {
    // ...
}

var privateVariable = 5
```

### Imports

#### Basic Import

```go
import "fmt"
import "os"
import "net/http"

// Or grouped
import (
    "fmt"
    "os"
    "net/http"
)
```

#### Import Aliases

```go
import (
    "fmt"
    f "fmt"           // Alias
    "database/sql"
    _ "database/sql/driver"  // Blank import (for side effects)
    m "math"          // Alias
)

// Using aliases
f.Println("Hello")
m.Sqrt(16)
```

#### Dot Import

```go
import . "fmt"  // Import into current namespace

// Can use Println directly instead of fmt.Println
Println("Hello")
```

### Modules

A module is a collection of Go packages with a `go.mod` file that defines the module path and dependencies.

#### Creating a Module

```bash
# Initialize module
go mod init github.com/username/project

# This creates go.mod file
```

#### go.mod File

```go
module github.com/username/project

go 1.21

require (
    github.com/gin-gonic/gin v1.9.1
    github.com/lib/pq v1.10.9
)

replace github.com/old/package => github.com/new/package v1.0.0

exclude github.com/problematic/package v1.0.0
```

#### Dependency Management

```bash
# Add dependency
go get github.com/gin-gonic/gin

# Add specific version
go get github.com/gin-gonic/gin@v1.9.1

# Update dependencies
go get -u ./...

# Remove unused dependencies
go mod tidy

# Download dependencies
go mod download

# Verify dependencies
go mod verify

# Vendor dependencies
go mod vendor
```

#### Version Selection

```go
// go.mod uses semantic versioning
require (
    github.com/pkg/errors v0.9.1  // Exact version
    github.com/gin-gonic/gin v1.9.1  // Latest v1.9.x
)
```

### Package Structure

#### Standard Layout

```
project/
├── cmd/
│   └── app/
│       └── main.go
├── internal/
│   ├── config/
│   └── handlers/
├── pkg/
│   └── utils/
├── api/
├── web/
├── go.mod
└── go.sum
```

#### Internal Packages

```go
// internal/ package is only importable by parent module
// Prevents external packages from importing internal code

project/
├── internal/
│   └── secret/
│       └── key.go  // Only importable within project
```

### Import Paths

#### Standard Library

```go
import (
    "fmt"
    "net/http"
    "encoding/json"
)
```

#### Third-Party Packages

```go
import (
    "github.com/gin-gonic/gin"
    "golang.org/x/crypto/bcrypt"
)
```

#### Local Packages

```go
// Within same module
import (
    "github.com/username/project/utils"
    "github.com/username/project/models"
)
```

## Real Code Examples

### Example: Multi-Package Project

```go
// go.mod
module github.com/example/mylib

go 1.21

// utils/string.go
package utils

import "strings"

func Reverse(s string) string {
    runes := []rune(s)
    for i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {
        runes[i], runes[j] = runes[j], runes[i]
    }
    return string(runes)
}

func TitleCase(s string) string {
    return strings.Title(strings.ToLower(s))
}

// models/user.go
package models

type User struct {
    ID    int
    Name  string
    Email string
}

func (u *User) Validate() error {
    if u.Name == "" {
        return fmt.Errorf("name is required")
    }
    if u.Email == "" {
        return fmt.Errorf("email is required")
    }
    return nil
}

// main.go
package main

import (
    "fmt"
    "github.com/example/mylib/models"
    "github.com/example/mylib/utils"
)

func main() {
    user := &models.User{
        ID:    1,
        Name:  "John Doe",
        Email: "john@example.com",
    }
    
    if err := user.Validate(); err != nil {
        fmt.Printf("Error: %v\n", err)
        return
    }
    
    reversed := utils.Reverse(user.Name)
    fmt.Printf("Reversed name: %s\n", reversed)
}
```

### Example: Dependency Management

```bash
# Initialize project
go mod init github.com/example/webapp

# Add dependencies
go get github.com/gin-gonic/gin
go get github.com/jinzhu/gorm
go get github.com/lib/pq

# go.mod is automatically updated
```

```go
// main.go
package main

import (
    "github.com/gin-gonic/gin"
    "github.com/jinzhu/gorm"
    _ "github.com/lib/pq"
)

func main() {
    r := gin.Default()
    r.GET("/", func(c *gin.Context) {
        c.JSON(200, gin.H{"message": "Hello"})
    })
    r.Run()
}
```

## Hard Use-Case: Plugin Architecture with Packages

### Problem Statement

Design a plugin system where plugins are separate packages that can be loaded dynamically, each implementing a common interface.

### Solution

```go
// go.mod
module github.com/example/plugin-system

go 1.21

// plugin/interface.go
package plugin

type Plugin interface {
    Name() string
    Execute(input interface{}) (interface{}, error)
}

var plugins = make(map[string]Plugin)

func Register(p Plugin) {
    plugins[p.Name()] = p
}

func Get(name string) (Plugin, bool) {
    p, ok := plugins[name]
    return p, ok
}

// plugins/calculator/calculator.go
package calculator

import "github.com/example/plugin-system/plugin"

type CalculatorPlugin struct{}

func (p *CalculatorPlugin) Name() string {
    return "calculator"
}

func (p *CalculatorPlugin) Execute(input interface{}) (interface{}, error) {
    numbers, ok := input.([]int)
    if !ok {
        return nil, fmt.Errorf("invalid input")
    }
    
    sum := 0
    for _, n := range numbers {
        sum += n
    }
    return sum, nil
}

func init() {
    plugin.Register(&CalculatorPlugin{})
}

// plugins/uppercase/uppercase.go
package uppercase

import (
    "strings"
    "github.com/example/plugin-system/plugin"
)

type UppercasePlugin struct{}

func (p *UppercasePlugin) Name() string {
    return "uppercase"
}

func (p *UppercasePlugin) Execute(input interface{}) (interface{}, error) {
    str, ok := input.(string)
    if !ok {
        return nil, fmt.Errorf("invalid input")
    }
    return strings.ToUpper(str), nil
}

func init() {
    plugin.Register(&UppercasePlugin{})
}

// main.go
package main

import (
    "fmt"
    _ "github.com/example/plugin-system/plugins/calculator"
    _ "github.com/example/plugin-system/plugins/uppercase"
    "github.com/example/plugin-system/plugin"
)

func main() {
    // Plugins are registered via init() functions
    
    calc, _ := plugin.Get("calculator")
    result, _ := calc.Execute([]int{1, 2, 3, 4, 5})
    fmt.Println("Sum:", result)
    
    upper, _ := plugin.Get("uppercase")
    result, _ = upper.Execute("hello world")
    fmt.Println("Uppercase:", result)
}
```

## Edge Cases and Pitfalls

### Common Mistakes

1. **Circular Imports**
```go
// Bad: Package A imports B, B imports A
// package a imports b
// package b imports a

// Good: Extract common code to third package
// package a imports common
// package b imports common
```

2. **Package Name Mismatch**
```go
// Bad: Package name doesn't match directory
// directory: utils/
// file: package util  // Wrong!

// Good: Match directory name
// directory: utils/
// file: package utils  // Correct
```

3. **Importing Internal Packages**
```go
// Bad: External package trying to import internal
import "github.com/user/project/internal/secret"  // Error!

// Good: Internal packages are protected
// Only importable within the same module
```

4. **Unused Imports**
```go
// Bad: Unused import causes compile error
import "fmt"  // Not used

// Good: Remove unused imports
go mod tidy  // Automatically removes unused
```

## References and Further Reading

- [Go Modules](https://go.dev/doc/modules/)
- [Go Packages](https://go.dev/doc/effective_go#packages)
- [Organizing Go Code](https://go.dev/doc/modules/layout)

## Quiz

### Question 1
What makes an identifier exported in Go?

**A)** `export` keyword  
**B)** Capitalizing the first letter  
**C)** `public` keyword  
**D)** Being in a public package

**Answer: B** - Identifiers starting with uppercase letters are exported and accessible from other packages.

### Question 2
What is the purpose of `go.mod`?

**A)** Compile configuration  
**B)** Module definition and dependency management  
**C)** Package documentation  
**D)** Test configuration

**Answer: B** - `go.mod` defines the module and manages its dependencies.

### Question 3
What does `go mod tidy` do?

**A)** Adds all dependencies  
**B)** Removes unused dependencies and adds missing ones  
**C)** Updates all dependencies  
**D)** Downloads dependencies

**Answer: B** - `go mod tidy` cleans up the module file by removing unused dependencies and adding missing ones.

### Question 4
Can you import an `internal` package from outside the module?

**A)** Yes, always  
**B)** No, never  
**C)** Only with special syntax  
**D)** Only if it's exported

**Answer: B** - `internal` packages can only be imported by packages within the same module tree.

### Question 5
What happens if you have a circular import?

**A)** Compile error  
**B)** Runtime error  
**C)** Works fine  
**D)** Warning only

**Answer: A** - Go doesn't allow circular imports and will produce a compile error.

## Related Topics

- [Go Error Handling and Defer](./04.%20Go%20Error%20Handling%20and%20Defer.md)
- [Go Concurrency Fundamentals](../02_intermediate/01.%20Go%20Concurrency%20Fundamentals.md)
- [Go I/O and Data Formats](../02_intermediate/03.%20Go%20I_O%20and%20Data%20Formats.md)

