---
number: 3
title: "Go Object-Oriented Programming"
slug: "go-object-oriented-programming"
level: "beginner"
tags: ["go", "methods", "interfaces", "embedding", "composition", "oop"]
prerequisites: ["go-data-structures"]
estimated_minutes: 100
contributors: []
diagrams: []
examples: []
canonical_id: "golang-beginner-03"
---

# Go Object-Oriented Programming

## Overview

Go takes a unique approach to object-oriented programming. While it doesn't have classes or inheritance in the traditional sense, it provides methods, interfaces, and embedding to achieve polymorphism and code reuse through composition. This guide covers Go's approach to OOP: methods with value and pointer receivers, interface types and their implicit satisfaction, embedding for composition, and how to design idiomatic Go code using these features.

## Deep Explanation

### Methods

Methods in Go are functions with a special receiver argument. They allow you to define behavior associated with a type.

#### Method Syntax

```go
type Rectangle struct {
    Width  float64
    Height float64
}

// Value receiver
func (r Rectangle) Area() float64 {
    return r.Width * r.Height
}

// Pointer receiver
func (r *Rectangle) Scale(factor float64) {
    r.Width *= factor
    r.Height *= factor
}

// Method call
rect := Rectangle{Width: 10, Height: 5}
area := rect.Area()        // Value receiver
rect.Scale(2)              // Pointer receiver (Go automatically converts)
```

#### Value vs Pointer Receivers

```go
type Counter struct {
    value int
}

// Value receiver - operates on copy
func (c Counter) Increment() {
    c.value++  // Doesn't modify original
}

// Pointer receiver - operates on original
func (c *Counter) IncrementPtr() {
    c.value++  // Modifies original
}

// When to use each:
// - Value receiver: When method doesn't need to modify receiver
// - Pointer receiver: When method modifies receiver or receiver is large

c := Counter{value: 0}
c.Increment()
fmt.Println(c.value)  // 0 (unchanged)

c.IncrementPtr()
fmt.Println(c.value)  // 1 (modified)
```

#### Methods on Non-Struct Types

```go
// Methods on custom types
type MyInt int

func (m MyInt) Double() MyInt {
    return m * 2
}

value := MyInt(5)
doubled := value.Double()  // 10

// Methods on slices
type IntSlice []int

func (s IntSlice) Sum() int {
    total := 0
    for _, v := range s {
        total += v
    }
    return total
}

numbers := IntSlice{1, 2, 3, 4, 5}
fmt.Println(numbers.Sum())  // 15
```

### Interfaces

Interfaces in Go define behavior through method signatures. Types implicitly satisfy interfaces by implementing all required methods.

#### Interface Declaration

```go
// Basic interface
type Shape interface {
    Area() float64
    Perimeter() float64
}

// Interface with single method (common pattern)
type Writer interface {
    Write([]byte) (int, error)
}

// Empty interface (accepts any type)
var anything interface{} = 42
anything = "hello"
anything = true
```

#### Interface Satisfaction

```go
// Types implicitly satisfy interfaces
type Circle struct {
    Radius float64
}

func (c Circle) Area() float64 {
    return 3.14159 * c.Radius * c.Radius
}

func (c Circle) Perimeter() float64 {
    return 2 * 3.14159 * c.Radius
}

// Circle automatically satisfies Shape interface
var s Shape = Circle{Radius: 5}
fmt.Println(s.Area())  // 78.54
```

#### Interface Composition

```go
// Compose interfaces
type Reader interface {
    Read([]byte) (int, error)
}

type Closer interface {
    Close() error
}

// ReadCloser combines Reader and Closer
type ReadCloser interface {
    Reader
    Closer
}

// Implementation
type File struct {
    name string
}

func (f *File) Read(data []byte) (int, error) {
    // Implementation
    return 0, nil
}

func (f *File) Close() error {
    // Implementation
    return nil
}

// File satisfies ReadCloser
var rc ReadCloser = &File{name: "test.txt"}
```

#### Interface Values

```go
// Interface value contains (type, value) pair
var s Shape
s = Circle{Radius: 5}

// Type assertion
circle, ok := s.(Circle)
if ok {
    fmt.Println("It's a circle with radius", circle.Radius)
}

// Type switch
switch v := s.(type) {
case Circle:
    fmt.Printf("Circle with radius %f\n", v.Radius)
case Rectangle:
    fmt.Printf("Rectangle %f x %f\n", v.Width, v.Height)
default:
    fmt.Println("Unknown shape")
}
```

#### Common Interface Patterns

```go
// Stringer interface (from fmt package)
type Stringer interface {
    String() string
}

type Person struct {
    Name string
    Age  int
}

func (p Person) String() string {
    return fmt.Sprintf("%s (%d years old)", p.Name, p.Age)
}

p := Person{Name: "Alice", Age: 30}
fmt.Println(p)  // Uses String() method

// Error interface
type MyError struct {
    Message string
    Code    int
}

func (e *MyError) Error() string {
    return fmt.Sprintf("Error %d: %s", e.Code, e.Message)
}

func doSomething() error {
    return &MyError{Message: "Something went wrong", Code: 500}
}
```

### Embedding and Composition

Go uses embedding to achieve composition, allowing one struct to include another struct's fields and methods.

#### Struct Embedding

```go
// Base struct
type Animal struct {
    Name string
    Age  int
}

func (a *Animal) Speak() {
    fmt.Printf("%s makes a sound\n", a.Name)
}

// Embedding Animal
type Dog struct {
    Animal        // Embedded struct
    Breed  string
}

// Dog automatically gets Animal's methods
dog := Dog{
    Animal: Animal{Name: "Buddy", Age: 3},
    Breed:  "Golden Retriever",
}
dog.Speak()  // Uses Animal's Speak method
fmt.Println(dog.Name)  // Direct access to embedded field
```

#### Method Overriding

```go
type Animal struct {
    Name string
}

func (a *Animal) Speak() {
    fmt.Println("Some generic sound")
}

type Dog struct {
    Animal
}

// Override Speak method
func (d *Dog) Speak() {
    fmt.Printf("%s barks!\n", d.Name)
}

dog := &Dog{Animal: Animal{Name: "Buddy"}}
dog.Speak()  // "Buddy barks!" (uses Dog's method)

// Access embedded method explicitly
var animal *Animal = &dog.Animal
animal.Speak()  // "Some generic sound"
```

#### Interface Embedding

```go
// Embed interfaces
type Reader interface {
    Read([]byte) (int, error)
}

type Writer interface {
    Write([]byte) (int, error)
}

type ReadWriter interface {
    Reader
    Writer
}

// Type that satisfies ReadWriter
type Buffer struct {
    data []byte
}

func (b *Buffer) Read(p []byte) (int, error) {
    copy(p, b.data)
    return len(b.data), nil
}

func (b *Buffer) Write(p []byte) (int, error) {
    b.data = append(b.data, p...)
    return len(p), nil
}

var rw ReadWriter = &Buffer{}
```

#### Multiple Embedding

```go
type Engine struct {
    Horsepower int
}

func (e *Engine) Start() {
    fmt.Println("Engine started")
}

type Radio struct {
    Frequency float64
}

func (r *Radio) Tune(freq float64) {
    r.Frequency = freq
    fmt.Printf("Tuned to %.2f MHz\n", freq)
}

type Car struct {
    Engine  // Embedded
    Radio   // Embedded
    Brand   string
}

car := Car{
    Engine: Engine{Horsepower: 200},
    Radio:  Radio{Frequency: 101.5},
    Brand:  "Toyota",
}

car.Start()           // Uses Engine's method
car.Tune(102.3)       // Uses Radio's method
fmt.Println(car.Horsepower)  // Direct access
```

## Real Code Examples

### Example: Shape Hierarchy

```go
package main

import (
    "fmt"
    "math"
)

type Shape interface {
    Area() float64
    Perimeter() float64
    String() string
}

type Rectangle struct {
    Width  float64
    Height float64
}

func (r Rectangle) Area() float64 {
    return r.Width * r.Height
}

func (r Rectangle) Perimeter() float64 {
    return 2 * (r.Width + r.Height)
}

func (r Rectangle) String() string {
    return fmt.Sprintf("Rectangle(%.2f x %.2f)", r.Width, r.Height)
}

type Circle struct {
    Radius float64
}

func (c Circle) Area() float64 {
    return math.Pi * c.Radius * c.Radius
}

func (c Circle) Perimeter() float64 {
    return 2 * math.Pi * c.Radius
}

func (c Circle) String() string {
    return fmt.Sprintf("Circle(radius=%.2f)", c.Radius)
}

type Triangle struct {
    A, B, C float64
}

func (t Triangle) Area() float64 {
    // Heron's formula
    s := t.Perimeter() / 2
    return math.Sqrt(s * (s - t.A) * (s - t.B) * (s - t.C))
}

func (t Triangle) Perimeter() float64 {
    return t.A + t.B + t.C
}

func (t Triangle) String() string {
    return fmt.Sprintf("Triangle(%.2f, %.2f, %.2f)", t.A, t.B, t.C)
}

func PrintShapeInfo(s Shape) {
    fmt.Printf("%s - Area: %.2f, Perimeter: %.2f\n",
        s.String(), s.Area(), s.Perimeter())
}

func main() {
    shapes := []Shape{
        Rectangle{Width: 10, Height: 5},
        Circle{Radius: 5},
        Triangle{A: 3, B: 4, C: 5},
    }
    
    for _, shape := range shapes {
        PrintShapeInfo(shape)
    }
}
```

### Example: File System Abstraction

```go
package main

import (
    "fmt"
    "io"
    "strings"
)

type FileSystem interface {
    Open(name string) (File, error)
    Create(name string) (File, error)
    Remove(name string) error
}

type File interface {
    io.Reader
    io.Writer
    io.Closer
    Name() string
    Size() int64
}

// In-memory file system
type MemoryFile struct {
    name    string
    content []byte
    pos     int
}

func (f *MemoryFile) Read(p []byte) (int, error) {
    if f.pos >= len(f.content) {
        return 0, io.EOF
    }
    n := copy(p, f.content[f.pos:])
    f.pos += n
    return n, nil
}

func (f *MemoryFile) Write(p []byte) (int, error) {
    n := len(p)
    f.content = append(f.content, p...)
    return n, nil
}

func (f *MemoryFile) Close() error {
    return nil
}

func (f *MemoryFile) Name() string {
    return f.name
}

func (f *MemoryFile) Size() int64 {
    return int64(len(f.content))
}

type MemoryFileSystem struct {
    files map[string]*MemoryFile
}

func NewMemoryFileSystem() *MemoryFileSystem {
    return &MemoryFileSystem{
        files: make(map[string]*MemoryFile),
    }
}

func (fs *MemoryFileSystem) Open(name string) (File, error) {
    file, exists := fs.files[name]
    if !exists {
        return nil, fmt.Errorf("file not found: %s", name)
    }
    file.pos = 0  // Reset position
    return file, nil
}

func (fs *MemoryFileSystem) Create(name string) (File, error) {
    file := &MemoryFile{
        name:    name,
        content: make([]byte, 0),
    }
    fs.files[name] = file
    return file, nil
}

func (fs *MemoryFileSystem) Remove(name string) error {
    if _, exists := fs.files[name]; !exists {
        return fmt.Errorf("file not found: %s", name)
    }
    delete(fs.files, name)
    return nil
}

func main() {
    fs := NewMemoryFileSystem()
    
    // Create and write
    file, _ := fs.Create("test.txt")
    file.Write([]byte("Hello, World!"))
    file.Close()
    
    // Open and read
    file, _ = fs.Open("test.txt")
    buffer := make([]byte, 100)
    n, _ := file.Read(buffer)
    fmt.Printf("Read %d bytes: %s\n", n, string(buffer[:n]))
    file.Close()
    
    fmt.Printf("File size: %d bytes\n", file.Size())
}
```

## Hard Use-Case: Plugin System with Interfaces

### Problem Statement

Design a plugin system where different plugins can be loaded and executed dynamically, each implementing a common interface but providing different functionality.

### Solution

```go
package main

import (
    "fmt"
    "time"
)

// Plugin interface
type Plugin interface {
    Name() string
    Initialize() error
    Execute(input interface{}) (interface{}, error)
    Cleanup() error
}

// Plugin manager
type PluginManager struct {
    plugins map[string]Plugin
}

func NewPluginManager() *PluginManager {
    return &PluginManager{
        plugins: make(map[string]Plugin),
    }
}

func (pm *PluginManager) Register(plugin Plugin) error {
    name := plugin.Name()
    if _, exists := pm.plugins[name]; exists {
        return fmt.Errorf("plugin %s already registered", name)
    }
    
    if err := plugin.Initialize(); err != nil {
        return fmt.Errorf("failed to initialize plugin %s: %v", name, err)
    }
    
    pm.plugins[name] = plugin
    return nil
}

func (pm *PluginManager) Execute(name string, input interface{}) (interface{}, error) {
    plugin, exists := pm.plugins[name]
    if !exists {
        return nil, fmt.Errorf("plugin %s not found", name)
    }
    return plugin.Execute(input)
}

func (pm *PluginManager) Shutdown() {
    for name, plugin := range pm.plugins {
        if err := plugin.Cleanup(); err != nil {
            fmt.Printf("Error cleaning up plugin %s: %v\n", name, err)
        }
    }
}

// Example plugins
type CalculatorPlugin struct {
    initialized bool
}

func (p *CalculatorPlugin) Name() string {
    return "calculator"
}

func (p *CalculatorPlugin) Initialize() error {
    p.initialized = true
    fmt.Println("Calculator plugin initialized")
    return nil
}

func (p *CalculatorPlugin) Execute(input interface{}) (interface{}, error) {
    if !p.initialized {
        return nil, fmt.Errorf("plugin not initialized")
    }
    
    numbers, ok := input.([]int)
    if !ok {
        return nil, fmt.Errorf("invalid input type")
    }
    
    sum := 0
    for _, num := range numbers {
        sum += num
    }
    return sum, nil
}

func (p *CalculatorPlugin) Cleanup() error {
    p.initialized = false
    fmt.Println("Calculator plugin cleaned up")
    return nil
}

type TimerPlugin struct {
    initialized bool
    startTime   time.Time
}

func (p *TimerPlugin) Name() string {
    return "timer"
}

func (p *TimerPlugin) Initialize() error {
    p.initialized = true
    p.startTime = time.Now()
    fmt.Println("Timer plugin initialized")
    return nil
}

func (p *TimerPlugin) Execute(input interface{}) (interface{}, error) {
    if !p.initialized {
        return nil, fmt.Errorf("plugin not initialized")
    }
    
    elapsed := time.Since(p.startTime)
    return elapsed.String(), nil
}

func (p *TimerPlugin) Cleanup() error {
    p.initialized = false
    fmt.Println("Timer plugin cleaned up")
    return nil
}

func main() {
    pm := NewPluginManager()
    
    // Register plugins
    pm.Register(&CalculatorPlugin{})
    pm.Register(&TimerPlugin{})
    
    // Execute calculator plugin
    result, _ := pm.Execute("calculator", []int{1, 2, 3, 4, 5})
    fmt.Printf("Sum: %d\n", result)
    
    // Execute timer plugin
    time.Sleep(1 * time.Second)
    elapsed, _ := pm.Execute("timer", nil)
    fmt.Printf("Elapsed time: %s\n", elapsed)
    
    // Shutdown
    pm.Shutdown()
}
```

## Edge Cases and Pitfalls

### Common Mistakes

1. **Nil Interface vs Nil Value**
```go
// Bad: Confusing nil interface with nil value
var w io.Writer  // nil interface
var buf *bytes.Buffer  // nil pointer
w = buf  // w is not nil! (it contains a nil *bytes.Buffer)

if w != nil {
    w.Write([]byte("test"))  // Panic: nil pointer dereference
}

// Good: Check both
if w != nil {
    if buf != nil {
        w.Write([]byte("test"))
    }
}
```

2. **Method Sets and Pointer Receivers**
```go
// Bad: Value doesn't satisfy interface requiring pointer receiver
type Counter struct {
    value int
}

func (c *Counter) Increment() {
    c.value++
}

type Incrementer interface {
    Increment()
}

var c Counter
var inc Incrementer = c  // Compile error!

// Good: Use pointer
var inc Incrementer = &c  // OK
```

3. **Embedding Name Collisions**
```go
// Bad: Ambiguous field access
type A struct {
    Name string
}

type B struct {
    Name string
}

type C struct {
    A
    B
}

c := C{}
// c.Name  // Ambiguous!

// Good: Explicit access or rename
fmt.Println(c.A.Name)
fmt.Println(c.B.Name)
```

4. **Interface Satisfaction Not Checked at Compile Time**
```go
// Bad: Missing method implementation
type Shape interface {
    Area() float64
    Perimeter() float64
}

type Rectangle struct {
    Width, Height float64
}

func (r Rectangle) Area() float64 {
    return r.Width * r.Height
}
// Missing Perimeter() - error only discovered at runtime

// Good: Ensure all methods are implemented
func (r Rectangle) Perimeter() float64 {
    return 2 * (r.Width + r.Height)
}
```

## References and Further Reading

- [Go Interfaces](https://go.dev/doc/effective_go#interfaces)
- [Go Methods](https://go.dev/doc/effective_go#methods)
- [Go Embedding](https://go.dev/doc/effective_go#embedding)

## Quiz

### Question 1
What is the main difference between value and pointer receivers?

**A)** Value receivers are faster  
**B)** Pointer receivers can modify the receiver  
**C)** Pointer receivers are required for interfaces  
**D)** No difference

**Answer: B** - Pointer receivers operate on the original value and can modify it, while value receivers work on a copy.

### Question 2
How do types satisfy interfaces in Go?

**A)** Explicitly using `implements` keyword  
**B)** Implicitly by implementing all required methods  
**C)** By embedding the interface  
**D)** By declaring satisfaction

**Answer: B** - Go uses duck typing: if a type implements all methods of an interface, it automatically satisfies that interface.

### Question 3
What happens when you embed a struct in another struct?

**A)** Methods are copied  
**B)** Methods are inherited  
**C)** Methods become available through embedding  
**D)** Methods must be redefined

**Answer: C** - Embedded struct's methods become available on the outer struct, allowing direct access to both fields and methods.

### Question 4
Can you have methods on non-struct types?

**A)** No, only structs  
**B)** Yes, on any named type  
**C)** Yes, but only with pointer receivers  
**D)** Only on built-in types

**Answer: B** - Methods can be defined on any named type, including custom types based on built-in types.

### Question 5
What is the zero value of an interface?

**A)** nil  
**B)** Empty struct  
**C)** Zero value of the underlying type  
**D)** Compile error

**Answer: A** - Interfaces are reference types, and their zero value is nil.

## Related Topics

- [Go Data Structures](./02.%20Go%20Data%20Structures.md)
- [Go Error Handling and Defer](./04.%20Go%20Error%20Handling%20and%20Defer.md)
- [Go Packages and Modules](./05.%20Go%20Packages%20and%20Modules.md)

