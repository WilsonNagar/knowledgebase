---
number: 2
title: "Go Data Structures"
slug: "go-data-structures"
level: "beginner"
tags: ["go", "arrays", "slices", "maps", "structs", "data-structures"]
prerequisites: ["go-language-fundamentals"]
estimated_minutes: 120
contributors: []
diagrams: []
examples: []
canonical_id: "golang-beginner-02"
---

# Go Data Structures

## Overview

Go provides powerful built-in data structures that form the foundation of most programs: arrays, slices, maps, and structs. Understanding these data structures, their characteristics, use cases, and performance implications is crucial for writing efficient Go code. This guide covers everything from basic array operations to advanced slice manipulation, map internals, and struct composition patterns.

## Deep Explanation

### Arrays

Arrays in Go are fixed-length sequences of elements of the same type. They are value types, meaning assignments create copies.

#### Array Declaration and Initialization

```go
// Declaration with zero values
var arr [5]int  // [0, 0, 0, 0, 0]

// Declaration with initialization
var arr1 [5]int = [5]int{1, 2, 3, 4, 5}
arr2 := [5]int{1, 2, 3, 4, 5}

// Array literal with ellipsis
arr3 := [...]int{1, 2, 3, 4, 5}  // Compiler determines length

// Sparse array (only specified indices)
arr4 := [5]int{1: 10, 3: 30}  // [0, 10, 0, 30, 0]

// Multi-dimensional arrays
var matrix [3][3]int
matrix := [3][3]int{
    {1, 2, 3},
    {4, 5, 6},
    {7, 8, 9},
}
```

#### Array Operations

```go
arr := [5]int{1, 2, 3, 4, 5}

// Access elements
first := arr[0]      // 1
last := arr[4]       // 5
length := len(arr)   // 5

// Iterate over array
for i := 0; i < len(arr); i++ {
    fmt.Println(arr[i])
}

for i, v := range arr {
    fmt.Printf("Index: %d, Value: %d\n", i, v)
}

// Array is a value type (copied)
arr1 := [3]int{1, 2, 3}
arr2 := arr1  // Copy
arr2[0] = 100
fmt.Println(arr1[0])  // 1 (unchanged)
fmt.Println(arr2[0])  // 100
```

#### Array Limitations

```go
// Arrays are fixed size - cannot be resized
arr := [5]int{1, 2, 3, 4, 5}
// arr = append(arr, 6)  // Compile error

// Arrays are value types - expensive to copy
largeArray := [1000000]int{}
copyArray := largeArray  // Full copy!
```

### Slices

Slices are dynamic, flexible views into arrays. They are reference types and are the preferred way to work with sequences in Go.

#### Slice Internals

A slice is a struct with three fields:
- Pointer to underlying array
- Length (number of elements)
- Capacity (maximum elements without reallocation)

```go
type slice struct {
    ptr    *T      // Pointer to underlying array
    len    int     // Current length
    cap    int     // Capacity
}
```

#### Slice Declaration and Creation

```go
// Nil slice
var s []int  // nil, len=0, cap=0

// Empty slice
s := []int{}  // Not nil, len=0, cap=0

// Slice literal
s := []int{1, 2, 3, 4, 5}

// Make slice with length
s := make([]int, 5)  // len=5, cap=5, zero values

// Make slice with length and capacity
s := make([]int, 5, 10)  // len=5, cap=10

// Slice from array
arr := [5]int{1, 2, 3, 4, 5}
s := arr[:]        // Full array
s := arr[1:4]      // [2, 3, 4], len=3, cap=4
s := arr[:3]       // [1, 2, 3], len=3, cap=5
s := arr[2:]       // [3, 4, 5], len=3, cap=3

// Slice from slice
s1 := []int{1, 2, 3, 4, 5}
s2 := s1[1:4]      // [2, 3, 4]
```

#### Slice Operations

```go
s := []int{1, 2, 3}

// Append elements
s = append(s, 4)           // [1, 2, 3, 4]
s = append(s, 5, 6, 7)     // [1, 2, 3, 4, 5, 6, 7]
s = append(s, []int{8, 9}...)  // [1, 2, 3, 4, 5, 6, 7, 8, 9]

// Copy slices
src := []int{1, 2, 3, 4, 5}
dst := make([]int, 3)
n := copy(dst, src)  // n=3, dst=[1, 2, 3]

// Length and capacity
s := make([]int, 3, 10)
fmt.Println(len(s))  // 3
fmt.Println(cap(s))  // 10

// Slice expressions
s := []int{0, 1, 2, 3, 4, 5}
s[1:4]      // [1, 2, 3] - simple slice
s[1:4:4]    // [1, 2, 3], cap=3 - full slice expression (limits capacity)
```

#### Slice Growth and Capacity

```go
// Understanding capacity growth
s := make([]int, 0, 2)
fmt.Printf("len=%d, cap=%d\n", len(s), cap(s))  // len=0, cap=2

s = append(s, 1, 2)
fmt.Printf("len=%d, cap=%d\n", len(s), cap(s))  // len=2, cap=2

s = append(s, 3)  // Capacity doubles when exceeded
fmt.Printf("len=%d, cap=%d\n", len(s), cap(s))  // len=3, cap=4

// Pre-allocate when size is known
s := make([]int, 0, 1000)  // Pre-allocate capacity
for i := 0; i < 1000; i++ {
    s = append(s, i)  // No reallocations
}
```

#### Slice Tricks

```go
// Remove element at index
s := []int{1, 2, 3, 4, 5}
index := 2
s = append(s[:index], s[index+1:]...)  // [1, 2, 4, 5]

// Insert element at index
s := []int{1, 2, 4, 5}
index := 2
value := 3
s = append(s[:index], append([]int{value}, s[index:]...)...)  // [1, 2, 3, 4, 5]

// More efficient insert
s := []int{1, 2, 4, 5}
index := 2
value := 3
s = append(s, 0)           // Extend by one
copy(s[index+1:], s[index:])  // Shift elements
s[index] = value            // Insert value

// Filter slice
s := []int{1, 2, 3, 4, 5, 6}
filtered := s[:0]  // Reuse underlying array
for _, v := range s {
    if v%2 == 0 {
        filtered = append(filtered, v)
    }
}
// filtered = [2, 4, 6]

// Reverse slice
s := []int{1, 2, 3, 4, 5}
for i, j := 0, len(s)-1; i < j; i, j = i+1, j-1 {
    s[i], s[j] = s[j], s[i]
}
// s = [5, 4, 3, 2, 1]
```

### Maps

Maps are hash tables that store key-value pairs. They are reference types and provide O(1) average-case lookup, insertion, and deletion.

#### Map Declaration and Initialization

```go
// Nil map (cannot be used until initialized)
var m map[string]int  // nil

// Empty map using make
m := make(map[string]int)

// Map literal
m := map[string]int{
    "apple":  5,
    "banana": 3,
    "orange": 2,
}

// Map with different key/value types
m1 := map[int]string{1: "one", 2: "two"}
m2 := map[string][]int{"even": {2, 4, 6}, "odd": {1, 3, 5}}
```

#### Map Operations

```go
m := make(map[string]int)

// Insert/Update
m["apple"] = 5
m["banana"] = 3
m["apple"] = 10  // Update existing

// Read
value := m["apple"]  // 10
value, exists := m["banana"]  // value=3, exists=true
value, exists := m["grape"]   // value=0, exists=false

// Delete
delete(m, "banana")

// Check existence
if value, ok := m["apple"]; ok {
    fmt.Println("Found:", value)
}

// Iterate
for key, value := range m {
    fmt.Printf("%s: %d\n", key, value)
}

// Keys only
for key := range m {
    fmt.Println(key)
}

// Values only
for _, value := range m {
    fmt.Println(value)
}

// Length
count := len(m)  // Number of key-value pairs
```

#### Map Characteristics

```go
// Maps are reference types
m1 := map[string]int{"a": 1, "b": 2}
m2 := m1  // Same reference
m2["c"] = 3
fmt.Println(m1["c"])  // 3 (both point to same map)

// Maps are not comparable (cannot use ==)
// m1 == m2  // Compile error

// Zero value is nil
var m map[string]int
fmt.Println(m == nil)  // true
// m["key"] = 1  // Panic: assignment to nil map

// Safe initialization check
if m == nil {
    m = make(map[string]int)
}
```

#### Map Patterns

```go
// Counting occurrences
words := []string{"apple", "banana", "apple", "orange", "banana", "apple"}
counts := make(map[string]int)
for _, word := range words {
    counts[word]++
}
// counts = map[string]int{"apple":3, "banana":2, "orange":1}

// Grouping
people := []struct {
    Name string
    Age  int
}{
    {"Alice", 25},
    {"Bob", 30},
    {"Charlie", 25},
    {"Diana", 30},
}
groups := make(map[int][]string)
for _, p := range people {
    groups[p.Age] = append(groups[p.Age], p.Name)
}
// groups = map[int][]string{25:["Alice","Charlie"], 30:["Bob","Diana"]}

// Set implementation
set := make(map[string]bool)
set["apple"] = true
set["banana"] = true
if set["apple"] {
    fmt.Println("apple is in set")
}

// Map of slices
m := make(map[string][]int)
m["even"] = append(m["even"], 2, 4, 6)
m["odd"] = append(m["odd"], 1, 3, 5)
```

### Structs

Structs are composite types that group together zero or more named fields of possibly different types.

#### Struct Declaration

```go
// Basic struct
type Person struct {
    Name string
    Age  int
}

// Struct literal
p1 := Person{"Alice", 30}  // Positional
p2 := Person{Name: "Bob", Age: 25}  // Named fields
p3 := Person{Name: "Charlie"}  // Age defaults to 0

// Pointer to struct
p4 := &Person{"Diana", 28}
p5 := new(Person)  // Zero value
p5.Name = "Eve"
p5.Age = 32

// Anonymous struct
p6 := struct {
    Name string
    Age  int
}{"Frank", 35}

// Embedded structs
type Address struct {
    Street string
    City   string
    Zip    string
}

type Employee struct {
    Person        // Embedded
    Address       // Embedded
    EmployeeID    int
    Department    string
}

emp := Employee{
    Person: Person{Name: "Alice", Age: 30},
    Address: Address{Street: "123 Main", City: "NYC", Zip: "10001"},
    EmployeeID:    12345,
    Department:    "Engineering",
}

// Access embedded fields
fmt.Println(emp.Name)      // Direct access
fmt.Println(emp.Person.Name)  // Explicit access
fmt.Println(emp.City)      // Direct access to embedded Address
```

#### Struct Methods

```go
type Rectangle struct {
    Width  float64
    Height float64
}

// Value receiver
func (r Rectangle) Area() float64 {
    return r.Width * r.Height
}

// Pointer receiver (can modify)
func (r *Rectangle) Scale(factor float64) {
    r.Width *= factor
    r.Height *= factor
}

// Method on pointer type
func (r *Rectangle) Perimeter() float64 {
    return 2 * (r.Width + r.Height)
}

r := Rectangle{Width: 10, Height: 5}
fmt.Println(r.Area())      // 50
r.Scale(2)                 // Modifies r
fmt.Println(r.Area())      // 200
```

#### Struct Tags and JSON

```go
import "encoding/json"

type User struct {
    ID        int    `json:"id"`
    FirstName string `json:"first_name"`
    LastName  string `json:"last_name"`
    Email     string `json:"email,omitempty"`  // Omit if empty
    Password  string `json:"-"`                 // Never serialize
    Age       int    `json:"age"`
}

user := User{
    ID:        1,
    FirstName: "John",
    LastName:  "Doe",
    Email:     "john@example.com",
    Age:       30,
}

// Marshal to JSON
data, err := json.Marshal(user)
// {"id":1,"first_name":"John","last_name":"Doe","email":"john@example.com","age":30}

// Unmarshal from JSON
jsonStr := `{"id":2,"first_name":"Jane","last_name":"Smith","age":25}`
var user2 User
json.Unmarshal([]byte(jsonStr), &user2)
```

## Real Code Examples

### Example: Contact Manager

```go
package main

import (
    "fmt"
    "sort"
)

type Contact struct {
    Name  string
    Phone string
    Email string
}

type ContactManager struct {
    contacts []Contact
}

func NewContactManager() *ContactManager {
    return &ContactManager{
        contacts: make([]Contact, 0),
    }
}

func (cm *ContactManager) Add(name, phone, email string) {
    cm.contacts = append(cm.contacts, Contact{
        Name:  name,
        Phone: phone,
        Email: email,
    })
}

func (cm *ContactManager) FindByName(name string) *Contact {
    for i := range cm.contacts {
        if cm.contacts[i].Name == name {
            return &cm.contacts[i]
        }
    }
    return nil
}

func (cm *ContactManager) Remove(name string) bool {
    for i, contact := range cm.contacts {
        if contact.Name == name {
            cm.contacts = append(cm.contacts[:i], cm.contacts[i+1:]...)
            return true
        }
    }
    return false
}

func (cm *ContactManager) List() []Contact {
    // Return a copy to prevent external modification
    result := make([]Contact, len(cm.contacts))
    copy(result, cm.contacts)
    return result
}

func (cm *ContactManager) SortByName() {
    sort.Slice(cm.contacts, func(i, j int) bool {
        return cm.contacts[i].Name < cm.contacts[j].Name
    })
}

func main() {
    cm := NewContactManager()
    
    cm.Add("Alice", "555-0101", "alice@example.com")
    cm.Add("Bob", "555-0102", "bob@example.com")
    cm.Add("Charlie", "555-0103", "charlie@example.com")
    
    fmt.Println("All contacts:")
    for _, contact := range cm.List() {
        fmt.Printf("  %s: %s (%s)\n", contact.Name, contact.Phone, contact.Email)
    }
    
    if contact := cm.FindByName("Bob"); contact != nil {
        fmt.Printf("\nFound: %s\n", contact.Name)
    }
    
    cm.SortByName()
    fmt.Println("\nSorted contacts:")
    for _, contact := range cm.List() {
        fmt.Printf("  %s\n", contact.Name)
    }
}
```

### Example: Word Frequency Counter

```go
package main

import (
    "fmt"
    "strings"
    "sort"
)

type WordCount struct {
    Word  string
    Count int
}

type WordFrequencyCounter struct {
    counts map[string]int
}

func NewWordFrequencyCounter() *WordFrequencyCounter {
    return &WordFrequencyCounter{
        counts: make(map[string]int),
    }
}

func (wfc *WordFrequencyCounter) AddText(text string) {
    words := strings.Fields(strings.ToLower(text))
    for _, word := range words {
        // Remove punctuation
        word = strings.Trim(word, ".,!?;:\"()[]{}")
        if word != "" {
            wfc.counts[word]++
        }
    }
}

func (wfc *WordFrequencyCounter) GetCount(word string) int {
    return wfc.counts[strings.ToLower(word)]
}

func (wfc *WordFrequencyCounter) TopN(n int) []WordCount {
    // Convert map to slice
    wordCounts := make([]WordCount, 0, len(wfc.counts))
    for word, count := range wfc.counts {
        wordCounts = append(wordCounts, WordCount{Word: word, Count: count})
    }
    
    // Sort by count (descending), then by word (ascending)
    sort.Slice(wordCounts, func(i, j int) bool {
        if wordCounts[i].Count == wordCounts[j].Count {
            return wordCounts[i].Word < wordCounts[j].Word
        }
        return wordCounts[i].Count > wordCounts[j].Count
    })
    
    // Return top N
    if n > len(wordCounts) {
        n = len(wordCounts)
    }
    return wordCounts[:n]
}

func main() {
    wfc := NewWordFrequencyCounter()
    
    text := `The quick brown fox jumps over the lazy dog.
    The dog was not lazy, but the fox was quick.
    Quick brown foxes are common in the forest.`
    
    wfc.AddText(text)
    
    fmt.Println("Top 5 words:")
    for i, wc := range wfc.TopN(5) {
        fmt.Printf("%d. %s: %d\n", i+1, wc.Word, wc.Count)
    }
}
```

## Hard Use-Case: LRU Cache Implementation

### Problem Statement

Implement a Least Recently Used (LRU) cache using Go's built-in data structures. The cache should support O(1) get and put operations.

### Solution

```go
package main

import (
    "fmt"
)

type Node struct {
    Key   int
    Value int
    Prev  *Node
    Next  *Node
}

type LRUCache struct {
    capacity int
    cache    map[int]*Node
    head     *Node  // Dummy head
    tail     *Node  // Dummy tail
}

func Constructor(capacity int) LRUCache {
    lru := LRUCache{
        capacity: capacity,
        cache:    make(map[int]*Node),
        head:     &Node{},
        tail:     &Node{},
    }
    lru.head.Next = lru.tail
    lru.tail.Prev = lru.head
    return lru
}

func (lru *LRUCache) addNode(node *Node) {
    // Add after head
    node.Prev = lru.head
    node.Next = lru.head.Next
    
    lru.head.Next.Prev = node
    lru.head.Next = node
}

func (lru *LRUCache) removeNode(node *Node) {
    prev := node.Prev
    next := node.Next
    
    prev.Next = next
    next.Prev = prev
}

func (lru *LRUCache) moveToHead(node *Node) {
    lru.removeNode(node)
    lru.addNode(node)
}

func (lru *LRUCache) popTail() *Node {
    last := lru.tail.Prev
    lru.removeNode(last)
    return last
}

func (lru *LRUCache) Get(key int) int {
    node, exists := lru.cache[key]
    if !exists {
        return -1
    }
    
    // Move to head (most recently used)
    lru.moveToHead(node)
    return node.Value
}

func (lru *LRUCache) Put(key, value int) {
    node, exists := lru.cache[key]
    
    if !exists {
        newNode := &Node{Key: key, Value: value}
        
        if len(lru.cache) >= lru.capacity {
            // Remove LRU
            tail := lru.popTail()
            delete(lru.cache, tail.Key)
        }
        
        lru.cache[key] = newNode
        lru.addNode(newNode)
    } else {
        // Update value and move to head
        node.Value = value
        lru.moveToHead(node)
    }
}

func main() {
    lru := Constructor(2)
    
    lru.Put(1, 1)
    lru.Put(2, 2)
    fmt.Println(lru.Get(1))  // 1
    lru.Put(3, 3)           // Evicts key 2
    fmt.Println(lru.Get(2))  // -1 (not found)
    lru.Put(4, 4)           // Evicts key 1
    fmt.Println(lru.Get(1))  // -1 (not found)
    fmt.Println(lru.Get(3))  // 3
    fmt.Println(lru.Get(4))  // 4
}
```

## Edge Cases and Pitfalls

### Common Mistakes

1. **Slice Sharing Underlying Array**
```go
// Bad: Modifying slice affects original
original := []int{1, 2, 3, 4, 5}
slice := original[1:4]  // [2, 3, 4]
slice[0] = 100
fmt.Println(original)  // [1, 100, 3, 4, 5] - modified!

// Good: Copy if you need independence
original := []int{1, 2, 3, 4, 5}
slice := make([]int, 3)
copy(slice, original[1:4])
slice[0] = 100
fmt.Println(original)  // [1, 2, 3, 4, 5] - unchanged
```

2. **Appending to Slice in Loop**
```go
// Bad: Inefficient - multiple reallocations
var result []int
for i := 0; i < 1000; i++ {
    result = append(result, i)  // May reallocate many times
}

// Good: Pre-allocate capacity
result := make([]int, 0, 1000)
for i := 0; i < 1000; i++ {
    result = append(result, i)  // No reallocations
}
```

3. **Map Iteration Order**
```go
// Bad: Assuming map iteration order
m := map[string]int{"a": 1, "b": 2, "c": 3}
for k, v := range m {
    fmt.Println(k, v)  // Order is random!
}

// Good: Sort keys if order matters
keys := make([]string, 0, len(m))
for k := range m {
    keys = append(keys, k)
}
sort.Strings(keys)
for _, k := range keys {
    fmt.Println(k, m[k])
}
```

4. **Nil Map Assignment**
```go
// Bad: Assignment to nil map causes panic
var m map[string]int
m["key"] = 1  // Panic!

// Good: Initialize map first
m := make(map[string]int)
m["key"] = 1  // OK
```

5. **Struct Field Visibility**
```go
// Bad: Unexported fields in different packages
type Person struct {
    name string  // Unexported - cannot access from other packages
    Age  int     // Exported
}

// Good: Export fields that need external access
type Person struct {
    Name string  // Exported
    Age  int     // Exported
}
```

## References and Further Reading

- [Go Slices: usage and internals](https://go.dev/blog/slices-intro)
- [Go Maps in Action](https://go.dev/blog/maps)
- [Effective Go - Data Structures](https://go.dev/doc/effective_go#data)

## Quiz

### Question 1
What is the zero value of a slice in Go?

**A)** nil  
**B)** []  
**C)** Empty slice with len=0, cap=0  
**D)** Both A and C

**Answer: D** - A nil slice has len=0 and cap=0, and is functionally equivalent to an empty slice for most operations.

### Question 2
What happens when you append to a slice that has reached its capacity?

**A)** Panic  
**B)** Slice capacity doubles (approximately)  
**C)** Slice capacity increases by 1  
**D)** Compile error

**Answer: B** - Go's runtime typically doubles the capacity when a slice needs to grow, though the exact growth strategy may vary.

### Question 3
Can you compare two maps using the == operator?

**A)** Yes, always  
**B)** Yes, if they have the same type  
**C)** No, maps are not comparable  
**D)** Only if they are nil

**Answer: C** - Maps are reference types and cannot be compared with ==. You must manually compare their contents.

### Question 4
What is the difference between `[]int{}` and `var s []int`?

**A)** No difference  
**B)** `[]int{}` is nil, `var s []int` is not  
**C)** `[]int{}` is not nil, `var s []int` is nil  
**D)** Both are compile errors

**Answer: C** - `[]int{}` creates an empty slice (not nil), while `var s []int` creates a nil slice.

### Question 5
When you assign a struct to another variable, what happens?

**A)** A reference is copied  
**B)** The entire struct is copied  
**C)** A pointer is created  
**D)** Compile error

**Answer: B** - Structs are value types, so assignment creates a complete copy of all fields.

## Related Topics

- [Go Language Fundamentals](./01.%20Go%20Language%20Fundamentals.md)
- [Go Object-Oriented Programming](./03.%20Go%20Object-Oriented%20Programming.md)
- [Go Error Handling and Defer](./04.%20Go%20Error%20Handling%20and%20Defer.md)

