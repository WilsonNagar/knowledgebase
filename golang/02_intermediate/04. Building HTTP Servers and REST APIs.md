---
number: 4
title: "Building HTTP Servers and REST APIs"
slug: "building-http-servers-and-rest-apis"
level: "intermediate"
tags: ["go", "http", "rest", "api", "middleware", "routing"]
prerequisites: ["go-io-and-data-formats"]
estimated_minutes: 120
contributors: []
diagrams: []
examples: []
canonical_id: "golang-intermediate-04"
---

# Building HTTP Servers and REST APIs

## Overview

This comprehensive guide covers building HTTP servers in Go using the net/http package, creating REST APIs, implementing middleware, routing, request/response handling, and best practices for API design. Learn to build production-ready HTTP services.

## Deep Explanation

### Basic HTTP Server

```go
import "net/http"

func handler(w http.ResponseWriter, r *http.Request) {
    fmt.Fprintf(w, "Hello, World!")
}

func main() {
    http.HandleFunc("/", handler)
    http.ListenAndServe(":8080", nil)
}
```

### REST API Patterns

```go
type User struct {
    ID    int    `json:"id"`
    Name  string `json:"name"`
    Email string `json:"email"`
}

func getUserHandler(w http.ResponseWriter, r *http.Request) {
    if r.Method != http.MethodGet {
        http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
        return
    }
    
    id := r.URL.Query().Get("id")
    // Fetch user...
    
    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(user)
}

func createUserHandler(w http.ResponseWriter, r *http.Request) {
    var user User
    if err := json.NewDecoder(r.Body).Decode(&user); err != nil {
        http.Error(w, err.Error(), http.StatusBadRequest)
        return
    }
    
    // Create user...
    w.WriteHeader(http.StatusCreated)
    json.NewEncoder(w).Encode(user)
}
```

### Middleware

```go
func loggingMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        start := time.Now()
        next.ServeHTTP(w, r)
        fmt.Printf("%s %s %v\n", r.Method, r.URL.Path, time.Since(start))
    })
}

func authMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        token := r.Header.Get("Authorization")
        if !isValidToken(token) {
            http.Error(w, "Unauthorized", http.StatusUnauthorized)
            return
        }
        next.ServeHTTP(w, r)
    })
}
```

## Real Code Examples

### Example: REST API Server

```go
package main

import (
    "encoding/json"
    "fmt"
    "net/http"
    "strconv"
    "sync"
)

type User struct {
    ID    int    `json:"id"`
    Name  string `json:"name"`
    Email string `json:"email"`
}

type UserService struct {
    mu    sync.RWMutex
    users map[int]*User
    nextID int
}

func NewUserService() *UserService {
    return &UserService{
        users: make(map[int]*User),
        nextID: 1,
    }
}

func (s *UserService) CreateUser(name, email string) *User {
    s.mu.Lock()
    defer s.mu.Unlock()
    
    user := &User{
        ID:    s.nextID,
        Name:  name,
        Email: email,
    }
    s.users[user.ID] = user
    s.nextID++
    return user
}

func (s *UserService) GetUser(id int) (*User, error) {
    s.mu.RLock()
    defer s.mu.RUnlock()
    
    user, exists := s.users[id]
    if !exists {
        return nil, fmt.Errorf("user not found")
    }
    return user, nil
}

type API struct {
    userService *UserService
}

func NewAPI() *API {
    return &API{
        userService: NewUserService(),
    }
}

func (api *API) createUser(w http.ResponseWriter, r *http.Request) {
    var req struct {
        Name  string `json:"name"`
        Email string `json:"email"`
    }
    
    if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
        http.Error(w, err.Error(), http.StatusBadRequest)
        return
    }
    
    user := api.userService.CreateUser(req.Name, req.Email)
    w.Header().Set("Content-Type", "application/json")
    w.WriteHeader(http.StatusCreated)
    json.NewEncoder(w).Encode(user)
}

func (api *API) getUser(w http.ResponseWriter, r *http.Request) {
    idStr := r.URL.Query().Get("id")
    id, err := strconv.Atoi(idStr)
    if err != nil {
        http.Error(w, "invalid id", http.StatusBadRequest)
        return
    }
    
    user, err := api.userService.GetUser(id)
    if err != nil {
        http.Error(w, err.Error(), http.StatusNotFound)
        return
    }
    
    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(user)
}

func main() {
    api := NewAPI()
    
    http.HandleFunc("/users", func(w http.ResponseWriter, r *http.Request) {
        switch r.Method {
        case http.MethodPost:
            api.createUser(w, r)
        case http.MethodGet:
            api.getUser(w, r)
        default:
            http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
        }
    })
    
    http.ListenAndServe(":8080", nil)
}
```

## Hard Use-Case: API Gateway with Rate Limiting

### Problem Statement

Build an API gateway that routes requests, applies rate limiting per client, and includes authentication middleware.

### Solution

```go
package main

import (
    "net/http"
    "sync"
    "time"
)

type RateLimiter struct {
    requests map[string][]time.Time
    mu       sync.Mutex
    limit    int
    window   time.Duration
}

func NewRateLimiter(limit int, window time.Duration) *RateLimiter {
    return &RateLimiter{
        requests: make(map[string][]time.Time),
        limit:    limit,
        window:   window,
    }
}

func (rl *RateLimiter) Allow(clientID string) bool {
    rl.mu.Lock()
    defer rl.mu.Unlock()
    
    now := time.Now()
    cutoff := now.Add(-rl.window)
    
    // Clean old requests
    times := rl.requests[clientID]
    valid := times[:0]
    for _, t := range times {
        if t.After(cutoff) {
            valid = append(valid, t)
        }
    }
    
    if len(valid) >= rl.limit {
        return false
    }
    
    valid = append(valid, now)
    rl.requests[clientID] = valid
    return true
}

func rateLimitMiddleware(limiter *RateLimiter) func(http.Handler) http.Handler {
    return func(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            clientID := r.RemoteAddr
            if !limiter.Allow(clientID) {
                http.Error(w, "Rate limit exceeded", http.StatusTooManyRequests)
                return
            }
            next.ServeHTTP(w, r)
        })
    }
}

func main() {
    limiter := NewRateLimiter(10, time.Minute)
    
    mux := http.NewServeMux()
    mux.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
        w.Write([]byte("OK"))
    })
    
    handler := rateLimitMiddleware(limiter)(mux)
    http.ListenAndServe(":8080", handler)
}
```

## Edge Cases and Pitfalls

### Common Mistakes

1. **Not Setting Content-Type**
```go
// Bad: Client may not parse JSON correctly
json.NewEncoder(w).Encode(data)

// Good: Set header
w.Header().Set("Content-Type", "application/json")
json.NewEncoder(w).Encode(data)
```

2. **Not Handling Errors Properly**
```go
// Bad: Panic on error
user, _ := getUser(id)  // Ignoring error

// Good: Handle errors
user, err := getUser(id)
if err != nil {
    http.Error(w, err.Error(), http.StatusNotFound)
    return
}
```

## References and Further Reading

- [Go net/http Package](https://pkg.go.dev/net/http)
- [Building Web Applications](https://go.dev/doc/articles/wiki/)

## Quiz

### Question 1
What is the default behavior of http.HandleFunc for unmatched routes?

**A)** Returns 404  
**B)** Returns 500  
**C)** Returns empty response  
**D)** Panics

**Answer: A** - Unmatched routes return 404 Not Found.

## Related Topics

- [Go I/O and Data Formats](./03.%20Go%20I_O%20and%20Data%20Formats.md)
- [Testing and Benchmarking in Go](./05.%20Testing%20and%20Benchmarking%20in%20Go.md)

