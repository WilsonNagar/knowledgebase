---
number: 3
title: "Go I/O and Data Formats"
slug: "go-io-and-data-formats"
level: "intermediate"
tags: ["go", "io", "file-io", "json", "encoding", "streams"]
prerequisites: ["go-concurrency-patterns-and-synchronization"]
estimated_minutes: 100
contributors: []
diagrams: []
examples: []
canonical_id: "golang-intermediate-03"
---

# Go I/O and Data Formats

## Overview

This guide covers Go's I/O operations including file reading and writing, working with JSON and other data formats, streaming data, buffered I/O, and the io package interfaces. Master these concepts to handle data persistence and serialization effectively.

## Deep Explanation

### File I/O

```go
import (
    "os"
    "io"
    "bufio"
)

// Reading files
data, err := os.ReadFile("file.txt")

// Writing files
err := os.WriteFile("file.txt", []byte("content"), 0644)

// Streaming
file, _ := os.Open("file.txt")
defer file.Close()
data, _ := io.ReadAll(file)

// Buffered I/O
reader := bufio.NewReader(file)
line, _ := reader.ReadString('\n')

writer := bufio.NewWriter(file)
writer.WriteString("line\n")
writer.Flush()
```

### JSON

```go
import "encoding/json"

type User struct {
    Name  string `json:"name"`
    Email string `json:"email,omitempty"`
    Age   int    `json:"age"`
}

// Marshal
user := User{Name: "Alice", Age: 30}
data, _ := json.Marshal(user)

// Unmarshal
var user User
json.Unmarshal(data, &user)

// Streaming
decoder := json.NewDecoder(reader)
encoder := json.NewEncoder(writer)
```

### Other Formats

```go
// CSV
import "encoding/csv"
reader := csv.NewReader(file)
records, _ := reader.ReadAll()

// XML
import "encoding/xml"
xml.Marshal(data)

// Base64
import "encoding/base64"
encoded := base64.StdEncoding.EncodeToString(data)
```

## Real Code Examples

### Example: Config File Reader

```go
package main

import (
    "encoding/json"
    "fmt"
    "os"
)

type Config struct {
    Host     string `json:"host"`
    Port     int    `json:"port"`
    Database string `json:"database"`
}

func LoadConfig(filename string) (*Config, error) {
    data, err := os.ReadFile(filename)
    if err != nil {
        return nil, err
    }
    
    var config Config
    if err := json.Unmarshal(data, &config); err != nil {
        return nil, err
    }
    
    return &config, nil
}

func main() {
    config, err := LoadConfig("config.json")
    if err != nil {
        fmt.Printf("Error: %v\n", err)
        return
    }
    
    fmt.Printf("Host: %s, Port: %d\n", config.Host, config.Port)
}
```

## Hard Use-Case: Log File Parser

### Problem Statement

Create a log file parser that reads large log files efficiently, parses JSON log entries, and filters by log level.

### Solution

```go
package main

import (
    "bufio"
    "encoding/json"
    "fmt"
    "os"
    "strings"
)

type LogEntry struct {
    Level   string `json:"level"`
    Message string `json:"message"`
    Time    string `json:"time"`
}

func ParseLogFile(filename string, level string) ([]LogEntry, error) {
    file, err := os.Open(filename)
    if err != nil {
        return nil, err
    }
    defer file.Close()
    
    var entries []LogEntry
    scanner := bufio.NewScanner(file)
    
    for scanner.Scan() {
        line := scanner.Text()
        if strings.TrimSpace(line) == "" {
            continue
        }
        
        var entry LogEntry
        if err := json.Unmarshal([]byte(line), &entry); err != nil {
            continue
        }
        
        if level == "" || entry.Level == level {
            entries = append(entries, entry)
        }
    }
    
    return entries, scanner.Err()
}

func main() {
    entries, err := ParseLogFile("app.log", "ERROR")
    if err != nil {
        fmt.Printf("Error: %v\n", err)
        return
    }
    
    for _, entry := range entries {
        fmt.Printf("[%s] %s: %s\n", entry.Time, entry.Level, entry.Message)
    }
}
```

## Edge Cases and Pitfalls

### Common Mistakes

1. **Not Closing Files**
```go
// Bad: File handle leak
file, _ := os.Open("file.txt")
// Never closed!

// Good: Use defer
file, _ := os.Open("file.txt")
defer file.Close()
```

2. **Large File Reading**
```go
// Bad: Loading entire file into memory
data, _ := os.ReadFile("huge.txt")  // May OOM

// Good: Stream processing
file, _ := os.Open("huge.txt")
defer file.Close()
scanner := bufio.NewScanner(file)
for scanner.Scan() {
    process(scanner.Text())
}
```

## References and Further Reading

- [Go io Package](https://pkg.go.dev/io)
- [Go encoding/json](https://pkg.go.dev/encoding/json)

## Quiz

### Question 1
What is the difference between os.ReadFile and io.ReadAll?

**A)** No difference  
**B)** os.ReadFile reads entire file, io.ReadAll reads from reader  
**C)** io.ReadAll is faster  
**D)** os.ReadFile is for binary only

**Answer: B** - os.ReadFile reads a file by name, while io.ReadAll reads from any io.Reader.

## Related Topics

- [Building HTTP Servers and REST APIs](./04.%20Building%20HTTP%20Servers%20and%20REST%20APIs.md)
- [Working with Databases in Go](./06.%20Working%20with%20Databases%20in%20Go.md)

