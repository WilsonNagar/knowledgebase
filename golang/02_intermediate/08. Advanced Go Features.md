---
number: 8
title: "Advanced Go Features"
slug: "advanced-go-features"
level: "intermediate"
tags: ["go", "reflection", "generics", "code-generation", "go-generate"]
prerequisites: ["building-cli-applications-in-go"]
estimated_minutes: 100
contributors: []
diagrams: []
examples: []
canonical_id: "golang-intermediate-08"
---

# Advanced Go Features

## Overview

This guide covers advanced Go features including reflection for runtime type inspection, generics introduced in Go 1.18, code generation with go:generate, and advanced type system features.

## Deep Explanation

### Reflection

```go
import "reflect"

func inspect(v interface{}) {
    t := reflect.TypeOf(v)
    v := reflect.ValueOf(v)
    
    fmt.Printf("Type: %s\n", t.Name())
    fmt.Printf("Kind: %s\n", t.Kind())
    
    if t.Kind() == reflect.Struct {
        for i := 0; i < t.NumField(); i++ {
            field := t.Field(i)
            value := v.Field(i)
            fmt.Printf("%s: %v\n", field.Name, value.Interface())
        }
    }
}
```

### Generics

```go
// Generic function
func Map[T any, U any](slice []T, fn func(T) U) []U {
    result := make([]U, len(slice))
    for i, v := range slice {
        result[i] = fn(v)
    }
    return result
}

// Generic type
type Stack[T any] struct {
    items []T
}

func (s *Stack[T]) Push(item T) {
    s.items = append(s.items, item)
}

func (s *Stack[T]) Pop() (T, bool) {
    if len(s.items) == 0 {
        var zero T
        return zero, false
    }
    item := s.items[len(s.items)-1]
    s.items = s.items[:len(s.items)-1]
    return item, true
}
```

### Code Generation

```go
//go:generate stringer -type=Status

type Status int

const (
    Pending Status = iota
    Active
    Completed
)

// Run: go generate
```

## Real Code Examples

### Example: Generic Cache

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

type Cache[K comparable, V any] struct {
    mu    sync.RWMutex
    items map[K]cacheItem[V]
}

type cacheItem[V any] struct {
    value      V
    expiration time.Time
}

func NewCache[K comparable, V any]() *Cache[K, V] {
    return &Cache[K, V]{
        items: make(map[K]cacheItem[V]),
    }
}

func (c *Cache[K, V]) Set(key K, value V, ttl time.Duration) {
    c.mu.Lock()
    defer c.mu.Unlock()
    c.items[key] = cacheItem[V]{
        value:      value,
        expiration: time.Now().Add(ttl),
    }
}

func (c *Cache[K, V]) Get(key K) (V, bool) {
    c.mu.RLock()
    defer c.mu.RUnlock()
    
    item, exists := c.items[key]
    if !exists {
        var zero V
        return zero, false
    }
    
    if time.Now().After(item.expiration) {
        delete(c.items, key)
        var zero V
        return zero, false
    }
    
    return item.value, true
}

func main() {
    cache := NewCache[string, int]()
    cache.Set("key1", 42, time.Minute)
    
    if value, ok := cache.Get("key1"); ok {
        fmt.Println(value)
    }
}
```

## Hard Use-Case: Dynamic Struct Builder

### Problem Statement

Create a system that builds structs dynamically using reflection and allows setting fields by name.

### Solution

```go
package main

import (
    "fmt"
    "reflect"
)

type Builder struct {
    typ   reflect.Type
    value reflect.Value
}

func NewBuilder(typ reflect.Type) *Builder {
    return &Builder{
        typ:   typ,
        value: reflect.New(typ).Elem(),
    }
}

func (b *Builder) SetField(name string, value interface{}) error {
    field := b.value.FieldByName(name)
    if !field.IsValid() {
        return fmt.Errorf("field %s not found", name)
    }
    
    if !field.CanSet() {
        return fmt.Errorf("field %s cannot be set", name)
    }
    
    val := reflect.ValueOf(value)
    if field.Type() != val.Type() {
        return fmt.Errorf("type mismatch for field %s", name)
    }
    
    field.Set(val)
    return nil
}

func (b *Builder) Build() interface{} {
    return b.value.Interface()
}

func main() {
    type Person struct {
        Name string
        Age  int
    }
    
    builder := NewBuilder(reflect.TypeOf(Person{}))
    builder.SetField("Name", "Alice")
    builder.SetField("Age", 30)
    
    person := builder.Build().(Person)
    fmt.Printf("%+v\n", person)
}
```

## References and Further Reading

- [Go Reflection](https://pkg.go.dev/reflect)
- [Go Generics Tutorial](https://go.dev/doc/tutorial/generics)

## Quiz

### Question 1
When were generics introduced to Go?

**A)** Go 1.0  
**B)** Go 1.15  
**C)** Go 1.18  
**D)** Go 2.0

**Answer: C** - Generics were introduced in Go 1.18.

## Related Topics

- [Building CLI Applications in Go](./07.%20Building%20CLI%20Applications%20in%20Go.md)
- [Advanced Concurrency in Go](../03_advanced/01.%20Advanced%20Concurrency%20in%20Go.md)

