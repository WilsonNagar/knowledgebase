---
number: 3
title: "Advanced Networking in Go"
slug: "advanced-networking-in-go"
level: "advanced"
tags: ["go", "networking", "tcp", "udp", "websockets", "streams"]
prerequisites: ["grpc-and-microservices-in-go"]
estimated_minutes: 125
contributors: []
diagrams: []
examples: []
canonical_id: "golang-advanced-03"
---

# Advanced Networking in Go

## Overview

This guide covers low-level networking with TCP/UDP sockets, WebSocket implementations, stream processing, connection pooling, and building high-performance network services.

## Deep Explanation

### TCP Server

```go
import "net"

listener, _ := net.Listen("tcp", ":8080")
defer listener.Close()

for {
    conn, _ := listener.Accept()
    go handleConnection(conn)
}

func handleConnection(conn net.Conn) {
    defer conn.Close()
    buffer := make([]byte, 1024)
    n, _ := conn.Read(buffer)
    conn.Write(buffer[:n])
}
```

### UDP Server

```go
conn, _ := net.ListenPacket("udp", ":8080")
defer conn.Close()

buffer := make([]byte, 1024)
n, addr, _ := conn.ReadFrom(buffer)
conn.WriteTo(buffer[:n], addr)
```

### WebSockets

```go
import "github.com/gorilla/websocket"

var upgrader = websocket.Upgrader{
    CheckOrigin: func(r *http.Request) bool { return true },
}

func handler(w http.ResponseWriter, r *http.Request) {
    conn, _ := upgrader.Upgrade(w, r, nil)
    defer conn.Close()
    
    for {
        messageType, message, _ := conn.ReadMessage()
        conn.WriteMessage(messageType, message)
    }
}
```

## Real Code Examples

### Example: Connection Pool

```go
package main

import (
    "net"
    "sync"
    "time"
)

type Pool struct {
    mu      sync.Mutex
    conns   chan net.Conn
    factory func() (net.Conn, error)
    maxOpen int
    maxIdle int
    idleTimeout time.Duration
}

func NewPool(factory func() (net.Conn, error), maxOpen, maxIdle int, idleTimeout time.Duration) *Pool {
    return &Pool{
        conns:       make(chan net.Conn, maxIdle),
        factory:     factory,
        maxOpen:     maxOpen,
        maxIdle:     maxIdle,
        idleTimeout: idleTimeout,
    }
}

func (p *Pool) Get() (net.Conn, error) {
    select {
    case conn := <-p.conns:
        return conn, nil
    default:
        return p.factory()
    }
}

func (p *Pool) Put(conn net.Conn) {
    select {
    case p.conns <- conn:
    default:
        conn.Close()
    }
}
```

## Hard Use-Case: High-Performance TCP Proxy

### Problem Statement

Build a TCP proxy that handles thousands of concurrent connections with minimal latency.

### Solution

```go
package main

import (
    "io"
    "net"
    "sync"
)

func proxyConnection(client, backend net.Conn) {
    var wg sync.WaitGroup
    wg.Add(2)
    
    go func() {
        defer wg.Done()
        io.Copy(backend, client)
        backend.Close()
    }()
    
    go func() {
        defer wg.Done()
        io.Copy(client, backend)
        client.Close()
    }()
    
    wg.Wait()
}

func main() {
    listener, _ := net.Listen("tcp", ":8080")
    backend, _ := net.Dial("tcp", "backend:9090")
    
    for {
        client, _ := listener.Accept()
        go proxyConnection(client, backend)
    }
}
```

## References and Further Reading

- [Go net Package](https://pkg.go.dev/net)
- [Gorilla WebSocket](https://github.com/gorilla/websocket)

## Quiz

### Question 1
What is the main difference between TCP and UDP?

**A)** TCP is faster  
**B)** TCP is connection-oriented, UDP is connectionless  
**C)** UDP is more reliable  
**D)** No difference

**Answer: B** - TCP is connection-oriented with guaranteed delivery, UDP is connectionless and faster but unreliable.

## Related Topics

- [gRPC and Microservices in Go](./02.%20gRPC%20and%20Microservices%20in%20Go.md)
- [Performance Optimization and Profiling](./04.%20Performance%20Optimization%20and%20Profiling.md)

