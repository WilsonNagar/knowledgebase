---
number: 1
title: "Advanced Concurrency in Go"
slug: "advanced-concurrency-in-go"
level: "advanced"
tags: ["go", "concurrency", "race-conditions", "memory-model", "advanced-patterns"]
prerequisites: ["advanced-go-features"]
estimated_minutes: 130
contributors: []
diagrams: []
examples: []
canonical_id: "golang-advanced-01"
---

# Advanced Concurrency in Go

## Overview

This advanced guide covers race conditions detection and prevention, Go's memory model, lock-free programming, advanced channel patterns, worker pool optimizations, and performance considerations for concurrent code.

## Deep Explanation

### Race Conditions

```go
// Race detector: go run -race or go test -race
var counter int

func increment() {
    counter++  // Race condition!
}

// Fix with mutex
var mu sync.Mutex
func increment() {
    mu.Lock()
    defer mu.Unlock()
    counter++
}
```

### Memory Model

Go's memory model defines when reads of a variable are guaranteed to see writes by other goroutines.

```go
// Synchronization via channels
var done = make(chan bool)

func worker() {
    // Work...
    done <- true
}

func main() {
    go worker()
    <-done  // Synchronization point
}
```

### Lock-Free Programming

```go
import "sync/atomic"

var counter int64

func increment() {
    atomic.AddInt64(&counter, 1)
}

func load() int64 {
    return atomic.LoadInt64(&counter)
}
```

## Real Code Examples

### Example: Lock-Free Ring Buffer

```go
package main

import (
    "sync/atomic"
    "unsafe"
)

type RingBuffer struct {
    buffer []interface{}
    mask   uint64
    write  uint64
    read   uint64
}

func NewRingBuffer(size uint64) *RingBuffer {
    if size&(size-1) != 0 {
        panic("size must be power of 2")
    }
    return &RingBuffer{
        buffer: make([]interface{}, size),
        mask:   size - 1,
    }
}

func (rb *RingBuffer) Push(item interface{}) bool {
    write := atomic.LoadUint64(&rb.write)
    read := atomic.LoadUint64(&rb.read)
    
    if write-read >= uint64(len(rb.buffer)) {
        return false  // Full
    }
    
    rb.buffer[write&rb.mask] = item
    atomic.StoreUint64(&rb.write, write+1)
    return true
}

func (rb *RingBuffer) Pop() (interface{}, bool) {
    read := atomic.LoadUint64(&rb.read)
    write := atomic.LoadUint64(&rb.write)
    
    if read >= write {
        return nil, false  // Empty
    }
    
    item := rb.buffer[read&rb.mask]
    atomic.StoreUint64(&rb.read, read+1)
    return item, true
}
```

## Hard Use-Case: Concurrent Map with Sharding

### Problem Statement

Implement a thread-safe map using sharding to reduce lock contention.

### Solution

```go
package main

import (
    "hash/fnv"
    "sync"
)

type ShardedMap struct {
    shards []*shard
    shardCount int
}

type shard struct {
    mu    sync.RWMutex
    items map[string]interface{}
}

func NewShardedMap(shardCount int) *ShardedMap {
    shards := make([]*shard, shardCount)
    for i := range shards {
        shards[i] = &shard{items: make(map[string]interface{})}
    }
    return &ShardedMap{
        shards:     shards,
        shardCount: shardCount,
    }
}

func (sm *ShardedMap) getShard(key string) *shard {
    h := fnv.New32a()
    h.Write([]byte(key))
    return sm.shards[h.Sum32()%uint32(sm.shardCount)]
}

func (sm *ShardedMap) Set(key string, value interface{}) {
    shard := sm.getShard(key)
    shard.mu.Lock()
    defer shard.mu.Unlock()
    shard.items[key] = value
}

func (sm *ShardedMap) Get(key string) (interface{}, bool) {
    shard := sm.getShard(key)
    shard.mu.RLock()
    defer shard.mu.RUnlock()
    return shard.items[key]
}
```

## References and Further Reading

- [Go Memory Model](https://go.dev/ref/mem)
- [Race Detector](https://go.dev/blog/race-detector)

## Quiz

### Question 1
What flag enables the race detector in Go?

**A)** -race  
**B)** -detect-race  
**C)** -check-race  
**D)** -race-check

**Answer: A** - Use `-race` flag with go run, go test, or go build.

## Related Topics

- [Go Concurrency Patterns and Synchronization](../02_intermediate/02.%20Go%20Concurrency%20Patterns%20and%20Synchronization.md)
- [Performance Optimization and Profiling](./04.%20Performance%20Optimization%20and%20Profiling.md)

