---
number: 155
title: analyzing tombstones
slug: analyzing-tombstones
level: advanced
tags:
  - aosp
  - debugging
  - tombstones
  - crash-analysis
  - native-crashes
  - stack-trace-analysis
prerequisites:
  - debugging-native-crashes-tombstones
  - gdbserver-for-native-debugging
estimated_minutes: 95
contributors: []
diagrams: []
examples: []
canonical_id: aosp-advanced-155
---

# analyzing tombstones

## Overview

Analyzing tombstones involves systematically examining tombstone files to identify crash causes, understand crash context, resolve symbols, interpret stack traces, and determine root causes of native crashes. Tombstone analysis is a critical debugging skill that requires understanding tombstone structure, symbol resolution techniques, stack trace interpretation, and analysis tools. Understanding how to analyze tombstones is essential for AOSP development, as it explains how to read tombstone files, how to resolve symbols, how to interpret stack traces, how to use analysis tools, and how to identify crash root causes. This guide provides a comprehensive overview of analyzing tombstones, tombstone structure, symbol resolution, stack trace analysis, analysis tools, and analysis techniques.

Think of analyzing tombstones like forensic analysis: just as a forensic analyst examines evidence systematically (collecting evidence, analyzing patterns, identifying clues, determining cause), analyzing tombstones involves systematically examining crash evidence (reading tombstone, resolving symbols, analyzing stack traces, identifying root cause) to understand what happened and why.

## Deep Explanation

### What is Tombstone Analysis?

Tombstone analysis is the systematic process of examining tombstone files to identify crash causes, understand crash context, resolve symbols, interpret stack traces, and determine root causes of native crashes. Effective tombstone analysis requires understanding tombstone structure, symbol resolution, and analysis techniques.

**Key Characteristics:**
- **Systematic:** Systematic examination process
- **Symbol Resolution:** Resolving addresses to symbols
- **Stack Trace Analysis:** Interpreting stack traces
- **Root Cause Identification:** Identifying crash causes
- **Tool-Assisted:** Uses analysis tools

**Why Analyze Tombstones?**
- **Crash Understanding:** Understand crash causes
- **Bug Fixing:** Fix native code bugs
- **Root Cause Analysis:** Identify root causes
- **Prevention:** Prevent future crashes

### Tombstone Structure

#### Header Section

**Header Information:**
```
*** *** *** *** *** *** *** *** *** *** *** *** *** *** *** ***
Build fingerprint: 'google/sdk_gphone64_arm64/emu64xa:13/...'
Revision: '0'
ABI: 'arm64'
Timestamp: 2024-01-15 10:30:45
Process: com.example.app
PID: 12345
UID: 10123
Signal: 11 (SIGSEGV), Code: 1 (SEGV_MAPERR), Fault addr: 0x0
```

**Key Fields:**
- **Build fingerprint:** Device/build information
- **ABI:** Architecture (arm64, arm, x86, etc.)
- **Process:** Process name
- **PID:** Process ID
- **Signal:** Crash signal (SIGSEGV, SIGABRT, etc.)
- **Code:** Signal code
- **Fault addr:** Fault address

#### Stack Trace Section

**Stack Trace Format:**
```
backtrace:
  #00 pc 0000000000012345  /system/lib64/libmylib.so (crash_function+123)
  #01 pc 0000000000056789  /system/lib64/libmylib.so (caller_function+456)
  #02 pc 000000000009abcd  /system/lib64/libc.so (__libc_init+789)
```

**Stack Trace Components:**
- **Frame number:** Stack frame number
- **PC:** Program counter address
- **Library path:** Library file path
- **Function name:** Function name (if symbols available)
- **Offset:** Offset from function start

#### Register State Section

**Register Information:**
```
registers:
  x0  0000000000000000  x1  0000000000000001
  x2  0000000000000002  x3  0000000000000003
  ...
  pc  0000007f8a123456  sp  0000007f8a987654
```

**Key Registers:**
- **PC (Program Counter):** Current instruction address
- **SP (Stack Pointer):** Stack pointer address
- **General registers:** Function arguments, local variables

#### Memory Map Section

**Memory Map:**
```
memory map:
  0000007f8a000000-0000007f8a100000 r-xp 00000000 00:00 0  /system/lib64/libmylib.so
  0000007f8a100000-0000007f8a200000 r--p 00010000 00:00 0  /system/lib64/libmylib.so
```

**Memory Map Information:**
- **Address ranges:** Memory address ranges
- **Permissions:** Read, write, execute permissions
- **File mapping:** Mapped file/library

### Symbol Resolution

#### Using addr2line

**addr2line Tool:**
```bash
# Resolve address to source location
addr2line -e libmylib.so -f -C 0x12345

# With debug symbols
addr2line -e libmylib.so.debug -f -C 0x12345

# Multiple addresses
addr2line -e libmylib.so -f -C 0x12345 0x67890
```

**Output:**
```
function_name
/path/to/source/file.cpp:123
```

**Options:**
- **-e:** Executable/library file
- **-f:** Show function names
- **-C:** Demangle C++ names
- **-i:** Inline functions

#### Using nm

**nm Tool:**
```bash
# List symbols
nm -D libmylib.so

# Find specific symbol
nm -D libmylib.so | grep function_name

# Show symbol addresses
nm -D -n libmylib.so
```

**Symbol Information:**
- **Function names:** Function symbols
- **Variable names:** Variable symbols
- **Addresses:** Symbol addresses

#### Using objdump

**objdump Tool:**
```bash
# Disassemble function
objdump -d libmylib.so | grep -A 20 function_name

# View symbols
objdump -t libmylib.so

# Disassemble at address
objdump -d libmylib.so --start-address=0x12345 --stop-address=0x12365
```

**Disassembly Output:**
- **Assembly code:** Assembly instructions
- **Addresses:** Instruction addresses
- **Hex dump:** Instruction bytes

### Stack Trace Analysis

#### Reading Stack Traces

**Analysis Process:**
1. Start from frame #00 (crash location)
2. Trace call chain upward
3. Identify problematic function
4. Analyze function context
5. Determine root cause

**Frame Analysis:**
```
#00 pc 0000000000012345  /system/lib64/libmylib.so (crash_function+123)
  → Crash occurred here
  → Check crash_function implementation
  → Analyze function parameters

#01 pc 0000000000056789  /system/lib64/libmylib.so (caller_function+456)
  → Called from caller_function
  → Check how crash_function is called
  → Analyze caller context
```

#### Identifying Crash Location

**Crash Location:**
- Frame #00 is crash location
- PC register shows crash address
- Fault address shows invalid access
- Signal indicates error type

**Crash Location Analysis:**
```bash
# Extract crash address from tombstone
grep "pc " tombstone_00 | head -1

# Resolve to source
addr2line -e libmylib.so -f -C <address>

# Check fault address
grep "Fault addr" tombstone_00
```

#### Call Chain Analysis

**Call Chain:**
- Trace from crash to entry point
- Understand execution flow
- Identify problematic path
- Find root cause

**Call Chain Example:**
```
#00 crash_function()        ← Crash here
#01 caller_function()       ← Called from
#02 main_function()         ← Entry point
```

### Analysis Tools

#### tombstone.py

**Android Tool:**
```bash
# Parse tombstone
tombstone.py tombstone_00

# Extract stack trace
tombstone.py --stack-trace tombstone_00

# Symbolize addresses
tombstone.py --symbols tombstone_00

# Full analysis
tombstone.py --full tombstone_00
```

**Tool Features:**
- Parse tombstone format
- Extract stack traces
- Resolve symbols
- Format output

#### stack Tool

**Stack Tool:**
```bash
# Symbolize stack trace
stack --symbols-dir=/path/to/symbols tombstone_00

# With specific library
stack --symbols-dir=/path/to/symbols --library=libmylib.so tombstone_00
```

**Tool Features:**
- Symbol resolution
- Stack trace formatting
- Library matching

#### ndk-stack

**NDK Stack Tool:**
```bash
# Symbolize stack trace
ndk-stack -sym /path/to/symbols -dump tombstone_00

# Filter by library
ndk-stack -sym /path/to/symbols -dump tombstone_00 | grep libmylib
```

**Tool Features:**
- NDK-specific symbol resolution
- Stack trace formatting
- Library filtering

### Analysis Techniques

#### Signal Analysis

**Signal Types:**
- **SIGSEGV (11):** Segmentation fault
- **SIGABRT (6):** Abort signal
- **SIGBUS (7):** Bus error
- **SIGILL (4):** Illegal instruction

**Signal Code Analysis:**
- **SEGV_MAPERR:** Address not mapped
- **SEGV_ACCERR:** Invalid permissions
- **BUS_ADRALN:** Alignment error

#### Fault Address Analysis

**Fault Address:**
- Shows invalid memory access
- 0x0 indicates null pointer
- Non-zero indicates invalid address
- Check memory map for validity

**Fault Address Analysis:**
```bash
# Extract fault address
grep "Fault addr" tombstone_00

# Check if in memory map
grep -A 50 "memory map" tombstone_00 | grep <fault_address>
```

#### Register Analysis

**Register Analysis:**
- PC register: Crash location
- SP register: Stack pointer
- General registers: Function arguments
- Analyze register values

**Register Analysis Example:**
```
pc  0000007f8a123456  ← Crash at this address
sp  0000007f8a987654  ← Stack pointer
x0  0000000000000000  ← First argument (possibly NULL)
```

### Common Crash Patterns

#### Null Pointer Dereference

**Pattern:**
- Signal: SIGSEGV
- Fault addr: 0x0
- Common in C/C++ code

**Analysis:**
```bash
# Check fault address
grep "Fault addr: 0x0" tombstone_00

# Check register x0 (first argument)
grep "x0 " tombstone_00
```

#### Buffer Overflow

**Pattern:**
- Signal: SIGSEGV
- Fault addr: Non-zero invalid address
- Stack corruption possible

**Analysis:**
- Check stack trace for corruption
- Analyze buffer operations
- Check bounds checking

#### Use-After-Free

**Pattern:**
- Signal: SIGSEGV
- Fault addr: Valid but freed address
- Memory corruption

**Analysis:**
- Check memory allocation/deallocation
- Analyze pointer usage
- Check reference counting

### Analysis Workflow

#### Step-by-Step Analysis

**Analysis Steps:**
1. Read tombstone header
2. Identify crash signal
3. Extract stack trace
4. Resolve symbols
5. Analyze call chain
6. Identify root cause
7. Verify analysis

**Workflow Example:**
```bash
# Step 1: Read header
head -20 tombstone_00

# Step 2: Extract signal
grep "Signal:" tombstone_00

# Step 3: Extract stack trace
grep -A 20 "backtrace:" tombstone_00

# Step 4: Resolve symbols
addr2line -e libmylib.so -f -C <address>

# Step 5: Analyze
# Review resolved symbols
# Check call chain
# Identify root cause
```

### Best Practices

#### Analysis Best Practices

**Best Practices:**
- Start with header information
- Resolve all symbols
- Analyze complete call chain
- Check memory map
- Verify analysis

**Practice Guidelines:**
- **Header First:** Start with header information
- **Symbol Resolution:** Resolve all symbols
- **Complete Analysis:** Analyze complete call chain
- **Memory Map:** Check memory map for context
- **Verification:** Verify analysis with code review

## Key Takeaways

1. **Analyzing tombstones** is the systematic process of examining tombstone files to identify crash causes, understand crash context, resolve symbols, interpret stack traces, and determine root causes of native crashes.

2. **Tombstone structure** includes header section (build fingerprint, ABI, process, PID, signal, fault address), stack trace section (frame numbers, PC addresses, library paths, function names, offsets), register state section (PC, SP, general registers), memory map section (address ranges, permissions, file mappings), and structure components.

3. **Symbol resolution** includes using addr2line (resolve address to source location, with debug symbols, multiple addresses), using nm (list symbols, find specific symbol, show symbol addresses), using objdump (disassemble function, view symbols, disassemble at address), and resolution tools.

4. **Stack trace analysis** includes reading stack traces (start from frame #00, trace call chain upward, identify problematic function), identifying crash location (frame #00 is crash location, PC register shows crash address, fault address shows invalid access), call chain analysis (trace from crash to entry point, understand execution flow, identify problematic path), and analysis techniques.

5. **Analysis tools** include tombstone.py (parse tombstone, extract stack trace, symbolize addresses), stack tool (symbolize stack trace, with specific library), ndk-stack (NDK-specific symbol resolution, stack trace formatting), and tool features.

6. **Analysis techniques** include signal analysis (signal types, signal code analysis), fault address analysis (shows invalid memory access, check memory map for validity), register analysis (PC register crash location, SP register stack pointer, general registers function arguments), and analysis methods.

7. **Common crash patterns** include null pointer dereference (signal SIGSEGV, fault addr 0x0), buffer overflow (signal SIGSEGV, fault addr non-zero invalid address, stack corruption possible), use-after-free (signal SIGSEGV, fault addr valid but freed address, memory corruption), and pattern analysis.

8. **Analysis workflow** includes step-by-step analysis (read tombstone header, identify crash signal, extract stack trace, resolve symbols, analyze call chain, identify root cause, verify analysis), workflow example, and workflow steps.

9. **Understanding analyzing tombstones** is essential for AOSP development, enabling crash understanding, bug fixing, root cause analysis, and proper tombstone analysis.

## Related Topics

- **Debugging native crashes (tombstones):** Native crash debugging details
- **gdbserver for native debugging:** Native debugging details
- **AddressSanitizer, HWASan in Android:** Memory debugging tools

