---
number: 124
title: SurfaceFlinger + HWC interactions
slug: surfaceflinger-hwc-interactions
level: advanced
tags:
  - aosp
  - graphics
  - surfaceflinger
  - hwc
  - hardware-composer
  - composition
  - graphics-pipeline
prerequisites:
  - surfaceflinger-composition-engine
  - gpu-composition
estimated_minutes: 95
contributors: []
diagrams: []
examples: []
canonical_id: aosp-advanced-124
---

# SurfaceFlinger + HWC interactions

## Overview

SurfaceFlinger + HWC interactions refers to how SurfaceFlinger coordinates with the Hardware Composer (HWC) to efficiently composite surfaces. HWC is a hardware composition engine that can handle simple compositions more efficiently than GPU composition, reducing power consumption and improving performance. Understanding SurfaceFlinger + HWC interactions is essential for AOSP development, as it explains how SurfaceFlinger selects composition modes, how HWC is used, how layers are assigned to HWC or GPU, how HWC capabilities are queried, and how the composition pipeline works with HWC. This guide provides a comprehensive overview of SurfaceFlinger + HWC interactions, HWC architecture, composition mode selection, layer assignment, HWC capabilities, and debugging.

Think of SurfaceFlinger + HWC interactions like a smart routing system: just as a routing system chooses the most efficient path (HWC for simple routes, GPU for complex routes), SurfaceFlinger chooses the most efficient composition method (HWC for simple compositions, GPU for complex compositions) based on layer complexity and HWC capabilities.

## Deep Explanation

### What are SurfaceFlinger + HWC Interactions?

SurfaceFlinger + HWC interactions refers to how SurfaceFlinger coordinates with the Hardware Composer (HWC) to efficiently composite surfaces. HWC is a hardware composition engine that can handle simple compositions more efficiently than GPU composition, and SurfaceFlinger dynamically selects between HWC and GPU composition based on layer complexity and HWC capabilities.

**Key Characteristics:**
- **Dynamic Selection:** SurfaceFlinger selects composition mode
- **HWC Preference:** HWC preferred for simple compositions
- **GPU Fallback:** GPU used for complex compositions
- **Capability Query:** Queries HWC capabilities
- **Layer Assignment:** Assigns layers to HWC or GPU

**Why SurfaceFlinger + HWC Interactions?**
- **Efficiency:** HWC more efficient for simple compositions
- **Power:** Lower power consumption with HWC
- **Performance:** Better performance for simple scenes
- **Flexibility:** GPU fallback for complex scenes

### HWC Architecture

#### HWC Overview

**HWC (Hardware Composer):**
- Hardware composition engine
- Part of display hardware
- Handles simple compositions
- More efficient than GPU

**HWC Characteristics:**
- **Hardware-Based:** Uses display hardware
- **Efficient:** Very efficient composition
- **Low Power:** Lower power consumption
- **Limited:** Limited to simple compositions

#### HWC Interface

**HWC Interface:**
- HWC HAL interface
- Query capabilities
- Set composition layers
- Execute composition

**HWC Interface Example:**
```cpp
// HWC interface
class IComposer {
    virtual int32_t getCapabilities(uint32_t* outCapabilities) = 0;
    virtual int32_t createLayer(uint64_t display, 
                                uint32_t* outLayer) = 0;
    virtual int32_t setLayerCompositionType(uint64_t display,
                                            uint32_t layer,
                                            int32_t type) = 0;
    virtual int32_t validateDisplay(uint64_t display,
                                     uint32_t* outNumTypes,
                                     uint32_t* outNumRequests) = 0;
    virtual int32_t presentDisplay(uint64_t display,
                                    int32_t* outPresentFence) = 0;
};
```

### Composition Mode Selection

#### Selection Process

**Selection Process:**
```
1. SurfaceFlinger collects layers
2. SurfaceFlinger queries HWC capabilities
3. SurfaceFlinger attempts HWC composition
4. HWC validates composition
5. If HWC accepts: Use HWC
6. If HWC rejects: Use GPU
```

**Selection Flow:**
```cpp
// Composition mode selection
CompositionType selectCompositionMode() {
    // Query HWC capabilities
    HwcCapabilities capabilities = queryHWCCapabilities();
    
    // Attempt HWC composition
    HwcCompositionResult result = attemptHWCComposition();
    
    if (result.canCompose) {
        return HWC_COMPOSITION;
    } else {
        return GPU_COMPOSITION;
    }
}
```

#### Selection Criteria

**Selection Criteria:**
- **Layer Complexity:** Simple layers → HWC
- **Layer Count:** Few layers → HWC
- **Effects:** No effects → HWC
- **Transformations:** Simple transformations → HWC
- **HWC Capabilities:** HWC supports → HWC

**Criteria Evaluation:**
```cpp
// Evaluate composition criteria
bool canUseHWC(Layer* layer) {
    // Check layer complexity
    if (layer->isComplex()) {
        return false;
    }
    
    // Check effects
    if (layer->hasEffects()) {
        return false;
    }
    
    // Check transformations
    if (layer->hasComplexTransform()) {
        return false;
    }
    
    // Check HWC capabilities
    if (!hwcSupportsLayer(layer)) {
        return false;
    }
    
    return true;
}
```

### Layer Assignment

#### Layer Assignment Process

**Layer Assignment:**
- Assign layers to HWC or GPU
- Based on layer properties
- Based on HWC capabilities
- Optimize assignment

**Assignment Process:**
```cpp
// Assign layers
void assignLayers() {
    mHWCLayers.clear();
    mGPULayers.clear();
    
    for (auto& layer : mLayers) {
        if (canUseHWC(layer)) {
            mHWCLayers.push_back(layer);
            layer->setCompositionType(HWC_COMPOSITION);
        } else {
            mGPULayers.push_back(layer);
            layer->setCompositionType(GPU_COMPOSITION);
        }
    }
}
```

#### Mixed Composition

**Mixed Composition:**
- Some layers use HWC
- Some layers use GPU
- Layers composited separately
- Final composition combines both

**Mixed Composition Process:**
```
1. Assign layers to HWC or GPU
2. HWC layers composited by HWC
3. GPU layers composited by GPU
4. Final composition combines results
```

### HWC Capabilities

#### Capability Query

**HWC Capabilities:**
- Query HWC capabilities
- Check supported features
- Determine composition limits
- Plan composition strategy

**Capability Query:**
```cpp
// Query HWC capabilities
HwcCapabilities queryHWCCapabilities() {
    HwcCapabilities caps;
    
    // Query capabilities
    hwc->getCapabilities(&caps);
    
    // Check features
    caps.supportsBlending = checkBlendingSupport();
    caps.supportsScaling = checkScalingSupport();
    caps.maxLayers = getMaxLayers();
    
    return caps;
}
```

#### Supported Features

**Supported Features:**
- **Blending:** Alpha blending support
- **Scaling:** Layer scaling support
- **Rotation:** Layer rotation support
- **Color Space:** Color space conversion
- **Layer Count:** Maximum layer count

### HWC Composition

#### HWC Composition Process

**HWC Composition Process:**
```
1. SurfaceFlinger prepares layers
2. SurfaceFlinger calls HWC validate
3. HWC validates composition
4. HWC accepts or rejects layers
5. SurfaceFlinger sets layer types
6. HWC executes composition
7. HWC presents frame
```

**Composition Execution:**
```cpp
// HWC composition
void executeHWCComposition() {
    // Validate display
    uint32_t numTypes, numRequests;
    hwc->validateDisplay(mDisplayId, &numTypes, &numRequests);
    
    // Set layer composition types
    for (auto& layer : mHWCLayers) {
        hwc->setLayerCompositionType(mDisplayId, 
                                     layer->getId(),
                                     HWC2_COMPOSITION_DEVICE);
    }
    
    // Present display
    int32_t presentFence;
    hwc->presentDisplay(mDisplayId, &presentFence);
}
```

#### HWC Layer Types

**HWC Layer Types:**
- **DEVICE:** Composed by HWC
- **CLIENT:** Composed by GPU
- **SOLID_COLOR:** Solid color layer
- **CURSOR:** Cursor layer

**Layer Type Assignment:**
```cpp
// Assign layer type
void assignLayerType(Layer* layer) {
    if (canUseHWC(layer)) {
        layer->setCompositionType(HWC2_COMPOSITION_DEVICE);
    } else {
        layer->setCompositionType(HWC2_COMPOSITION_CLIENT);
    }
}
```

### HWC Validation

#### Validation Process

**HWC Validation:**
- HWC validates composition
- Checks layer compatibility
- Determines composition feasibility
- Returns validation result

**Validation Flow:**
```cpp
// HWC validation
HwcValidationResult validateComposition() {
    uint32_t numTypes, numRequests;
    
    // Validate display
    int32_t error = hwc->validateDisplay(mDisplayId, 
                                         &numTypes, 
                                         &numRequests);
    
    if (error == HWC2_ERROR_NONE) {
        return VALIDATION_SUCCESS;
    } else if (error == HWC2_ERROR_HAS_CHANGES) {
        return VALIDATION_CHANGES_NEEDED;
    } else {
        return VALIDATION_FAILED;
    }
}
```

#### Validation Results

**Validation Results:**
- **SUCCESS:** All layers accepted
- **CHANGES_NEEDED:** Some layers need changes
- **FAILED:** Composition not possible

**Handling Validation Results:**
```cpp
// Handle validation results
void handleValidationResult(HwcValidationResult result) {
    switch (result) {
        case VALIDATION_SUCCESS:
            // All layers accepted, use HWC
            useHWCComposition();
            break;
            
        case VALIDATION_CHANGES_NEEDED:
            // Some layers need changes
            adjustLayersForHWC();
            break;
            
        case VALIDATION_FAILED:
            // Use GPU composition
            useGPUComposition();
            break;
    }
}
```

### Performance Considerations

#### HWC Benefits

**HWC Benefits:**
- **Efficiency:** Very efficient composition
- **Power:** Lower power consumption
- **Performance:** Excellent for simple scenes
- **Hardware:** Hardware-optimized

#### GPU Benefits

**GPU Benefits:**
- **Flexibility:** Handles complex compositions
- **Effects:** Supports various effects
- **Compatibility:** Works on all devices
- **Complexity:** Handles complex layers

### Debugging SurfaceFlinger + HWC

#### Debugging Tools

**Debugging Tools:**
- SurfaceFlinger dumps
- HWC state inspection
- Composition mode analysis
- Performance profiling

**Debugging Commands:**
```bash
# Dump SurfaceFlinger state
adb shell dumpsys SurfaceFlinger

# Check HWC composition
adb shell dumpsys SurfaceFlinger | grep HWC

# Check layer composition types
adb shell dumpsys SurfaceFlinger | grep "Composition"

# HWC debugging
adb shell setprop debug.hwc.log 1
```

#### Common Issues

**Common Issues:**
- HWC not used when expected
- Composition mode switching
- HWC validation failures
- Performance issues

**Debugging Steps:**
1. Check HWC capabilities
2. Verify layer assignment
3. Review validation results
4. Check composition mode
5. Profile performance

## Key Takeaways

1. **SurfaceFlinger + HWC interactions** refers to how SurfaceFlinger coordinates with the Hardware Composer (HWC) to efficiently composite surfaces, with HWC handling simple compositions and GPU handling complex compositions.

2. **HWC architecture** includes HWC overview (hardware composition engine, part of display hardware), HWC interface (HWC HAL interface, query capabilities, set layers, execute composition), and HWC characteristics (hardware-based, efficient, low power, limited).

3. **Composition mode selection** includes selection process (collect layers, query HWC, attempt HWC, validate, select mode), selection criteria (layer complexity, layer count, effects, transformations, HWC capabilities), and selection logic (HWC preferred, GPU fallback).

4. **Layer assignment** includes layer assignment process (assign layers to HWC or GPU based on properties and capabilities), mixed composition (some layers HWC, some GPU, combined result), and assignment optimization.

5. **HWC capabilities** include capability query (query HWC capabilities, check supported features), supported features (blending, scaling, rotation, color space, layer count), and capability usage (plan composition strategy based on capabilities).

6. **HWC composition** includes HWC composition process (prepare layers, validate, set types, execute, present), composition execution (validate display, set layer types, present display), and HWC layer types (DEVICE, CLIENT, SOLID_COLOR, CURSOR).

7. **HWC validation** includes validation process (HWC validates composition, checks compatibility, determines feasibility), validation results (SUCCESS, CHANGES_NEEDED, FAILED), and handling validation results (use HWC, adjust layers, use GPU).

8. **Performance considerations** include HWC benefits (efficiency, power, performance, hardware-optimized), GPU benefits (flexibility, effects, compatibility, complexity), and performance optimization (select optimal mode, optimize layer assignment).

9. **Understanding SurfaceFlinger + HWC interactions** is essential for AOSP development, enabling efficient composition, power optimization, performance improvement, and optimal graphics pipeline operation.

## Related Topics

- **SurfaceFlinger (composition engine):** Composition engine coordinating with HWC
- **GPU composition:** GPU-based composition alternative
- **HWUI:** Hardware-accelerated UI rendering
- **Skia:** 2D graphics library

