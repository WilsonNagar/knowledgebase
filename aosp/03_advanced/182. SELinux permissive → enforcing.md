---
number: 182
title: SELinux permissive → enforcing
slug: selinux-permissive-to-enforcing
level: advanced
tags:
  - aosp
  - selinux
  - permissive
  - enforcing
  - security
  - policy-development
prerequisites:
  - selinux-overview
  - selinux-policy-initialization
  - adding-custom-selinux-rules
estimated_minutes: 95
contributors: []
diagrams: []
examples: []
canonical_id: aosp-advanced-182
---

# SELinux permissive → enforcing

## Overview

SELinux permissive → enforcing refers to the process of transitioning a device or system from SELinux permissive mode (where violations are logged but allowed) to enforcing mode (where violations are denied and security is fully enforced). Understanding this transition is essential for AOSP development, as it explains how to develop and test SELinux policies in permissive mode, how to identify and fix policy violations, how to transition to enforcing mode, and how to ensure system security. This guide provides a comprehensive overview of SELinux permissive → enforcing transition, permissive mode usage, violation identification, policy development, transition process, and enforcement verification.

Think of SELinux permissive → enforcing like training wheels on a bicycle: just as you start with training wheels (permissive mode) where mistakes are allowed but logged, then remove them (enforcing mode) once you've learned to ride properly, SELinux starts in permissive mode during development to identify and fix policy issues, then transitions to enforcing mode for production security once all policies are correct.

## Deep Explanation

### What is SELinux Permissive → Enforcing?

SELinux permissive → enforcing refers to the process of transitioning a device or system from SELinux permissive mode (where violations are logged but allowed) to enforcing mode (where violations are denied and security is fully enforced).

**Key Characteristics:**
- **Development Phase:** Permissive mode for development
- **Policy Development:** Develop and test policies
- **Violation Identification:** Identify policy violations
- **Policy Fixing:** Fix policy issues
- **Production Phase:** Enforcing mode for security

**Why Permissive → Enforcing?**
- **Policy Development:** Develop policies safely
- **Violation Detection:** Identify all violations
- **Policy Testing:** Test policies thoroughly
- **Security:** Enable full security enforcement
- **Production:** Production-ready security

### Permissive Mode

#### Permissive Mode Characteristics

**Permissive Mode:**
- Violations logged but allowed
- Development and debugging
- Policy testing
- Violation identification
- No security enforcement

**Mode Characteristics:**
- Logging enabled
- Enforcement disabled
- Development tool
- Testing support
- Debugging aid

#### Using Permissive Mode

**Permissive Mode Usage:**
```bash
# Set permissive mode
setenforce 0

# Check mode
getenforce
# Returns: Permissive

# Or in kernel command line
androidboot.selinux=permissive
```

**Usage Characteristics:**
- Runtime setting
- Kernel parameter
- Development mode
- Testing mode
- Debugging mode

### Violation Identification

#### Violation Logging

**Violation Logs:**
- AVC (Access Vector Cache) denials
- Logged to logcat
- Logged to dmesg
- Detailed violation information
- Policy violation details

**Log Analysis:**
```bash
# View AVC denials
adb logcat | grep avc

# View kernel denials
adb shell dmesg | grep avc

# Detailed violation info
adb shell dmesg | grep "avc: denied"
```

**Log Characteristics:**
- Detailed violation info
- Source and target
- Permission requested
- Context information
- Policy information

#### Violation Analysis

**Violation Information:**
```
avc: denied { read } for pid=1234 comm="app" 
scontext=u:r:untrusted_app:s0 
tcontext=u:object_r:system_file:s0 
tclass=file permissive=1
```

**Violation Components:**
- **Permission:** `read` (denied permission)
- **Source Context:** `untrusted_app` (process context)
- **Target Context:** `system_file` (file context)
- **Object Class:** `file` (object type)
- **Permissive:** `1` (permissive mode)

**Analysis Process:**
- Parse violation logs
- Identify source and target
- Determine required permission
- Understand violation cause
- Plan policy fix

### Policy Development

#### Policy Rule Creation

**Rule Development:**
```
# Identify violation
avc: denied { read } for scontext=untrusted_app tcontext=system_file

# Create allow rule
allow untrusted_app system_file:file read;
```

**Development Process:**
```
1. Identify violation
2. Analyze violation
3. Determine if access should be allowed
4. Create policy rule
5. Test policy rule
6. Verify fix
```

**Development Characteristics:**
- Violation-driven development
- Incremental policy building
- Testing and verification
- Policy refinement
- Security consideration

#### Policy File Updates

**Policy Updates:**
```te
# In policy file (e.g., untrusted_app.te)
# Allow untrusted_app to read system files
allow untrusted_app system_file:file { read };
```

**Update Process:**
- Edit policy source files
- Add allow rules
- Compile policy
- Test policy
- Verify enforcement

**Update Characteristics:**
- Source file editing
- Rule addition
- Policy compilation
- Testing
- Verification

### Transition Process

#### Pre-Transition Checklist

**Checklist Items:**
- All violations identified
- All violations analyzed
- Policy rules created
- Policy rules tested
- No critical violations remaining

**Checklist Process:**
```
1. Run system in permissive mode
2. Exercise all functionality
3. Collect all violations
4. Analyze violations
5. Fix all violations
6. Test fixes
7. Verify no new violations
```

**Checklist Characteristics:**
- Comprehensive testing
- Violation collection
- Policy fixing
- Testing and verification
- Transition readiness

#### Transition Steps

**Transition Process:**
```
1. Ensure all violations fixed
2. Test system thoroughly
3. Set enforcing mode
4. Test system again
5. Monitor for violations
6. Fix any remaining issues
```

**Transition Methods:**
```bash
# Runtime transition
setenforce 1

# Boot-time transition (in init.rc)
setenforce 1

# Kernel parameter
androidboot.selinux=enforcing
```

**Transition Characteristics:**
- Gradual transition
- Testing at each step
- Violation monitoring
- Issue resolution
- Security enforcement

### Enforcement Verification

#### Verification Methods

**Verification Steps:**
```bash
# Check current mode
getenforce
# Should return: Enforcing

# Check detailed status
sestatus

# Monitor for violations
adb logcat | grep avc
# Should show no new violations

# Test system functionality
# All features should work
```

**Verification Characteristics:**
- Mode verification
- Status checking
- Violation monitoring
- Functionality testing
- Security verification

#### Violation Monitoring

**Monitoring Process:**
- Monitor logcat for AVC denials
- Monitor dmesg for kernel denials
- Test all system features
- Verify no access denied errors
- Check system stability

**Monitoring Characteristics:**
- Continuous monitoring
- Violation detection
- Feature testing
- Error checking
- Stability verification

### Policy Testing

#### Testing Strategy

**Testing Approach:**
- Test in permissive mode first
- Identify all violations
- Fix violations
- Test fixes
- Transition to enforcing
- Test in enforcing mode

**Testing Characteristics:**
- Permissive testing
- Violation identification
- Fix verification
- Enforcing testing
- Comprehensive testing

#### Testing Scenarios

**Test Scenarios:**
- Normal operation
- Edge cases
- Error conditions
- All system features
- All user workflows

**Scenario Testing:**
- Comprehensive coverage
- Edge case testing
- Error handling
- Feature testing
- Workflow testing

### Common Issues

#### Transition Issues

**Common Problems:**
- System not booting
- Services not starting
- Features not working
- Access denied errors
- System instability

**Issue Resolution:**
- Check violation logs
- Identify missing rules
- Add required rules
- Test fixes
- Verify resolution

#### Policy Issues

**Policy Problems:**
- Missing allow rules
- Incorrect contexts
- Wrong permissions
- Policy conflicts
- Incomplete policies

**Problem Resolution:**
- Analyze violations
- Fix policy rules
- Update contexts
- Resolve conflicts
- Complete policies

### Transition Best Practices

#### Best Practices

**Best Practices:**
- Develop in permissive mode
- Fix all violations
- Test thoroughly
- Transition gradually
- Monitor after transition

**Practice Guidelines:**
- **Development:** Develop in permissive mode
- **Fixing:** Fix all violations
- **Testing:** Test thoroughly
- **Transition:** Transition gradually
- **Monitoring:** Monitor after transition

## Key Takeaways

1. **SELinux permissive → enforcing** refers to the process of transitioning a device or system from SELinux permissive mode (where violations are logged but allowed) to enforcing mode (where violations are denied and security is fully enforced).

2. **Permissive mode** includes permissive mode characteristics (violations logged but allowed, development and debugging, policy testing, violation identification, no security enforcement), using permissive mode (runtime setting, kernel parameter, development mode, testing mode, debugging mode), and mode characteristics.

3. **Violation identification** includes violation logging (AVC denials, logged to logcat, logged to dmesg, detailed violation information, policy violation details), violation analysis (parse violation logs, identify source and target, determine required permission, understand violation cause, plan policy fix), and identification characteristics.

4. **Policy development** includes policy rule creation (identify violation, analyze violation, determine if access should be allowed, create policy rule, test policy rule, verify fix), policy file updates (edit policy source files, add allow rules, compile policy, test policy, verify enforcement), and development characteristics.

5. **Transition process** includes pre-transition checklist (all violations identified, all violations analyzed, policy rules created, policy rules tested, no critical violations remaining), transition steps (ensure all violations fixed, test system thoroughly, set enforcing mode, test system again, monitor for violations, fix any remaining issues), and transition characteristics.

6. **Enforcement verification** includes verification methods (mode verification, status checking, violation monitoring, functionality testing, security verification), violation monitoring (monitor logcat for AVC denials, monitor dmesg for kernel denials, test all system features, verify no access denied errors, check system stability), and verification characteristics.

7. **Policy testing** includes testing strategy (test in permissive mode first, identify all violations, fix violations, test fixes, transition to enforcing, test in enforcing mode), testing scenarios (normal operation, edge cases, error conditions, all system features, all user workflows), and testing characteristics.

8. **Understanding SELinux permissive → enforcing** is essential for AOSP development, enabling policy development, violation identification, policy testing, security enforcement, and proper SELinux implementation.

## Related Topics

- **SELinux Overview:** SELinux details
- **SELinux policy initialization:** Policy initialization details
- **Adding custom SELinux rules:** Custom rules details

