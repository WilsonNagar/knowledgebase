---
number: 123
title: GPU composition
slug: gpu-composition
level: advanced
tags:
  - aosp
  - graphics
  - gpu
  - composition
  - rendering
  - surfaceflinger
  - graphics-pipeline
prerequisites:
  - surfaceflinger-composition-engine
  - hwui
  - skia
estimated_minutes: 95
contributors: []
diagrams: []
examples: []
canonical_id: aosp-advanced-123
---

# GPU composition

## Overview

GPU composition is a composition mode used by SurfaceFlinger that utilizes the GPU (Graphics Processing Unit) to composite multiple surfaces into a single frame. GPU composition uses OpenGL ES to blend layers, apply transformations, and render the final frame. Understanding GPU composition is essential for AOSP development, as it explains how the GPU is used for composition, how layers are blended, how transformations are applied, how GPU composition compares to HWC, and how GPU composition integrates with the graphics pipeline. This guide provides a comprehensive overview of GPU composition, architecture, composition process, layer blending, transformations, performance considerations, and debugging.

Think of GPU composition like a digital compositor: just as a digital compositor combines multiple image layers using software tools, GPU composition combines multiple surface layers using GPU hardware, providing flexible and powerful composition capabilities.

## Deep Explanation

### What is GPU Composition?

GPU composition is a composition mode used by SurfaceFlinger that utilizes the GPU to composite multiple surfaces into a single frame. GPU composition uses OpenGL ES to blend layers, apply transformations, handle transparency, and render the final frame to the display.

**Key Characteristics:**
- **GPU-Based:** Uses GPU for composition
- **OpenGL ES:** Uses OpenGL ES for rendering
- **Flexible:** Handles complex compositions
- **Hardware Accelerated:** Hardware-accelerated composition
- **Default Mode:** Default composition mode when HWC unavailable

**Why GPU Composition?**
- **Flexibility:** Handles complex compositions
- **Effects:** Supports various graphics effects
- **Compatibility:** Works on all devices
- **Performance:** Hardware-accelerated composition

### GPU Composition Architecture

#### Composition Pipeline

**GPU Composition Pipeline:**
```
Surfaces → Layer Sorting → GPU Composition (OpenGL ES) → 
Frame Buffer → Display
```

**Pipeline Stages:**
1. **Layer Collection:** Collect surfaces to composite
2. **Layer Sorting:** Sort layers by Z-order
3. **GPU Composition:** Composite layers using GPU
4. **Frame Output:** Output final frame to display

#### OpenGL ES Backend

**OpenGL ES Backend:**
- Uses OpenGL ES for GPU operations
- Manages OpenGL context
- Handles OpenGL state
- Performs OpenGL rendering

**OpenGL ES Integration:**
- **Context Management:** Manage OpenGL context
- **State Management:** Manage OpenGL state
- **Rendering:** Perform OpenGL rendering
- **Buffer Management:** Manage OpenGL buffers

### Composition Process

#### Layer Collection

**Layer Collection:**
- Collect all surfaces to composite
- Gather layer information
- Prepare for composition
- Validate layer data

**Collection Process:**
```cpp
// Collect layers for composition
void collectLayersForComposition() {
    mLayers.clear();
    
    // Collect all active layers
    for (auto& layer : mActiveLayers) {
        if (layer->isVisible() && layer->hasBuffer()) {
            mLayers.push_back(layer);
        }
    }
    
    // Sort by Z-order
    std::sort(mLayers.begin(), mLayers.end(), 
              [](const Layer* a, const Layer* b) {
                  return a->getZOrder() < b->getZOrder();
              });
}
```

#### Layer Sorting

**Layer Sorting:**
- Sort layers by Z-order
- Bottom layer first
- Top layer last
- Maintain composition order

**Sorting Criteria:**
- **Z-Order:** Primary sorting criterion
- **Layer Type:** Secondary sorting
- **Visibility:** Only visible layers
- **Buffer Availability:** Only layers with buffers

### GPU Rendering

#### OpenGL ES Setup

**OpenGL ES Setup:**
- Initialize OpenGL context
- Set up OpenGL state
- Configure rendering parameters
- Prepare for composition

**Setup Process:**
```cpp
// OpenGL ES setup
void setupOpenGLES() {
    // Enable blending
    glEnable(GL_BLEND);
    glBlendFunc(GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
    
    // Set viewport
    glViewport(0, 0, mDisplayWidth, mDisplayHeight);
    
    // Clear framebuffer
    glClearColor(0.0f, 0.0f, 0.0f, 1.0f);
    glClear(GL_COLOR_BUFFER_BIT);
}
```

#### Layer Blending

**Layer Blending:**
- Blend layers from bottom to top
- Apply alpha blending
- Handle transparency
- Combine layer colors

**Blending Process:**
```cpp
// Blend layers
void blendLayers() {
    for (auto& layer : mLayers) {
        // Bind layer texture
        glBindTexture(GL_TEXTURE_2D, layer->getTexture());
        
        // Set transformation
        setLayerTransform(layer);
        
        // Set blend mode
        setBlendMode(layer->getBlendMode());
        
        // Draw layer
        drawLayerQuad(layer);
    }
}
```

#### Transformation Application

**Transformations:**
- Translation
- Rotation
- Scaling
- Skewing

**Transformation Application:**
```cpp
// Apply transformation
void setLayerTransform(Layer* layer) {
    // Get transformation matrix
    mat4 transform = layer->getTransform();
    
    // Set model matrix
    glUniformMatrix4fv(mModelMatrixLoc, 1, GL_FALSE, 
                       transform.data());
}
```

### Composition Techniques

#### Alpha Blending

**Alpha Blending:**
- Blend layers with transparency
- Handle alpha channel
- Support various blend modes
- Efficient GPU blending

**Blend Modes:**
- **Normal:** Standard alpha blending
- **Multiply:** Multiply blend
- **Screen:** Screen blend
- **Overlay:** Overlay blend

#### Layer Effects

**Layer Effects:**
- Shadows
- Blur
- Color filters
- Gradients

**Effect Application:**
```cpp
// Apply layer effects
void applyLayerEffects(Layer* layer) {
    if (layer->hasShadow()) {
        renderShadow(layer);
    }
    
    if (layer->hasBlur()) {
        applyBlur(layer);
    }
    
    if (layer->hasColorFilter()) {
        applyColorFilter(layer);
    }
}
```

### Performance Optimization

#### Rendering Optimization

**Optimization Techniques:**
- **Layer Caching:** Cache rendered layers
- **Dirty Region Tracking:** Only render changed regions
- **Occlusion Culling:** Skip hidden layers
- **Batch Operations:** Batch similar operations

**Optimization Example:**
```cpp
// Optimized composition
void optimizedComposition() {
    // Only composite dirty regions
    for (auto& region : mDirtyRegions) {
        compositeRegion(region);
    }
    
    // Skip occluded layers
    for (auto& layer : mLayers) {
        if (!isOccluded(layer)) {
            compositeLayer(layer);
        }
    }
}
```

#### Memory Management

**Memory Management:**
- Efficient buffer usage
- Reuse textures when possible
- Minimize memory allocations
- Proper cleanup

**Memory Optimization:**
```cpp
// Memory-efficient composition
class CompositionBufferPool {
    std::vector<GLuint> mTextures;
    
    GLuint acquireTexture() {
        if (!mTextures.empty()) {
            GLuint texture = mTextures.back();
            mTextures.pop_back();
            return texture;
        }
        return createTexture();
    }
    
    void releaseTexture(GLuint texture) {
        mTextures.push_back(texture);
    }
};
```

### GPU vs HWC

#### Comparison

**GPU Composition:**
- **Flexibility:** Handles complex compositions
- **Effects:** Supports various effects
- **Compatibility:** Works on all devices
- **Power:** Higher power consumption
- **Performance:** Good for complex scenes

**HWC Composition:**
- **Efficiency:** Very efficient
- **Power:** Lower power consumption
- **Performance:** Excellent for simple scenes
- **Limitations:** Limited to simple compositions
- **Hardware:** Requires hardware support

#### Selection Criteria

**Selection Criteria:**
- **Layer Complexity:** Complex layers → GPU
- **Effects:** Effects required → GPU
- **Power:** Power sensitive → HWC
- **Performance:** Simple scenes → HWC
- **Compatibility:** No HWC → GPU

**Selection Logic:**
```cpp
// Select composition mode
CompositionType selectCompositionType() {
    // Check if HWC can handle
    if (canUseHWC()) {
        return HWC_COMPOSITION;
    }
    
    // Use GPU composition
    return GPU_COMPOSITION;
}
```

### Frame Timing

#### Composition Timing

**Composition Timing:**
- **Target Time:** < 6ms per frame
- **VSync Period:** 16.67ms (60Hz)
- **Frame Budget:** Must complete within VSync period
- **Frame Drop:** If exceeds VSync period

**Timing Management:**
```cpp
// Composition timing
void composeFrame() {
    nsecs_t startTime = systemTime();
    
    // Perform composition
    performGPUComposition();
    
    nsecs_t compositionTime = systemTime() - startTime;
    
    // Check timing
    if (compositionTime > mVSyncPeriod) {
        // Frame drop
        dropFrame();
    }
}
```

### Debugging GPU Composition

#### Debugging Tools

**Debugging Tools:**
- SurfaceFlinger dumps
- OpenGL debugging
- Performance profiling
- Frame timing analysis

**Debugging Commands:**
```bash
# Dump SurfaceFlinger state
adb shell dumpsys SurfaceFlinger

# Check composition mode
adb shell dumpsys SurfaceFlinger | grep "Composition"

# OpenGL debugging
adb shell setprop debug.egl.trace 1

# Performance profiling
adb shell dumpsys gfxinfo
```

#### Common Issues

**Common Issues:**
- Slow composition
- Frame drops
- OpenGL errors
- Memory issues
- Power consumption

**Debugging Steps:**
1. Check composition timing
2. Verify OpenGL state
3. Profile GPU usage
4. Check memory usage
5. Review layer complexity

## Key Takeaways

1. **GPU composition** is a composition mode used by SurfaceFlinger that utilizes the GPU to composite multiple surfaces into a single frame using OpenGL ES.

2. **GPU composition architecture** includes composition pipeline (layer collection, sorting, GPU composition, frame output), OpenGL ES backend (uses OpenGL ES, manages context, handles state), and composition process.

3. **Composition process** includes layer collection (collect surfaces, gather information, prepare for composition), layer sorting (sort by Z-order, bottom to top), and GPU rendering (OpenGL ES setup, layer blending, transformation application).

4. **GPU rendering** includes OpenGL ES setup (initialize context, set up state, configure parameters), layer blending (blend layers, apply alpha, handle transparency), and transformation application (translation, rotation, scaling, skewing).

5. **Composition techniques** include alpha blending (blend layers with transparency, handle alpha channel, support blend modes), layer effects (shadows, blur, color filters, gradients), and effect application.

6. **Performance optimization** includes rendering optimization (layer caching, dirty region tracking, occlusion culling, batch operations), memory management (efficient buffer usage, texture reuse, minimize allocations), and optimization techniques.

7. **GPU vs HWC** includes comparison (GPU: flexible, effects, compatibility; HWC: efficient, lower power, limited), selection criteria (layer complexity, effects, power, performance, compatibility), and selection logic (check HWC capability, use GPU as fallback).

8. **Frame timing** includes composition timing (target < 6ms, VSync period 16.67ms, frame budget, frame drop handling), and timing management (measure composition time, check timing, handle frame drops).

9. **Understanding GPU composition** is essential for AOSP development, enabling flexible composition, complex effects, hardware-accelerated rendering, and optimal graphics performance.

## Related Topics

- **SurfaceFlinger (composition engine):** Composition engine using GPU composition
- **HWUI:** Hardware-accelerated UI rendering
- **Skia:** 2D graphics library
- **SurfaceFlinger + HWC interactions:** HWC composition alternative

