---
number: 163
title: Adding custom tiles
slug: adding-custom-tiles
level: advanced
tags:
  - aosp
  - systemui
  - quick-settings
  - custom-tiles
  - tile-implementation
prerequisites:
  - quick-settings-architecture
  - customizing-systemui-oem-customizations
  - systemui-architecture
estimated_minutes: 95
contributors: []
diagrams: []
examples: []
canonical_id: aosp-advanced-163
---

# Adding custom tiles

## Overview

Adding custom tiles involves creating and implementing custom quick settings tiles for SystemUI, including tile class implementation, tile state management, tile UI design, tile registration, and tile integration with system services. Custom tiles allow developers and OEMs to add quick access to custom features, OEM-specific functionality, or brand-specific controls. Understanding how to add custom tiles is essential for AOSP development, as it explains how to create custom tiles, how to implement tile functionality, how to register tiles, how to manage tile state, and how to integrate tiles with system services. This guide provides a comprehensive overview of adding custom tiles, tile implementation, tile registration, state management, UI design, and integration.

Think of adding custom tiles like adding custom buttons to a control panel: just as you can add custom buttons to a control panel (custom tile) that control specific systems (custom functionality), connect to those systems (system service integration), and provide visual feedback (tile state), custom tiles allow you to add custom buttons to the quick settings panel that control custom features, connect to system services, and display state information.

## Deep Explanation

### What is Adding Custom Tiles?

Adding custom tiles involves creating and implementing custom quick settings tiles for SystemUI, including tile class implementation, tile state management, tile UI design, tile registration, and tile integration with system services. Custom tiles extend the quick settings system with additional functionality.

**Key Characteristics:**
- **Custom Implementation:** Custom tile implementation
- **Quick Settings Integration:** Integrated with quick settings
- **System Service Integration:** Can integrate with system services
- **User Interaction:** User interaction handling
- **State Management:** Dynamic state management

**Why Add Custom Tiles?**
- **Custom Features:** Add custom features
- **OEM Functionality:** OEM-specific functionality
- **Brand Features:** Brand-specific controls
- **User Experience:** Enhanced user experience

### Tile Implementation

#### Tile Class Structure

**Tile Class:**
- Extend QSTile base class
- Implement tile logic
- Define tile state
- Handle interactions

**Basic Tile Structure:**
```java
public class CustomTile extends QSTile<BooleanState> {
    private final CustomTileHost mHost;
    
    public CustomTile(QSHost host) {
        super(host);
        mHost = (CustomTileHost) host;
    }
    
    @Override
    protected void handleClick() {
        // Handle tile click
    }
    
    @Override
    protected void handleUpdateState(BooleanState state, Object arg) {
        // Update tile state
    }
}
```

#### Tile State Types

**State Types:**
- **BooleanState:** On/off state
- **SignalState:** Signal strength state
- **ResourceIconState:** Icon resource state
- **Custom State:** Custom state types

**State Selection:**
- Choose appropriate state type
- Match state to functionality
- Define state properties
- Implement state updates

### Tile Implementation Details

#### Toggle Tile Implementation

**Toggle Tile:**
```java
public class CustomToggleTile extends QSTile<BooleanState> {
    private boolean mEnabled = false;
    
    public CustomToggleTile(QSHost host) {
        super(host);
    }
    
    @Override
    protected void handleClick() {
        mEnabled = !mEnabled;
        // Toggle feature
        toggleCustomFeature(mEnabled);
        refreshState();
    }
    
    @Override
    protected void handleUpdateState(BooleanState state, Object arg) {
        state.value = mEnabled;
        state.label = "Custom Feature";
        state.icon = ResourceIcon.get(R.drawable.ic_custom_tile);
        state.contentDescription = "Custom Feature";
    }
    
    @Override
    public int getMetricsCategory() {
        return MetricsEvent.QS_CUSTOM_TILE;
    }
}
```

#### State Tile Implementation

**State Tile:**
```java
public class CustomStateTile extends QSTile<SignalState> {
    private int mState = 0;
    
    public CustomStateTile(QSHost host) {
        super(host);
    }
    
    @Override
    protected void handleClick() {
        // Handle click
        performAction();
    }
    
    @Override
    protected void handleUpdateState(SignalState state, Object arg) {
        state.value = mState;
        state.label = "Custom State";
        state.icon = ResourceIcon.get(R.drawable.ic_custom_state);
        state.contentDescription = "Custom State: " + mState;
    }
}
```

### Tile Registration

#### Tile Factory Registration

**Factory Registration:**
```java
public class CustomTileFactory implements QSTileFactory {
    @Override
    public QSTile createTile(String tileSpec) {
        if ("custom".equals(tileSpec)) {
            return new CustomTile(mHost);
        }
        return null;
    }
}
```

#### Tile Host Registration

**Host Registration:**
```java
public class SystemUIApplication extends Application {
    @Override
    public void onCreate() {
        super.onCreate();
        
        // Register custom tile
        QSTileHost tileHost = new QSTileHost(this, ...);
        tileHost.addTile("custom", CustomTile.class);
    }
}
```

#### Tile Specification

**Tile Specification:**
- Tile spec string
- Tile class reference
- Tile configuration
- Tile availability

**Specification Format:**
- String identifier
- Class reference
- Configuration options
- Availability conditions

### Tile State Management

#### State Updates

**State Update Sources:**
- System service changes
- User interactions
- System events
- Configuration changes

**Update Mechanisms:**
```java
// Broadcast receiver
private BroadcastReceiver mReceiver = new BroadcastReceiver() {
    @Override
    public void onReceive(Context context, Intent intent) {
        refreshState();
    }
};

// Service callback
private ServiceCallback mCallback = new ServiceCallback() {
    @Override
    public void onStateChanged() {
        refreshState();
    }
};
```

#### State Synchronization

**State Synchronization:**
- Tile state ↔ System service state
- Real-time updates
- State consistency
- Change notifications

**Synchronization Implementation:**
```java
@Override
protected void handleUpdateState(BooleanState state, Object arg) {
    // Get current state from service
    CustomService service = getSystemService(CustomService.class);
    state.value = service.isEnabled();
    
    // Update UI
    state.label = service.getLabel();
    state.icon = service.getIcon();
}
```

### Tile UI Design

#### Icon Design

**Icon Requirements:**
- 24x24dp size
- Vector drawable preferred
- Material design guidelines
- State-aware icons

**Icon Implementation:**
```xml
<!-- res/drawable/ic_custom_tile.xml -->
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24">
    <path
        android:fillColor="@android:color/white"
        android:pathData="..."/>
</vector>
```

#### Label Design

**Label Requirements:**
- Short, descriptive
- Localized
- State-aware
- Clear meaning

**Label Implementation:**
```java
state.label = getString(R.string.custom_tile_label);
state.secondaryLabel = getString(R.string.custom_tile_secondary);
```

### System Service Integration

#### Service Integration

**Service Integration:**
- Connect to system services
- Monitor service state
- Control service behavior
- Handle service callbacks

**Integration Example:**
```java
public class CustomTile extends QSTile<BooleanState> {
    private WifiManager mWifiManager;
    private BroadcastReceiver mReceiver;
    
    @Override
    public void setListening(boolean listening) {
        if (listening) {
            mWifiManager = getSystemService(WifiManager.class);
            mReceiver = new BroadcastReceiver() {
                @Override
                public void onReceive(Context context, Intent intent) {
                    refreshState();
                }
            };
            registerReceiver(mReceiver, new IntentFilter(WifiManager.WIFI_STATE_CHANGED_ACTION));
        } else {
            if (mReceiver != null) {
                unregisterReceiver(mReceiver);
            }
        }
    }
}
```

### Tile Configuration

#### Tile Availability

**Availability Control:**
- Conditional availability
- Feature flags
- Device capabilities
- User preferences

**Availability Implementation:**
```java
@Override
public boolean isAvailable() {
    // Check if feature is available
    return FeatureFlags.isCustomTileEnabled() 
        && DeviceCapabilities.supportsCustomFeature();
}
```

#### Tile Ordering

**Tile Ordering:**
- Default order
- User customization
- Priority-based ordering
- Configuration-based

**Ordering Configuration:**
- Configuration files
- Settings UI
- Build configuration
- System properties

### Tile Permissions

#### Permission Requirements

**Permission Requirements:**
- System permissions for system features
- Runtime permissions for user features
- Signature permissions for system tiles
- Permission checks

**Permission Implementation:**
```java
@Override
protected void handleClick() {
    if (!hasPermission(Manifest.permission.CUSTOM_PERMISSION)) {
        requestPermission();
        return;
    }
    // Perform action
}
```

### Tile Testing

#### Testing Custom Tiles

**Testing Approach:**
- Functional testing
- State testing
- Integration testing
- UI testing

**Test Coverage:**
- Tile creation
- State updates
- User interactions
- Service integration
- Error handling

### Tile Best Practices

#### Best Practices

**Best Practices:**
- Clear functionality
- Efficient state updates
- Proper error handling
- Good UX design
- Battery efficiency

**Practice Guidelines:**
- **Functionality:** Clear, useful functionality
- **Updates:** Efficient state updates
- **Errors:** Proper error handling
- **UX:** Good user experience design
- **Efficiency:** Battery-efficient operations

## Key Takeaways

1. **Adding custom tiles** involves creating and implementing custom quick settings tiles for SystemUI, including tile class implementation, tile state management, tile UI design, tile registration, and tile integration with system services.

2. **Tile implementation** includes tile class structure (extend QSTile base class, implement tile logic, define tile state, handle interactions), tile state types (BooleanState, SignalState, ResourceIconState, custom state types), and implementation details.

3. **Tile implementation details** include toggle tile implementation (on/off toggle functionality), state tile implementation (state display functionality), and implementation examples.

4. **Tile registration** includes tile factory registration (factory pattern for tile creation), tile host registration (register tile with SystemUI), tile specification (tile spec string, tile class reference, tile configuration), and registration methods.

5. **Tile state management** includes state updates (system service changes, user interactions, system events, configuration changes), update mechanisms (broadcast receivers, service callbacks, event listeners), state synchronization (tile state ↔ system service state, real-time updates, state consistency), and synchronization implementation.

6. **Tile UI design** includes icon design (24x24dp size, vector drawable preferred, Material design guidelines, state-aware icons), label design (short, descriptive, localized, state-aware), and UI design guidelines.

7. **System service integration** includes service integration (connect to system services, monitor service state, control service behavior, handle service callbacks), integration example, and integration methods.

8. **Tile configuration** includes tile availability (conditional availability, feature flags, device capabilities, user preferences), tile ordering (default order, user customization, priority-based ordering, configuration-based), and configuration methods.

9. **Understanding adding custom tiles** is essential for AOSP development, enabling custom feature addition, OEM functionality, brand features, and proper custom tile implementation.

## Related Topics

- **Quick settings architecture:** Quick settings details
- **Customizing SystemUI (OEM customizations):** SystemUI customization details
- **SystemUI architecture:** SystemUI architecture details

