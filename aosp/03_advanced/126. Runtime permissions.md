---
number: 126
title: Runtime permissions
slug: runtime-permissions
level: advanced
tags:
  - aosp
  - framework
  - permissions
  - runtime-permissions
  - permission-requests
  - security
prerequisites:
  - permissions-system
  - permissions-service
  - android-architecture-complete-overview
estimated_minutes: 95
contributors: []
diagrams: []
examples: []
canonical_id: aosp-advanced-126
---

# Runtime permissions

## Overview

Runtime permissions is the permission model introduced in Android 6.0 (API 23) that requires apps to request dangerous permissions at runtime rather than receiving them automatically at install time. Runtime permissions provide users with granular control over permissions, allow permissions to be revoked, and improve privacy protection. Understanding runtime permissions is essential for AOSP development, as it explains how runtime permission requests work, how the permission dialog system operates, how permission grants are managed, how permission state is tracked, and how the runtime permission model integrates with the permissions system. This guide provides a comprehensive overview of runtime permissions, permission request flow, permission dialog system, permission state management, permission revocation, and debugging.

Think of runtime permissions like a building access system: just as a building access system requires visitors to request access at the door (runtime request) rather than having permanent access (install-time), runtime permissions require apps to request access when needed (runtime) rather than having all permissions at install time, giving users control over when and what permissions are granted.

## Deep Explanation

### What are Runtime Permissions?

Runtime permissions is the permission model introduced in Android 6.0 (API 23) that requires apps to request dangerous permissions at runtime rather than receiving them automatically at install time. Runtime permissions provide users with granular control over permissions, allow permissions to be revoked, and improve privacy protection.

**Key Characteristics:**
- **Runtime Request:** Request permissions when needed
- **User Control:** User approves/denies at runtime
- **Granular Control:** Per-permission control
- **Revocable:** Can be revoked by user
- **Privacy:** Better privacy protection

**Why Runtime Permissions?**
- **Privacy:** Better privacy protection
- **User Control:** User controls access
- **Transparency:** Users see when permissions used
- **Flexibility:** Can revoke permissions

### Runtime Permission Model

#### Model Overview

**Runtime Permission Model:**
- Dangerous permissions require runtime request
- User must approve at runtime
- Permissions can be revoked
- Granular per-permission control

**Model Characteristics:**
- **On-Demand:** Request when needed
- **User Approval:** User must approve
- **Revocable:** Can be revoked
- **Granular:** Per-permission control

#### Permission Request Flow

**Request Flow:**
```
1. App needs permission
2. App checks if permission granted
3. If not granted, app requests permission
4. System shows permission dialog
5. User approves/denies
6. Result delivered to app
7. Permission state updated
8. App can use permission (if granted)
```

**Flow Diagram:**
```
App → Check Permission → Request Permission → 
System Dialog → User Decision → 
Result Callback → Permission State Updated
```

### Permission Request

#### Request Process

**Request Process:**
1. App calls `requestPermissions()`
2. Framework checks current state
3. If not granted, show dialog
4. User makes decision
5. Result delivered via callback
6. Permission state updated

**Request Implementation:**
```java
// Request permission
ActivityCompat.requestPermissions(
    activity,
    new String[]{Manifest.permission.CAMERA},
    REQUEST_CODE_CAMERA
);

// Handle result
@Override
public void onRequestPermissionsResult(
    int requestCode,
    String[] permissions,
    int[] grantResults
) {
    if (requestCode == REQUEST_CODE_CAMERA) {
        if (grantResults.length > 0 && 
            grantResults[0] == PERMISSION_GRANTED) {
            // Permission granted
            useCamera();
        } else {
            // Permission denied
            handlePermissionDenied();
        }
    }
}
```

#### Permission Dialog

**Permission Dialog:**
- System shows permission dialog
- Dialog explains permission usage
- User can approve or deny
- Dialog shows permission group

**Dialog Characteristics:**
- **System UI:** System-managed dialog
- **Permission Group:** Shows permission group
- **Explanation:** Explains permission usage
- **User Choice:** Approve or deny

### Permission State

#### Permission States

**Permission States:**
- **GRANTED:** Permission granted
- **DENIED:** Permission denied
- **NOT_REQUESTED:** Not yet requested
- **DENIED_ALWAYS:** Permanently denied (user checked "Don't ask again")

**State Transitions:**
```
NOT_REQUESTED → Request → GRANTED or DENIED
DENIED → Request Again → GRANTED or DENIED_ALWAYS
GRANTED → User Revokes → DENIED
```

#### State Checking

**State Checking:**
```java
// Check permission state
int result = ContextCompat.checkSelfPermission(
    context,
    Manifest.permission.CAMERA
);

if (result == PackageManager.PERMISSION_GRANTED) {
    // Permission granted
} else {
    // Permission not granted
    // Request permission
}
```

### Permission Rationale

#### Rationale Concept

**Permission Rationale:**
- Explanation of why permission needed
- Shown before permission request
- Helps user understand need
- Improves permission grant rate

**Rationale Usage:**
- Show before first request
- Explain permission usage
- Improve user understanding
- Increase grant likelihood

#### Rationale Implementation

**Rationale Implementation:**
```java
// Check if should show rationale
if (ActivityCompat.shouldShowRequestPermissionRationale(
        activity, Manifest.permission.CAMERA)) {
    // Show rationale
    showRationaleDialog(new DialogInterface.OnClickListener() {
        @Override
        public void onClick(DialogInterface dialog, int which) {
            // User understood, request permission
            requestCameraPermission();
        }
    });
} else {
    // Request permission directly
    requestCameraPermission();
}
```

### Permission Groups

#### Group-Based Granting

**Group-Based Granting:**
- User grants permission group
- All permissions in group granted
- Simplified user experience
- Group-based UI

**Group Grant Example:**
```
User grants CALENDAR group:
├── READ_CALENDAR → Granted
└── WRITE_CALENDAR → Granted
```

#### Group Behavior

**Group Behavior:**
- Granting one permission grants group
- Revoking one permission revokes group
- Group-based UI
- Simplified management

### Permission Revocation

#### Revocation Process

**Revocation Process:**
- User can revoke permissions
- Revocation via Settings
- App notified of revocation
- Permission state updated

**Revocation Flow:**
```
User Revokes Permission → Settings Updates State → 
System Notifies App → Permission State Updated → 
App Must Handle Revocation
```

#### Handling Revocation

**Handling Revocation:**
- App should handle gracefully
- Check permission before use
- Request again if needed
- Provide fallback behavior

**Revocation Handling:**
```java
// Check permission before use
if (hasPermission(CAMERA)) {
    useCamera();
} else {
    // Permission revoked
    requestCameraPermission();
}
```

### Permission Persistence

#### State Storage

**State Storage:**
- Permission state stored persistently
- Stored in `/data/system/users/<user-id>/runtime-permissions.xml`
- Per-user storage
- Persistent across reboots

**Storage Format:**
```xml
<runtime-permissions>
    <pkg name="com.example.app">
        <perm name="android.permission.CAMERA" granted="true" />
        <perm name="android.permission.READ_CONTACTS" granted="false" />
    </pkg>
</runtime-permissions>
```

#### State Restoration

**State Restoration:**
- State restored on boot
- State loaded from storage
- Permission state maintained
- System ready for checks

### Permission Callbacks

#### Callback Mechanism

**Callback Mechanism:**
- Result delivered via callback
- `onRequestPermissionsResult()`
- Activity-based callbacks
- Result contains grant state

**Callback Implementation:**
```java
@Override
public void onRequestPermissionsResult(
    int requestCode,
    String[] permissions,
    int[] grantResults
) {
    // Handle permission result
    for (int i = 0; i < permissions.length; i++) {
        if (grantResults[i] == PERMISSION_GRANTED) {
            // Permission granted
            handlePermissionGranted(permissions[i]);
        } else {
            // Permission denied
            handlePermissionDenied(permissions[i]);
        }
    }
}
```

### Multiple Permissions

#### Multiple Permission Request

**Multiple Permissions:**
- Request multiple permissions at once
- Single dialog for group
- All permissions in result
- Handle each permission

**Multiple Request:**
```java
// Request multiple permissions
ActivityCompat.requestPermissions(
    activity,
    new String[]{
        Manifest.permission.CAMERA,
        Manifest.permission.READ_CONTACTS,
        Manifest.permission.ACCESS_FINE_LOCATION
    },
    REQUEST_CODE_MULTIPLE
);
```

### Permission Best Practices

#### Request Timing

**Request Timing:**
- Request when feature used
- Not on app start
- Contextual requests
- Explain why needed

**Good Practice:**
```java
// GOOD: Request when needed
void onTakePhotoClick() {
    if (hasPermission(CAMERA)) {
        takePhoto();
    } else {
        requestCameraPermission();
    }
}

// BAD: Request on app start
void onCreate() {
    requestAllPermissions(); // Too early
}
```

#### Permission Handling

**Permission Handling:**
- Always check before use
- Handle denial gracefully
- Provide fallback behavior
- Explain permission need

### System Integration

#### Framework Integration

**Framework Integration:**
- Framework handles requests
- System shows dialogs
- Permission state managed
- Callbacks delivered

**Integration Flow:**
```
App Request → Framework → PermissionManager → 
Dialog Shown → User Decision → 
State Updated → Callback Delivered
```

#### PermissionManager Integration

**PermissionManager Integration:**
- PermissionManager manages state
- Handles grant/revoke
- Stores permission state
- Coordinates with system

### Debugging Runtime Permissions

#### Debugging Tools

**Debugging Tools:**
- Permission dumps
- State inspection
- Permission logs
- Grant/revoke commands

**Debugging Commands:**
```bash
# Check permission state
adb shell dumpsys package <package-name> | grep permission

# Grant permission
adb shell pm grant <package> <permission>

# Revoke permission
adb shell pm revoke <package> <permission>

# List permissions
adb shell pm list permissions -g
```

#### Common Issues

**Common Issues:**
- Permission not requested
- Permission denied unexpectedly
- State not updating
- Callback not called

**Debugging Steps:**
1. Check permission declaration
2. Verify request code
3. Check permission state
4. Review permission logs
5. Verify callback implementation

## Key Takeaways

1. **Runtime permissions** is the permission model introduced in Android 6.0 that requires apps to request dangerous permissions at runtime, providing user control and better privacy protection.

2. **Runtime permission model** includes model overview (dangerous permissions require runtime request, user approval, revocable), permission request flow (check, request, dialog, decision, result, state update), and model characteristics (on-demand, user approval, revocable, granular).

3. **Permission request** includes request process (app calls requestPermissions, framework checks state, shows dialog, user decides, result delivered), permission dialog (system UI, shows permission group, explains usage, user choice), and request implementation.

4. **Permission state** includes permission states (GRANTED, DENIED, NOT_REQUESTED, DENIED_ALWAYS), state transitions (NOT_REQUESTED → request → GRANTED/DENIED), and state checking (checkSelfPermission, handle result).

5. **Permission rationale** includes rationale concept (explanation of why needed, shown before request), rationale usage (show before first request, explain usage, improve understanding), and rationale implementation (shouldShowRequestPermissionRationale, show rationale dialog).

6. **Permission groups** include group-based granting (user grants group, all permissions in group granted), group behavior (granting one grants group, revoking one revokes group), and group-based UI (simplified user experience).

7. **Permission revocation** includes revocation process (user can revoke, via Settings, app notified, state updated), handling revocation (handle gracefully, check before use, request again, provide fallback), and revocation flow.

8. **Permission persistence** includes state storage (stored in runtime-permissions.xml, per-user, persistent), storage format (XML format, package and permission data), and state restoration (restored on boot, loaded from storage, maintained).

9. **Permission callbacks** include callback mechanism (result via onRequestPermissionsResult, activity-based, contains grant state), callback implementation (handle result, check grant state, handle granted/denied), and multiple permissions (request multiple, single dialog, handle each).

10. **Understanding runtime permissions** is essential for AOSP development, enabling user control, privacy protection, granular permission management, and proper permission request handling.

## Related Topics

- **Permissions system:** Overall permissions system architecture
- **Permissions service:** PermissionManagerService implementation
- **PackageManagerService:** Package and permission management
- **Android Security Model:** Overall security architecture

