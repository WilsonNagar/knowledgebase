---
number: 115
title: InputDispatcher + InputReader
slug: inputdispatcher-inputreader
level: advanced
tags:
  - aosp
  - framework
  - input
  - inputdispatcher
  - inputreader
  - input-processing
  - system-services
prerequisites:
  - inputmanagerservice-ims
  - system-server-overview
  - binder-ipc-basics
estimated_minutes: 95
contributors: []
diagrams: []
examples: []
canonical_id: aosp-advanced-115
---

# InputDispatcher + InputReader

## Overview

InputDispatcher and InputReader are the core components of Android's input system, responsible for reading input events from hardware devices and dispatching them to appropriate windows. InputReader reads raw input events from kernel input devices, while InputDispatcher routes processed events to target windows. Understanding InputDispatcher and InputReader is essential for AOSP development, as it explains how input events are read from hardware, how events are processed, how events are routed to windows, how input focus is managed, and how the input pipeline works. This guide provides a comprehensive overview of InputDispatcher and InputReader, architecture, event reading, event processing, event dispatching, focus management, and debugging.

Think of InputDispatcher and InputReader like a postal system: just as a postal system has mail carriers who collect mail (InputReader reads events), sort it (process events), and deliver it to addresses (InputDispatcher routes to windows), InputReader collects input events, processes them, and InputDispatcher delivers them to the correct windows.

## Deep Explanation

### What are InputDispatcher and InputReader?

InputDispatcher and InputReader are core components of Android's input system that work together to read input events from hardware devices and dispatch them to appropriate windows. InputReader reads raw input events from kernel input devices, while InputDispatcher routes processed events to target windows.

**Key Characteristics:**
- **InputReader:** Reads events from `/dev/input/`
- **InputDispatcher:** Routes events to windows
- **Native Components:** Implemented in C++
- **Thread-Based:** Run in separate threads
- **Event Pipeline:** Reader → Dispatcher → Window

**Why InputDispatcher and InputReader?**
- **Hardware Abstraction:** Abstracts hardware differences
- **Event Processing:** Processes raw input data
- **Event Routing:** Routes events to correct windows
- **Performance:** Efficient event handling

### Architecture

#### Component Location

**Component Location:**
- Native C++ components
- Part of InputManagerService
- Run in native threads
- Access kernel input devices

**Component Structure:**
```
InputManagerService (Java)
    ↓
InputManager (Native)
    ├── InputReader (Native Thread)
    └── InputDispatcher (Native Thread)
```

#### Thread Model

**Thread Model:**
- **InputReader Thread:** Reads events from kernel
- **InputDispatcher Thread:** Dispatches events to windows
- **Separate Threads:** Independent execution
- **Thread Communication:** Event queue

**Thread Communication:**
```
InputReader Thread:
    Read event → Process → Queue

InputDispatcher Thread:
    Dequeue → Route → Dispatch
```

### InputReader

#### InputReader Responsibilities

**InputReader Responsibilities:**
- Read events from `/dev/input/`
- Process raw input data
- Convert to Android input events
- Queue events for dispatcher

**InputReader Process:**
```
1. Open /dev/input/ devices
2. Poll for events
3. Read raw input data
4. Parse input data
5. Create InputEvent
6. Queue for dispatcher
```

#### Event Reading

**Event Reading Process:**
- Poll input devices
- Read event data
- Parse event structure
- Create event objects

**Reading Implementation:**
```cpp
// InputReader reads from /dev/input/
void InputReader::loopOnce() {
    // Poll input devices
    size_t count = mEventHub->getEvents(timeout, mEventBuffer);
    
    // Process events
    for (size_t i = 0; i < count; i++) {
        RawEvent& event = mEventBuffer[i];
        processEventsLocked(&event);
    }
}
```

#### Event Processing

**Event Processing:**
- Parse raw event data
- Convert to Android events
- Apply device configuration
- Filter events

**Processing Steps:**
1. Parse event type
2. Parse event code
3. Parse event value
4. Apply calibration
5. Apply filters
6. Create InputEvent

#### Event Types

**Event Types:**
- **Motion Events:** Touch, mouse movement
- **Key Events:** Keyboard input
- **Switch Events:** Lid, etc.

**Motion Event Processing:**
```cpp
// Process touch event
void InputReader::processMotionEvent(...) {
    // Parse touch coordinates
    float x = event.x;
    float y = event.y;
    
    // Apply calibration
    applyCalibration(x, y);
    
    // Create MotionEvent
    MotionEvent* motionEvent = new MotionEvent(...);
    queueEvent(motionEvent);
}
```

**Key Event Processing:**
```cpp
// Process key event
void InputReader::processKeyEvent(...) {
    // Parse key code
    int32_t keyCode = event.code;
    
    // Apply key mapping
    keyCode = mapKey(keyCode);
    
    // Create KeyEvent
    KeyEvent* keyEvent = new KeyEvent(...);
    queueEvent(keyEvent);
}
```

#### Device Management

**Device Management:**
- Discover input devices
- Configure devices
- Monitor device changes
- Handle device removal

**Device Discovery:**
```cpp
// Discover input devices
void InputReader::discoverDevices() {
    // Scan /dev/input/
    for (int i = 0; i < MAX_DEVICES; i++) {
        char path[PATH_MAX];
        snprintf(path, sizeof(path), "/dev/input/event%d", i);
        
        if (access(path, R_OK) == 0) {
            addDevice(path);
        }
    }
}
```

### InputDispatcher

#### InputDispatcher Responsibilities

**InputDispatcher Responsibilities:**
- Receive events from InputReader
- Determine target window
- Apply input policy
- Route events to windows
- Handle input focus

**InputDispatcher Process:**
```
1. Receive event from InputReader
2. Determine target window (hit testing)
3. Apply input policy
4. Route to WindowManager
5. Handle focus changes
```

#### Event Dispatching

**Event Dispatching:**
- Receive events from queue
- Determine target window
- Apply policies
- Dispatch to window

**Dispatching Implementation:**
```cpp
// InputDispatcher dispatches events
void InputDispatcher::dispatchOnce() {
    // Dequeue event
    EventEntry* event = dequeueEvent();
    
    // Determine target window
    sp<InputWindowHandle> window = findTargetWindow(event);
    
    // Apply policy
    if (shouldDispatch(event, window)) {
        // Dispatch to window
        dispatchEventToWindow(event, window);
    }
}
```

#### Target Window Determination

**Hit Testing:**
- Get event coordinates
- Query WindowManager for windows
- Find topmost window at coordinates
- Check window visibility
- Check window focusability

**Hit Test Process:**
```cpp
// Find target window
sp<InputWindowHandle> InputDispatcher::findTargetWindow(EventEntry* event) {
    // Get touch coordinates
    float x = event->x;
    float y = event->y;
    
    // Query WindowManager
    std::vector<sp<InputWindowHandle>> windows = mWindowManager->getWindows();
    
    // Find topmost window
    for (auto it = windows.rbegin(); it != windows.rend(); ++it) {
        sp<InputWindowHandle> window = *it;
        
        // Check if point is in window
        if (isPointInWindow(x, y, window)) {
            // Check visibility
            if (window->isVisible()) {
                // Check focusability
                if (window->canReceiveInput()) {
                    return window;
                }
            }
        }
    }
    
    return nullptr;
}
```

#### Event Routing

**Event Routing:**
- Route to target window
- Handle routing failures
- Apply routing policies
- Manage routing state

**Routing Process:**
```
1. Determine target window
2. Check routing policies
3. Route to WindowManager
4. WindowManager delivers to window
5. Window delivers to application
```

#### Input Policy

**Input Policy:**
- System key handling
- Input filtering
- Accessibility features
- Security policies

**Policy Application:**
```cpp
// Apply input policy
bool InputDispatcher::shouldDispatch(EventEntry* event, 
                                     sp<InputWindowHandle> window) {
    // Check system keys
    if (isSystemKey(event)) {
        return handleSystemKey(event);
    }
    
    // Check accessibility
    if (mAccessibilityManager->shouldFilter(event)) {
        return false;
    }
    
    // Check security
    if (!checkSecurityPolicy(event, window)) {
        return false;
    }
    
    return true;
}
```

### Event Queue

#### Event Queue Structure

**Event Queue:**
- FIFO (First In, First Out) queue
- Thread-safe queue
- Priority queue for some events
- Queue management

**Queue Operations:**
- Enqueue event
- Dequeue event
- Peek event
- Clear queue

#### Queue Management

**Queue Management:**
- Manage queue size
- Handle queue overflow
- Prioritize events
- Filter duplicate events

**Queue Implementation:**
```cpp
// Event queue
class EventQueue {
    std::queue<EventEntry*> mQueue;
    Mutex mLock;
    
public:
    void enqueue(EventEntry* event) {
        AutoMutex _l(mLock);
        mQueue.push(event);
        mCondition.signal();
    }
    
    EventEntry* dequeue() {
        AutoMutex _l(mLock);
        while (mQueue.empty()) {
            mCondition.wait(mLock);
        }
        EventEntry* event = mQueue.front();
        mQueue.pop();
        return event;
    }
};
```

### Focus Management

#### Input Focus

**Input Focus:**
- Only one window has focus
- Focus determines event target
- Focus changes on window state
- Focus notifications

**Focus Management:**
```cpp
// Manage input focus
void InputDispatcher::setInputFocus(sp<InputWindowHandle> window) {
    // Update focus
    if (mFocusedWindow != window) {
        // Notify old window of focus loss
        if (mFocusedWindow != nullptr) {
            notifyFocusLost(mFocusedWindow);
        }
        
        // Set new focus
        mFocusedWindow = window;
        
        // Notify new window of focus gain
        if (mFocusedWindow != nullptr) {
            notifyFocusGained(mFocusedWindow);
        }
    }
}
```

#### Focus Changes

**Focus Changes:**
- Window gains focus
- Window loses focus
- Focus notifications
- Focus state tracking

**Focus Change Flow:**
```
1. Window state changes
2. InputDispatcher notified
3. InputDispatcher updates focus
4. Notify windows of focus change
5. Update event routing
```

### Event Batching

#### Event Batching

**Event Batching:**
- Batch similar events
- Reduce event overhead
- Improve performance
- Maintain event order

**Batching Process:**
```cpp
// Batch events
void InputDispatcher::batchEvents() {
    // Collect similar events
    std::vector<MotionEvent*> batch;
    
    while (!mEventQueue.empty()) {
        EventEntry* event = mEventQueue.front();
        
        if (canBatch(event, batch)) {
            batch.push_back(event);
            mEventQueue.pop();
        } else {
            break;
        }
    }
    
    // Dispatch batch
    if (!batch.empty()) {
        dispatchBatch(batch);
    }
}
```

### Performance Optimization

#### Performance Considerations

**Performance:**
- Minimize event latency
- Efficient event processing
- Optimize hit testing
- Reduce memory allocations

**Optimization Techniques:**
- Event batching
- Efficient data structures
- Minimize locking
- Cache hit test results

#### Latency Management

**Latency Management:**
- Minimize event latency
- Prioritize input events
- Reduce processing time
- Optimize event routing

### Debugging

#### Input Event Debugging

**Debugging Tools:**
- getevent command
- dumpsys input
- Input event logs
- Event tracing

**Debugging Commands:**
```bash
# Monitor input events
adb shell getevent

# Monitor specific device
adb shell getevent /dev/input/event0

# Dump input state
adb shell dumpsys input

# Input event logs
adb logcat | grep InputDispatcher
```

#### Common Issues

**Common Issues:**
- Events not received
- Wrong target window
- Focus issues
- Event latency

**Debugging Steps:**
1. Check input device
2. Verify event reading
3. Check event routing
4. Verify focus state
5. Review event logs

## Key Takeaways

1. **InputDispatcher and InputReader** are core components of Android's input system, with InputReader reading events from hardware and InputDispatcher routing events to windows.

2. **Architecture** includes component location (native C++ components, part of InputManagerService), thread model (InputReader thread and InputDispatcher thread), and thread communication (event queue).

3. **InputReader** includes responsibilities (read events, process raw data, convert to Android events, queue events), event reading (poll devices, read data, parse events), event processing (parse, convert, apply configuration), and device management (discover, configure, monitor devices).

4. **InputDispatcher** includes responsibilities (receive events, determine target, apply policy, route events), event dispatching (receive, determine target, dispatch), target window determination (hit testing based on coordinates and z-order), and event routing (route to WindowManager, deliver to window).

5. **Event queue** includes queue structure (FIFO queue, thread-safe), queue management (manage size, handle overflow, prioritize events), and queue operations (enqueue, dequeue, peek, clear).

6. **Focus management** includes input focus (only one window has focus), focus changes (window gains/loses focus), focus notifications (notify windows of changes), and focus state tracking (track current focus).

7. **Event batching** includes batching process (batch similar events, reduce overhead), batching benefits (improve performance, maintain order), and batching implementation (collect similar events, dispatch batch).

8. **Performance optimization** includes performance considerations (minimize latency, efficient processing), optimization techniques (event batching, efficient data structures), and latency management (minimize event latency, prioritize events).

9. **Understanding InputDispatcher and InputReader** is essential for AOSP development, enabling input event processing, event routing, focus management, and efficient input handling.

## Related Topics

- **InputManagerService (IMS):** High-level input service
- **WindowManagerService (WMS):** Window management coordination
- **System Server Overview:** How system services are organized
- **Binder IPC Basics:** How input system communicates

