---
number: 116
title: SurfaceFlinger (composition engine)
slug: surfaceflinger-composition-engine
level: advanced
tags:
  - aosp
  - graphics
  - surfaceflinger
  - composition
  - rendering
  - display
  - graphics-pipeline
prerequisites:
  - windowmanagerservice-wms
  - android-architecture-complete-overview
  - binder-ipc-basics
estimated_minutes: 95
contributors: []
diagrams: []
examples: []
canonical_id: aosp-advanced-116
---

# SurfaceFlinger (composition engine)

## Overview

SurfaceFlinger is Android's composition engine, responsible for compositing multiple surfaces (windows) into a single frame and displaying it on the screen. SurfaceFlinger receives surfaces from applications, composites them in layer order, applies transformations, and outputs the final frame to the display. Understanding SurfaceFlinger is essential for AOSP development, as it explains how graphics are composited, how surfaces are managed, how the display pipeline works, how VSync synchronization works, and how the graphics system renders frames. This guide provides a comprehensive overview of SurfaceFlinger, architecture, surface composition, layer management, VSync handling, display output, and debugging.

Think of SurfaceFlinger like a video editor: just as a video editor combines multiple video layers (surfaces), applies effects and transformations (compositing), and outputs a final video (display frame), SurfaceFlinger combines multiple surfaces, applies transformations, and outputs the final frame to the display.

## Deep Explanation

### What is SurfaceFlinger?

SurfaceFlinger is Android's composition engine, a native system service that composites multiple surfaces (windows) into a single frame and displays it on the screen. SurfaceFlinger runs in a separate process and coordinates with WindowManagerService to manage window rendering.

**Key Characteristics:**
- **Composition Engine:** Composites multiple surfaces
- **Native Service:** Implemented in C++
- **Separate Process:** Runs in `surfaceflinger` process
- **VSync Synchronized:** Synchronized with display refresh
- **Hardware Accelerated:** Uses GPU for composition

**Why SurfaceFlinger?**
- **Efficient Composition:** Hardware-accelerated composition
- **Multiple Surfaces:** Handles multiple windows efficiently
- **VSync Synchronization:** Prevents screen tearing
- **Display Output:** Manages display output

### SurfaceFlinger Architecture

#### Service Location

**SurfaceFlinger Location:**
- Runs in `surfaceflinger` process
- Native C++ service
- Started by init
- Registered with ServiceManager

**Service Registration:**
```cpp
// In SurfaceFlinger
sp<SurfaceFlinger> flinger = new SurfaceFlinger();
ServiceManager::addService(String16("SurfaceFlinger"), flinger);
```

**Access from Framework:**
```java
// Framework accesses via SurfaceControl
SurfaceControl control = new SurfaceControl(...);
```

#### Process Structure

**Process Structure:**
```
surfaceflinger Process:
├── SurfaceFlinger (main service)
├── Composition Engine
├── Layer Management
├── VSync Handler
└── Display Management
```

**Thread Model:**
- **Main Thread:** Service management
- **Composition Thread:** Composition operations
- **VSync Thread:** VSync handling
- **Event Thread:** Event processing

### Surface Composition

#### What is a Surface?

**Surface:**
- Drawing surface for a window
- Buffer queue for rendering
- Shared between app and SurfaceFlinger
- Hardware-accelerated rendering

**Surface Characteristics:**
- **Buffer Queue:** Triple buffering
- **Shared Memory:** Shared between processes
- **Hardware Acceleration:** GPU rendering
- **Layer Assignment:** Assigned to layer

#### Composition Process

**Composition Flow:**
```
1. Applications render to surfaces
2. Surfaces submit buffers to SurfaceFlinger
3. SurfaceFlinger receives buffers
4. SurfaceFlinger sorts layers by Z-order
5. SurfaceFlinger composites layers
6. SurfaceFlinger outputs to display
7. Display shows final frame
```

**Composition Steps:**
1. **Buffer Submission:** Apps submit rendered buffers
2. **Layer Sorting:** Sort layers by Z-order
3. **Composition:** Composite layers from bottom to top
4. **Transformation:** Apply transformations (rotation, scaling)
5. **Output:** Send to display hardware

#### Layer Ordering

**Layer Z-Order:**
```
Top Layer:
  - System Alert Windows (highest)
  - Application Windows
  - System Windows (Status bar)
  - Wallpaper (lowest)
```

**Layer Management:**
- Layers sorted by Z-order
- Bottom layer rendered first
- Top layer rendered last
- Alpha blending for transparency

### Surface Management

#### Surface Creation

**Surface Creation:**
- WindowManager requests surface
- SurfaceFlinger creates surface
- Surface assigned to layer
- Buffer queue created

**Creation Process:**
```cpp
// SurfaceFlinger creates surface
sp<Surface> SurfaceFlinger::createSurface(...) {
    // Create layer
    sp<Layer> layer = new Layer(...);
    
    // Create surface
    sp<Surface> surface = layer->getSurface();
    
    // Add to layer list
    mLayers.add(layer);
    
    return surface;
}
```

#### Buffer Queue

**Buffer Queue:**
- Triple buffering system
- Producer (app) submits buffers
- Consumer (SurfaceFlinger) consumes buffers
- Prevents blocking

**Buffer Queue Structure:**
```
Producer (App)          Consumer (SurfaceFlinger)
    │                          │
    │─── Buffer 1 ────────────>│ (Displaying)
    │                          │
    │─── Buffer 2 ────────────>│ (Queued)
    │                          │
    │─── Buffer 3 ────────────>│ (Available)
    │                          │
    │<─── Buffer 1 ────────────│ (Released)
```

**Triple Buffering:**
- **Buffer 1:** Currently displaying
- **Buffer 2:** Queued for next frame
- **Buffer 3:** App can render to
- **Benefits:** Smooth rendering, no blocking

#### Surface Lifecycle

**Surface Lifecycle:**
- **Creation:** Surface created
- **Active:** Surface receiving buffers
- **Inactive:** Surface not receiving buffers
- **Destruction:** Surface destroyed

**Lifecycle Management:**
```cpp
// Surface lifecycle
void SurfaceFlinger::onSurfaceCreated(sp<Layer> layer) {
    // Surface created
    mLayers.add(layer);
}

void SurfaceFlinger::onSurfaceDestroyed(sp<Layer> layer) {
    // Surface destroyed
    mLayers.remove(layer);
}
```

### Layer Management

#### Layer Types

**Layer Types:**
- **Application Layers:** App windows
- **System Layers:** System UI (status bar, navigation)
- **Overlay Layers:** System overlays
- **Wallpaper Layer:** Background wallpaper

**Layer Characteristics:**
- Z-order position
- Visibility state
- Transformation matrix
- Alpha value

#### Layer Properties

**Layer Properties:**
- **Position:** X, Y coordinates
- **Size:** Width, height
- **Z-Order:** Layer depth
- **Alpha:** Transparency
- **Transform:** Rotation, scaling

**Layer Properties Example:**
```cpp
// Set layer properties
layer->setPosition(x, y);
layer->setSize(width, height);
layer->setZOrder(z);
layer->setAlpha(alpha);
layer->setTransform(transform);
```

### VSync Synchronization

#### What is VSync?

**VSync (Vertical Synchronization):**
- Display refresh signal
- Synchronizes frame rendering
- Prevents screen tearing
- Typically 60Hz (16.67ms per frame)

**VSync Purpose:**
- Synchronize composition with display
- Prevent screen tearing
- Ensure smooth rendering
- Coordinate frame timing

#### VSync Handling

**VSync Flow:**
```
1. Display hardware generates VSync
2. VSync signal received by SurfaceFlinger
3. SurfaceFlinger triggers composition
4. SurfaceFlinger composites layers
5. SurfaceFlinger outputs frame
6. Wait for next VSync
```

**VSync Implementation:**
```cpp
// VSync handling
void SurfaceFlinger::onVSync(nsecs_t timestamp) {
    // VSync received
    // Trigger composition
    composeSurfaces();
    
    // Output to display
    postFrame();
}
```

#### Frame Timing

**Frame Timing:**
- **VSync Period:** 16.67ms (60Hz)
- **Composition Time:** < 6ms (target)
- **Display Time:** < 16.67ms
- **Frame Drop:** If composition > 16.67ms

**Timing Example:**
```
VSync:     |────|────|────|────|
          16.67ms
Compose:   |──────|
          <6ms (target)
Display:   |────|
          <16.67ms
```

### Composition Modes

#### GPU Composition

**GPU Composition:**
- Uses GPU for composition
- Hardware-accelerated
- Efficient for complex scenes
- Default composition mode

**GPU Composition Benefits:**
- Fast composition
- Hardware acceleration
- Efficient blending
- Supports complex effects

#### HWC (Hardware Composer)

**HWC (Hardware Composer):**
- Hardware composition engine
- More efficient than GPU
- Handles simple compositions
- Reduces GPU load

**HWC Benefits:**
- Very fast composition
- Lower power consumption
- Hardware-optimized
- Reduces GPU usage

**HWC vs GPU:**
- **HWC:** Simple compositions, lower power
- **GPU:** Complex compositions, more flexible

#### Composition Selection

**Composition Selection:**
- SurfaceFlinger selects composition mode
- HWC preferred for simple cases
- GPU fallback for complex cases
- Dynamic selection

**Selection Logic:**
```cpp
// Select composition mode
CompositionType SurfaceFlinger::selectCompositionType(Layer* layer) {
    if (canUseHWC(layer)) {
        return HWC_COMPOSITION;
    } else {
        return GPU_COMPOSITION;
    }
}
```

### Display Management

#### Display Configuration

**Display Configuration:**
- Display resolution
- Display refresh rate
- Display orientation
- Display properties

**Configuration Management:**
```cpp
// Display configuration
void SurfaceFlinger::configureDisplay(DisplayId id, ...) {
    // Configure display
    Display* display = getDisplay(id);
    display->setConfiguration(...);
}
```

#### Multi-Display Support

**Multi-Display:**
- Support for multiple displays
- Each display has own composition
- Independent VSync per display
- Display-specific layers

**Multi-Display Management:**
```cpp
// Multi-display composition
void SurfaceFlinger::composeSurfaces() {
    for (Display* display : mDisplays) {
        composeDisplay(display);
    }
}
```

### Performance Optimization

#### Composition Optimization

**Optimization Techniques:**
- Layer caching
- Dirty region tracking
- Partial composition
- Frame skipping

**Dirty Region Tracking:**
- Track changed regions
- Only recompose changed areas
- Reduce composition work
- Improve performance

#### Memory Management

**Memory Management:**
- Buffer pool management
- Buffer reuse
- Memory allocation optimization
- Reduce memory footprint

**Buffer Pool:**
```cpp
// Buffer pool
class BufferPool {
    std::vector<sp<GraphicBuffer>> mBuffers;
    
    sp<GraphicBuffer> acquire() {
        // Reuse buffer or allocate new
        if (!mBuffers.empty()) {
            sp<GraphicBuffer> buffer = mBuffers.back();
            mBuffers.pop_back();
            return buffer;
        }
        return new GraphicBuffer(...);
    }
};
```

### Debugging SurfaceFlinger

#### SurfaceFlinger Dumps

**Dump SurfaceFlinger State:**
```bash
# Dump SurfaceFlinger state
adb shell dumpsys SurfaceFlinger

# Dump layer information
adb shell dumpsys SurfaceFlinger | grep Layer

# Dump display information
adb shell dumpsys SurfaceFlinger | grep Display
```

#### Performance Monitoring

**Performance Tools:**
- systrace
- perfetto
- SurfaceFlinger logs
- Frame timing

**Monitoring Commands:**
```bash
# systrace
python systrace.py -t 10 sched freq idle am wm gfx view binder_driver hal dalvik camera input res

# perfetto
adb shell perfetto -c /data/local/tmp/config.pb -o /data/local/tmp/trace.pb
```

#### Common Issues

**Common Issues:**
- Frame drops
- Screen tearing
- Composition lag
- Memory issues

**Debugging Steps:**
1. Check SurfaceFlinger logs
2. Monitor frame timing
3. Check layer state
4. Review composition mode
5. Analyze performance traces

## Key Takeaways

1. **SurfaceFlinger** is Android's composition engine, compositing multiple surfaces into a single frame and displaying it on the screen.

2. **SurfaceFlinger architecture** includes service location (runs in surfaceflinger process), process structure (main service, composition engine, layer management), and thread model (main thread, composition thread, VSync thread).

3. **Surface composition** includes surface concept (drawing surface for window), composition process (buffer submission, layer sorting, composition, transformation, output), and layer ordering (sorted by Z-order, bottom to top).

4. **Surface management** includes surface creation (WindowManager requests, SurfaceFlinger creates), buffer queue (triple buffering, producer/consumer), and surface lifecycle (creation, active, inactive, destruction).

5. **Layer management** includes layer types (application, system, overlay, wallpaper), layer properties (position, size, Z-order, alpha, transform), and layer organization (sorted by Z-order).

6. **VSync synchronization** includes VSync concept (display refresh signal, synchronizes rendering), VSync handling (triggers composition, coordinates timing), and frame timing (16.67ms period, composition < 6ms target).

7. **Composition modes** include GPU composition (hardware-accelerated, default), HWC (Hardware Composer, more efficient), and composition selection (HWC preferred, GPU fallback).

8. **Display management** includes display configuration (resolution, refresh rate, orientation), multi-display support (multiple displays, independent composition), and display output (frame output to display).

9. **Performance optimization** includes composition optimization (layer caching, dirty region tracking), memory management (buffer pool, buffer reuse), and performance monitoring (systrace, perfetto).

10. **Understanding SurfaceFlinger** is essential for AOSP development, enabling efficient graphics composition, smooth rendering, VSync synchronization, and optimal display output.

## Related Topics

- **WindowManagerService (WMS):** Window management coordination
- **View system internals:** How views render to surfaces
- **Graphics Pipeline Deep Dive:** Complete graphics pipeline
- **Binder IPC Basics:** How SurfaceFlinger communicates

