---
number: 136
title: 'domain, type enforcement rules'
slug: domain-type-enforcement-rules
level: advanced
tags:
  - aosp
  - security
  - selinux
  - domain
  - type-enforcement
  - te-rules
  - security-policies
prerequisites:
  - sepolicy
  - selinux-mandatory-access-control
  - selinux-overview
estimated_minutes: 95
contributors: []
diagrams: []
examples: []
canonical_id: aosp-advanced-136
---

# domain, type enforcement rules

## Overview

Domain and type enforcement rules are the core mechanism of SELinux policy that define which processes (domains) can access which objects (types) and what operations they can perform. Domain enforcement controls what processes can do, while type enforcement controls what objects processes can access. Understanding domain and type enforcement rules is essential for AOSP development, as it explains how SELinux policies control access, how domains are defined, how types are defined, how access rules work, how domain transitions occur, and how type enforcement provides security. This guide provides a comprehensive overview of domain and type enforcement rules, domain concepts, type concepts, access rules, domain transitions, and enforcement mechanisms.

Think of domain and type enforcement rules like access control rules: just as a building might have rules about which employees (domains) can access which rooms (types) and what they can do in those rooms (permissions), domain and type enforcement rules define which processes (domains) can access which objects (types) and what operations they can perform.

## Deep Explanation

### What are Domain and Type Enforcement Rules?

Domain and type enforcement rules are the core mechanism of SELinux policy that define which processes (domains) can access which objects (types) and what operations they can perform. Domain enforcement controls what processes can do, while type enforcement controls what objects processes can access.

**Key Characteristics:**
- **Domain-Based:** Processes have domains
- **Type-Based:** Objects have types
- **Rule-Based:** Access defined by rules
- **Fine-Grained:** Detailed permissions
- **Security-Enforced:** Enforced by kernel

**Why Domain and Type Enforcement?**
- **Security:** Controls access to resources
- **Isolation:** Isolates processes from each other
- **Privilege Control:** Controls process privileges
- **Defense in Depth:** Additional security layer

### Domain Concepts

#### What is a Domain?

**Domain:**
- SELinux context for processes
- Defines what process can do
- Determines access permissions
- Used for access control decisions

**Domain Characteristics:**
- **Process Context:** Domain is process context
- **Access Control:** Determines access permissions
- **Isolation:** Isolates processes
- **Security:** Security enforcement

**Domain Examples:**
- `untrusted_app` - Untrusted applications
- `system_server` - System server process
- `zygote` - Zygote process
- `init` - Init process

#### Domain Definition

**Domain Definition:**
- Defined in policy files
- Associated with attributes
- Defines domain characteristics
- Used for access control

**Definition Syntax:**
```
type <domain_name>, domain;
```

**Definition Example:**
```
# Define domain
type untrusted_app, domain;

# Associate with attributes
app_domain(untrusted_app)
```

#### Domain Attributes

**Domain Attributes:**
- Associate domains with common properties
- Simplify policy writing
- Provide common patterns
- Reusable policy elements

**Attribute Examples:**
- `domain` - Process domain attribute
- `app_domain` - Application domain attribute
- `untrusted_app_domain` - Untrusted app domain attribute

### Type Concepts

#### What is a Type?

**Type:**
- SELinux context for objects
- Defines object security identity
- Determines access permissions
- Used for access control decisions

**Type Characteristics:**
- **Object Context:** Type is object context
- **Access Control:** Determines access permissions
- **Classification:** Classifies objects
- **Security:** Security enforcement

**Type Examples:**
- `app_data_file` - Application data files
- `system_file` - System files
- `vendor_file` - Vendor files
- `socket` - Socket objects

#### Type Definition

**Type Definition:**
- Defined in policy files
- Associated with attributes
- Defines type characteristics
- Used for access control

**Definition Syntax:**
```
type <type_name>, <attribute1>, <attribute2>, ...;
```

**Definition Example:**
```
# Define type
type app_data_file, file_type, data_file_type;

# Define type with attributes
type system_file, file_type;
```

#### Type Attributes

**Type Attributes:**
- Associate types with common properties
- Simplify policy writing
- Provide common patterns
- Reusable policy elements

**Attribute Examples:**
- `file_type` - File type attribute
- `data_file_type` - Data file type attribute
- `system_file_type` - System file type attribute

### Access Rules

#### Allow Rules

**Allow Rules:**
- Define allowed operations
- Specify source domain and target type
- Specify object class and permissions
- Primary access control mechanism

**Rule Syntax:**
```
allow <source_domain> <target_type>:<class> { <permissions> };
```

**Rule Components:**
- **source_domain:** Process domain (subject)
- **target_type:** Object type (object)
- **class:** Object class (file, dir, socket, etc.)
- **permissions:** Allowed operations (read, write, execute, etc.)

**Rule Examples:**
```
# File access
allow untrusted_app app_data_file:file { read write };

# Directory access
allow untrusted_app app_data_file:dir { add_name write };

# Socket access
allow untrusted_app socket:udp_socket { create bind };
```

#### Neverallow Rules

**Neverallow Rules:**
- Define prohibited operations
- Prevent policy mistakes
- Enforced at compile time
- Security enforcement

**Rule Syntax:**
```
neverallow <source_domain> <target_type>:<class> { <permissions> };
```

**Rule Example:**
```
# Never allow untrusted apps to access system files
neverallow untrusted_app system_file:file { write };
```

#### Auditallow Rules

**Auditallow Rules:**
- Define operations to audit
- Log allowed operations
- Used for monitoring
- Audit trail

**Rule Syntax:**
```
auditallow <source_domain> <target_type>:<class> { <permissions> };
```

**Rule Example:**
```
# Audit file access
auditallow untrusted_app app_data_file:file { read write };
```

### Domain Transitions

#### What are Domain Transitions?

**Domain Transitions:**
- Process transitions from one domain to another
- Controlled by policy rules
- Used for privilege changes
- Security-critical operations

**Transition Characteristics:**
- **Controlled:** Controlled by policy
- **Explicit:** Explicitly defined in policy
- **Security:** Security-critical
- **Privilege:** Used for privilege changes

#### Transition Rules

**Transition Rules:**
- Define allowed domain transitions
- Specify source and target domains
- Specify transition conditions
- Control privilege changes

**Rule Syntax:**
```
type_transition <source_domain> <target_type>:<class> <new_domain>;
```

**Rule Example:**
```
# Allow zygote to transition to untrusted_app
type_transition zygote untrusted_app:process untrusted_app;
```

#### Transition Process

**Transition Process:**
```
1. Process in source domain
2. Process performs transition action
3. Policy checks transition rule
4. If allowed, process transitions to target domain
5. Process continues in new domain
```

**Transition Example:**
```
# Zygote forks app
1. Zygote runs as: zygote:s0
2. Zygote forks new process
3. Domain transition: zygote â†’ untrusted_app
4. App runs as: untrusted_app:s0
```

### Object Classes

#### Object Class Concept

**Object Classes:**
- Categories of objects
- Define available permissions
- Used in access rules
- Object classification

**Common Object Classes:**
- `file` - Files
- `dir` - Directories
- `socket` - Sockets
- `process` - Processes
- `binder` - Binder objects

#### File Class

**File Class:**
- Files and regular files
- Common permissions: read, write, execute, create, etc.
- Most common object class
- File access control

**File Permissions:**
- `read` - Read file
- `write` - Write file
- `execute` - Execute file
- `create` - Create file
- `delete` - Delete file

#### Directory Class

**Directory Class:**
- Directories
- Common permissions: read, write, add_name, remove_name, etc.
- Directory access control
- File creation control

**Directory Permissions:**
- `read` - Read directory
- `write` - Write directory
- `add_name` - Add file to directory
- `remove_name` - Remove file from directory
- `search` - Search directory

### Access Rule Examples

#### File Access

**File Access Example:**
```
# Allow untrusted app to read and write its data files
allow untrusted_app app_data_file:file { read write };
```

**Meaning:**
- Process in `untrusted_app` domain can
- Access files with `app_data_file` type
- With `read` and `write` permissions

#### Directory Access

**Directory Access Example:**
```
# Allow untrusted app to create files in its data directory
allow untrusted_app app_data_file:dir { add_name write };
```

**Meaning:**
- Process in `untrusted_app` domain can
- Access directories with `app_data_file` type
- With `add_name` and `write` permissions

#### Socket Access

**Socket Access Example:**
```
# Allow untrusted app to create UDP sockets
allow untrusted_app socket:udp_socket { create bind };
```

**Meaning:**
- Process in `untrusted_app` domain can
- Access UDP sockets
- With `create` and `bind` permissions

### Policy Macros

#### Domain Macros

**Domain Macros:**
- Simplify domain definitions
- Provide common patterns
- Reduce policy complexity
- Reusable policy elements

**Macro Examples:**
```
# App domain macro
app_domain(untrusted_app)

# Init daemon domain macro
init_daemon_domain(my_service)
```

#### Access Macros

**Access Macros:**
- Simplify access rules
- Provide common patterns
- Reduce policy complexity
- Reusable policy elements

**Macro Examples:**
```
# Read directory and file
r_dir_file(untrusted_app, app_data_file)

# Get property
get_prop(untrusted_app, system_prop)
```

### Enforcement

#### Enforcement Mechanism

**Enforcement:**
- Kernel enforces access rules
- Checks domain and type on access
- Allows or denies based on rules
- Logs violations

**Enforcement Process:**
```
1. Process attempts operation
2. Kernel checks process domain
3. Kernel checks object type
4. Kernel checks access rule
5. If allowed: Operation proceeds
6. If denied: Operation blocked, violation logged
```

#### Enforcement Points

**Enforcement Points:**
- System call interception
- File access
- Socket operations
- IPC operations
- Process operations

### Debugging Domain and Type Enforcement

#### Debugging Tools

**Debugging Tools:**
- Policy analysis tools
- Access rule inspection
- Domain/type inspection
- Violation logs

**Debugging Commands:**
```bash
# Check process domain
adb shell ps -Z | grep <process>

# Check file type
adb shell ls -Z <file>

# View access violations
adb shell dmesg | grep avc

# Check policy rules
adb shell sesearch -A -s untrusted_app -t app_data_file
```

#### Common Issues

**Common Issues:**
- Access denied errors
- Domain transition failures
- Type mismatches
- Policy rule errors

**Debugging Steps:**
1. Check process domain
2. Check object type
3. Review access rules
4. Check domain transitions
5. Review violation logs

## Key Takeaways

1. **Domain and type enforcement rules** are the core mechanism of SELinux policy that define which processes (domains) can access which objects (types) and what operations they can perform.

2. **Domain concepts** include what is a domain (SELinux context for processes, defines what process can do, determines access permissions), domain definition (defined in policy files, associated with attributes), domain attributes (associate domains with common properties, simplify policy writing), and domain examples.

3. **Type concepts** include what is a type (SELinux context for objects, defines object security identity, determines access permissions), type definition (defined in policy files, associated with attributes), type attributes (associate types with common properties, simplify policy writing), and type examples.

4. **Access rules** include allow rules (define allowed operations, specify source domain and target type, specify object class and permissions), neverallow rules (define prohibited operations, prevent policy mistakes, enforced at compile time), auditallow rules (define operations to audit, log allowed operations), and rule syntax and examples.

5. **Domain transitions** include what are domain transitions (process transitions from one domain to another, controlled by policy rules, used for privilege changes), transition rules (define allowed domain transitions, specify source and target domains), transition process (process in source domain, performs transition action, policy checks rule, transitions to target domain), and transition examples.

6. **Object classes** include object class concept (categories of objects, define available permissions, used in access rules), file class (files and regular files, common permissions: read, write, execute), directory class (directories, common permissions: read, write, add_name, remove_name), and class characteristics.

7. **Access rule examples** include file access (allow untrusted_app app_data_file:file { read write }), directory access (allow untrusted_app app_data_file:dir { add_name write }), socket access (allow untrusted_app socket:udp_socket { create bind }), and rule meanings.

8. **Policy macros** include domain macros (simplify domain definitions, provide common patterns, reduce complexity), access macros (simplify access rules, provide common patterns, reduce complexity), and macro examples.

9. **Enforcement** includes enforcement mechanism (kernel enforces access rules, checks domain and type on access, allows or denies based on rules), enforcement process, enforcement points (system call interception, file access, socket operations, IPC operations), and enforcement characteristics.

10. **Understanding domain and type enforcement rules** is essential for AOSP development, enabling access control definition, security policy enforcement, process isolation, and proper SELinux policy implementation.

## Related Topics

- **sepolicy:** SELinux policy details
- **SELinux (Mandatory Access Control):** SELinux MAC details
- **file contexts:** File context details
- **audit logs:** SELinux audit logging

