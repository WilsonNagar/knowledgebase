---
number: 157
title: StrictMode
slug: strictmode
level: advanced
tags:
  - aosp
  - debugging
  - strictmode
  - performance
  - development-tools
  - best-practices
prerequisites:
  - android-architecture-complete-overview
  - handler-looper-deep-dive
estimated_minutes: 95
contributors: []
diagrams: []
examples: []
canonical_id: aosp-advanced-157
---

# StrictMode

## Overview

StrictMode is a developer tool that detects and reports violations of best practices in Android applications, such as performing disk I/O or network operations on the main thread, leaking activities, and other performance and policy violations. StrictMode helps developers identify and fix performance issues, memory leaks, and policy violations during development. Understanding StrictMode is essential for AOSP development, as it explains how to enable StrictMode, how to configure StrictMode policies, how to detect violations, how to interpret StrictMode reports, and how to use StrictMode for development and debugging. This guide provides a comprehensive overview of StrictMode, policy configuration, violation detection, reporting mechanisms, and StrictMode best practices.

Think of StrictMode like a strict teacher monitoring your code: just as a strict teacher watches for rule violations (talking in class, not following instructions) and reports them immediately, StrictMode watches for code violations (main thread I/O, memory leaks) and reports them immediately, helping you learn and fix issues before they become problems.

## Deep Explanation

### What is StrictMode?

StrictMode is a developer tool that detects and reports violations of best practices in Android applications, such as performing disk I/O or network operations on the main thread, leaking activities, and other performance and policy violations. StrictMode helps developers identify and fix issues during development.

**Key Characteristics:**
- **Violation Detection:** Detects policy violations
- **Development Tool:** Development-time tool
- **Performance Monitoring:** Monitors performance issues
- **Policy Enforcement:** Enforces best practices
- **Immediate Feedback:** Immediate violation reports

**Why StrictMode?**
- **Performance Issues:** Identify performance problems
- **Memory Leaks:** Detect memory leaks
- **Best Practices:** Enforce best practices
- **Development:** Development-time debugging

### StrictMode Policies

#### Thread Policy

**Thread Policy:**
- Detects main thread violations
- Disk I/O on main thread
- Network operations on main thread
- Custom violations

**Thread Policy Violations:**
- Disk reads/writes on main thread
- Network operations on main thread
- Slow operations on main thread
- Blocking operations on main thread

#### VM Policy

**VM Policy:**
- Detects memory leaks
- Activity leaks
- SQLite object leaks
- Resource leaks

**VM Policy Violations:**
- Activity leaks
- SQLite cursor leaks
- Closeable object leaks
- Resource leaks

### Enabling StrictMode

#### Basic Enablement

**Basic Enablement:**
```java
// In Application.onCreate() or Activity.onCreate()
if (BuildConfig.DEBUG) {
    StrictMode.setThreadPolicy(new StrictMode.ThreadPolicy.Builder()
        .detectAll()
        .penaltyLog()
        .build());
    
    StrictMode.setVmPolicy(new StrictMode.VmPolicy.Builder()
        .detectAll()
        .penaltyLog()
        .build());
}
```

#### Selective Enablement

**Selective Enablement:**
```java
// Enable specific detections
StrictMode.setThreadPolicy(new StrictMode.ThreadPolicy.Builder()
    .detectDiskReads()
    .detectDiskWrites()
    .detectNetwork()
    .penaltyLog()
    .build());
```

### StrictMode Configuration

#### Thread Policy Configuration

**Thread Policy Options:**
- **detectDiskReads():** Detect disk reads
- **detectDiskWrites():** Detect disk writes
- **detectNetwork():** Detect network operations
- **detectCustomSlowCalls():** Detect custom slow calls
- **detectAll():** Detect all thread violations

**Thread Policy Example:**
```java
StrictMode.ThreadPolicy policy = new StrictMode.ThreadPolicy.Builder()
    .detectDiskReads()
    .detectDiskWrites()
    .detectNetwork()
    .detectCustomSlowCalls()
    .penaltyLog()
    .penaltyDialog()
    .penaltyDeath()
    .build();
StrictMode.setThreadPolicy(policy);
```

#### VM Policy Configuration

**VM Policy Options:**
- **detectActivityLeaks():** Detect activity leaks
- **detectLeakedSqlLiteObjects():** Detect SQLite leaks
- **detectLeakedClosableObjects():** Detect closeable leaks
- **detectLeakedRegistrationObjects():** Detect registration leaks
- **detectAll():** Detect all VM violations

**VM Policy Example:**
```java
StrictMode.VmPolicy policy = new StrictMode.VmPolicy.Builder()
    .detectActivityLeaks()
    .detectLeakedSqlLiteObjects()
    .detectLeakedClosableObjects()
    .penaltyLog()
    .penaltyDeath()
    .build();
StrictMode.setVmPolicy(policy);
```

### Penalties

#### Log Penalty

**Log Penalty:**
- Logs violations to logcat
- Non-blocking
- Development use
- Information only

**Log Penalty:**
```java
.penaltyLog()
```

#### Dialog Penalty

**Dialog Penalty:**
- Shows violation dialog
- Blocks execution
- User-visible
- Development use

**Dialog Penalty:**
```java
.penaltyDialog()
```

#### Death Penalty

**Death Penalty:**
- Crashes application
- Most severe
- Development use
- Forces fixes

**Death Penalty:**
```java
.penaltyDeath()
```

#### Flash Penalty

**Flash Penalty:**
- Flashes screen
- Visual indicator
- Non-blocking
- Development use

**Flash Penalty:**
```java
.penaltyFlashScreen()
```

### Violation Detection

#### Disk I/O Detection

**Disk I/O Violations:**
```java
// BAD: Disk read on main thread
public void loadData() {
    File file = new File("/data/file.txt");
    String content = Files.readString(file.toPath()); // Violation!
}

// GOOD: Disk read on background thread
public void loadData() {
    executor.execute(() -> {
        File file = new File("/data/file.txt");
        String content = Files.readString(file.toPath());
        // Process on background thread
    });
}
```

#### Network Detection

**Network Violations:**
```java
// BAD: Network on main thread
public void fetchData() {
    URL url = new URL("https://api.example.com/data");
    HttpURLConnection conn = (HttpURLConnection) url.openConnection();
    conn.connect(); // Violation!
}

// GOOD: Network on background thread
public void fetchData() {
    executor.execute(() -> {
        URL url = new URL("https://api.example.com/data");
        HttpURLConnection conn = (HttpURLConnection) url.openConnection();
        conn.connect();
        // Process on background thread
    });
}
```

#### Activity Leak Detection

**Activity Leak Violations:**
```java
// BAD: Static reference to Activity
public class MyManager {
    private static Activity sActivity; // Leak!
    
    public static void setActivity(Activity activity) {
        sActivity = activity; // Violation!
    }
}

// GOOD: Use Application Context or WeakReference
public class MyManager {
    private static WeakReference<Activity> sActivityRef;
    
    public static void setActivity(Activity activity) {
        sActivityRef = new WeakReference<>(activity);
    }
}
```

### StrictMode Reports

#### Logcat Output

**Logcat Format:**
```
D/StrictMode: StrictMode policy violation; ~duration=1234 ms: android.os.StrictMode$StrictModeDiskReadViolation: policy=31 violation=2
    at android.os.StrictMode$AndroidBlockGuardPolicy.onReadFromDisk(StrictMode.java:1445)
    at java.io.FileInputStream.read(FileInputStream.java:162)
    at com.example.app.MyActivity.loadData(MyActivity.java:123)
```

**Report Information:**
- Violation type
- Duration
- Stack trace
- Policy information

#### Violation Analysis

**Analyzing Violations:**
1. Identify violation type
2. Check stack trace
3. Find violation location
4. Understand violation cause
5. Fix violation

**Violation Types:**
- **DiskReadViolation:** Disk read on main thread
- **DiskWriteViolation:** Disk write on main thread
- **NetworkViolation:** Network operation on main thread
- **ActivityLeakViolation:** Activity memory leak
- **SqliteObjectLeakViolation:** SQLite object leak

### StrictMode Best Practices

#### Development Use

**Development Guidelines:**
- Enable in debug builds only
- Use appropriate penalties
- Fix violations immediately
- Don't disable StrictMode

**Best Practices:**
- **Debug Only:** Enable only in debug builds
- **Appropriate Penalties:** Use appropriate penalties
- **Fix Violations:** Fix violations immediately
- **Don't Disable:** Don't disable StrictMode

#### Production Considerations

**Production:**
- Disable in production
- Use BuildConfig.DEBUG
- Don't ship with StrictMode enabled
- Performance impact

**Production Code:**
```java
if (BuildConfig.DEBUG) {
    // Enable StrictMode
    StrictMode.setThreadPolicy(...);
    StrictMode.setVmPolicy(...);
}
// Production: StrictMode disabled
```

### Advanced StrictMode Usage

#### Custom Slow Calls

**Custom Slow Calls:**
```java
// Detect slow operations
StrictMode.noteSlowCall("slow_operation");

// In code
public void slowOperation() {
    StrictMode.noteSlowCall("slow_operation");
    // ... slow operation ...
}
```

#### Custom Violations

**Custom Violations:**
```java
// Report custom violation
StrictMode.onViolation(new StrictMode.Violation() {
    @Override
    public void writeToParcel(Parcel dest, int flags) {
        // Custom violation data
    }
});
```

### StrictMode Integration

#### Integration with Testing

**Testing Integration:**
- Enable in tests
- Catch violations in tests
- Automated violation detection
- CI/CD integration

**Test Example:**
```java
@Before
public void setUp() {
    StrictMode.setThreadPolicy(new StrictMode.ThreadPolicy.Builder()
        .detectAll()
        .penaltyLog()
        .penaltyDeath()
        .build());
}
```

#### Integration with Profiling

**Profiling Integration:**
- Use with profilers
- Identify performance issues
- Correlate with profiling data
- Performance analysis

### Debugging with StrictMode

#### Common Violations

**Common Violations:**
- Disk I/O on main thread
- Network on main thread
- Activity leaks
- SQLite leaks
- Resource leaks

**Debugging Steps:**
1. Enable StrictMode
2. Run application
3. Check logcat for violations
4. Analyze stack traces
5. Fix violations

#### Violation Resolution

**Resolution Process:**
1. Identify violation
2. Understand cause
3. Move to background thread
4. Fix memory leaks
5. Verify fix

**Resolution Examples:**
- Move I/O to background thread
- Use async APIs
- Fix memory leaks
- Close resources properly

## Key Takeaways

1. **StrictMode** is a developer tool that detects and reports violations of best practices in Android applications, such as performing disk I/O or network operations on the main thread, leaking activities, and other performance and policy violations.

2. **StrictMode policies** include thread policy (detects main thread violations, disk I/O on main thread, network operations on main thread), VM policy (detects memory leaks, activity leaks, SQLite object leaks, resource leaks), and policy configuration.

3. **Enabling StrictMode** includes basic enablement (enable in Application.onCreate() or Activity.onCreate()), selective enablement (enable specific detections), and enablement methods.

4. **StrictMode configuration** includes thread policy configuration (detectDiskReads, detectDiskWrites, detectNetwork, detectCustomSlowCalls, detectAll), VM policy configuration (detectActivityLeaks, detectLeakedSqlLiteObjects, detectLeakedClosableObjects, detectAll), and configuration options.

5. **Penalties** include log penalty (logs violations to logcat, non-blocking), dialog penalty (shows violation dialog, blocks execution), death penalty (crashes application, most severe), flash penalty (flashes screen, visual indicator), and penalty types.

6. **Violation detection** includes disk I/O detection (detects disk reads/writes on main thread), network detection (detects network operations on main thread), activity leak detection (detects activity memory leaks), and detection examples.

7. **StrictMode reports** include logcat output (violation type, duration, stack trace, policy information), violation analysis (identify violation type, check stack trace, find violation location, understand violation cause, fix violation), and report formats.

8. **StrictMode best practices** include development use (enable in debug builds only, use appropriate penalties, fix violations immediately), production considerations (disable in production, use BuildConfig.DEBUG, don't ship with StrictMode enabled), and best practice guidelines.

9. **Understanding StrictMode** is essential for AOSP development, enabling performance issue identification, memory leak detection, best practice enforcement, and proper StrictMode usage.

## Related Topics

- **Handler/Looper deep dive:** Main thread details
- **Debugging ANR at framework level:** ANR debugging details
- **Performance profiling:** Performance analysis details

