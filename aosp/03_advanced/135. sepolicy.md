---
number: 135
title: sepolicy
slug: sepolicy
level: advanced
tags:
  - aosp
  - security
  - selinux
  - sepolicy
  - policy
  - security-policy
  - policy-compilation
prerequisites:
  - selinux-mandatory-access-control
  - selinux-overview
  - selinux-policy-initialization
estimated_minutes: 95
contributors: []
diagrams: []
examples: []
canonical_id: aosp-advanced-135
---

# sepolicy

## Overview

sepolicy (SELinux policy) is the security policy system that defines what actions processes can perform in Android. sepolicy consists of policy source files written in SELinux policy language, compiled to binary format, and loaded into the kernel to enforce security rules. Understanding sepolicy is essential for AOSP development, as it explains how SELinux policies are structured, how policies are written, how policies are compiled, how policies are loaded, and how policies enforce security. This guide provides a comprehensive overview of sepolicy, policy structure, policy files, policy syntax, policy compilation, policy loading, and policy management.

Think of sepolicy like a rulebook: just as a rulebook defines what actions are allowed or prohibited in a game, sepolicy defines what actions processes are allowed or prohibited to perform in Android, and these rules are enforced by the kernel to ensure security.

## Deep Explanation

### What is sepolicy?

sepolicy (SELinux policy) is the security policy system that defines what actions processes can perform in Android. sepolicy consists of policy source files written in SELinux policy language, compiled to binary format, and loaded into the kernel to enforce security rules.

**Key Characteristics:**
- **Policy-Based:** Security defined by policies
- **Compiled:** Source compiled to binary
- **Kernel-Loaded:** Loaded into kernel
- **Enforced:** Enforced by kernel
- **Fine-Grained:** Detailed security rules

**Why sepolicy?**
- **Security:** Defines security rules
- **Enforcement:** Enforced by kernel
- **Flexibility:** Can be updated
- **Auditability:** Policies are auditable

### Policy Structure

#### Policy Source Files

**Policy Source Files:**
- Written in SELinux policy language
- Located in `system/sepolicy/` or `device/*/sepolicy/`
- Organized into modules
- Compiled to binary format

**Policy File Organization:**
```
system/sepolicy/
├── private/          # Private policy files
├── public/           # Public policy files
├── vendor/           # Vendor policy files
├── product/          # Product policy files
└── ...
```

**Policy File Types:**
- **.te files:** Type enforcement rules
- **.fc files:** File contexts
- **.property_contexts:** Property contexts
- **.service_contexts:** Service contexts
- **.seapp_contexts:** App contexts

#### Policy Components

**Policy Components:**
- **Type Definitions:** Define types and domains
- **Access Rules:** Define allowed operations
- **File Contexts:** Map files to contexts
- **Property Contexts:** Map properties to contexts
- **Service Contexts:** Map services to contexts

**Component Examples:**
```
# Type definition
type untrusted_app, domain;

# Access rule
allow untrusted_app app_data_file:file { read write };

# File context
/data/data(/.*)? u:object_r:app_data_file:s0
```

### Policy Files

#### Type Enforcement Files (.te)

**Type Enforcement Files:**
- Define types and domains
- Define access rules
- Define domain transitions
- Primary policy files

**File Structure:**
```
# Type definition
type untrusted_app, domain;

# Domain attributes
app_domain(untrusted_app)

# Access rules
allow untrusted_app app_data_file:file { read write };
allow untrusted_app app_data_file:dir { add_name write };

# Domain transitions
type_transition zygote untrusted_app:process untrusted_app;
```

#### File Context Files (.fc)

**File Context Files:**
- Map file paths to SELinux contexts
- Used for filesystem labeling
- Applied during boot
- Format: `path_regex context [file_type]`

**File Structure:**
```
# System files
/system/bin/.* u:object_r:system_file:s0
/system/lib/.* u:object_r:system_file:s0

# App data
/data/data(/.*)? u:object_r:app_data_file:s0

# Vendor files
/vendor/bin/.* u:object_r:vendor_file:s0
```

#### Property Context Files

**Property Context Files:**
- Map system properties to contexts
- Control property access
- Format: `property_name context`

**File Structure:**
```
# System properties
ro.build.version.release u:object_r:system_prop:s0
persist.sys.timezone u:object_r:system_prop:s0

# Vendor properties
ro.vendor.build.version u:object_r:vendor_prop:s0
```

#### Service Context Files

**Service Context Files:**
- Map Binder service names to contexts
- Control service access
- Format: `service_name context`

**File Structure:**
```
# System services
activity u:object_r:activity_service:s0
window u:object_r:window_service:s0

# Vendor services
vendor_service u:object_r:vendor_service:s0
```

#### App Context Files (.seapp_contexts)

**App Context Files:**
- Map app attributes to contexts
- Determine app SELinux context
- Based on UID, package name, etc.

**File Structure:**
```
# App context mapping
user=_app seinfo=platform domain=untrusted_app type=app_data_file
user=_app seinfo=platform domain=untrusted_app type=app_data_file levelFrom=user
```

### Policy Syntax

#### Type Definitions

**Type Definitions:**
- Define types and domains
- Associate attributes
- Define type relationships

**Syntax:**
```
type <type_name>, <attribute1>, <attribute2>, ...;
```

**Examples:**
```
# Define type
type untrusted_app, domain;

# Define type with attributes
type app_data_file, file_type, data_file_type;
```

#### Access Rules

**Access Rules:**
- Define allowed operations
- Specify subject and object
- Specify permissions

**Syntax:**
```
allow <source_type> <target_type>:<class> { <permissions> };
```

**Examples:**
```
# File access
allow untrusted_app app_data_file:file { read write };

# Directory access
allow untrusted_app app_data_file:dir { add_name write };

# Socket access
allow untrusted_app socket:udp_socket { create bind };
```

#### Domain Transitions

**Domain Transitions:**
- Allow process to transition between domains
- Controlled by policy rules
- Used for privilege changes

**Syntax:**
```
type_transition <source_type> <target_type>:<class> <new_type>;
```

**Examples:**
```
# Domain transition
type_transition zygote untrusted_app:process untrusted_app;
```

### Policy Macros

#### Common Macros

**Common Macros:**
- Simplify policy writing
- Provide common patterns
- Reduce policy complexity

**Macro Examples:**
```
# App domain
app_domain(untrusted_app)

# Init daemon domain
init_daemon_domain(my_service)

# Read directory and file
r_dir_file(untrusted_app, app_data_file)

# Get property
get_prop(untrusted_app, system_prop)
```

#### Macro Definitions

**Macro Definitions:**
- Defined in policy files
- Expand to multiple rules
- Reusable policy patterns

**Macro Example:**
```
# Macro definition
define(`app_domain', `
    type $1, domain;
    # ... additional rules ...
')

# Macro usage
app_domain(untrusted_app)
```

### Policy Compilation

#### Compilation Process

**Compilation Process:**
- Source files compiled to binary
- Policy compiler processes files
- Binary policy created
- Loaded into kernel

**Compilation Steps:**
```
1. Parse policy source files
2. Resolve type definitions
3. Resolve access rules
4. Generate binary policy
5. Create policy file
```

#### Policy Compiler

**Policy Compiler:**
- `checkpolicy` or `sepolicy` tool
- Part of AOSP build system
- Compiles source to binary
- Validates policy syntax

**Compiler Usage:**
```bash
# Compile policy
checkpolicy -M -o sepolicy policy.conf

# Or use build system
m sepolicy
```

#### Binary Policy Format

**Binary Policy Format:**
- Binary format (not human-readable)
- Optimized for kernel loading
- Version-specific format
- Loaded directly into kernel

**Policy File:**
- Location: `/sepolicy` or `/system/etc/selinux/sepolicy`
- Format: Binary
- Size: Typically 500KB - 2MB
- Version: Policy version number

### Policy Loading

#### Loading Process

**Loading Process:**
- Policy loaded at boot time
- Loaded into kernel
- Applied to system
- Enforced immediately

**Loading Steps:**
```
1. Kernel boots
2. Init loads policy binary
3. Policy loaded into kernel
4. Filesystem labeled
5. Enforcement enabled
```

#### Policy Location

**Policy Location:**
- `/sepolicy` - Initramfs (primary)
- `/system/etc/selinux/sepolicy` - System partition
- `/vendor/etc/selinux/sepolicy` - Vendor partition
- `/product/etc/selinux/sepolicy` - Product partition

**Loading Order:**
1. Initramfs policy (early boot)
2. System policy (after system mount)
3. Vendor policy (after vendor mount)
4. Product policy (after product mount)

### Policy Management

#### Policy Updates

**Policy Updates:**
- Policies can be updated
- Requires policy reload
- May require reboot
- Version compatibility

**Update Process:**
```
1. Update policy source
2. Recompile policy
3. Update policy binary
4. Reload policy (or reboot)
```

#### Policy Versioning

**Policy Versioning:**
- Policies have version numbers
- Version compatibility checked
- Kernel enforces version
- Policy updates require version match

**Version Management:**
- Policy version in binary
- Kernel checks version
- Version mismatch prevents loading
- Version updates require kernel update

### Policy Best Practices

#### Policy Writing

**Best Practices:**
- Follow least privilege principle
- Use macros for common patterns
- Document policy rules
- Test policies thoroughly

**Writing Guidelines:**
- **Least Privilege:** Grant minimum permissions
- **Macros:** Use macros for patterns
- **Documentation:** Document policy rules
- **Testing:** Test policies before deployment

### Debugging sepolicy

#### Debugging Tools

**Debugging Tools:**
- Policy analysis tools
- Policy validation tools
- Policy inspection tools
- Violation logs

**Debugging Commands:**
```bash
# Check policy version
adb shell getenforce

# View policy info
adb shell sestatus

# Check policy file
adb shell ls -l /sepolicy

# View policy violations
adb shell dmesg | grep avc
```

#### Common Issues

**Common Issues:**
- Policy compilation errors
- Policy loading failures
- Policy version mismatches
- Access denied errors

**Debugging Steps:**
1. Check policy syntax
2. Verify policy compilation
3. Check policy version
4. Review policy violations
5. Verify policy loading

## Key Takeaways

1. **sepolicy** is the security policy system that defines what actions processes can perform in Android, consisting of policy source files, compiled binary, and kernel-loaded enforcement.

2. **Policy structure** includes policy source files (written in SELinux policy language, organized into modules), policy file organization, policy file types (.te, .fc, property_contexts, service_contexts, .seapp_contexts), and policy components (type definitions, access rules, file contexts).

3. **Policy files** include type enforcement files (.te - define types and domains, access rules, domain transitions), file context files (.fc - map file paths to contexts, used for filesystem labeling), property context files (map system properties to contexts, control property access), service context files (map Binder service names to contexts, control service access), and app context files (.seapp_contexts - map app attributes to contexts).

4. **Policy syntax** includes type definitions (define types and domains, associate attributes), access rules (define allowed operations, specify subject and object, specify permissions), domain transitions (allow process to transition between domains, controlled by policy rules), and syntax examples.

5. **Policy macros** include common macros (simplify policy writing, provide common patterns, reduce complexity), macro definitions (defined in policy files, expand to multiple rules, reusable patterns), and macro examples (app_domain, init_daemon_domain, r_dir_file, get_prop).

6. **Policy compilation** includes compilation process (source files compiled to binary, policy compiler processes files, binary policy created), policy compiler (checkpolicy or sepolicy tool, part of AOSP build system, compiles source to binary), binary policy format (binary format, optimized for kernel loading, version-specific), and compilation steps.

7. **Policy loading** includes loading process (policy loaded at boot time, loaded into kernel, applied to system, enforced immediately), policy location (/sepolicy, /system/etc/selinux/sepolicy, /vendor/etc/selinux/sepolicy), loading order (initramfs, system, vendor, product), and loading steps.

8. **Policy management** includes policy updates (policies can be updated, requires policy reload, may require reboot), policy versioning (policies have version numbers, version compatibility checked, kernel enforces version), and management characteristics.

9. **Understanding sepolicy** is essential for AOSP development, enabling security policy definition, policy enforcement, security rule management, and proper sepolicy architecture implementation.

## Related Topics

- **SELinux (Mandatory Access Control):** SELinux MAC details
- **domain, type enforcement rules:** Type enforcement details
- **file contexts:** File context details
- **audit logs:** SELinux audit logging
- **SELinux Policy Initialization:** Policy initialization process

