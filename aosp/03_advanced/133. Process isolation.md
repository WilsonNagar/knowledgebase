---
number: 133
title: Process isolation
slug: process-isolation
level: advanced
tags:
  - aosp
  - security
  - process-isolation
  - isolation
  - uid-gid
  - memory-isolation
prerequisites:
  - android-security-model
  - sandboxing
  - app-sandbox
  - android-architecture-complete-overview
estimated_minutes: 95
contributors: []
diagrams: []
examples: []
canonical_id: aosp-advanced-133
---

# Process isolation

## Overview

Process isolation is a security mechanism that ensures each Android application runs in its own isolated process with separate memory space, unique user ID (UID), isolated file system access, and independent execution context. Process isolation prevents applications from accessing each other's memory, files, or resources, providing security, privacy, and stability. Understanding process isolation is essential for AOSP development, as it explains how Android isolates processes, how UID/GID isolation works, how memory isolation is enforced, how file system isolation is maintained, and how process isolation provides security and stability. This guide provides a comprehensive overview of process isolation, isolation mechanisms, UID/GID isolation, memory isolation, file system isolation, and security enforcement.

Think of process isolation like separate apartments in a building: just as each apartment (process) has its own space, locks, and boundaries that prevent residents from accessing each other's apartments, each Android process has its own memory space, UID, and boundaries that prevent processes from accessing each other's memory, files, or resources.

## Deep Explanation

### What is Process Isolation?

Process isolation is a security mechanism that ensures each Android application runs in its own isolated process with separate memory space, unique user ID (UID), isolated file system access, and independent execution context. Process isolation prevents applications from accessing each other's memory, files, or resources.

**Key Characteristics:**
- **Separate Processes:** Each app runs in separate process
- **Isolated Memory:** Cannot access other process memory
- **Unique UID:** Each app has unique user ID
- **File System Isolation:** Isolated file access
- **Independent Execution:** Independent execution context

**Why Process Isolation?**
- **Security:** Prevents unauthorized access
- **Privacy:** Protects user data
- **Stability:** Isolates app failures
- **Resource Management:** Controls resource usage

### Isolation Mechanisms

#### Process Separation

**Process Separation:**
- Each app runs in separate process
- Isolated memory address space
- Isolated execution context
- Process-level security

**Separation Characteristics:**
- **Separate Process:** Cannot access other processes
- **Isolated Memory:** Cannot access other memory
- **Isolated Execution:** Independent execution
- **Security Context:** Isolated security context

#### UID/GID Isolation

**UID/GID Isolation:**
- Each app has unique UID
- File system access based on UID
- Process identification by UID
- Resource ownership by UID

**UID Assignment:**
```
System apps: UID < 10000
User apps: UID >= 10000
Shared UIDs: Multiple apps can share UID
```

**Isolation Mechanism:**
- Linux kernel enforces UID isolation
- File permissions based on UID
- Process ownership by UID
- Resource limits per UID

### Memory Isolation

#### Virtual Memory Isolation

**Virtual Memory Isolation:**
- Each process has separate virtual address space
- Memory protection prevents cross-process access
- Kernel enforces memory boundaries
- Memory isolation at hardware level

**Memory Protection:**
```
Process A: Virtual Address Space 0x00000000 - 0xFFFFFFFF
Process B: Virtual Address Space 0x00000000 - 0xFFFFFFFF
(Each process sees its own address space, cannot access others)
```

**Memory Isolation Benefits:**
- **Security:** Processes cannot access each other's memory
- **Stability:** App crashes don't affect other processes
- **Privacy:** Data isolated between processes
- **Resource Management:** Independent memory limits

#### Memory Protection Mechanisms

**Memory Protection:**
- Hardware memory management unit (MMU)
- Kernel page tables
- Memory access permissions
- Copy-on-write (COW) for shared memory

**Protection Implementation:**
- **MMU:** Hardware enforces memory protection
- **Page Tables:** Kernel manages page tables
- **Permissions:** Memory access permissions
- **COW:** Shared memory with copy-on-write

### File System Isolation

#### UID-Based File Isolation

**UID-Based File Isolation:**
- Each app has unique UID
- Files owned by app UID
- File permissions enforce isolation
- Other apps cannot access

**File Ownership:**
```
App files: /data/data/com.example.app/
Owner: UID 10000 (app's UID)
Group: GID 10000 (app's GID)
Permissions: 700 (owner read/write/execute only)
Other apps: Cannot access
```

**Isolation Enforcement:**
- Linux file permissions enforce isolation
- Kernel checks UID on file access
- Directory permissions enforce boundaries
- SELinux provides additional enforcement

#### Directory Isolation

**Directory Isolation:**
- Each app has isolated directory
- App files in `/data/data/<package>/`
- Directory permissions enforce isolation
- Other apps cannot access

**Directory Structure:**
```
/data/data/
├── com.example.app1/  (UID 10000)
│   ├── files/
│   ├── cache/
│   └── databases/
├── com.example.app2/  (UID 10001)
│   ├── files/
│   ├── cache/
│   └── databases/
└── ...
```

### Process Creation and Isolation

#### Process Creation

**Process Creation:**
- Zygote forks new process
- Process gets unique PID
- UID/GID assigned to process
- SELinux context assigned
- Memory space allocated

**Creation Process:**
```
1. Zygote receives fork request
2. Zygote forks new process
3. Process gets unique PID
4. UID/GID assigned to process
5. SELinux context assigned
6. Memory space allocated
7. Process ready
```

#### Process Specialization

**Process Specialization:**
- Forked process specialized for app
- Process name set to package name
- UID/GID set to app values
- SELinux context configured
- App classes loaded

**Specialization Steps:**
1. Set process name
2. Set UID/GID
3. Configure SELinux context
4. Load app-specific classes
5. Initialize app environment
6. Start app main method

### Security Enforcement

#### Kernel-Level Enforcement

**Kernel-Level Enforcement:**
- Process isolation enforced by kernel
- Memory protection enforced by kernel
- UID/GID isolation enforced by kernel
- System call filtering by kernel

**Enforcement Mechanisms:**
- **Process Isolation:** Kernel enforces
- **Memory Protection:** MMU enforces
- **UID/GID:** Kernel enforces
- **System Calls:** Kernel filters

#### File System Enforcement

**File System Enforcement:**
- File permissions enforce isolation
- Kernel checks UID on file access
- Directory permissions enforce boundaries
- SELinux provides additional enforcement

**Enforcement Mechanisms:**
- **File Permissions:** Linux permissions
- **UID Checks:** Kernel checks UID
- **Directory Permissions:** Directory isolation
- **SELinux:** Additional enforcement

### Inter-Process Communication

#### Secure IPC

**Secure IPC:**
- Processes communicate via IPC
- Binder IPC with permissions
- Intent-based communication
- Content providers with permissions

**IPC Mechanisms:**
- **Binder:** Primary IPC mechanism
- **Intents:** Intent-based communication
- **Content Providers:** Data sharing
- **Messenger:** Message passing

#### IPC Security

**IPC Security:**
- Permission checks on IPC
- Binder security enforcement
- Intent filtering
- Content provider permissions

**Security Mechanisms:**
- **Permission Checks:** Required for IPC
- **Binder Security:** Binder security enforcement
- **Intent Filtering:** Intent security
- **Content Provider Permissions:** Provider permissions

### Process Lifecycle

#### Process Creation

**Process Creation:**
- Created when app launched
- Zygote forks new process
- Process specialized for app
- App starts execution

**Creation Characteristics:**
- **Fork:** Zygote forks process
- **Specialization:** Process specialized
- **Initialization:** App initialized
- **Execution:** App starts

#### Process Runtime

**Process Runtime:**
- Process runs in isolation
- Memory isolated from other processes
- File access isolated
- Security maintained

**Runtime Characteristics:**
- **Isolation:** Maintained during runtime
- **Memory:** Isolated memory space
- **File Access:** Isolated file access
- **Security:** Security maintained

#### Process Termination

**Process Termination:**
- Process terminated when app closed
- Memory released
- File handles closed
- Resources cleaned up

**Termination Characteristics:**
- **Termination:** Process terminated
- **Cleanup:** Resources cleaned up
- **Memory:** Memory released
- **Files:** File handles closed

### Isolation Benefits

#### Security Benefits

**Security Benefits:**
- Prevents unauthorized access
- Isolates app failures
- Prevents privilege escalation
- Protects system integrity

**Security Features:**
- **Isolation:** Processes isolated
- **Access Control:** Permission-based access
- **Enforcement:** Multiple enforcement layers
- **Protection:** System and data protection

#### Privacy Benefits

**Privacy Benefits:**
- Protects user data
- Isolates app data
- Prevents data leakage
- User-controlled access

**Privacy Features:**
- **Data Isolation:** App data isolated
- **User Control:** User controls access
- **Data Protection:** Data protected
- **Privacy:** Privacy maintained

#### Stability Benefits

**Stability Benefits:**
- App crashes isolated
- System stability maintained
- Resource conflicts prevented
- Independent app execution

**Stability Features:**
- **Crash Isolation:** App crashes isolated
- **System Stability:** System remains stable
- **Resource Management:** Independent resources
- **Execution:** Independent execution

### Isolation Limitations

#### Shared Resources

**Shared Resources:**
- External storage
- Network access
- System services
- Hardware resources

**Shared Resource Access:**
- Permission-based access
- User-controlled access
- System-controlled access
- Controlled sharing

#### IPC Communication

**IPC Communication:**
- Processes can communicate via IPC
- Permission-based IPC
- Intent-based communication
- Controlled communication

### Debugging Process Isolation

#### Debugging Tools

**Debugging Tools:**
- Process inspection
- Memory inspection
- UID/GID inspection
- File system inspection
- SELinux logs

**Debugging Commands:**
```bash
# Check process UID
adb shell ps -u | grep <package-name>

# Check process memory
adb shell dumpsys meminfo <package-name>

# Check file permissions
adb shell ls -la /data/data/<package-name>/

# Check SELinux context
adb shell ps -Z | grep <package-name>
```

#### Common Issues

**Common Issues:**
- File access denied
- Memory access violations
- IPC communication failures
- SELinux violations
- Permission issues

**Debugging Steps:**
1. Check process UID/GID
2. Verify memory isolation
3. Check file permissions
4. Review SELinux context
5. Verify IPC permissions
6. Check process boundaries

## Key Takeaways

1. **Process isolation** is a security mechanism that ensures each Android application runs in its own isolated process with separate memory space, unique UID, isolated file system access, and independent execution context.

2. **Isolation mechanisms** include process separation (separate processes, isolated memory, isolated execution context), UID/GID isolation (unique UID per app, file system access based on UID, process identification by UID), and isolation characteristics.

3. **Memory isolation** includes virtual memory isolation (separate virtual address space, memory protection, kernel enforcement), memory protection mechanisms (MMU, page tables, memory access permissions, COW), and memory isolation benefits (security, stability, privacy, resource management).

4. **File system isolation** includes UID-based file isolation (unique UID, files owned by app UID, file permissions enforce isolation), directory isolation (isolated directory per app, directory permissions enforce isolation), and isolation enforcement (Linux file permissions, kernel UID checks, SELinux enforcement).

5. **Process creation and isolation** includes process creation (Zygote forks process, unique PID, UID/GID assigned, SELinux context assigned), process specialization (forked process specialized, process name set, UID/GID set, SELinux context configured), and creation characteristics.

6. **Security enforcement** includes kernel-level enforcement (process isolation, memory protection, UID/GID isolation, system call filtering), file system enforcement (file permissions, kernel UID checks, directory permissions, SELinux enforcement), and enforcement mechanisms.

7. **Inter-process communication** includes secure IPC (Binder IPC, Intent-based communication, Content providers, Messenger), IPC security (permission checks, Binder security, Intent filtering, Content provider permissions), and IPC mechanisms.

8. **Process lifecycle** includes process creation (created when app launched, Zygote forks, process specialized), process runtime (process runs in isolation, memory isolated, file access isolated), process termination (process terminated, memory released, resources cleaned up), and lifecycle characteristics.

9. **Isolation benefits** include security benefits (prevents unauthorized access, isolates app failures, prevents privilege escalation), privacy benefits (protects user data, isolates app data, prevents data leakage), stability benefits (app crashes isolated, system stability maintained, resource conflicts prevented), and benefit characteristics.

10. **Understanding process isolation** is essential for AOSP development, enabling application isolation, security enforcement, privacy protection, and proper isolation architecture implementation.

## Related Topics

- **Sandboxing:** General sandboxing concepts
- **App sandbox:** Application sandbox implementation
- **Android Security Model:** Overall security architecture
- **SELinux (Mandatory Access Control):** SELinux details

