---
number: 138
title: audit logs
slug: audit-logs
level: advanced
tags:
  - aosp
  - security
  - selinux
  - audit-logs
  - avc
  - violations
  - logging
  - debugging
prerequisites:
  - sepolicy
  - domain-type-enforcement-rules
  - file-contexts
  - selinux-overview
estimated_minutes: 95
contributors: []
diagrams: []
examples: []
canonical_id: aosp-advanced-138
---

# audit logs

## Overview

SELinux audit logs are security event logs that record SELinux access control decisions, including allowed and denied operations. Audit logs provide visibility into SELinux enforcement, helping developers and security administrators understand what operations are being allowed or denied, why they are being denied, and how to fix policy issues. Understanding audit logs is essential for AOSP development, as it explains how SELinux logs access decisions, how to read and interpret audit logs, how to use audit logs for debugging, how to analyze violations, and how to fix policy issues based on audit log information. This guide provides a comprehensive overview of audit logs, AVC messages, violation format, log locations, log analysis, and debugging techniques.

Think of audit logs like security camera recordings: just as security cameras record what happens in a building for later review, audit logs record what SELinux allows or denies for later analysis and debugging.

## Deep Explanation

### What are Audit Logs?

SELinux audit logs are security event logs that record SELinux access control decisions, including allowed and denied operations. Audit logs provide visibility into SELinux enforcement, helping developers and security administrators understand what operations are being allowed or denied, why they are being denied, and how to fix policy issues.

**Key Characteristics:**
- **Access Decisions:** Records access control decisions
- **Violations:** Logs denied operations
- **Allowed Operations:** Can log allowed operations
- **Debugging:** Used for debugging policy issues
- **Security:** Provides security visibility

**Why Audit Logs?**
- **Visibility:** Provides visibility into SELinux enforcement
- **Debugging:** Helps debug policy issues
- **Security:** Provides security audit trail
- **Compliance:** Supports security compliance

### AVC Messages

#### What are AVC Messages?

**AVC (Access Vector Cache) Messages:**
- SELinux access control decision messages
- Recorded when access is checked
- Include denied and allowed operations
- Primary audit log format

**AVC Message Characteristics:**
- **Access Decisions:** Record access control decisions
- **Denied Operations:** Log denied operations
- **Allowed Operations:** Can log allowed operations (with auditallow)
- **Detailed Information:** Include detailed access information

#### AVC Message Format

**AVC Message Format:**
```
avc: denied { permission } for pid=1234 comm="app_process" 
scontext=u:r:untrusted_app:s0:c512,c768 
tcontext=u:object_r:system_file:s0 
tclass=file permissive=0
```

**Format Components:**
- **avc:** Access Vector Cache identifier
- **denied/allowed:** Access decision
- **permission:** Operation attempted
- **pid:** Process ID
- **comm:** Command name
- **scontext:** Source context (process)
- **tcontext:** Target context (object)
- **tclass:** Object class
- **permissive:** Whether in permissive mode

### Violation Format

#### Denied Operation Format

**Denied Operation Format:**
```
avc: denied { read } for pid=1234 comm="app_process" 
scontext=u:r:untrusted_app:s0:c512,c768 
tcontext=u:object_r:system_file:s0 
tclass=file permissive=0
```

**Violation Components:**
- **Operation:** What was attempted (read, write, etc.)
- **Process:** Process attempting operation
- **Source Context:** Process SELinux context
- **Target Context:** Object SELinux context
- **Object Class:** Type of object (file, dir, etc.)

#### Allowed Operation Format

**Allowed Operation Format:**
```
avc: granted { read } for pid=1234 comm="app_process" 
scontext=u:r:untrusted_app:s0:c512,c768 
tcontext=u:object_r:app_data_file:s0 
tclass=file permissive=0
```

**Allowed Operation Components:**
- **Operation:** What was allowed
- **Process:** Process performing operation
- **Source Context:** Process SELinux context
- **Target Context:** Object SELinux context
- **Object Class:** Type of object

### Log Locations

#### Kernel Logs (dmesg)

**Kernel Logs:**
- SELinux messages in kernel log
- Accessed via `dmesg` command
- Includes AVC messages
- Kernel-level logging

**Accessing Kernel Logs:**
```bash
# View all SELinux messages
adb shell dmesg | grep avc

# View recent messages
adb shell dmesg -c | grep avc

# View with timestamps
adb shell dmesg -T | grep avc
```

#### Logcat

**Logcat:**
- Android log system
- Includes SELinux messages
- Accessed via `logcat` command
- Application-level logging

**Accessing Logcat:**
```bash
# View SELinux violations
adb logcat | grep avc

# View with timestamps
adb logcat -v time | grep avc

# Save to file
adb logcat | grep avc > violations.log
```

#### Audit Log Files

**Audit Log Files:**
- `/proc/kmsg` - Kernel messages
- `/sys/fs/selinux/avc/cache_stats` - AVC cache statistics
- Log files in `/data/misc/audit/` (if auditd enabled)

**Log File Access:**
```bash
# View kernel messages
adb shell cat /proc/kmsg | grep avc

# View AVC cache stats
adb shell cat /sys/fs/selinux/avc/cache_stats
```

### Log Analysis

#### Reading Violations

**Reading Violations:**
- Parse AVC message format
- Identify operation attempted
- Identify source and target contexts
- Understand why access was denied

**Analysis Steps:**
```
1. Read AVC message
2. Identify operation (read, write, etc.)
3. Identify source context (process domain)
4. Identify target context (object type)
5. Check policy for missing rule
6. Add policy if legitimate
```

#### Violation Analysis

**Violation Analysis:**
- Understand violation context
- Determine if violation is legitimate
- Identify missing policy rules
- Plan policy fixes

**Analysis Process:**
```
1. Understand what operation was attempted
2. Determine if operation should be allowed
3. Check if policy rule exists
4. Add policy rule if legitimate
5. Test policy fix
```

### Common Violation Patterns

#### File Access Violations

**File Access Violations:**
- Process trying to access file
- Missing policy rule for file access
- Common violation type

**Example:**
```
avc: denied { read } for pid=1234 
scontext=u:r:untrusted_app:s0 
tcontext=u:object_r:system_file:s0 
tclass=file
```

**Fix:**
```
# Add policy rule (if legitimate)
allow untrusted_app system_file:file { read };
```

#### Directory Access Violations

**Directory Access Violations:**
- Process trying to access directory
- Missing policy rule for directory access
- Common violation type

**Example:**
```
avc: denied { add_name } for pid=1234 
scontext=u:r:untrusted_app:s0 
tcontext=u:object_r:app_data_file:s0 
tclass=dir
```

**Fix:**
```
# Add policy rule
allow untrusted_app app_data_file:dir { add_name write };
```

#### Socket Access Violations

**Socket Access Violations:**
- Process trying to create/use socket
- Missing policy rule for socket access
- Common violation type

**Example:**
```
avc: denied { create } for pid=1234 
scontext=u:r:untrusted_app:s0 
tcontext=u:object_r:socket:s0 
tclass=udp_socket
```

**Fix:**
```
# Add policy rule
allow untrusted_app socket:udp_socket { create bind };
```

### Debugging with Audit Logs

#### Collecting Violations

**Collecting Violations:**
- Enable permissive mode for development
- Reproduce issue
- Collect all violations
- Analyze violations

**Collection Process:**
```bash
# Enable permissive mode
adb shell setenforce 0

# Clear logs
adb logcat -c
adb shell dmesg -c

# Reproduce issue
# ... run app, trigger violation ...

# Collect violations
adb logcat | grep avc > violations.log
adb shell dmesg | grep avc >> violations.log
```

#### Analyzing Violations

**Analyzing Violations:**
- Parse violation messages
- Group related violations
- Identify root causes
- Plan fixes

**Analysis Tools:**
```bash
# Use audit2allow to generate policy
audit2allow -i violations.log

# Review generated policy
# Add appropriate policies
# Test in enforcing mode
```

### audit2allow Tool

#### What is audit2allow?

**audit2allow:**
- Tool that generates policy rules from violations
- Analyzes audit logs
- Generates allow rules
- Helps fix policy issues

**Tool Characteristics:**
- **Analysis:** Analyzes violation logs
- **Generation:** Generates policy rules
- **Automation:** Automates policy generation
- **Review:** Requires manual review

#### Using audit2allow

**Using audit2allow:**
- Input violation logs
- Generate policy rules
- Review generated rules
- Add to policy

**Usage:**
```bash
# Generate policy from violations
audit2allow -i violations.log

# Output example:
# allow untrusted_app system_file:file { read };
# allow untrusted_app app_data_file:dir { add_name write };
```

**Important Notes:**
- Generated rules need review
- Not all violations should be allowed
- Security implications must be considered
- Test thoroughly after adding rules

### Audit Log Best Practices

#### Best Practices

**Best Practices:**
- Enable permissive mode for development
- Collect all violations before fixing
- Understand violations before fixing
- Add minimal policies needed
- Test in enforcing mode

**Practice Guidelines:**
- **Development:** Use permissive mode for development
- **Collection:** Collect all violations
- **Understanding:** Understand why violations occur
- **Minimal:** Add minimal policies needed
- **Testing:** Test in enforcing mode

### Debugging Techniques

#### Debugging Workflow

**Debugging Workflow:**
```
1. Enable permissive mode
2. Reproduce issue
3. Collect violations
4. Analyze violations
5. Generate policy rules (audit2allow)
6. Review and add policies
7. Test in enforcing mode
8. Verify fixes
```

#### Common Debugging Scenarios

**Scenario 1: App Cannot Access File**
```
1. Check violation log
2. Identify file access violation
3. Check if file has correct context
4. Add policy rule if legitimate
5. Test access
```

**Scenario 2: Service Cannot Start**
```
1. Check violation log
2. Identify service startup violations
3. Check service context
4. Add domain transition rules if needed
5. Test service startup
```

### Audit Log Tools

#### Command-Line Tools

**Command-Line Tools:**
- `dmesg` - Kernel messages
- `logcat` - Android logs
- `grep` - Filter logs
- `audit2allow` - Generate policies

**Tool Usage:**
```bash
# View violations
adb shell dmesg | grep avc
adb logcat | grep avc

# Generate policy
audit2allow -i violations.log

# Filter specific violations
adb logcat | grep "avc.*denied.*read"
```

## Key Takeaways

1. **Audit logs** are security event logs that record SELinux access control decisions, including allowed and denied operations, providing visibility into SELinux enforcement.

2. **AVC messages** include what are AVC messages (SELinux access control decision messages, recorded when access is checked), AVC message format (avc: denied/allowed { permission } for pid=... scontext=... tcontext=... tclass=...), and AVC message characteristics.

3. **Violation format** includes denied operation format (avc: denied { operation } with process and context information), allowed operation format (avc: granted { operation } with process and context information), and violation components (operation, process, source context, target context, object class).

4. **Log locations** include kernel logs (dmesg - SELinux messages in kernel log, accessed via dmesg command), logcat (Android log system, includes SELinux messages, accessed via logcat command), audit log files (/proc/kmsg, /sys/fs/selinux/avc/cache_stats, log files in /data/misc/audit/), and log file access.

5. **Log analysis** includes reading violations (parse AVC message format, identify operation attempted, identify source and target contexts), violation analysis (understand violation context, determine if violation is legitimate, identify missing policy rules, plan policy fixes), and analysis steps.

6. **Common violation patterns** include file access violations (process trying to access file, missing policy rule for file access), directory access violations (process trying to access directory, missing policy rule for directory access), socket access violations (process trying to create/use socket, missing policy rule for socket access), and violation examples and fixes.

7. **Debugging with audit logs** includes collecting violations (enable permissive mode, reproduce issue, collect all violations), analyzing violations (parse violation messages, group related violations, identify root causes, plan fixes), and debugging workflow.

8. **audit2allow tool** includes what is audit2allow (tool that generates policy rules from violations, analyzes audit logs, generates allow rules), using audit2allow (input violation logs, generate policy rules, review generated rules, add to policy), and important notes (generated rules need review, not all violations should be allowed, security implications must be considered).

9. **Understanding audit logs** is essential for AOSP development, enabling SELinux debugging, policy issue identification, security audit trail, and proper SELinux audit log usage.

## Related Topics

- **sepolicy:** SELinux policy details
- **domain, type enforcement rules:** Type enforcement details
- **file contexts:** File context details
- **SELinux (Mandatory Access Control):** SELinux MAC details

