---
number: 172
title: Pre-installation verification
slug: pre-installation-verification
level: advanced
tags:
  - aosp
  - apex
  - verification
  - security
  - package-verification
  - signature
prerequisites:
  - apex-package-structure
  - mainline-modules-apex-apks-in-system
  - verified-boot-avb
estimated_minutes: 95
contributors: []
diagrams: []
examples: []
canonical_id: aosp-advanced-172
---

# Pre-installation verification

## Overview

Pre-installation verification refers to the security checks performed on APEX packages before they are installed on an Android device. These verification steps ensure package integrity, authenticity, and compatibility before installation. Understanding pre-installation verification is essential for AOSP development, as it explains how APEX packages are verified, what checks are performed, how signatures are validated, how integrity is verified, and how verification ensures system security. This guide provides a comprehensive overview of pre-installation verification, verification steps, signature verification, integrity checks, compatibility verification, and verification failure handling.

Think of pre-installation verification like airport security checks: just as airport security verifies your identity (signature verification), checks your luggage (integrity verification), and ensures you have proper documentation (compatibility verification) before allowing you to board, pre-installation verification verifies APEX package signatures, checks package integrity, and ensures compatibility before allowing installation on the device.

## Deep Explanation

### What is Pre-installation Verification?

Pre-installation verification refers to the security checks performed on APEX packages before they are installed on an Android device. These verification steps ensure package security and compatibility.

**Key Characteristics:**
- **Security Checks:** Multiple security checks
- **Before Installation:** Performed before installation
- **Comprehensive:** Covers multiple aspects
- **Fail-Safe:** Prevents installation on failure
- **Automated:** Automated verification process

**Why Pre-installation Verification?**
- **Security:** Ensures package security
- **Integrity:** Verifies package integrity
- **Authenticity:** Verifies package authenticity
- **Compatibility:** Ensures compatibility

### Verification Process

#### Verification Steps

**Verification Sequence:**
```
1. Signature Verification
   ↓
2. Integrity Verification
   ↓
3. Manifest Verification
   ↓
4. Compatibility Verification
   ↓
5. Dependency Verification
   ↓
6. Installation Allowed
```

**Verification Characteristics:**
- Sequential verification
- Each step must pass
- Fail-safe mechanism
- Comprehensive checks

#### Verification Flow

**Verification Flow:**
```
Package Received
    ↓
Signature Verification
    ↓ (if valid)
Integrity Verification
    ↓ (if valid)
Manifest Verification
    ↓ (if valid)
Compatibility Verification
    ↓ (if valid)
Dependency Verification
    ↓ (if valid)
Installation Proceeds
```

**Flow Characteristics:**
- Sequential flow
- Fail-safe
- Early failure detection
- Comprehensive verification

### Signature Verification

#### Signature Check

**Signature Verification:**
- Verify package signature
- Verify certificate chain
- Check certificate validity
- Verify signing key

**Verification Steps:**
```
1. Read META-INF/CERT.RSA
2. Extract certificate
3. Verify certificate chain
4. Check certificate validity
5. Verify signature with public key
6. Check signing key authorization
```

**Verification Characteristics:**
- Cryptographic verification
- Certificate chain validation
- Key authorization check
- Signature validation

#### Certificate Validation

**Certificate Checks:**
- Certificate not expired
- Certificate not revoked
- Certificate chain valid
- Certificate trusted

**Validation Characteristics:**
- Expiration checking
- Revocation checking
- Chain validation
- Trust verification

### Integrity Verification

#### Hash Verification

**Hash Verification:**
- Calculate package hashes
- Compare with stored hashes
- Verify file integrity
- Check for tampering

**Verification Steps:**
```
1. Read META-INF/MANIFEST.MF
2. Extract file hashes
3. Calculate current file hashes
4. Compare hashes
5. Verify match
```

**Verification Characteristics:**
- Hash calculation
- Hash comparison
- Integrity checking
- Tamper detection

#### File Integrity

**File Integrity Checks:**
- All files present
- File sizes correct
- File hashes match
- No corruption detected

**Integrity Characteristics:**
- File presence check
- Size verification
- Hash matching
- Corruption detection

### Manifest Verification

#### Manifest Validation

**Manifest Verification:**
- Parse manifest files
- Validate manifest structure
- Check required fields
- Verify manifest integrity

**Verification Steps:**
```
1. Parse AndroidManifest.xml
2. Parse apex_manifest.pb
3. Validate structure
4. Check required fields
5. Verify field values
```

**Verification Characteristics:**
- Structure validation
- Field validation
- Value verification
- Integrity checking

#### Field Validation

**Field Checks:**
- Required fields present
- Field values valid
- Field formats correct
- Field constraints satisfied

**Validation Characteristics:**
- Presence checking
- Value validation
- Format checking
- Constraint verification

### Compatibility Verification

#### Version Compatibility

**Version Checks:**
- Android version compatibility
- API level compatibility
- Module version compatibility
- Version requirements satisfied

**Compatibility Characteristics:**
- Version matching
- API level checking
- Module version checking
- Requirement satisfaction

#### System Compatibility

**System Checks:**
- Device compatibility
- Architecture compatibility
- Feature compatibility
- Hardware compatibility

**Compatibility Characteristics:**
- Device matching
- Architecture checking
- Feature verification
- Hardware verification

### Dependency Verification

#### Dependency Checks

**Dependency Verification:**
- Required modules present
- Module versions compatible
- Native libraries available
- Dependencies satisfied

**Verification Steps:**
```
1. Read dependency list
2. Check required modules
3. Verify module versions
4. Check native libraries
5. Verify all dependencies
```

**Verification Characteristics:**
- Module checking
- Version verification
- Library verification
- Dependency satisfaction

#### Dependency Resolution

**Resolution Process:**
- Identify dependencies
- Check availability
- Verify compatibility
- Resolve conflicts

**Resolution Characteristics:**
- Dependency identification
- Availability checking
- Compatibility verification
- Conflict resolution

### Verification Failure Handling

#### Failure Detection

**Failure Detection:**
- Verification failures detected immediately
- Failures logged for debugging
- Failures prevent installation
- Failures reported to user

**Failure Characteristics:**
- Immediate detection
- Logging for debugging
- Installation prevention
- User notification

#### Failure Types

**Failure Categories:**
- **Signature Failure:** Invalid signature
- **Integrity Failure:** Package corrupted
- **Manifest Failure:** Invalid manifest
- **Compatibility Failure:** Incompatible package
- **Dependency Failure:** Missing dependencies

**Failure Handling:**
- Specific error messages
- Failure logging
- Installation prevention
- User notification

### Verification Security

#### Security Measures

**Security Features:**
- Cryptographic signatures
- Hash verification
- Certificate validation
- Integrity checking

**Security Characteristics:**
- Strong cryptography
- Multiple verification layers
- Fail-safe mechanism
- Comprehensive security

#### Security Benefits

**Security Benefits:**
- Prevents malicious packages
- Ensures package integrity
- Verifies package authenticity
- Protects system security

**Benefit Details:**
- Malware prevention
- Integrity protection
- Authenticity verification
- System protection

### Verification Best Practices

#### Best Practices

**Best Practices:**
- Verify all packages
- Use strong signatures
- Check all verification steps
- Log verification results
- Handle failures properly

**Practice Guidelines:**
- **Verification:** Verify all packages
- **Signatures:** Use strong signatures
- **Checks:** Check all verification steps
- **Logging:** Log verification results
- **Handling:** Handle failures properly

## Key Takeaways

1. **Pre-installation verification** refers to the security checks performed on APEX packages before they are installed on an Android device, ensuring package security and compatibility.

2. **Verification process** includes verification steps (signature verification, integrity verification, manifest verification, compatibility verification, dependency verification), verification flow (sequential flow, fail-safe mechanism, early failure detection, comprehensive verification), and process characteristics.

3. **Signature verification** includes signature check (verify package signature, verify certificate chain, check certificate validity, verify signing key), certificate validation (certificate not expired, certificate not revoked, certificate chain valid, certificate trusted), and verification characteristics.

4. **Integrity verification** includes hash verification (calculate package hashes, compare with stored hashes, verify file integrity, check for tampering), file integrity (all files present, file sizes correct, file hashes match, no corruption detected), and integrity characteristics.

5. **Manifest verification** includes manifest validation (parse manifest files, validate manifest structure, check required fields, verify manifest integrity), field validation (required fields present, field values valid, field formats correct, field constraints satisfied), and validation characteristics.

6. **Compatibility verification** includes version compatibility (Android version compatibility, API level compatibility, module version compatibility, version requirements satisfied), system compatibility (device compatibility, architecture compatibility, feature compatibility, hardware compatibility), and compatibility characteristics.

7. **Dependency verification** includes dependency checks (required modules present, module versions compatible, native libraries available, dependencies satisfied), dependency resolution (identify dependencies, check availability, verify compatibility, resolve conflicts), and verification characteristics.

8. **Verification failure handling** includes failure detection (verification failures detected immediately, failures logged for debugging, failures prevent installation, failures reported to user), failure types (signature failure, integrity failure, manifest failure, compatibility failure, dependency failure), and failure handling.

9. **Understanding pre-installation verification** is essential for AOSP development, enabling package security, system protection, compatibility assurance, and proper verification implementation.

## Related Topics

- **APEX package structure:** Package structure details
- **Verified Boot (AVB):** Verification details
- **ADB installation of APEX:** Installation details

