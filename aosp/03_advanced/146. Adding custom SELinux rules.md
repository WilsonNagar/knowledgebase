---
number: 146
title: Adding custom SELinux rules
slug: adding-custom-selinux-rules
level: advanced
tags:
  - aosp
  - security
  - selinux
  - custom-selinux-rules
  - sepolicy-customization
  - selinux-policy-development
prerequisites:
  - sepolicy
  - domain-type-enforcement-rules
  - file-contexts
  - selinux-overview
estimated_minutes: 95
contributors: []
diagrams: []
examples: []
canonical_id: aosp-advanced-146
---

# Adding custom SELinux rules

## Overview

Adding custom SELinux rules involves creating, modifying, and managing custom SELinux policy rules to meet specific security requirements, enable new functionality, or fix policy issues. Custom SELinux rules allow developers to extend the default SELinux policy with device-specific or application-specific rules. Understanding how to add custom SELinux rules is essential for AOSP development, as it explains how to create custom policy rules, how to modify existing policies, how to add new types and domains, how to define access rules, how to test custom rules, and how to integrate custom rules into the build system. This guide provides a comprehensive overview of adding custom SELinux rules, policy file structure, rule creation, policy modification, testing custom rules, and rule integration.

Think of adding custom SELinux rules like adding custom security rules to a building: just as a building might have custom security rules for specific areas or situations (custom access controls, special permissions, area-specific rules), custom SELinux rules allow you to add specific security rules for your device or application needs.

## Deep Explanation

### What are Custom SELinux Rules?

Custom SELinux rules are SELinux policy rules that extend or modify the default SELinux policy to meet specific security requirements, enable new functionality, or fix policy issues. Custom rules allow developers to add device-specific or application-specific security policies.

**Key Characteristics:**
- **Custom:** Custom policy rules
- **Extensible:** Extend default policy
- **Device-Specific:** Device-specific rules
- **Application-Specific:** Application-specific rules
- **Configurable:** Configurable security policies

**Why Custom SELinux Rules?**
- **Customization:** Customize security policies
- **Functionality:** Enable new functionality
- **Fixes:** Fix policy issues
- **Requirements:** Meet specific requirements

### Policy File Structure

#### Policy File Organization

**Policy File Organization:**
- System policy: `system/sepolicy/`
- Device policy: `device/*/sepolicy/`
- Vendor policy: `vendor/*/sepolicy/`
- Product policy: `product/*/sepolicy/`

**File Organization:**
```
system/sepolicy/
├── private/          # Private policy files
├── public/           # Public policy files
└── ...

device/*/sepolicy/
├── private/          # Device private policy
├── public/           # Device public policy
└── ...
```

#### Policy File Types

**Policy File Types:**
- **.te files:** Type enforcement rules
- **.fc files:** File contexts
- **.property_contexts:** Property contexts
- **.service_contexts:** Service contexts
- **.seapp_contexts:** App contexts

### Creating Custom Rules

#### Type Definitions

**Type Definitions:**
- Define new types for files
- Define new domains for processes
- Associate types with attributes
- Define type relationships

**Type Definition Example:**
```
# Define new file type
type my_custom_file, file_type, data_file_type;

# Define new process domain
type my_custom_service, domain;
init_daemon_domain(my_custom_service)
```

#### Access Rules

**Access Rules:**
- Define allowed operations
- Specify source and target
- Specify permissions
- Control access

**Access Rule Example:**
```
# Allow custom service to read custom file
allow my_custom_service my_custom_file:file { read };

# Allow app to access custom service
allow untrusted_app my_custom_service:binder { call };
```

#### File Contexts

**File Contexts:**
- Map file paths to contexts
- Label files with types
- Define file contexts
- Apply contexts to files

**File Context Example:**
```
# Label custom file
/data/myapp/config.txt u:object_r:my_custom_file:s0

# Label custom directory
/data/myapp(/.*)? u:object_r:my_custom_file:s0
```

### Policy Modification

#### Modifying Existing Rules

**Modifying Existing Rules:**
- Extend existing types
- Add new access rules
- Modify file contexts
- Update service contexts

**Modification Techniques:**
- **Type Extension:** Extend existing types
- **Rule Addition:** Add new access rules
- **Context Updates:** Update file contexts
- **Service Updates:** Update service contexts

#### Policy Inheritance

**Policy Inheritance:**
- Inherit from system policy
- Extend system types
- Use system macros
- Build on existing policies

**Inheritance Characteristics:**
- **System Policy:** Inherit from system policy
- **Type Extension:** Extend system types
- **Macro Usage:** Use system macros
- **Policy Building:** Build on existing policies

### Custom Rule Examples

#### Example 1: Custom Service

**Custom Service Example:**
```
# Define service type
type my_service, domain;
init_daemon_domain(my_service)

# Allow service to read config
allow my_service my_config_file:file { read };

# Allow apps to call service
allow untrusted_app my_service:binder { call };

# Service context
my_service u:object_r:my_service:s0
```

#### Example 2: Custom File Access

**Custom File Access Example:**
```
# Define file type
type my_config_file, file_type;

# File context
/data/myapp/config.txt u:object_r:my_config_file:s0

# Allow app to read
allow untrusted_app my_config_file:file { read };
```

#### Example 3: Custom Domain Transition

**Custom Domain Transition Example:**
```
# Define domain
type my_app_domain, domain;
app_domain(my_app_domain)

# Domain transition
type_transition zygote my_app_domain:process my_app_domain;
allow zygote my_app_domain:process { transition };
```

### Policy Testing

#### Testing Custom Rules

**Testing Custom Rules:**
- Test in permissive mode first
- Collect violations
- Fix violations
- Test in enforcing mode

**Testing Process:**
```
1. Set permissive mode
2. Test functionality
3. Collect violations
4. Fix violations
5. Test in enforcing mode
6. Verify functionality
```

#### Violation Analysis

**Violation Analysis:**
- Parse violation logs
- Identify missing rules
- Generate policy rules
- Review and add rules

**Analysis Process:**
- **Parse Logs:** Parse violation logs
- **Identify Rules:** Identify missing rules
- **Generate Rules:** Generate policy rules
- **Review Rules:** Review and add rules

### Policy Integration

#### Build System Integration

**Build System Integration:**
- Add policy files to build
- Compile with system policy
- Include in build output
- Test in build

**Integration Process:**
```
1. Add policy files to device sepolicy
2. Build system compiles policies
3. Policies included in build
4. Test on device
```

#### Policy Compilation

**Policy Compilation:**
- Policies compiled to binary
- Merged with system policy
- Loaded at boot time
- Enforced by kernel

**Compilation Process:**
- **Source to Binary:** Compiled to binary
- **Policy Merging:** Merged with system policy
- **Boot Loading:** Loaded at boot time
- **Kernel Enforcement:** Enforced by kernel

### Custom Rule Best Practices

#### Best Practices

**Best Practices:**
- Follow least privilege principle
- Use specific rules
- Document custom rules
- Test thoroughly

**Practice Guidelines:**
- **Least Privilege:** Follow least privilege
- **Specificity:** Use specific rules
- **Documentation:** Document custom rules
- **Testing:** Test thoroughly

### Debugging Custom Rules

#### Debugging Tools

**Debugging Tools:**
- SELinux logs
- Policy analysis tools
- Violation logs
- Policy inspection tools

**Debugging Commands:**
```bash
# View violations
adb shell dmesg | grep avc

# Check policy
adb shell sesearch -A -s my_service -t my_file

# View file contexts
adb shell ls -Z /data/myapp/

# Check process context
adb shell ps -Z | grep my_service
```

#### Common Issues

**Common Issues:**
- Policy compilation errors
- Missing access rules
- Incorrect file contexts
- Domain transition failures

**Debugging Steps:**
1. Check policy syntax
2. Review violation logs
3. Verify file contexts
4. Check domain transitions
5. Test in permissive mode
6. Test in enforcing mode

## Key Takeaways

1. **Adding custom SELinux rules** involves creating, modifying, and managing custom SELinux policy rules to meet specific security requirements, enable new functionality, or fix policy issues.

2. **Policy file structure** includes policy file organization (system policy, device policy, vendor policy, product policy), policy file types (.te files, .fc files, property_contexts, service_contexts, .seapp_contexts), and file organization.

3. **Creating custom rules** includes type definitions (define new types for files, define new domains for processes, associate types with attributes), access rules (define allowed operations, specify source and target, specify permissions), file contexts (map file paths to contexts, label files with types), and rule examples.

4. **Policy modification** includes modifying existing rules (extend existing types, add new access rules, modify file contexts), policy inheritance (inherit from system policy, extend system types, use system macros), and modification techniques.

5. **Custom rule examples** include custom service example (define service type, allow service operations, allow app access), custom file access example (define file type, file context, allow app access), custom domain transition example (define domain, domain transition), and example implementations.

6. **Policy testing** includes testing custom rules (test in permissive mode first, collect violations, fix violations, test in enforcing mode), violation analysis (parse violation logs, identify missing rules, generate policy rules), and testing process.

7. **Policy integration** includes build system integration (add policy files to build, compile with system policy, include in build output), policy compilation (policies compiled to binary, merged with system policy, loaded at boot time), and integration process.

8. **Custom rule best practices** include best practices (follow least privilege principle, use specific rules, document custom rules, test thoroughly), practice guidelines, and implementation practices.

9. **Understanding adding custom SELinux rules** is essential for AOSP development, enabling policy customization, functionality enablement, policy fixes, and proper custom SELinux rule implementation.

## Related Topics

- **sepolicy:** SELinux policy details
- **domain, type enforcement rules:** Type enforcement details
- **file contexts:** File context details
- **Hardening the OS:** OS hardening details

