---
number: 130
title: Android Security Model
slug: android-security-model
level: advanced
tags:
  - aosp
  - security
  - android-security
  - security-model
  - sandboxing
  - access-control
prerequisites:
  - android-architecture-complete-overview
  - permissions-system
  - selinux-overview
estimated_minutes: 95
contributors: []
diagrams: []
examples: []
canonical_id: aosp-advanced-130
---

# Android Security Model

## Overview

The Android Security Model is a multi-layered security architecture that protects the Android system, user data, and applications through process isolation, permission-based access control, application sandboxing, SELinux enforcement, and various security mechanisms. Understanding the Android Security Model is essential for AOSP development, as it explains how Android provides security, how different security layers work together, how process isolation is achieved, how permissions enforce access control, how sandboxing protects apps, and how the overall security architecture operates. This guide provides a comprehensive overview of the Android Security Model, security layers, process isolation, permission system, application sandbox, SELinux integration, and security mechanisms.

Think of the Android Security Model like a multi-layered security system: just as a building might have multiple security layers (guards at entrance, keycard access, security cameras, alarm systems), Android has multiple security layers (process isolation, permissions, sandboxing, SELinux) that work together to provide comprehensive security protection.

## Deep Explanation

### What is the Android Security Model?

The Android Security Model is a multi-layered security architecture that protects the Android system, user data, and applications through process isolation, permission-based access control, application sandboxing, SELinux enforcement, and various security mechanisms working together to provide comprehensive security.

**Key Characteristics:**
- **Multi-Layered:** Multiple security layers
- **Defense in Depth:** Multiple security mechanisms
- **Process Isolation:** Apps isolated from each other
- **Permission-Based:** Permission-based access control
- **SELinux:** Mandatory access control

**Why Android Security Model?**
- **Protection:** Protects system and user data
- **Isolation:** Isolates apps from each other
- **Access Control:** Controls resource access
- **Security:** Provides comprehensive security

### Security Layers

#### Layer 1: Linux Kernel Security

**Linux Kernel Security:**
- Process isolation via UID/GID
- File system permissions
- Network isolation
- Resource limits

**Kernel Security Features:**
- **UID/GID:** Each app has unique UID
- **File Permissions:** File system access control
- **Process Isolation:** Process-level isolation
- **Resource Limits:** CPU, memory limits

#### Layer 2: Application Sandbox

**Application Sandbox:**
- Isolated execution environment
- Restricted system access
- Permission-based access control
- Secure inter-process communication

**Sandbox Characteristics:**
- **Isolation:** Apps isolated from each other
- **Restricted Access:** Limited system access
- **Permission-Based:** Access via permissions
- **Secure IPC:** Secure communication

#### Layer 3: Permission System

**Permission System:**
- Permission-based access control
- User-controlled permissions
- Runtime permission requests
- Fine-grained control

**Permission System Features:**
- **Access Control:** Controls resource access
- **User Control:** User controls permissions
- **Runtime Requests:** Runtime permission model
- **Fine-Grained:** Per-permission control

#### Layer 4: SELinux

**SELinux (Security-Enhanced Linux):**
- Mandatory access control
- Fine-grained permissions
- Policy enforcement
- Prevents privilege escalation

**SELinux Features:**
- **MAC:** Mandatory access control
- **Fine-Grained:** Detailed permissions
- **Policy-Based:** Policy enforcement
- **Privilege Prevention:** Prevents escalation

### Process Isolation

#### Linux UID/GID Isolation

**UID/GID Isolation:**
- Each app has unique UID
- File system isolation
- Process-level security
- Resource isolation

**Isolation Mechanism:**
```
App A: UID 10000
App B: UID 10001
App C: UID 10002

Each app can only access its own files
```

#### Process Separation

**Process Separation:**
- Each app runs in separate process
- Isolated memory space
- Isolated file system
- Isolated network

**Separation Benefits:**
- **Security:** Apps cannot access each other
- **Stability:** App crashes don't affect others
- **Privacy:** Data isolated between apps
- **Resource Management:** Independent resource limits

### Application Sandbox

#### Sandbox Concept

**Application Sandbox:**
- Isolated execution environment
- Restricted system access
- Permission-based access
- Secure boundaries

**Sandbox Characteristics:**
- **Isolation:** Isolated from other apps
- **Restricted:** Limited system access
- **Permission-Based:** Access via permissions
- **Secure:** Secure boundaries

#### Sandbox Implementation

**Sandbox Implementation:**
- UID/GID isolation
- File system isolation
- Network isolation
- Permission enforcement

**Implementation Details:**
```java
// App sandbox
- App runs as unique UID
- App files in /data/data/<package>/
- App cannot access other app files
- App access controlled by permissions
```

### Permission-Based Access Control

#### Permission System

**Permission System:**
- Controls access to resources
- User-controlled grants
- Runtime permission model
- Fine-grained control

**Permission Control:**
- **Resource Access:** Controls resource access
- **User Control:** User grants permissions
- **Runtime Model:** Runtime permission requests
- **Fine-Grained:** Per-permission control

#### Permission Enforcement

**Permission Enforcement:**
- Framework-level enforcement
- System service enforcement
- Automatic enforcement
- Consistent across system

**Enforcement Points:**
- Framework API calls
- System service calls
- Component access
- Resource access

### SELinux Integration

#### SELinux Role

**SELinux Role:**
- Mandatory access control
- Fine-grained permissions
- Policy enforcement
- Additional security layer

**SELinux Features:**
- **MAC:** Mandatory access control
- **Fine-Grained:** Detailed permissions
- **Policy-Based:** Policy enforcement
- **Privilege Prevention:** Prevents escalation

#### SELinux Contexts

**SELinux Contexts:**
- Process contexts
- File contexts
- Object contexts
- Access control decisions

**Context Format:**
```
u:r:untrusted_app:s0
│ │ │              │
│ │ │              └─ MLS level
│ │ └─────────────── Domain
│ └───────────────── Role
└─────────────────── User
```

### Security Mechanisms

#### Verified Boot

**Verified Boot:**
- Verifies system integrity
- Chain of trust
- Prevents tampering
- Secure boot process

**Verified Boot Features:**
- **Integrity:** Verifies system integrity
- **Chain of Trust:** Boot chain verification
- **Tamper Prevention:** Prevents tampering
- **Secure Boot:** Secure boot process

#### Encryption

**Encryption:**
- Data encryption
- File-based encryption
- Full disk encryption
- Key management

**Encryption Features:**
- **Data Protection:** Encrypts user data
- **File Encryption:** Per-file encryption
- **Full Disk:** Full disk encryption
- **Key Management:** Secure key management

### Defense in Depth

#### Multiple Security Layers

**Defense in Depth:**
- Multiple security layers
- Redundant protection
- Comprehensive security
- Layered defense

**Security Layers:**
1. **Linux Kernel:** Process isolation, file permissions
2. **Application Sandbox:** Isolated execution
3. **Permission System:** Access control
4. **SELinux:** Mandatory access control
5. **Verified Boot:** System integrity
6. **Encryption:** Data protection

#### Layer Coordination

**Layer Coordination:**
- Layers work together
- Complementary protection
- Comprehensive security
- Coordinated enforcement

**Coordination Example:**
```
App tries to access resource:
1. Linux kernel checks UID/GID
2. Application sandbox checks isolation
3. Permission system checks permission
4. SELinux checks policy
5. Access granted/denied
```

### Security Policies

#### Policy Types

**Security Policies:**
- Permission policies
- SELinux policies
- App policies
- System policies

**Policy Enforcement:**
- System-wide policies
- Per-app policies
- User preferences
- System restrictions

### Security Best Practices

#### Development Best Practices

**Best Practices:**
- Follow security guidelines
- Use permissions properly
- Validate inputs
- Secure communication
- Handle sensitive data carefully

**Security Guidelines:**
- **Least Privilege:** Grant minimum permissions
- **Input Validation:** Validate all inputs
- **Secure Communication:** Use secure channels
- **Data Protection:** Protect sensitive data

### Debugging Security Model

#### Debugging Tools

**Debugging Tools:**
- Security dumps
- Permission dumps
- SELinux logs
- Process inspection

**Debugging Commands:**
```bash
# Check SELinux status
adb shell getenforce

# Check app UID
adb shell dumpsys package <package-name> | grep userId

# Check permissions
adb shell dumpsys package <package-name> | grep permission

# Check SELinux context
adb shell ps -Z | grep <package-name>
```

#### Common Issues

**Common Issues:**
- Permission denied
- SELinux violations
- Sandbox violations
- Security policy issues

**Debugging Steps:**
1. Check permission state
2. Verify SELinux context
3. Review security logs
4. Check sandbox isolation
5. Verify security policies

## Key Takeaways

1. **Android Security Model** is a multi-layered security architecture that protects the Android system, user data, and applications through multiple security mechanisms working together.

2. **Security layers** include Linux kernel security (process isolation, file permissions), application sandbox (isolated execution, restricted access), permission system (access control, user control), and SELinux (mandatory access control, fine-grained permissions).

3. **Process isolation** includes Linux UID/GID isolation (each app unique UID, file system isolation), process separation (separate processes, isolated memory, isolated file system), and isolation benefits (security, stability, privacy, resource management).

4. **Application sandbox** includes sandbox concept (isolated execution environment, restricted system access), sandbox implementation (UID/GID isolation, file system isolation, network isolation, permission enforcement), and sandbox characteristics (isolation, restricted, permission-based, secure).

5. **Permission-based access control** includes permission system (controls resource access, user-controlled grants, runtime model), permission enforcement (framework-level, system service-level, automatic, consistent), and enforcement points (framework APIs, system services, component access, resource access).

6. **SELinux integration** includes SELinux role (mandatory access control, fine-grained permissions, policy enforcement), SELinux contexts (process contexts, file contexts, object contexts), and SELinux features (MAC, fine-grained, policy-based, privilege prevention).

7. **Security mechanisms** include verified boot (verifies system integrity, chain of trust, tamper prevention), encryption (data encryption, file-based encryption, full disk encryption, key management), and security features.

8. **Defense in depth** includes multiple security layers (Linux kernel, application sandbox, permission system, SELinux, verified boot, encryption), layer coordination (layers work together, complementary protection, comprehensive security), and layered defense.

9. **Understanding Android Security Model** is essential for AOSP development, enabling comprehensive security, process isolation, access control, and proper security architecture implementation.

## Related Topics

- **Sandboxing:** Application sandbox details
- **App sandbox:** App sandbox implementation
- **Process isolation:** Process isolation mechanisms
- **SELinux (Mandatory Access Control):** SELinux details
- **Permissions system:** Permission system architecture

