---
number: 131
title: Sandboxing
slug: sandboxing
level: advanced
tags:
  - aosp
  - security
  - sandboxing
  - isolation
  - app-sandbox
  - security-model
prerequisites:
  - android-security-model
  - android-architecture-complete-overview
  - selinux-overview
estimated_minutes: 95
contributors: []
diagrams: []
examples: []
canonical_id: aosp-advanced-131
---

# Sandboxing

## Overview

Sandboxing is a security mechanism that isolates applications and processes from each other and from the system, creating isolated execution environments with restricted access to resources. In Android, sandboxing is implemented through multiple layers including Linux UID/GID isolation, file system isolation, process isolation, SELinux enforcement, and permission-based access control. Understanding sandboxing is essential for AOSP development, as it explains how Android isolates applications, how sandbox boundaries are enforced, how resources are restricted, how inter-process communication is secured, and how sandboxing provides security and privacy protection. This guide provides a comprehensive overview of sandboxing, sandbox architecture, isolation mechanisms, resource restrictions, sandbox boundaries, and security enforcement.

Think of sandboxing like individual play areas: just as children might have separate play areas (sandboxes) where they can play independently without interfering with each other, Android applications run in isolated sandboxes where they can execute independently without accessing each other's data or interfering with the system.

## Deep Explanation

### What is Sandboxing?

Sandboxing is a security mechanism that isolates applications and processes from each other and from the system, creating isolated execution environments with restricted access to resources. In Android, sandboxing ensures that each application runs in its own isolated environment, preventing apps from accessing each other's data or interfering with system operations.

**Key Characteristics:**
- **Isolation:** Apps isolated from each other
- **Restricted Access:** Limited access to resources
- **Security:** Security through isolation
- **Privacy:** Privacy protection
- **Stability:** App crashes don't affect others

**Why Sandboxing?**
- **Security:** Prevents unauthorized access
- **Privacy:** Protects user data
- **Stability:** Isolates app failures
- **Resource Management:** Controls resource usage

### Sandbox Architecture

#### Sandbox Components

**Sandbox Components:**
- **Process Isolation:** Separate processes
- **UID/GID Isolation:** Unique user IDs
- **File System Isolation:** Isolated file access
- **Network Isolation:** Limited network access
- **SELinux Enforcement:** Mandatory access control

**Sandbox Layers:**
1. **Linux Kernel:** Process and UID isolation
2. **File System:** File access restrictions
3. **Network:** Network access control
4. **SELinux:** Fine-grained access control
5. **Permissions:** Permission-based access

#### Sandbox Boundaries

**Sandbox Boundaries:**
- **Process Boundary:** Separate processes
- **Memory Boundary:** Isolated memory space
- **File System Boundary:** Isolated file access
- **Network Boundary:** Limited network access
- **Security Boundary:** SELinux enforcement

**Boundary Enforcement:**
- Kernel enforces boundaries
- File system permissions enforce boundaries
- Network policies enforce boundaries
- SELinux policies enforce boundaries

### Isolation Mechanisms

#### Process Isolation

**Process Isolation:**
- Each app runs in separate process
- Isolated memory space
- Isolated execution context
- Process-level security

**Isolation Benefits:**
- **Security:** Apps cannot access each other
- **Stability:** App crashes isolated
- **Privacy:** Data isolated between apps
- **Resource Management:** Independent resource limits

#### UID/GID Isolation

**UID/GID Isolation:**
- Each app has unique UID
- File system access based on UID
- Process identification by UID
- Resource ownership by UID

**UID Assignment:**
```
App A: UID 10000
App B: UID 10001
App C: UID 10002
```

**Isolation Mechanism:**
- Linux kernel enforces UID isolation
- File permissions based on UID
- Process ownership by UID
- Resource limits per UID

### File System Isolation

#### File System Sandbox

**File System Sandbox:**
- Each app has isolated directory
- App files in `/data/data/<package>/`
- Other apps cannot access
- File permissions enforce isolation

**File System Structure:**
```
/data/data/
├── com.example.app1/
│   ├── files/
│   ├── cache/
│   └── databases/
├── com.example.app2/
│   ├── files/
│   ├── cache/
│   └── databases/
└── ...
```

**File Permissions:**
```
App files: /data/data/com.example.app/
Owner: UID 10000 (app's UID)
Permissions: 700 (owner read/write/execute only)
Other apps: Cannot access
```

#### Shared Storage

**Shared Storage:**
- External storage accessible to all apps
- Permission-based access
- Media store for media files
- Scoped storage (Android 10+)

**Shared Storage Access:**
- Requires permissions
- User-controlled access
- Scoped storage restrictions
- Media store integration

### Network Isolation

#### Network Sandbox

**Network Sandbox:**
- Apps have limited network access
- Permission-based network access
- Network security policies
- VPN and proxy support

**Network Access Control:**
- INTERNET permission required
- Network security config
- Cleartext traffic restrictions
- Certificate pinning

#### Network Restrictions

**Network Restrictions:**
- Background network restrictions
- Data saver mode
- Network security policies
- App-specific restrictions

### SELinux Integration

#### SELinux Sandbox

**SELinux Sandbox:**
- Mandatory access control
- Fine-grained permissions
- Policy-based enforcement
- Additional security layer

**SELinux Contexts:**
- Process contexts
- File contexts
- Object contexts
- Access control decisions

**SELinux Enforcement:**
- Policy-based access control
- Prevents privilege escalation
- Enforces sandbox boundaries
- Additional security layer

### Resource Restrictions

#### Memory Restrictions

**Memory Restrictions:**
- Per-app memory limits
- Low memory killer
- Memory pressure handling
- Resource limits

**Memory Management:**
- Process memory limits
- Heap size limits
- Memory pressure notifications
- OOM killer integration

#### CPU Restrictions

**CPU Restrictions:**
- CPU time limits
- Background CPU restrictions
- CPU affinity
- Scheduling priorities

**CPU Management:**
- Process scheduling
- CPU time limits
- Background restrictions
- Priority management

### Sandbox Boundaries

#### Process Boundary

**Process Boundary:**
- Separate process per app
- Isolated memory space
- Isolated execution context
- Process-level security

**Boundary Enforcement:**
- Kernel enforces process isolation
- Memory protection
- Process separation
- Security context isolation

#### File System Boundary

**File System Boundary:**
- Isolated file directories
- File permission enforcement
- Directory access restrictions
- Shared storage boundaries

**Boundary Enforcement:**
- File permissions enforce boundaries
- Directory isolation
- Access control
- SELinux file contexts

### Inter-Process Communication

#### Secure IPC

**Secure IPC:**
- Binder IPC with permissions
- Intent-based communication
- Content providers with permissions
- Secure message passing

**IPC Security:**
- Permission checks on IPC
- Binder security
- Intent filtering
- Content provider permissions

#### IPC Boundaries

**IPC Boundaries:**
- Permission-based IPC
- Binder security enforcement
- Intent security
- Content provider security

### Sandbox Enforcement

#### Enforcement Mechanisms

**Enforcement Mechanisms:**
- Kernel-level enforcement
- File system enforcement
- Network enforcement
- SELinux enforcement
- Permission enforcement

**Enforcement Layers:**
1. **Kernel:** Process and UID isolation
2. **File System:** File permissions
3. **Network:** Network policies
4. **SELinux:** Mandatory access control
5. **Permissions:** Permission checks

#### Enforcement Points

**Enforcement Points:**
- Process creation
- File access
- Network access
- System call execution
- IPC operations

### Sandbox Benefits

#### Security Benefits

**Security Benefits:**
- Prevents unauthorized access
- Isolates app failures
- Prevents privilege escalation
- Protects system integrity

#### Privacy Benefits

**Privacy Benefits:**
- Protects user data
- Isolates app data
- Prevents data leakage
- User-controlled access

#### Stability Benefits

**Stability Benefits:**
- App crashes isolated
- System stability maintained
- Resource conflicts prevented
- Independent app execution

### Sandbox Limitations

#### Shared Resources

**Shared Resources:**
- External storage
- Network access
- System services
- Hardware resources

**Shared Resource Access:**
- Permission-based access
- User-controlled access
- System-controlled access
- Controlled sharing

#### IPC Communication

**IPC Communication:**
- Apps can communicate via IPC
- Permission-based IPC
- Intent-based communication
- Controlled communication

### Debugging Sandboxing

#### Debugging Tools

**Debugging Tools:**
- Process inspection
- File system inspection
- Network inspection
- SELinux logs
- Permission dumps

**Debugging Commands:**
```bash
# Check app UID
adb shell dumpsys package <package-name> | grep userId

# Check file permissions
adb shell ls -la /data/data/<package-name>/

# Check SELinux context
adb shell ps -Z | grep <package-name>

# Check network access
adb shell dumpsys connectivity
```

#### Common Issues

**Common Issues:**
- File access denied
- Network access denied
- IPC communication failures
- SELinux violations
- Permission issues

**Debugging Steps:**
1. Check app UID/GID
2. Verify file permissions
3. Review SELinux context
4. Check network policies
5. Verify permissions
6. Review sandbox boundaries

## Key Takeaways

1. **Sandboxing** is a security mechanism that isolates applications and processes from each other and from the system, creating isolated execution environments with restricted access to resources.

2. **Sandbox architecture** includes sandbox components (process isolation, UID/GID isolation, file system isolation, network isolation, SELinux enforcement), sandbox layers (Linux kernel, file system, network, SELinux, permissions), and sandbox boundaries (process, memory, file system, network, security).

3. **Isolation mechanisms** include process isolation (separate processes, isolated memory, isolated execution context), UID/GID isolation (unique UID per app, file system access based on UID, process identification by UID), and isolation benefits (security, stability, privacy, resource management).

4. **File system isolation** includes file system sandbox (isolated directory per app, app files in /data/data/<package>/, file permissions enforce isolation), file system structure, file permissions, shared storage (external storage, permission-based access, scoped storage), and shared storage access.

5. **Network isolation** includes network sandbox (limited network access, permission-based access, network security policies), network access control (INTERNET permission, network security config, cleartext restrictions), network restrictions (background restrictions, data saver, network policies), and network management.

6. **SELinux integration** includes SELinux sandbox (mandatory access control, fine-grained permissions, policy-based enforcement), SELinux contexts (process, file, object contexts), SELinux enforcement (policy-based access control, prevents privilege escalation, enforces boundaries), and SELinux features.

7. **Resource restrictions** include memory restrictions (per-app memory limits, low memory killer, memory pressure handling), CPU restrictions (CPU time limits, background restrictions, CPU affinity, scheduling priorities), and resource management.

8. **Sandbox boundaries** include process boundary (separate process, isolated memory, isolated execution context), file system boundary (isolated directories, file permissions, directory access restrictions), boundary enforcement (kernel, file system, network, SELinux enforcement), and boundary characteristics.

9. **Inter-process communication** includes secure IPC (Binder IPC with permissions, Intent-based communication, Content providers with permissions), IPC security (permission checks, Binder security, Intent filtering), IPC boundaries (permission-based IPC, Binder security enforcement), and IPC mechanisms.

10. **Understanding sandboxing** is essential for AOSP development, enabling application isolation, security enforcement, privacy protection, and proper sandbox architecture implementation.

## Related Topics

- **App sandbox:** Application sandbox implementation details
- **Process isolation:** Process isolation mechanisms
- **Android Security Model:** Overall security architecture
- **SELinux (Mandatory Access Control):** SELinux details

