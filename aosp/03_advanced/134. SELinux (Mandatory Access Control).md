---
number: 134
title: SELinux (Mandatory Access Control)
slug: selinux-mandatory-access-control
level: advanced
tags:
  - aosp
  - security
  - selinux
  - mandatory-access-control
  - mac
  - sepolicy
  - security-policies
prerequisites:
  - selinux-overview
  - android-security-model
  - process-isolation
estimated_minutes: 95
contributors: []
diagrams: []
examples: []
canonical_id: aosp-advanced-134
---

# SELinux (Mandatory Access Control)

## Overview

SELinux (Security-Enhanced Linux) Mandatory Access Control (MAC) is a security mechanism that enforces fine-grained security policies beyond traditional Linux permissions. SELinux provides mandatory access control where security policies are defined by the system and cannot be bypassed by users or processes, even with root privileges. Understanding SELinux MAC is essential for AOSP development, as it explains how SELinux enforces security policies, how mandatory access control works, how SELinux policies are defined and enforced, how SELinux contexts are used, and how SELinux provides defense in depth security. This guide provides a comprehensive overview of SELinux MAC, mandatory access control concepts, SELinux architecture, policy enforcement, security contexts, and SELinux integration.

Think of SELinux MAC like a strict security system: just as a building might have a security system that enforces strict rules about who can access what areas (mandatory rules that cannot be bypassed), SELinux MAC enforces strict security policies about which processes can access which resources, and these policies cannot be bypassed even by root users.

## Deep Explanation

### What is SELinux Mandatory Access Control?

SELinux Mandatory Access Control (MAC) is a security mechanism that enforces fine-grained security policies beyond traditional Linux permissions. Unlike Discretionary Access Control (DAC), where users can change permissions on files they own, MAC policies are defined by the system and cannot be bypassed by users or processes, even with root privileges.

**Key Characteristics:**
- **Mandatory:** Policies cannot be bypassed
- **Fine-Grained:** Detailed security policies
- **Policy-Based:** Security defined by policies
- **System-Enforced:** Enforced by kernel
- **Defense in Depth:** Additional security layer

**Why SELinux MAC?**
- **Security:** Prevents unauthorized access
- **Privilege Prevention:** Prevents privilege escalation
- **Isolation:** Isolates processes from each other
- **Defense in Depth:** Additional security layer

### Mandatory Access Control Concepts

#### MAC vs DAC

**Mandatory Access Control (MAC):**
- Security policies defined by system
- Policies enforced by kernel
- Cannot be overridden by users
- Provides defense in depth

**Discretionary Access Control (DAC):**
- Traditional Linux permissions
- Users can change permissions
- Root can bypass restrictions
- Less secure but more flexible

**Comparison:**
```
DAC (Traditional Linux):
- File owner can change permissions
- Root can access anything
- User-controlled permissions
- Less secure

MAC (SELinux):
- System-defined policies
- Root cannot bypass policies
- System-controlled permissions
- More secure
```

#### MAC Principles

**MAC Principles:**
- **Mandatory:** Policies are mandatory
- **System-Defined:** Policies defined by system
- **Kernel-Enforced:** Enforced by kernel
- **Non-Bypassable:** Cannot be bypassed

**MAC Benefits:**
- **Security:** Enhanced security
- **Privilege Prevention:** Prevents privilege escalation
- **Isolation:** Process isolation
- **Defense in Depth:** Additional layer

### SELinux Architecture

#### SELinux Components

**SELinux Components:**
- **SELinux Kernel Module:** Enforces policies
- **SELinux Policy:** Defines security rules
- **SELinux Contexts:** Labels for processes and files
- **Policy Compiler:** Compiles policies

**Component Roles:**
- **Kernel Module:** Enforces policies at kernel level
- **Policy:** Defines what is allowed/denied
- **Contexts:** Identify processes and files
- **Compiler:** Converts policy source to binary

#### SELinux Modes

**SELinux Modes:**
- **Enforcing:** Policies enforced (production)
- **Permissive:** Policies logged but not enforced (debugging)
- **Disabled:** SELinux disabled (not recommended)

**Mode Characteristics:**
- **Enforcing:** Security enforced, violations denied
- **Permissive:** Violations logged but allowed
- **Disabled:** No security enforcement

**Mode Management:**
```bash
# Check current mode
getenforce
# Returns: Enforcing, Permissive, or Disabled

# Set enforcing mode
setenforce 1

# Set permissive mode
setenforce 0
```

### Policy Enforcement

#### Policy Enforcement Mechanism

**Policy Enforcement:**
- Kernel intercepts system calls
- Kernel checks SELinux policies
- Access allowed or denied based on policy
- Violations logged

**Enforcement Process:**
```
1. Process attempts operation
2. Kernel intercepts system call
3. Kernel checks SELinux policy
4. Policy allows or denies access
5. Access granted or denied
6. Violation logged (if denied)
```

**Enforcement Characteristics:**
- **Kernel-Level:** Enforced at kernel level
- **Automatic:** Automatic enforcement
- **Transparent:** Transparent to processes
- **Consistent:** Consistent enforcement

#### Policy Rules

**Policy Rules:**
- Define allowed operations
- Specify subject (process)
- Specify object (file, socket, etc.)
- Specify permissions

**Rule Format:**
```
allow <subject> <object>:<class> <permissions>;
```

**Rule Example:**
```
allow untrusted_app app_data_file:file { read write };
```

**Rule Meaning:**
- **Subject:** `untrusted_app` (process domain)
- **Object:** `app_data_file` (file type)
- **Class:** `file` (object class)
- **Permissions:** `read`, `write` (allowed operations)

### Security Contexts

#### Context Concept

**Security Contexts:**
- Labels attached to processes and objects
- Used for access control decisions
- Format: `user:role:type:level`
- Contexts define security identity

**Context Format:**
```
u:r:untrusted_app:s0
│ │ │              │
│ │ │              └─ MLS level
│ │ └─────────────── Type/Domain
│ └───────────────── Role
└─────────────────── User
```

#### Process Contexts

**Process Contexts:**
- Each process has security context
- Context defines process domain
- Domain determines allowed operations
- Context assigned at process creation

**Process Context Examples:**
- `u:r:untrusted_app:s0` - Untrusted app
- `u:r:system_server:s0` - System server
- `u:r:init:s0` - Init process
- `u:r:zygote:s0` - Zygote process

#### File Contexts

**File Contexts:**
- Each file has security context
- Context defines file type
- Type determines access permissions
- Context assigned at file creation

**File Context Examples:**
- `u:object_r:app_data_file:s0` - App data file
- `u:object_r:system_file:s0` - System file
- `u:object_r:exec:s0` - Executable file
- `u:object_r:config_file:s0` - Config file

### Type Enforcement

#### Type Enforcement Concept

**Type Enforcement:**
- Primary SELinux access control mechanism
- Processes have types (domains)
- Files have types
- Policies define type interactions

**Type Enforcement Rules:**
```
allow <source_type> <target_type>:<class> <permissions>;
```

**Type Enforcement Example:**
```
allow untrusted_app app_data_file:file { read write };
```

**Meaning:**
- Process with type `untrusted_app` can
- Access files with type `app_data_file`
- With permissions `read` and `write`

#### Domain Transitions

**Domain Transitions:**
- Process can transition between domains
- Controlled by policy rules
- Used for privilege changes
- Security-critical operations

**Domain Transition Example:**
```
allow untrusted_app untrusted_app:process transition;
```

**Meaning:**
- Process in `untrusted_app` domain can
- Transition to `untrusted_app` domain
- (Example of domain transition rule)

### SELinux Policies

#### Policy Structure

**Policy Structure:**
- Policy source files
- Compiled to binary format
- Loaded at boot time
- Enforced by kernel

**Policy Location:**
- Source: `external/selinux/` or `system/sepolicy/`
- Binary: `/system/etc/selinux/` or `/vendor/etc/selinux/`
- Loaded at boot
- Enforced by kernel

#### Policy Types

**Policy Types:**
- **Type Enforcement:** Primary access control
- **Role-Based Access Control:** Role-based permissions
- **Multi-Level Security:** Security levels
- **Constraints:** Additional restrictions

**Policy Components:**
- **Type Definitions:** Define types
- **Allow Rules:** Define allowed operations
- **Neverallow Rules:** Define prohibited operations
- **Constraints:** Additional restrictions

### SELinux Integration

#### Android Integration

**Android Integration:**
- SELinux integrated into Android kernel
- Policies defined in AOSP
- Contexts assigned at runtime
- Enforcement automatic

**Integration Points:**
- **Kernel:** SELinux kernel module
- **Init:** Context assignment during boot
- **Zygote:** Context assignment for apps
- **System Services:** Context management

#### Context Assignment

**Context Assignment:**
- Processes get contexts at creation
- Files get contexts at creation
- Contexts persist across operations
- Contexts used for access control

**Assignment Process:**
```
1. Process created
2. SELinux context assigned
3. Context based on process type
4. Context used for access control
```

### SELinux Benefits

#### Security Benefits

**Security Benefits:**
- Prevents unauthorized access
- Prevents privilege escalation
- Isolates processes
- Provides defense in depth

**Security Features:**
- **Mandatory:** Policies cannot be bypassed
- **Fine-Grained:** Detailed permissions
- **Policy-Based:** Explicit security rules
- **Kernel-Enforced:** Enforced at kernel level

#### Defense in Depth

**Defense in Depth:**
- Additional security layer
- Works with other security mechanisms
- Provides redundant protection
- Comprehensive security

**Defense Layers:**
1. **Linux Permissions:** Basic access control
2. **UID/GID Isolation:** Process isolation
3. **Permission System:** Application permissions
4. **SELinux:** Mandatory access control

### Debugging SELinux

#### Debugging Tools

**Debugging Tools:**
- SELinux logs
- Context inspection
- Policy analysis
- Violation logs

**Debugging Commands:**
```bash
# Check SELinux status
getenforce

# Check process context
adb shell ps -Z | grep <process>

# Check file context
adb shell ls -Z <file>

# View SELinux logs
adb shell dmesg | grep avc

# Check SELinux violations
adb shell cat /proc/kmsg | grep avc
```

#### Common Issues

**Common Issues:**
- SELinux violations
- Context mismatches
- Policy issues
- Access denied errors

**Debugging Steps:**
1. Check SELinux mode
2. Review SELinux logs
3. Check process contexts
4. Check file contexts
5. Review policy rules
6. Verify access permissions

## Key Takeaways

1. **SELinux Mandatory Access Control** is a security mechanism that enforces fine-grained security policies beyond traditional Linux permissions, where policies are defined by the system and cannot be bypassed.

2. **Mandatory Access Control concepts** include MAC vs DAC (MAC: system-defined policies, kernel-enforced, non-bypassable; DAC: user-controlled permissions, root can bypass), MAC principles (mandatory, system-defined, kernel-enforced, non-bypassable), and MAC benefits.

3. **SELinux architecture** includes SELinux components (kernel module, policy, contexts, compiler), SELinux modes (enforcing, permissive, disabled), mode characteristics, and mode management.

4. **Policy enforcement** includes policy enforcement mechanism (kernel intercepts system calls, checks policies, allows/denies access), policy rules (define allowed operations, specify subject/object/permissions), rule format, and enforcement characteristics.

5. **Security contexts** include context concept (labels attached to processes and objects, used for access control), context format (user:role:type:level), process contexts (each process has context, defines domain), file contexts (each file has context, defines type), and context examples.

6. **Type enforcement** includes type enforcement concept (primary access control mechanism, processes and files have types, policies define type interactions), type enforcement rules, domain transitions (process can transition between domains, controlled by policy), and type enforcement examples.

7. **SELinux policies** include policy structure (source files, compiled to binary, loaded at boot, enforced by kernel), policy location, policy types (type enforcement, role-based access control, multi-level security, constraints), and policy components.

8. **SELinux integration** includes Android integration (SELinux integrated into kernel, policies defined in AOSP, contexts assigned at runtime), context assignment (processes and files get contexts at creation, contexts persist, used for access control), and integration points.

9. **SELinux benefits** include security benefits (prevents unauthorized access, prevents privilege escalation, isolates processes), defense in depth (additional security layer, works with other mechanisms, provides redundant protection), and benefit characteristics.

10. **Understanding SELinux MAC** is essential for AOSP development, enabling mandatory access control, security policy enforcement, defense in depth security, and proper SELinux architecture implementation.

## Related Topics

- **SELinux Overview:** SELinux introduction
- **sepolicy:** SELinux policy details
- **domain, type enforcement rules:** Type enforcement details
- **file contexts:** File context details
- **audit logs:** SELinux audit logging

