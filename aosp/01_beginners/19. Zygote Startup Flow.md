---
number: 19
title: Zygote Startup Flow
slug: zygote-startup-flow
level: beginner
tags:
  - aosp
  - zygote
  - boot
  - startup
  - runtime
  - art
  - app-process
  - fork
prerequisites:
  - boot-process-overview
  - init-system-in-android
  - init-phases-early-init-init-late-init
estimated_minutes: 80
contributors: []
diagrams: []
examples: []
canonical_id: aosp-beginner-19
---

# Zygote Startup Flow

## Overview

Zygote is a critical process in the Android boot sequence that preloads common classes and resources, enabling fast application startup through process forking. Understanding Zygote's startup flow is essential for comprehending how Android applications are launched, how the runtime environment is prepared, and how the system optimizes memory and performance. This guide provides a detailed walkthrough of Zygote's startup sequence, from init service launch to when it's ready to fork application processes.

Think of Zygote like a "template process" in a factory: instead of building each product (app) from scratch, the factory creates a perfect template (Zygote) with all common components pre-installed. When a new product is needed, the factory simply copies the template (forks Zygote) and customizes it slightly. This is much faster than building from scratch each time, and it ensures consistency across all products.

## Deep Explanation

### What is Zygote?

Zygote is a special Android process that serves as the parent process for all Android application processes. It's started early in the boot sequence and preloads commonly used Java classes, resources, and native libraries. When an app needs to start, Android forks (creates a copy of) the Zygote process, which already has everything preloaded, resulting in much faster app startup times.

**Key Characteristics:**
- **Parent Process:** All app processes are children of Zygote
- **Preloading:** Loads common classes and resources before apps need them
- **Fork Model:** Apps start by forking Zygote, not starting from scratch
- **Single Instance:** Only one Zygote process runs (or two on 64-bit: 32-bit and 64-bit Zygotes)
- **Critical Process:** System cannot function without Zygote

**Why "Zygote"?**
The name comes from biology - a zygote is a fertilized egg that contains all the genetic material needed to create a new organism. Similarly, Android's Zygote contains all the "genetic material" (preloaded classes and resources) needed to create new app processes.

### Zygote's Role in Android

**Before Zygote (The Problem):**
- Each app would need to load all Java classes from scratch
- Each app would need to load all resources independently
- Startup time would be slow (several seconds per app)
- Memory usage would be inefficient (duplicate copies of common code)

**With Zygote (The Solution):**
- Common classes loaded once in Zygote
- Resources preloaded and shared
- Fast app startup (milliseconds instead of seconds)
- Efficient memory usage (shared memory via copy-on-write)

**The Fork Advantage:**
When Zygote forks to create a new app process:
- The new process inherits all preloaded classes (via copy-on-write memory)
- The new process inherits all preloaded resources
- Only app-specific initialization is needed
- Startup is dramatically faster

### Zygote Startup Sequence

Zygote startup is a carefully orchestrated sequence of steps that prepares the runtime environment. Let's trace through each step:

#### Step 1: Init Service Definition

**Location:** `init.rc` or device-specific init files

**Service Declaration:**
```bash
service zygote /system/bin/app_process64 -Xzygote /system/bin --zygote --start-system-server
    class main
    priority -20
    user root
    group root readproc
    socket zygote stream 660 root system
    onrestart write /sys/power/state on
    onrestart restart audioserver
    writepid /dev/cpuset/foreground/tasks
```

**Key Elements:**
- **Executable:** `/system/bin/app_process64` (64-bit) or `/system/bin/app_process32` (32-bit)
- **Arguments:** `-Xzygote /system/bin --zygote --start-system-server`
- **Class:** `main` (starts in main init phase)
- **User:** `root` (initially, transitions later)
- **Socket:** Creates Zygote socket for IPC

**When It Starts:**
- Triggered during `late-init` phase
- After partitions are mounted
- After basic system properties are set
- Before most other services

**Timing:**
- Typically starts around 1-2 seconds after kernel init
- One of the first Java processes to start
- Critical path for boot time

#### Step 2: Init Launches Zygote Process

**Process Creation:**
1. Init reads service definition from `init.rc`
2. Init forks a new process
3. New process executes `/system/bin/app_process64`
4. Process runs as root initially
5. Process has Zygote socket created

**Initial State:**
- **PID:** New process ID (not 1, which is init)
- **PPID:** 1 (parent is init)
- **UID:** 0 (root)
- **GID:** 0 (root)
- **State:** Just started, no Java code running yet

**Environment:**
- Minimal environment variables
- Basic file descriptors (stdin, stdout, stderr)
- Zygote socket file descriptor
- No Java runtime yet

#### Step 3: Native Code Initialization

**app_process Entry Point:**
The `app_process` binary is a native (C/C++) program that:
1. Parses command-line arguments
2. Determines it's running in Zygote mode (`--zygote` flag)
3. Sets up JNI (Java Native Interface)
4. Prepares to load Java runtime

**Argument Parsing:**
- `-Xzygote`: Indicates Zygote mode
- `/system/bin`: Base directory for classpath
- `--zygote`: Explicit Zygote mode flag
- `--start-system-server`: Flag to start System Server after initialization

**JNI Setup:**
- Initialize Java Native Interface
- Load native libraries needed for Java runtime
- Set up JNI environment
- Prepare for Java VM creation

**Native Library Loading:**
- Load ART (Android Runtime) native libraries
- Load Zygote-specific native code
- Load system native libraries
- Initialize native methods

#### Step 4: Java Virtual Machine (VM) Creation

**VM Initialization:**
1. Create Java Virtual Machine instance
2. Configure VM parameters
3. Set up heap size and memory limits
4. Configure garbage collection
5. Enable optimizations

**VM Configuration:**
```java
// Typical VM arguments for Zygote
-Xms:initial-heap-size
-Xmx:max-heap-size
-XX:+UseG1GC
-XX:MaxGCPauseMillis=200
-Djava.class.path=/system/framework/core-libart.jar:...
```

**Memory Settings:**
- Initial heap: Typically 4-8 MB
- Max heap: Device-dependent (256 MB - 512 MB)
- Garbage collector: G1GC (Garbage First)
- GC pause target: ~200ms

**Classpath Setup:**
- Core Android framework JARs
- System framework classes
- Zygote-specific classes
- Essential system libraries

#### Step 5: Zygote Class Loading

**ZygoteInit.main() Entry:**
The Java code starts executing in `ZygoteInit.main()`:

```java
public static void main(String argv[]) {
    ZygoteServer zygoteServer = null;
    
    // Parse arguments
    // Initialize runtime
    // Preload classes and resources
    // Start System Server (if requested)
    // Enter Zygote server loop
}
```

**Initialization Steps:**
1. Parse command-line arguments
2. Create ZygoteServer instance
3. Register Zygote socket
4. Set up signal handlers
5. Prepare for preloading

**Argument Processing:**
- `--zygote`: Confirms Zygote mode
- `--start-system-server`: Flag to fork System Server
- Socket name: Determines Zygote socket path
- Abi list: Supported ABIs (32-bit, 64-bit)

#### Step 6: Preloading Phase

**Why Preload?**
Preloading common classes and resources in Zygote means:
- All forked processes inherit them (via copy-on-write)
- No need to load them per-app
- Faster app startup
- Lower memory usage (shared pages)

**Preloading Sequence:**

**1. Preload Classes:**
```java
preloadClasses();
```
- Loads ~1000+ commonly used classes
- Includes: String, ArrayList, HashMap, etc.
- Framework classes: Activity, Service, etc.
- System classes: SystemProperties, etc.

**Classes Preloaded:**
- `java.lang.*` classes (String, Object, etc.)
- `java.util.*` classes (ArrayList, HashMap, etc.)
- `android.*` framework classes
- Common system classes

**2. Preload Resources:**
```java
preloadResources();
```
- Loads common resources
- Drawables, colors, strings
- System resources
- Framework resources

**Resources Preloaded:**
- System drawables
- Common colors
- System strings
- Framework resources

**3. Preload OpenGL:**
```java
preloadOpenGL();
```
- Initializes OpenGL ES
- Loads graphics libraries
- Prepares graphics context

**4. Preload Shared Libraries:**
```java
preloadSharedLibraries();
```
- Loads native libraries
- System libraries
- Framework native code

**Preloading Statistics:**
- **Time:** 200-500ms (device-dependent)
- **Classes:** ~1000-2000 classes
- **Memory:** 10-50 MB (shared across all apps)
- **Impact:** Significant boot time component

**Memory Sharing:**
After preloading, memory pages are:
- Marked as copy-on-write (COW)
- Shared across all forked processes
- Only copied when modified
- Highly memory-efficient

#### Step 7: Zygote Socket Setup

**Socket Creation:**
Zygote creates a Unix domain socket for receiving fork requests:

**Socket Path:**
- Primary: `/dev/socket/zygote`
- Secondary (64-bit): `/dev/socket/zygote_secondary`
- Permissions: 660 (root:system)

**Socket Purpose:**
- Receives fork requests from ActivityManager
- Receives app launch requests
- Handles process creation commands
- Manages Zygote communication

**Socket Registration:**
1. Create socket file descriptor
2. Bind to socket path
3. Set permissions
4. Listen for connections
5. Register with init (for restart handling)

#### Step 8: System Server Fork (If Requested)

**Conditional Fork:**
If `--start-system-server` flag is present:

```java
if (startSystemServer) {
    Runnable r = forkSystemServer(abiList, zygoteSocketName, zygoteServer);
    if (r != null) {
        r.run();
        return;
    }
}
```

**Fork Process:**
1. Fork new process from Zygote
2. Child process becomes System Server
3. Parent (Zygote) continues to server loop
4. System Server inherits all preloaded classes

**System Server Process:**
- **PID:** New process ID
- **PPID:** Zygote's PID
- **Inherits:** All preloaded classes and resources
- **Starts:** System Server main method
- **Zygote continues:** Enters server loop

**Why Fork from Zygote?**
- System Server benefits from preloaded classes
- Faster System Server startup
- Shared memory with Zygote
- Consistent environment

#### Step 9: Zygote Server Loop

**Entering the Loop:**
After System Server is forked (or if not requested), Zygote enters its main server loop:

```java
zygoteServer.runSelectLoop(abiList);
```

**Server Loop Function:**
1. Wait for incoming connections on Zygote socket
2. Receive fork requests from ActivityManager
3. Fork new process for app
4. Return to waiting state
5. Repeat indefinitely

**Loop Behavior:**
- **Blocking:** Waits for connections (doesn't consume CPU)
- **Event-driven:** Responds to fork requests
- **Persistent:** Runs for device lifetime
- **Restartable:** Init can restart if it crashes

**Fork Request Handling:**
When a fork request arrives:
1. Parse request (app info, UID, GID, etc.)
2. Fork new process
3. Configure child process
4. Return child PID to requester
5. Continue waiting

#### Step 10: Process Transition and Security

**UID/GID Transition:**
After forking, child processes transition from root:

**Zygote (Parent):**
- Remains as root
- Continues serving fork requests
- Maintains Zygote socket

**Child Process (App):**
- Transitions to app's UID/GID
- Drops root privileges
- Runs with app's permissions
- Isolated from other apps

**Security Context:**
- Each app gets its own UID
- SELinux context applied
- App sandbox enforced
- Process isolation maintained

### Zygote Variants

**32-bit Zygote:**
- For 32-bit apps on 64-bit devices
- Separate Zygote process
- 32-bit native libraries
- 32-bit ART runtime

**64-bit Zygote:**
- For 64-bit apps
- Primary Zygote on 64-bit devices
- 64-bit native libraries
- 64-bit ART runtime

**WebView Zygote:**
- Separate Zygote for WebView
- Isolated from app Zygotes
- Security isolation
- Resource isolation

### Zygote Startup Timeline

**Typical Timeline:**
- **0ms:** Init reads service definition
- **10ms:** Init forks Zygote process
- **20ms:** Native code initialization
- **50ms:** Java VM creation
- **100ms:** ZygoteInit.main() starts
- **150ms:** Preloading begins
- **400ms:** Preloading completes
- **450ms:** Zygote socket ready
- **500ms:** System Server forked (if requested)
- **550ms:** Zygote enters server loop
- **600ms:** Zygote ready for fork requests

**Factors Affecting Time:**
- Device performance (CPU speed)
- Storage speed (loading classes)
- Number of classes to preload
- Memory initialization time
- System load

### Zygote Socket Communication

**Protocol:**
Zygote uses a simple protocol over Unix domain socket:

**Request Format:**
- App package name
- App UID/GID
- App arguments
- App class name
- App main method

**Response Format:**
- Child process PID
- Success/failure status
- Error messages (if any)

**Communication Flow:**
1. ActivityManager connects to Zygote socket
2. Sends fork request with app details
3. Zygote forks new process
4. Zygote returns child PID
5. ActivityManager manages child process

### Zygote Process Forking

**Fork Mechanism:**
When Zygote forks a new process:

**1. Fork System Call:**
- Creates copy of Zygote process
- Child inherits memory (copy-on-write)
- Child gets new PID
- Parent (Zygote) continues

**2. Child Configuration:**
- Set UID/GID to app's values
- Set process name
- Configure SELinux context
- Set up app-specific environment

**3. Child Execution:**
- Jump to app's main method
- Start app's Activity/Service
- Begin app execution
- App is now running

**Memory Inheritance:**
- All preloaded classes (shared pages)
- All preloaded resources (shared pages)
- Native libraries (shared pages)
- Only copied when modified (COW)

### Zygote Restart Handling

**When Zygote Crashes:**
- Init detects Zygote death
- Init restarts Zygote service
- Zygote goes through startup again
- Preloading happens again
- System Server may need restart

**Restart Triggers:**
- Zygote process crash
- Zygote socket error
- Manual restart command
- System update

**Restart Impact:**
- All app processes may be killed
- System Server may restart
- Boot time increases
- User experience affected

### Debugging Zygote Startup

**Logging:**
- Zygote logs to logcat
- Tag: `Zygote`
- Filter: `adb logcat -s Zygote`

**Common Issues:**
- Preloading failures
- Class loading errors
- Memory issues
- Socket creation failures

**Debugging Tools:**
- `adb logcat` - View Zygote logs
- `adb shell ps | grep zygote` - Check if running
- `adb shell dumpsys` - System state
- `strace` - System call tracing

### Zygote Optimization

**Preloading Optimization:**
- Only preload truly common classes
- Avoid preloading rarely used classes
- Balance memory vs. startup time
- Device-specific tuning

**Memory Optimization:**
- Efficient class loading
- Shared memory usage
- Garbage collection tuning
- Heap size optimization

**Startup Time Optimization:**
- Parallel preloading (where possible)
- Lazy loading strategies
- Caching optimizations
- Device-specific tuning

## Key Takeaways

1. **Zygote is the parent process** for all Android app processes, preloading common classes and resources for fast app startup.

2. **Zygote starts during late-init phase** as an init service, after partitions are mounted and basic system is ready.

3. **Preloading phase** loads ~1000+ common classes, resources, and libraries that all apps will use, taking 200-500ms.

4. **Fork model** allows apps to start quickly by copying Zygote's preloaded state rather than loading everything from scratch.

5. **Zygote socket** enables ActivityManager to request new app processes by communicating with Zygote.

6. **System Server is forked from Zygote** if requested, inheriting all preloaded classes for faster startup.

7. **Zygote server loop** runs indefinitely, waiting for fork requests and creating new app processes as needed.

8. **Understanding Zygote startup** is essential for optimizing boot time, debugging app launch issues, and developing AOSP features.

## Related Topics

- **System Server Launch:** The next process forked from Zygote that starts all system services
- **Boot Process Overview:** The complete boot sequence that includes Zygote startup
- **Init System in Android:** The init system that launches Zygote as a service
- **Android Runtime (ART):** The Java runtime that Zygote uses to execute Java code

