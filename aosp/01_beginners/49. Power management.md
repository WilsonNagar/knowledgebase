---
number: 49
title: Power management
slug: power-management
level: beginner
tags:
  - aosp
  - kernel
  - power-management
  - battery
  - suspend
  - resume
  - cpu-frequency
prerequisites:
  - wakelocks
  - scheduler-internals
  - differences-android-kernel-linux-kernel
estimated_minutes: 85
contributors: []
diagrams: []
examples: []
canonical_id: aosp-beginner-49
---

# Power management

## Overview

Power management is critical for mobile devices, controlling how the system conserves battery power through CPU frequency scaling, sleep states, suspend/resume, and power governors. Understanding kernel power management is essential for AOSP development, as it directly affects battery life, system performance, and user experience. This guide provides a comprehensive overview of kernel power management, CPU frequency scaling, sleep states, suspend/resume mechanisms, and Android-specific power management features.

Think of power management like a smart home's energy system: just as a smart home automatically turns off lights when rooms are empty, adjusts heating based on occupancy, and puts systems in low-power mode when not needed, the kernel power management system automatically adjusts CPU frequency, puts the system to sleep when idle, and manages power consumption to maximize battery life while maintaining responsiveness.

## Deep Explanation

### What is Kernel Power Management?

Kernel power management is the subsystem responsible for controlling power consumption of the system, including CPU frequency scaling, sleep states, suspend/resume, and power-aware scheduling. It's essential for battery-powered devices.

**Key Responsibilities:**
- **CPU Frequency Scaling:** Adjust CPU speed based on load
- **Sleep States:** Put system to sleep when idle
- **Device Power Control:** Control power to peripherals
- **Wake Management:** Handle wake events
- **Battery Optimization:** Maximize battery life

**Why It Matters:**
- **Battery Life:** Directly affects device runtime
- **Performance:** Balances performance and power
- **User Experience:** Affects responsiveness
- **Heat Management:** Reduces heat generation

### Power Consumption Sources

#### Major Power Consumers

**CPU:**
- Major power consumer
- Power ∝ frequency × voltage²
- Higher frequency = more power
- Idle CPU still consumes power

**Display:**
- High power consumption
- Brightness affects power
- Screen-on time critical
- Backlight power

**Radio (WiFi, Cellular, Bluetooth):**
- Significant power consumption
- Active transmission uses power
- Idle listening uses power
- Network activity affects power

**GPU:**
- Graphics processing power
- Rendering consumes power
- 3D graphics intensive
- Video decoding power

**Other Components:**
- Sensors (accelerometer, gyro, etc.)
- GPS
- Audio codecs
- Camera

### CPU Frequency Scaling

#### What is Frequency Scaling?

Frequency scaling dynamically adjusts CPU frequency based on workload to balance performance and power consumption.

**Principle:**
- Higher frequency = faster execution, more power
- Lower frequency = slower execution, less power
- Scale up when needed, down when idle
- Optimize for workload

**Benefits:**
- Power savings when idle
- Performance when needed
- Heat reduction
- Battery life extension

#### P-States (Performance States)

**P-State Definition:**
- Performance states (P0, P1, P2, ...)
- P0 = Maximum frequency (highest performance)
- P1-Pn = Lower frequencies (lower power)
- Each state has frequency and voltage

**Example:**
```
P0: 2.4 GHz @ 1.2V (maximum performance)
P1: 1.8 GHz @ 1.0V
P2: 1.2 GHz @ 0.9V
P3: 600 MHz @ 0.8V (minimum power)
```

**State Selection:**
- Based on workload
- Power governor decides
- Automatic or manual
- Performance vs power trade-off

#### C-States (Idle States)

**C-State Definition:**
- CPU idle states (C0, C1, C2, ...)
- C0 = Active (CPU running)
- C1+ = Idle states (CPU halted)
- Deeper states = more power saved, slower wake

**Common C-States:**
```
C0: Active (CPU executing)
C1: Halt (CPU halted, cache active)
C2: Stop Clock (CPU and some clocks stopped)
C3: Deep Sleep (CPU and cache stopped)
```

**State Entry:**
- When CPU idle
- Scheduler detects idle
- Enters appropriate C-state
- Wakes on interrupt

### Dynamic Voltage and Frequency Scaling (DVFS)

#### What is DVFS?

DVFS adjusts both voltage and frequency together, providing significant power savings since power is proportional to voltage squared times frequency.

**Power Equation:**
```
P ∝ V² × f
```

**Relationship:**
- Lower frequency allows lower voltage
- Voltage reduction saves significant power
- Combined scaling more effective
- Hardware-dependent

**Implementation:**
- CPU frequency driver
- Voltage regulator
- Coordinated changes
- Hardware-specific

### Power Governors

#### What are Power Governors?

Power governors are policies that decide when and how to change CPU frequency based on system load and other factors.

**Governor Responsibilities:**
- Monitor CPU load
- Decide frequency changes
- Balance performance and power
- Respond to workload changes

#### Governor Types

**1. Performance:**
- Always maximum frequency
- Best performance
- Worst battery life
- Use: Performance-critical tasks

**2. Powersave:**
- Always minimum frequency
- Best battery life
- Worst performance
- Use: Battery conservation

**3. Ondemand:**
- Scale up on high load
- Scale down on low load
- Balanced approach
- Use: General purpose

**4. Conservative:**
- Similar to ondemand
- More gradual changes
- Better battery than ondemand
- Use: Battery-sensitive

**5. Interactive:**
- Optimized for responsiveness
- Quick scale-up
- Gradual scale-down
- Use: Mobile devices (Android default)

**6. Schedutil:**
- Integrated with scheduler
- Uses scheduler load information
- More accurate
- Modern default (Linux 4.7+)

### Sleep States

#### ACPI Sleep States

**S0 (Working):**
- System fully on
- All components active
- Normal operation
- Highest power consumption

**S1 (Sleep):**
- CPU stopped
- RAM powered
- Fast wake
- Minimal power savings

**S2:**
- CPU off
- RAM powered
- Faster than S3
- Some power savings

**S3 (Suspend to RAM):**
- CPU off
- RAM in low-power mode
- Most components off
- Significant power savings
- Fast wake (seconds)

**S4 (Hibernate/Suspend to Disk):**
- System state saved to disk
- Power off
- Maximum power savings
- Slow wake (tens of seconds)

**S5 (Shutdown):**
- Complete power off
- No power consumption
- Cold boot required

#### Android Sleep States

**Active:**
- Screen on
- CPU active
- Normal operation
- Highest power

**Early Suspend:**
- Screen off, CPU on
- Some components active
- Partial power savings
- Android-specific

**Suspend:**
- Deep sleep
- Minimal power
- Wake on interrupt
- Similar to S3

### Suspend and Resume

#### Suspend Process

**Steps:**
1. **Prepare:**
   - Freeze processes
   - Save device state
   - Prepare for suspend

2. **Suspend Devices:**
   - Suspend device drivers
   - Save device state
   - Power down devices

3. **Enter Sleep:**
   - CPU enters sleep state
   - RAM in low-power mode
   - Minimal power consumption

**Wake Sources:**
- Power button
- RTC alarm
- Interrupts
- Wake locks (prevent suspend)

#### Resume Process

**Steps:**
1. **Wake:**
   - Wake source triggers
   - CPU exits sleep state
   - System begins resume

2. **Restore Devices:**
   - Restore device state
   - Resume device drivers
   - Reinitialize devices

3. **Thaw Processes:**
   - Unfreeze processes
   - Resume execution
   - System operational

**Resume Time:**
- Typically 1-3 seconds
- Depends on sleep depth
- Device initialization time
- Process restoration

### Android-Specific Power Management

#### Wakelocks

**What are Wakelocks:**
- Prevent system from sleeping
- Kernel-level mechanism
- Android-specific
- Critical for power management

**Types:**
- **Partial:** Screen off, CPU on
- **Full:** Screen on, CPU on
- **System:** System wakelocks
- **Kernel:** Kernel wakelocks

**Management:**
- Acquire when needed
- Release when done
- Leaked wakelocks drain battery
- Must be carefully managed

#### Early Suspend

**What is Early Suspend:**
- Android-specific feature
- Suspend display early
- CPU continues running
- Partial power savings

**Benefits:**
- Faster screen-off response
- Some power savings
- Background tasks continue
- Better user experience

#### Wakeup Sources

**What are Wakeup Sources:**
- Track what wakes system
- Identify wakeup causes
- Debug power issues
- Power optimization

**Common Sources:**
- Power button
- RTC alarms
- Network activity
- Sensor events
- Wakelocks

### Power Management Framework

#### PM Framework Components

**1. PM Core:**
- Core power management
- Suspend/resume framework
- Device PM coordination
- System-wide PM

**2. Device PM:**
- Per-device power management
- Device suspend/resume
- Power state management
- Driver integration

**3. CPU PM:**
- CPU frequency scaling
- CPU idle states
- CPU hotplug
- CPU power management

**4. System PM:**
- System suspend/resume
- Sleep state management
- Wake management
- Power policy

### Power Management APIs

#### Kernel APIs

**CPU Frequency:**
```c
cpufreq_set_policy()  // Set frequency policy
cpufreq_get()         // Get current frequency
```

**Suspend/Resume:**
```c
pm_suspend()          // Suspend system
pm_resume()           // Resume system
```

**Wake Locks:**
```c
wake_lock_init()      // Initialize wakelock
wake_lock()           // Acquire wakelock
wake_unlock()         // Release wakelock
```

#### User-Space APIs

**Sysfs Interface:**
```bash
# CPU frequency
/sys/devices/system/cpu/cpu0/cpufreq/scaling_governor
/sys/devices/system/cpu/cpu0/cpufreq/scaling_cur_freq

# Power management
/sys/power/state
/sys/power/wake_lock
/sys/power/wake_unlock
```

**Android APIs:**
- PowerManager (Java)
- WakeLock (Java)
- BatteryManager (Java)
- System properties

### Power Optimization

#### Optimization Strategies

**1. CPU Optimization:**
- Use appropriate governor
- Set frequency limits
- Optimize idle states
- Reduce CPU wakeups

**2. Display Optimization:**
- Reduce brightness
- Shorter timeout
- Adaptive brightness
- Dark mode

**3. Radio Optimization:**
- Turn off when not needed
- Batch network requests
- Reduce polling
- Use efficient protocols

**4. Background Activity:**
- Limit background tasks
- Batch operations
- Use efficient algorithms
- Reduce wakeups

#### Power Profiling

**Tools:**
- **PowerTop:** Linux power profiling
- **Battery Historian:** Android battery analysis
- **powertop:** Real-time power monitoring
- **dumpsys batterystats:** Android battery stats

**Process:**
1. Baseline measurement
2. Identify power consumers
3. Optimize high consumers
4. Measure improvements
5. Iterate

### Power Management Debugging

#### Common Issues

**High Power Consumption:**
- Check wakelocks
- Review CPU frequency
- Check background activity
- Review device usage

**Battery Drain:**
- Identify wakeup sources
- Check wakelock leaks
- Review CPU usage
- Check network activity

**Poor Performance:**
- Check CPU frequency limits
- Review governor settings
- Check thermal throttling
- Review scheduler settings

#### Debugging Tools

**Kernel Logs:**
```bash
dmesg | grep -i "power\|suspend\|resume"
dmesg | grep -i "wake\|wakelock"
```

**Power Statistics:**
```bash
cat /sys/power/wake_lock
cat /sys/power/wake_unlock
cat /proc/wakelocks
```

**CPU Frequency:**
```bash
cat /sys/devices/system/cpu/cpu*/cpufreq/scaling_cur_freq
cat /sys/devices/system/cpu/cpu*/cpufreq/scaling_governor
```

## Key Takeaways

1. **Kernel power management** controls system power consumption through CPU frequency scaling, sleep states, and device power control.

2. **CPU frequency scaling** dynamically adjusts CPU frequency based on workload, balancing performance and power consumption.

3. **Power governors** are policies that decide when to change CPU frequency, with different governors optimized for different use cases.

4. **Sleep states** (S0-S5) provide different levels of power savings, with deeper sleep saving more power but taking longer to wake.

5. **Suspend and resume** mechanisms put the system to sleep and restore it, with wake sources determining when to wake.

6. **Android-specific features** include wakelocks, early suspend, and wakeup source tracking for mobile-optimized power management.

7. **Power optimization** involves CPU, display, radio, and background activity optimization to maximize battery life.

8. **Understanding power management** is essential for battery optimization, performance tuning, and AOSP development.

## Related Topics

- **Wakelocks:** Android's mechanism for preventing system sleep
- **Scheduler internals:** How scheduling affects power consumption
- **Differences between Android kernel & Linux kernel:** Android-specific power management features
- **Android Architecture - Complete Overview:** How power management fits into Android architecture

