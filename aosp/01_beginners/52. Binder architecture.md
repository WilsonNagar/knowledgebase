---
number: 52
title: Binder architecture
slug: binder-architecture
level: beginner
tags:
  - aosp
  - binder
  - architecture
  - ipc
  - design
  - components
  - layers
prerequisites:
  - binder-ipc-basics
  - android-architecture-complete-overview
estimated_minutes: 90
contributors: []
diagrams: []
examples: []
canonical_id: aosp-beginner-52
---

# Binder architecture

## Overview

Binder architecture is the comprehensive design and structure of Android's Binder IPC system, including its layered components, design patterns, communication flow, and how all pieces work together. Understanding Binder architecture is essential for AOSP development, as it provides the foundation for all inter-process communication in Android and explains how the system is organized. This guide provides a comprehensive overview of Binder's architectural layers, components, design patterns, and how they integrate to provide efficient and secure IPC.

Think of Binder architecture like a multi-layered postal system: just as a postal system has layers (local post office, regional sorting centers, national network, delivery trucks), Binder has layers (application code, framework, native libraries, kernel driver). Each layer has specific responsibilities, and they work together to deliver messages (method calls) reliably and efficiently between processes.

## Deep Explanation

### Binder Architecture Overview

Binder architecture consists of multiple layers that work together to provide inter-process communication. Each layer has specific responsibilities and abstracts complexity from the layers above.

**Architectural Layers:**
1. **Application Layer:** Java/Kotlin code using AIDL interfaces
2. **Framework Layer:** Android Framework Binder APIs
3. **Native Layer:** C++ Binder libraries (libbinder)
4. **Kernel Layer:** Binder driver in Linux kernel

**Key Principles:**
- **Layered Design:** Clear separation of concerns
- **Abstraction:** Each layer hides complexity from above
- **Efficiency:** Optimized for Android's use cases
- **Security:** Built-in security mechanisms

### Architectural Layers

#### Layer 1: Application Layer

**What It Is:**
- Java/Kotlin application code
- Uses AIDL-generated interfaces
- Calls look like local method calls
- Transparent IPC

**Components:**
- **AIDL Interfaces:** Service interface definitions
- **Stub Classes:** Server-side implementation base
- **Proxy Classes:** Client-side proxy objects
- **Application Code:** Business logic

**Example:**
```java
// Application code
IMyService service = IMyService.Stub.asInterface(binder);
String result = service.doSomething("param");
```

**Characteristics:**
- Simple API for applications
- Type-safe through AIDL
- Transparent remote calls
- No knowledge of underlying layers

#### Layer 2: Framework Layer

**What It Is:**
- Android Framework Binder APIs
- Java Binder classes
- Service management
- Lifecycle handling

**Components:**
- **IBinder:** Base Binder interface
- **Binder:** Native Binder implementation
- **ServiceManager:** Service registry
- **Parcel:** Data serialization
- **Service:** Base service class

**Key Classes:**
```java
IBinder          // Base Binder interface
Binder           // Native Binder implementation
Service          // Base service class
ServiceManager   // Service registry
Parcel           // Data container
```

**Responsibilities:**
- Provide Java API for Binder
- Manage service lifecycle
- Handle service registration
- Serialize/deserialize data

#### Layer 3: Native Layer (libbinder)

**What It Is:**
- C++ Binder library
- Core Binder implementation
- Native Binder APIs
- Bridge to kernel

**Components:**
- **BpBinder:** Binder Proxy (client side)
- **BBinder:** Binder Base (server side)
- **Parcel:** Native data container
- **ProcessState:** Process Binder state
- **IPCThreadState:** Thread Binder state

**Key Classes:**
```cpp
BpBinder         // Binder Proxy
BBinder          // Binder Base
Parcel           // Data container
ProcessState     // Process state
IPCThreadState   // Thread state
```

**Responsibilities:**
- Implement Binder protocol
- Handle transaction marshaling
- Manage Binder threads
- Interface with kernel driver

#### Layer 4: Kernel Layer (Binder Driver)

**What It Is:**
- Linux kernel driver
- `/dev/binder` device
- Transaction routing
- Security enforcement

**Components:**
- **Binder Driver:** Kernel module
- **Device File:** `/dev/binder`
- **Transaction Queue:** Pending transactions
- **Process Management:** Binder process tracking

**Responsibilities:**
- Route transactions between processes
- Enforce security (permissions, caller identity)
- Manage memory (transaction buffers)
- Handle process death notifications

### Component Architecture

#### Client-Server Model

**Architecture:**
```
┌─────────────┐                    ┌─────────────┐
│   Client    │                    │   Server    │
│  Process    │                    │  Process    │
│             │                    │             │
│  BpBinder   │───Transaction─────▶│  BBinder    │
│  (Proxy)    │                    │  (Native)   │
│             │                    │             │
│  AIDL       │                    │  AIDL       │
│  Proxy      │                    │  Stub       │
└─────────────┘                    └─────────────┘
       │                                   │
       └───────────Binder Driver──────────┘
                    (Kernel)
```

**Client Side:**
- **BpBinder:** Proxy object representing remote Binder
- **AIDL Proxy:** Generated proxy class
- **Application Code:** Makes method calls

**Server Side:**
- **BBinder:** Native Binder object
- **AIDL Stub:** Generated stub class
- **Service Implementation:** Business logic

#### Binder Objects

**Binder Object Types:**
- **Local Binder:** Object in current process
- **Remote Binder:** Object in different process
- **Binder Token:** Unique identifier for Binder object
- **Binder Handle:** Reference to remote Binder

**Object Lifecycle:**
- Created when service registered
- Referenced by clients
- Reference counted
- Destroyed when no references

#### Service Discovery

**ServiceManager:**
- Central registry for services
- Maps service names to Binder tokens
- First service to start
- Critical for service discovery

**Discovery Flow:**
```
1. Client queries ServiceManager by name
2. ServiceManager returns Binder token
3. Client creates BpBinder with token
4. Client can now call service methods
```

### Design Patterns

#### Proxy Pattern

**What It Is:**
- BpBinder acts as proxy for remote Binder
- Client calls proxy, proxy forwards to remote
- Transparent to client code
- Handles marshaling/unmarshaling

**Benefits:**
- Transparent remote calls
- Type safety through AIDL
- Clean API for clients
- Hides complexity

#### Stub Pattern

**What It Is:**
- BBinder/Stub provides base implementation
- Server extends stub
- Handles transaction routing
- Unmarshals parameters

**Benefits:**
- Consistent transaction handling
- Automatic parameter unmarshaling
- Error handling
- Lifecycle management

#### Reference Counting

**What It Is:**
- Binder objects are reference counted
- Incremented when referenced
- Decremented when released
- Destroyed when count reaches zero

**Benefits:**
- Automatic memory management
- Prevents use-after-free
- Handles process death
- Efficient resource management

### Communication Flow

#### Transaction Flow

**Complete Flow:**
```
1. Client calls method on AIDL interface
   ↓
2. AIDL Proxy (BpBinder) marshals parameters
   ↓
3. BpBinder sends transaction to Binder driver
   ↓
4. Binder driver routes to server process
   ↓
5. Server's BBinder receives transaction
   ↓
6. AIDL Stub unmarshals parameters
   ↓
7. Stub calls service implementation
   ↓
8. Service executes business logic
   ↓
9. Stub marshals return value
   ↓
10. BBinder sends reply to Binder driver
   ↓
11. Binder driver routes reply to client
   ↓
12. BpBinder unmarshals return value
   ↓
13. Client receives result
```

#### Marshaling/Unmarshaling

**Marshaling (Client → Server):**
- Serialize parameters to Parcel
- Include transaction code
- Send to Binder driver
- Driver copies to server

**Unmarshaling (Server):**
- Receive Parcel from driver
- Deserialize parameters
- Extract transaction code
- Call appropriate method

**Return Marshaling:**
- Serialize return value
- Send reply transaction
- Client receives and deserializes

### Security Architecture

#### Caller Identity

**What It Is:**
- Binder tracks caller's identity
- Includes UID, PID, security context
- Available to server
- Enables permission checking

**Identity Components:**
- **UID:** User ID of caller
- **PID:** Process ID of caller
- **Security Context:** SELinux context
- **Package Name:** App package (if available)

**Usage:**
- Permission enforcement
- Access control
- Audit logging
- Security policies

#### Permission Checking

**How It Works:**
- Server receives caller identity
- Checks required permissions
- Grants or denies access
- Returns error if denied

**Permission Types:**
- **System Permissions:** Framework permissions
- **Custom Permissions:** App-defined permissions
- **Signature Permissions:** Same-signature apps
- **SELinux:** Kernel-level enforcement

### Threading Model

#### Binder Threads

**What They Are:**
- Threads dedicated to Binder transactions
- Created per process
- Handle incoming transactions
- Pool of threads for efficiency

**Thread Pool:**
- Default: 15 threads per process
- Configurable per process
- Handles concurrent transactions
- Prevents blocking

#### Transaction Execution

**Synchronous:**
- Most Binder calls are synchronous
- Client blocks until reply
- Server executes in Binder thread
- Return value sent back

**Asynchronous:**
- One-way transactions possible
- Client doesn't wait
- Fire-and-forget semantics
- No return value

### Memory Management

#### Transaction Buffers

**What They Are:**
- Memory buffers for transactions
- Allocated by Binder driver
- Shared between processes
- Freed after transaction

**Buffer Lifecycle:**
1. Allocated when transaction sent
2. Data copied into buffer
3. Buffer mapped to server
4. Freed after transaction complete

#### Zero-Copy Optimization

**Small Messages:**
- Messages < 1KB: zero-copy
- Data stays in kernel buffer
- No copying to userspace
- Very efficient

**Large Messages:**
- Messages > 1KB: one copy
- More efficient than sockets (two copies)
- Still optimized
- Acceptable performance

### Error Handling

#### Error Types

**Transaction Errors:**
- **DEAD_OBJECT:** Remote process died
- **BAD_TYPE:** Invalid transaction type
- **FAILED_TRANSACTION:** Transaction failed
- **TIMEOUT:** Transaction timeout

**Error Handling:**
- Errors returned to client
- Client can handle gracefully
- Service death detected
- Automatic cleanup

#### Process Death Handling

**Death Recipients:**
- Clients can register death recipients
- Notified when service dies
- Can clean up resources
- Can reconnect if needed

**Automatic Cleanup:**
- Binder driver detects process death
- Cleans up references
- Notifies clients
- Frees resources

### Performance Architecture

#### Optimization Strategies

**Efficient Marshaling:**
- Optimized Parcel implementation
- Type-specific serialization
- Minimal copying
- Fast path for common types

**Thread Pool:**
- Multiple threads handle transactions
- Prevents blocking
- Better concurrency
- Configurable size

**Memory Management:**
- Zero-copy for small messages
- Efficient buffer management
- Shared memory where possible
- Minimal allocations

### Integration Points

#### With System Services

**Service Registration:**
- Services register with ServiceManager
- Get Binder token
- Become discoverable
- Handle client requests

**Service Lifecycle:**
- Created during system startup
- Registered with ServiceManager
- Handle transactions
- Clean up on shutdown

#### With Applications

**Service Binding:**
- Apps bind to services
- Get Binder reference
- Make method calls
- Unbind when done

**AIDL Usage:**
- Apps define AIDL interfaces
- Generate proxy/stub
- Use for IPC
- Type-safe communication

## Key Takeaways

1. **Binder architecture is layered** with Application, Framework, Native, and Kernel layers, each with specific responsibilities.

2. **Client-Server model** is fundamental, with BpBinder (proxy) on client side and BBinder (native) on server side.

3. **ServiceManager** provides service discovery, mapping service names to Binder tokens for client lookup.

4. **Design patterns** include Proxy pattern (BpBinder), Stub pattern (BBinder/Stub), and Reference counting for lifecycle management.

5. **Transaction flow** involves marshaling, kernel routing, unmarshaling, execution, and reply, all transparent to application code.

6. **Security architecture** includes caller identity tracking, permission checking, and SELinux integration.

7. **Threading model** uses a pool of Binder threads per process to handle concurrent transactions efficiently.

8. **Understanding Binder architecture** is essential for AOSP development, system service implementation, and debugging IPC issues.

## Related Topics

- **Binder IPC Basics:** Introduction to Binder usage
- **Binder driver (low-level):** Kernel-level Binder implementation
- **ServiceManager:** Service discovery and registration
- **AIDL:** Interface definition language for Binder services

