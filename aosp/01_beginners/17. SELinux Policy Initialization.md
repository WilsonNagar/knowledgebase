---
number: 17
title: SELinux Policy Initialization
slug: selinux-policy-initialization
level: beginner
tags:
  - aosp
  - selinux
  - security
  - policy
  - initialization
  - boot
  - sepolicy
prerequisites:
  - selinux-overview
  - init-system-in-android
  - boot-process-overview
estimated_minutes: 90
contributors: []
diagrams: []
examples: []
canonical_id: aosp-beginner-17
---

# SELinux Policy Initialization

## Overview

SELinux policy initialization is the process by which Android loads and applies SELinux security policies during the boot sequence. This happens very early in the boot process, before most system services start, ensuring that security enforcement is active from the moment processes begin executing. Understanding how SELinux policy is initialized is crucial for AOSP development, as it affects system security, service startup, and debugging of security-related issues.

Think of SELinux policy initialization as "setting up the security rules before the game begins." Just as a sports referee establishes the rules before the match starts, Android must load and apply SELinux policies before processes can interact with each other and system resources. Without proper policy initialization, the system would either be insecure or unable to function properly.

## Deep Explanation

### What is SELinux Policy Initialization?

SELinux policy initialization is the multi-stage process of:
1. **Loading the policy binary** into the kernel
2. **Setting SELinux mode** (permissive or enforcing)
3. **Labeling the filesystem** with security contexts
4. **Applying contexts to processes** as they start
5. **Enforcing policies** throughout system operation

This process ensures that every process, file, and system resource has a proper security context and that all access control decisions can be made according to the loaded policy.

**Key Characteristics:**
- **Early execution:** Happens during early-init phase
- **Critical path:** System cannot function properly without it
- **One-time load:** Policy loaded once at boot (though can be reloaded)
- **Kernel integration:** Policy loaded into kernel's SELinux subsystem
- **Filesystem-wide:** All files must be labeled with contexts

### Why Policy Initialization Matters

**1. Security Foundation:**
- Establishes security boundaries before services start
- Prevents unauthorized access from the beginning
- Ensures defense in depth from boot

**2. System Functionality:**
- Services need proper contexts to function
- File access requires correct labeling
- IPC communication needs policy rules

**3. Boot Sequence Dependency:**
- Many services depend on SELinux being initialized
- File operations require labeled filesystem
- Process creation needs domain transitions

### Policy Initialization Timeline

#### Boot Sequence Context

```
1. Kernel boots
   ↓
2. Initramfs loaded
   ↓
3. Init process starts (PID 1)
   ↓
4. Early-init phase begins
   ↓
5. SELinux policy initialization ← WE ARE HERE
   ├── Load policy binary
   ├── Set SELinux mode
   ├── Label filesystem
   └── Enable enforcement
   ↓
6. Init phase
   ↓
7. Late-init phase
   ↓
8. Services start (with SELinux contexts)
```

#### Critical Timing

**Why Early:**
- Must happen before filesystem operations
- Required before process creation
- Needed for service startup
- Prevents security gaps

**When It Happens:**
- During `early-init` phase in init.rc
- Before mounting system partitions (in some cases)
- After basic filesystem setup
- Before service startup

### Policy Loading Process

#### Step 1: Policy Binary Location

The SELinux policy binary is located in the initramfs or early filesystem:

**Locations:**
- `/sepolicy` - Primary location (in initramfs)
- `/sys/fs/selinux/policy` - Kernel interface
- `/system/etc/selinux/` - System partition (after mount)
- `/vendor/etc/selinux/` - Vendor partition (after mount)

**Initramfs Policy:**
- Policy included in boot image
- Available before system partition mount
- Used for early boot security
- May be replaced by system partition policy

**Example:**
```bash
# Policy in initramfs
$ ls -l /sepolicy
-rw-r--r-- 1 root root 524288 /sepolicy

# Policy loaded into kernel
$ cat /sys/fs/selinux/policy | wc -c
524288
```

#### Step 2: Loading Policy into Kernel

The init process loads the policy binary into the kernel's SELinux subsystem:

**Loading Mechanism:**
```c
// Simplified init code
int load_policy(const char* policy_path) {
    // Open policy file
    int fd = open(policy_path, O_RDONLY);
    
    // Read policy size
    size_t policy_size = get_file_size(fd);
    
    // Allocate buffer
    void* policy_data = malloc(policy_size);
    read(fd, policy_data, policy_size);
    
    // Load into kernel
    security_load_policy(policy_data, policy_size);
    
    close(fd);
    return 0;
}
```

**Kernel Interface:**
- Policy loaded via `/sys/fs/selinux/load`
- Kernel validates policy format
- Policy compiled into kernel's access vector cache
- Loading is atomic (all or nothing)

**Init.rc Command:**
```
on early-init
    # Load SELinux policy
    load_policy /sepolicy
```

#### Step 3: Policy Validation

After loading, the kernel validates the policy:

**Validation Checks:**
- Policy format correctness
- Version compatibility
- Syntax validation
- Consistency checks

**Failure Handling:**
- Invalid policy causes boot failure
- System may fall back to permissive mode
- Errors logged to kernel log
- May require policy rebuild

### SELinux Mode Transition

#### Initial Mode: Permissive

**Why Start Permissive:**
- Allows policy loading without blocking
- Enables filesystem labeling
- Prevents boot failures from policy issues
- Logs violations for debugging

**Permissive Mode Characteristics:**
- Policy checked but not enforced
- Violations logged but allowed
- Used during initialization
- Transition to enforcing after setup

#### Transition to Enforcing

**When Transition Happens:**
- After policy is loaded
- After filesystem is labeled
- Before services start
- During early-init or init phase

**Transition Command:**
```
on early-init
    load_policy /sepolicy
    # ... label filesystem ...
    setenforce 1  # Transition to enforcing
```

**Enforcing Mode:**
- Policy violations are denied
- Security fully active
- Production mode
- Cannot be bypassed

#### Mode Checking

**Current Mode:**
```bash
# Check current mode
$ getenforce
Enforcing

# Detailed status
$ sestatus
SELinux status:                 enabled
SELinuxfs mount:                /sys/fs/selinux
Current mode:                   enforcing
Mode from config file:          enforcing
Policy version:                 30
Policy from config file:        /sepolicy
```

### Filesystem Labeling

#### File Contexts

File contexts map file paths to SELinux security contexts:

**File Contexts File:**
- Location: `/file_contexts` (in initramfs)
- Format: `path_regex context [file_type]`
- Used during boot to label filesystem
- Applied recursively to directories

**Example file_contexts:**
```
# System files
/system/bin/.* u:object_r:system_file:s0
/system/lib/.* u:object_r:system_file:s0

# App data
/data/data(/.*)? u:object_r:app_data_file:s0

# Vendor files
/vendor/bin/.* u:object_r:vendor_file:s0
```

#### Labeling Process

**restorecon Command:**
```bash
# Restore contexts for directory
restorecon -R /system

# Restore contexts for file
restorecon /system/bin/app_process

# Verbose output
restorecon -v -R /data
```

**Init.rc Usage:**
```
on early-init
    # Label filesystem
    restorecon_recursive /system
    restorecon_recursive /vendor
    restorecon_recursive /data
```

#### Labeling Timing

**When Labeling Happens:**
- During early-init phase
- After policy is loaded
- Before enforcing mode
- After partitions are mounted

**Labeling Order:**
1. System partition mounted
2. Policy loaded
3. File contexts applied
4. Enforcing mode enabled

### Process Context Initialization

#### Init Process Context

The init process itself has a SELinux context:

**Init Context:**
- Domain: `init`
- Context: `u:r:init:s0`
- Highest privileges
- Can transition to other domains

**Viewing Init Context:**
```bash
# View init process context
$ ps -Z | grep init
u:r:init:s0                   1     0 /init
```

#### Domain Transitions

Processes transition from one SELinux domain to another:

**Transition Rules:**
- Defined in policy
- Init can transition to service domains
- Zygote transitions to app domains
- Controlled by policy rules

**Example Transition:**
```
# Policy rule allowing transition
type_transition init my_service:process my_service;

# Init starts service
service my_service /system/bin/my_service
    seclabel u:r:my_service:s0
```

#### Service Context Assignment

Services get their contexts from:

**1. Service Definition:**
```
service zygote /system/bin/app_process
    seclabel u:r:zygote:s0
```

**2. Default Context:**
- If not specified, uses init context
- May transition based on policy
- Context inherited from parent

**3. seapp_contexts:**
- Maps app attributes to contexts
- Based on UID, package name, etc.
- Used for app process contexts

### Policy Files in Detail

#### sepolicy (Binary Policy)

**Location:**
- `/sepolicy` - Initramfs
- `/system/etc/selinux/` - System partition
- `/vendor/etc/selinux/` - Vendor partition

**Format:**
- Binary format (compiled from source)
- Not human-readable
- Loaded directly into kernel
- Version-specific

**Size:**
- Typically 500KB - 2MB
- Depends on policy complexity
- Grows with Android versions
- Device-specific additions

#### file_contexts

**Purpose:**
- Maps file paths to SELinux contexts
- Used for filesystem labeling
- Applied during boot
- Updated when filesystem changes

**Format:**
```
# Format: path_regex context [file_type]
/system/bin/.* u:object_r:system_file:s0
/data/data(/.*)? u:object_r:app_data_file:s0
```

**Application:**
- `restorecon` uses this file
- Applied recursively
- Regex pattern matching
- Order matters (first match wins)

#### property_contexts

**Purpose:**
- Maps system properties to contexts
- Controls property access
- Defines who can read/write properties

**Format:**
```
# Format: property_name context
ro.build.version.release u:object_r:system_prop:s0
persist.sys.timezone u:object_r:system_prop:s0
```

**Usage:**
- Property service uses this
- Enforces property access
- Prevents unauthorized access
- Logs violations

#### service_contexts

**Purpose:**
- Maps Binder service names to contexts
- Controls service access
- Defines service security

**Format:**
```
# Format: service_name context
activity u:object_r:activity_service:s0
window u:object_r:window_service:s0
```

**Usage:**
- ServiceManager uses this
- Enforces service access
- Prevents unauthorized service calls
- Critical for IPC security

#### seapp_contexts

**Purpose:**
- Maps app attributes to contexts
- Determines app process context
- Based on UID, package name, etc.

**Format:**
```
# Format: isSystemServer, user, seinfo, name, domain, type, level
true ,, system_app ,, system_app ,, ,,
false ,, untrusted_app ,, untrusted_app ,, ,,
```

**Usage:**
- Zygote uses this
- Assigns contexts to apps
- Isolates apps from each other
- Critical for app security

### Policy Initialization in Init.rc

#### Early-Init Phase

**Typical SELinux Initialization:**
```
on early-init
    # Create SELinux filesystem
    mkdir /sys/fs/selinux 0755 root root
    
    # Mount SELinux filesystem
    mount selinuxfs selinuxfs /sys/fs/selinux noatime
    
    # Load SELinux policy
    load_policy /sepolicy
    
    # Start in permissive mode
    setenforce 0
    
    # Label early filesystem
    restorecon /sys/fs/selinux
    restorecon /dev
```

#### Init Phase

**Continuing Initialization:**
```
on init
    # Mount system partitions
    mount ext4 /dev/block/... /system ro
    
    # Label system partition
    restorecon_recursive /system
    
    # Load additional policy files (if needed)
    # Policy may be updated from system partition
    
    # Transition to enforcing
    setenforce 1
```

#### Late-Init Phase

**Final Setup:**
```
on late-init
    # Ensure all filesystems labeled
    restorecon_recursive /vendor
    restorecon_recursive /data
    
    # Verify SELinux status
    # Services will start with proper contexts
```

### Policy Reloading

#### When Policy Can Be Reloaded

**Development Scenarios:**
- Policy updates during development
- Testing policy changes
- Debugging policy issues

**Limitations:**
- Not typically done in production
- Requires root access
- May cause service restarts
- Complex operation

#### Reload Process

**Manual Reload:**
```bash
# Load new policy
load_policy /path/to/new/sepolicy

# Reload file contexts
restorecon -R /system
```

**Risks:**
- May break running services
- Context mismatches
- Access denied errors
- System instability

### Real-World Examples

#### Example 1: Standard Policy Initialization

**Complete Init.rc Sequence:**
```
on early-init
    # Setup SELinux
    mkdir /sys/fs/selinux 0755
    mount selinuxfs selinuxfs /sys/fs/selinux noatime
    
    # Load policy
    load_policy /sepolicy
    
    # Start permissive
    setenforce 0
    
    # Label early filesystem
    restorecon /sys/fs/selinux
    restorecon /dev

on init
    # Mount partitions
    mount ext4 /dev/block/system /system ro
    
    # Label system
    restorecon_recursive /system
    
    # Go enforcing
    setenforce 1

on late-init
    # Label remaining partitions
    restorecon_recursive /vendor
    restorecon_recursive /data
```

#### Example 2: Debugging Policy Issues

**Enable Permissive Mode:**
```bash
# Set permissive for debugging
adb shell setenforce 0

# Check violations
adb logcat | grep avc

# Analyze violations
adb shell dmesg | grep avc

# Fix policy and reload
load_policy /path/to/fixed/sepolicy
setenforce 1
```

#### Example 3: Custom Service Context

**Adding New Service:**
```
# In sepolicy
type my_service, domain;
init_daemon_domain(my_service)

# In service_contexts
my_service u:object_r:my_service:s0

# In init.rc
service my_service /system/bin/my_service
    seclabel u:r:my_service:s0
    class main
```

### Edge Cases and Pitfalls

#### Common Mistakes

**1. Missing Policy File:**
```bash
# BAD: Policy not in initramfs
# Boot will fail or be insecure

# GOOD: Ensure policy in initramfs
$ ls -l /sepolicy
-rw-r--r-- 1 root root 524288 /sepolicy
```

**2. Wrong Labeling Order:**
```bash
# BAD: Enforcing before labeling
setenforce 1
restorecon_recursive /system  # May fail!

# GOOD: Label before enforcing
restorecon_recursive /system
setenforce 1
```

**3. Missing File Contexts:**
```bash
# BAD: Files not labeled
# Services may fail to access files

# GOOD: Proper labeling
restorecon_recursive /system
restorecon_recursive /vendor
restorecon_recursive /data
```

**4. Policy Version Mismatch:**
```bash
# BAD: Policy version incompatible
# Kernel may reject policy

# GOOD: Match policy version to kernel
# Check policy version compatibility
```

### Best Practices

#### For System Developers

**1. Policy Initialization:**
- Load policy early in boot
- Label filesystem before enforcing
- Use permissive mode during development
- Test thoroughly before enforcing

**2. File Labeling:**
- Label all partitions
- Use restorecon_recursive for directories
- Verify contexts after labeling
- Update file_contexts when adding files

**3. Service Contexts:**
- Define contexts for all services
- Use appropriate domains
- Follow least privilege principle
- Document context decisions

**4. Debugging:**
- Use permissive mode for development
- Collect all violations before fixing
- Understand violation causes
- Test in enforcing mode

#### For Application Developers

**1. Understanding Policy:**
- Know that SELinux is always active
- Understand app context limitations
- Be aware of file access restrictions
- Report violations properly

**2. Debugging Issues:**
- Check SELinux violations in logcat
- Use permissive mode for testing
- Understand violation messages
- Work with system team for fixes

## References and Further Reading

- [AOSP SELinux Documentation](https://source.android.com/docs/security/features/selinux)
- [SELinux Policy Initialization](https://source.android.com/docs/security/features/selinux/device-policy)
- [Init System in Android](./04.%20Init%20System%20in%20Android.md)
- [SELinux Overview](./07.%20SELinux%20Overview.md)

## Quiz

### Question 1
When does SELinux policy initialization occur during the Android boot process?

**A)** After all services have started  
**B)** During the late-init phase  
**C)** During the early-init phase, before most system services start  
**D)** Only when explicitly triggered by a service

**Answer: C** - SELinux policy initialization happens during the early-init phase, very early in the boot process. This ensures that security policies are loaded and active before processes begin executing and accessing system resources.

### Question 2
What is the purpose of starting SELinux in permissive mode during initialization?

**A)** To improve system performance  
**B)** To allow policy loading and filesystem labeling without blocking operations  
**C)** To disable security temporarily  
**D)** To reduce memory usage

**Answer: B** - Starting in permissive mode allows the system to load the policy and label the filesystem without blocking operations. Violations are logged but not denied, which prevents boot failures while still establishing the security foundation. The system then transitions to enforcing mode.

### Question 3
What is the primary file used to map file paths to SELinux contexts during filesystem labeling?

**A)** sepolicy  
**B)** file_contexts  
**C)** property_contexts  
**D)** service_contexts

**Answer: B** - The `file_contexts` file contains mappings between file path patterns (using regex) and SELinux security contexts. This file is used by `restorecon` to label the filesystem during boot, ensuring all files have proper security contexts.

### Question 4
What command is used to apply SELinux contexts to files based on the file_contexts file?

**A)** `setenforce`  
**B)** `load_policy`  
**C)** `restorecon`  
**D)** `getenforce`

**Answer: C** - The `restorecon` command reads the `file_contexts` file and applies the appropriate SELinux contexts to files and directories. The `-R` flag applies contexts recursively to directories.

### Question 5
Why is it important to label the filesystem before transitioning SELinux to enforcing mode?

**A)** To improve boot performance  
**B)** To prevent access denied errors when files are accessed with incorrect or missing contexts  
**C)** To reduce memory usage  
**D)** To enable policy reloading

**Answer: B** - If the filesystem is not properly labeled before enforcing mode is enabled, processes may try to access files that don't have the correct SELinux contexts. This would result in access denied errors and could prevent the system from booting properly or cause services to fail.

## Related Topics

- [SELinux Overview](./07.%20SELinux%20Overview.md)
- [Init System in Android](./04.%20Init%20System%20in%20Android.md)
- [Boot Process Overview](./03.%20Boot%20Process%20Overview.md)
- [Initramfs in Android](./14.%20Initramfs%20in%20Android.md)

