---
number: 13
title: Boot Partitions
slug: boot-partitions
level: beginner
tags:
  - aosp
  - boot
  - partitions
  - bootloader
  - kernel
  - ramdisk
  - boot-image
prerequisites:
  - android-partitions
  - boot-process-overview
estimated_minutes: 90
contributors: []
diagrams: []
examples: []
canonical_id: aosp-beginner-13
---

# Boot Partitions

## Overview

Boot partitions are critical storage areas on Android devices that contain the essential components needed to start the Android system. Unlike other partitions that contain file systems, boot partitions store binary images in a special format that the bootloader can directly load into memory. Understanding boot partitions is essential for AOSP development, as they determine how the device boots, what kernel runs, and how the initial system is set up.

Think of boot partitions like a "starter kit" for your device - they contain everything needed to get the device running: the bootloader instructions, the kernel (the core of the operating system), the initial filesystem (ramdisk), and hardware configuration (device tree). Without a valid boot partition, the device cannot start, making it one of the most critical components of the Android system.

## Deep Explanation

### What are Boot Partitions?

Boot partitions are dedicated storage areas that contain bootable images - special binary formats that the bootloader can directly load and execute. Unlike regular partitions that contain file systems (like ext4), boot partitions contain raw binary data in a specific format.

**Key Characteristics:**
- **Raw Binary Format:** Not a file system, but a structured binary image
- **Bootloader-Readable:** Format understood by the bootloader
- **Critical for Boot:** Device cannot boot without valid boot partition
- **Small Size:** Typically 64-128 MB (much smaller than system partition)
- **Read-Only:** Not mounted during normal operation
- **Signed:** Must be cryptographically signed for verified boot

**Physical Location:**
```
Storage Device (eMMC/UFS)
├── boot partition (typically 64-128 MB)
├── system partition
├── vendor partition
└── data partition
```

### Boot Partition Structure

#### Boot Image Format

Android uses a special boot image format that packages multiple components into a single binary file:

```
boot.img Structure:
┌─────────────────────────────────────┐
│ Boot Image Header                   │
│ - Magic number                      │
│ - Kernel size                       │
│ - Kernel load address               │
│ - Ramdisk size                      │
│ - Ramdisk load address              │
│ - Second stage size (optional)      │
│ - Tags offset                       │
│ - Page size                         │
│ - Device tree size                  │
│ - Device tree load address          │
│ - Header version                    │
│ - Header size                       │
├─────────────────────────────────────┤
│ Kernel Image                        │
│ (compressed Linux kernel)           │
├─────────────────────────────────────┤
│ Ramdisk Image                       │
│ (cpio archive with initramfs)      │
├─────────────────────────────────────┤
│ Second Stage (optional)             │
│ (additional bootloader code)        │
├─────────────────────────────────────┤
│ Device Tree Blob (DTB)              │
│ (hardware configuration)            │
└─────────────────────────────────────┘
```

**Boot Image Header:**
- Contains metadata about the boot image
- Specifies sizes and load addresses
- Different versions (v0, v1, v2, v3) with different features
- Header version determines format compatibility

**Kernel Image:**
- Compressed Linux kernel (typically gzip or lz4)
- Contains core operating system code
- Handles hardware abstraction
- Manages memory, processes, and drivers

**Ramdisk Image:**
- CPIO archive containing initial root filesystem
- Contains init binary and early boot scripts
- Provides minimal environment before main filesystem mounts
- Critical for early boot process

**Device Tree Blob:**
- Hardware configuration data
- Describes device hardware to kernel
- Platform-specific information
- Replaces hardcoded hardware descriptions

### Boot Image Versions

Android boot images have evolved through several versions:

#### Boot Image v0 (Legacy)
- Original Android boot image format
- Fixed header size (8 KB)
- Limited metadata
- Still supported for compatibility

#### Boot Image v1
- Added recovery DTBO support
- Better header structure
- More flexible layout

#### Boot Image v2
- Added vendor ramdisk support
- Support for vendor-specific boot components
- Better separation of concerns

#### Boot Image v3
- Support for boot signature
- Enhanced security features
- Better error handling

**Checking Boot Image Version:**
```bash
# Unpack boot image to check version
$ unpack_bootimg --boot_img boot.img --out boot_unpacked/
$ cat boot_unpacked/boot.img-header
# Look for "boot_img_hdr_v" field
```

### Boot Partition Contents

#### 1. Bootloader Code (Optional)

Some boot partitions may contain additional bootloader code:
- **Second Stage Bootloader:** Additional bootloader code
- **Bootloader Configuration:** Settings and parameters
- **Recovery Bootloader:** Alternative boot path

**Note:** Modern devices often store bootloader in separate partition or ROM.

#### 2. Kernel Image

The kernel is the core of the Linux-based Android system:

**Kernel Components:**
- **Core Kernel:** Process management, memory management, scheduling
- **Device Drivers:** Hardware interface code
- **File System Support:** ext4, f2fs, etc.
- **Network Stack:** TCP/IP, networking protocols
- **Security Modules:** SELinux, etc.

**Kernel Compression:**
- Typically compressed with gzip or lz4
- Decompressed by bootloader before execution
- Reduces boot partition size
- Faster loading from storage

**Kernel Configuration:**
- Compiled with specific options
- Device-specific drivers included
- Optimized for target hardware
- Defines available features

#### 3. Ramdisk (Initramfs)

The ramdisk contains the initial root filesystem:

**Ramdisk Contents:**
```
/init                    - Init binary (first user-space process)
/init.rc                 - Init configuration script
/sbin/                   - System binaries
/system/                 - System partition mount point
/vendor/                 - Vendor partition mount point
/dev/                    - Device nodes
/proc/                   - Proc filesystem
/sys/                    - Sysfs filesystem
/default.prop            - Default system properties
/file_contexts           - SELinux file contexts
/sepolicy                - SELinux policy
```

**Ramdisk Purpose:**
- Provides minimal environment before main filesystem mounts
- Contains init process that starts system services
- Sets up early filesystem structure
- Loads SELinux policy
- Mounts system partitions

**Ramdisk Format:**
- CPIO archive (newc format)
- Compressed (typically gzip)
- Extracted to RAM during boot
- Temporary - replaced by real root filesystem

#### 4. Device Tree Blob (DTB)

Device Tree describes hardware configuration:

**Device Tree Purpose:**
- Describes hardware to kernel
- Platform-specific configuration
- Replaces hardcoded hardware info
- Enables single kernel for multiple devices

**Device Tree Contents:**
- CPU information
- Memory layout
- Peripheral addresses
- Interrupt mappings
- Clock configurations
- GPIO configurations

**Device Tree Overlay (DTBO):**
- Additional hardware configuration
- Stored in separate DTBO partition
- Applied on top of base DTB
- Enables hardware variants

### A/B Boot Partitions

Modern Android devices support A/B partitions for seamless updates:

#### A/B Boot Partition Layout

```
boot_a    - Boot partition slot A
boot_b    - Boot partition slot B
```

**How A/B Boot Works:**
1. Device boots from one slot (e.g., boot_a)
2. Update installs new boot image to other slot (boot_b)
3. Bootloader switches to updated slot on next boot
4. Allows rollback if update fails

**Benefits:**
- Seamless updates (no recovery mode needed)
- Rollback capability
- Reduced downtime
- Better user experience

**Checking Current Boot Slot:**
```bash
# Check current slot
$ getprop ro.boot.slot_suffix
_a  # or _b

# Check if A/B supported
$ getprop ro.build.ab_update
true
```

**Viewing A/B Boot Partitions:**
```bash
# List boot partitions
$ ls -l /dev/block/by-name/ | grep boot
boot_a -> /dev/block/sda1
boot_b -> /dev/block/sda2
```

### Boot Partition Access

#### Block Device Access

Boot partitions are accessed via block devices:

**Block Device Paths:**
```bash
# By-name symlink (preferred)
/dev/block/bootdevice/by-name/boot
/dev/block/bootdevice/by-name/boot_a
/dev/block/bootdevice/by-name/boot_b

# Direct block device
/dev/block/mmcblk0p1  # First partition
/dev/block/mmcblk0p2  # Second partition
```

**Listing Boot Partitions:**
```bash
# List all partitions
$ lsblk

# List by-name links
$ ls -l /dev/block/bootdevice/by-name/ | grep boot

# Get partition info
$ blockdev --getsize64 /dev/block/bootdevice/by-name/boot
```

#### Reading Boot Partition

**Extracting Boot Image:**
```bash
# Extract boot partition (requires root)
$ dd if=/dev/block/bootdevice/by-name/boot of=/sdcard/boot.img bs=4096

# Extract from specific slot
$ dd if=/dev/block/bootdevice/by-name/boot_a of=/sdcard/boot_a.img bs=4096
```

**Unpacking Boot Image:**
```bash
# Using unpack_bootimg (Android build tools)
$ unpack_bootimg --boot_img boot.img --out boot_unpacked/

# Output structure:
# boot_unpacked/
# ├── boot.img-header
# ├── boot.img-kernel
# ├── boot.img-ramdisk.cpio
# └── boot.img-second
```

**Alternative Tools:**
```bash
# Using abootimg (Linux tool)
$ abootimg -x boot.img

# Using mkbootimg/unpackbootimg (legacy)
$ unpackbootimg -i boot.img -o boot_unpacked/
```

### Boot Image Creation

#### Building Boot Image

Boot images are created during AOSP build:

**Build Process:**
```
1. Kernel compiled → Image.gz
2. Ramdisk created → ramdisk.cpio.gz
3. Device tree compiled → dtb
4. mkbootimg combines all → boot.img
5. Boot image signed (if verified boot enabled)
```

**Manual Boot Image Creation:**
```bash
# Using mkbootimg
$ mkbootimg \
  --kernel Image.gz \
  --ramdisk ramdisk.cpio.gz \
  --dtb device.dtb \
  --base 0x80000000 \
  --pagesize 4096 \
  --output boot.img

# Using abootimg
$ abootimg --create boot.img \
  -f bootimg.cfg \
  -k zImage \
  -r ramdisk.cpio.gz
```

**Boot Image Configuration:**
```bash
# bootimg.cfg example
bootsize = 0x4000000
pagesize = 4096
kerneladdr = 0x80008000
ramdiskaddr = 0x81000000
secondaddr = 0x80f00000
tagsaddr = 0x80000100
```

### Boot Partition Security

#### Verified Boot

Boot partitions are critical for device security:

**Verified Boot Process:**
1. Bootloader verifies boot partition signature
2. Checks cryptographic signature
3. Validates partition integrity
4. Prevents tampering

**Boot Signature:**
- Cryptographically signed with device keys
- Signature stored in boot image (v3+) or separate partition
- Bootloader verifies before loading
- Prevents unauthorized modifications

**Chain of Trust:**
```
Boot ROM → Bootloader → Boot Partition → Kernel → System
   (trusted)    (verified)      (verified)    (verified)
```

#### dm-verity

Runtime verification of boot partition:
- Hash tree verification
- Detects tampering at runtime
- Transparent to applications
- Protects boot integrity

### Boot Partition Updates

#### OTA Updates

Boot partitions are updated via OTA:

**OTA Update Process:**
1. OTA package contains new boot.img
2. Update script verifies signature
3. Boot image written to inactive slot (B if on A)
4. Bootloader updated to boot from new slot
5. Device reboots with new boot image

**Update Verification:**
- Signature verification before writing
- Integrity check after writing
- Rollback if verification fails

#### Fastboot Updates

Boot partitions can be updated via fastboot:

**Fastboot Commands:**
```bash
# Flash boot partition
$ fastboot flash boot boot.img

# Flash to specific slot
$ fastboot flash boot_a boot.img
$ fastboot flash boot_b boot.img

# Boot without flashing (temporary)
$ fastboot boot boot.img

# Check boot partition
$ fastboot getvar boot-size
```

**Requirements:**
- Bootloader unlocked (for development)
- Fastboot mode enabled
- Valid boot image
- Device-specific compatibility

### Boot Partition Management

#### Viewing Boot Partition Information

**Partition Size:**
```bash
# Get boot partition size
$ blockdev --getsize64 /dev/block/bootdevice/by-name/boot

# Get partition info
$ fdisk -l /dev/block/mmcblk0 | grep boot
```

**Boot Image Information:**
```bash
# Using file command
$ file boot.img
boot.img: Android bootimg, kernel, ramdisk, page size: 4096

# Using abootimg
$ abootimg -i boot.img
```

#### Backup and Restore

**Backup Boot Partition:**
```bash
# Backup boot partition
$ dd if=/dev/block/bootdevice/by-name/boot of=/sdcard/boot_backup.img bs=4096

# Backup both slots (A/B)
$ dd if=/dev/block/bootdevice/by-name/boot_a of=/sdcard/boot_a_backup.img
$ dd if=/dev/block/bootdevice/by-name/boot_b of=/sdcard/boot_b_backup.img
```

**Restore Boot Partition:**
```bash
# Restore boot partition (DANGEROUS - can brick device!)
$ dd if=/sdcard/boot_backup.img of=/dev/block/bootdevice/by-name/boot bs=4096

# Via fastboot (safer)
$ fastboot flash boot boot_backup.img
```

**⚠️ Warning:**
- Always backup before modifying
- Invalid boot image can brick device
- Test on non-critical devices first
- Understand recovery procedures

### Boot Partition Troubleshooting

#### Common Issues

**Issue 1: Boot Loop**
- **Symptom:** Device reboots continuously
- **Cause:** Corrupted boot image or incompatible kernel
- **Solution:** Restore valid boot image, check kernel compatibility

**Issue 2: Boot Stuck at Logo**
- **Symptom:** Device shows boot logo but doesn't progress
- **Cause:** Kernel panic, init failure, or missing ramdisk
- **Solution:** Check kernel logs, verify ramdisk, check init process

**Issue 3: Verified Boot Failure**
- **Symptom:** "Your device is corrupt" message
- **Cause:** Boot partition signature invalid or tampered
- **Solution:** Restore signed boot image, check verified boot status

**Issue 4: A/B Slot Mismatch**
- **Symptom:** Device boots but system doesn't match boot
- **Cause:** Boot and system from different slots
- **Solution:** Ensure boot and system slots match, check slot suffix

#### Debugging Boot Issues

**Kernel Logs:**
```bash
# View kernel messages
$ dmesg

# View boot logs
$ logcat -b kernel

# Check last kernel message
$ dmesg | tail -50
```

**Boot Process Logs:**
```bash
# View init logs
$ logcat -b all | grep init

# Check boot process
$ logcat -b all | grep -E "(boot|init|zygote)"
```

**Boot Partition Verification:**
```bash
# Check boot partition integrity
$ fsck.vfat /dev/block/bootdevice/by-name/boot  # If FAT
# Or verify boot image structure
$ file boot.img
```

### Real-World Examples

#### Example 1: Extracting and Analyzing Boot Image

```bash
# Extract boot partition
$ adb shell
# su
# dd if=/dev/block/bootdevice/by-name/boot of=/sdcard/boot.img bs=4096

# Transfer to host
$ adb pull /sdcard/boot.img .

# Unpack boot image
$ unpack_bootimg --boot_img boot.img --out boot_unpacked/

# Extract ramdisk
$ cd boot_unpacked/
$ mkdir ramdisk
$ cd ramdisk
$ gunzip -c ../boot.img-ramdisk.cpio | cpio -i

# View ramdisk contents
$ ls -la
$ cat init.rc
```

#### Example 2: Creating Custom Boot Image

```bash
# Prepare components
# 1. Kernel: Image.gz (from kernel build)
# 2. Ramdisk: ramdisk.cpio.gz (from AOSP build)
# 3. Device tree: device.dtb (from device tree build)

# Create boot image
$ mkbootimg \
  --kernel Image.gz \
  --ramdisk ramdisk.cpio.gz \
  --dtb device.dtb \
  --base 0x80000000 \
  --pagesize 4096 \
  --cmdline "console=ttyMSM0,115200,n8" \
  --output boot_custom.img

# Verify boot image
$ file boot_custom.img

# Flash to device (requires unlocked bootloader)
$ fastboot flash boot boot_custom.img
```

#### Example 3: A/B Boot Partition Management

```bash
# Check current slot
$ getprop ro.boot.slot_suffix
_a

# View both boot partitions
$ ls -l /dev/block/by-name/ | grep boot
boot_a -> /dev/block/sda1
boot_b -> /dev/block/sda2

# Backup both slots
$ dd if=/dev/block/by-name/boot_a of=/sdcard/boot_a.img
$ dd if=/dev/block/by-name/boot_b of=/sdcard/boot_b.img

# Update inactive slot (B if on A)
$ fastboot flash boot_b new_boot.img

# Switch to slot B (next boot will use B)
$ fastboot set_active b
```

### Best Practices

#### For System Developers

**1. Boot Image Management:**
- Always backup boot partition before modifications
- Test boot images on non-critical devices first
- Keep original boot images for recovery
- Document boot image changes

**2. A/B Partition Handling:**
- Always update both slots during development
- Verify slot consistency (boot and system match)
- Test rollback scenarios
- Handle slot switching properly

**3. Security Considerations:**
- Sign boot images for production
- Verify boot signatures before flashing
- Use verified boot when possible
- Protect boot partition access

**4. Debugging:**
- Keep kernel logs for boot issues
- Use permissive SELinux for debugging (then fix properly)
- Test boot process thoroughly
- Document known issues

#### For Application Developers

**1. Boot Partition Awareness:**
- Understand that boot partition is read-only
- Don't try to modify boot partition from apps
- Be aware of A/B partition implications
- Understand boot process for debugging

**2. Boot-Related Issues:**
- Boot loops may indicate system-level problems
- Boot time affects user experience
- Monitor boot performance
- Report boot issues to system team

### Edge Cases and Pitfalls

#### Common Mistakes

**1. Modifying Boot Partition Incorrectly:**
```bash
# BAD: Direct modification without understanding
$ echo "test" > /dev/block/bootdevice/by-name/boot  # WRONG!

# GOOD: Extract, modify, repack, flash
$ dd if=/dev/block/bootdevice/by-name/boot of=boot.img
$ unpack_bootimg --boot_img boot.img --out boot_unpacked/
# Modify components
$ mkbootimg ... --output new_boot.img
$ fastboot flash boot new_boot.img
```

**2. Ignoring A/B Partitions:**
```bash
# BAD: Only updating one slot
$ fastboot flash boot new_boot.img  # Only updates current slot

# GOOD: Update both slots
$ fastboot flash boot_a new_boot.img
$ fastboot flash boot_b new_boot.img
```

**3. Not Backing Up:**
```bash
# BAD: Flash without backup
$ fastboot flash boot experimental.img  # No backup!

# GOOD: Always backup first
$ fastboot flash boot backup.img  # Restore if needed
```

**4. Signature Mismatch:**
- Boot image must match device keys
- Development keys different from release keys
- Verified boot will reject mismatched signatures
- Always use correct signing keys

## References and Further Reading

- [AOSP Boot Image Format](https://source.android.com/docs/core/architecture/bootloader/boot-image-header)
- [Android Boot Process](https://source.android.com/docs/core/architecture/bootloader)
- [A/B Partitions](https://source.android.com/docs/core/ota/ab_partitions)
- [Android Verified Boot](https://source.android.com/docs/security/features/verifiedboot)
- [Device Tree Documentation](https://source.android.com/docs/core/architecture/dts)

## Quiz

### Question 1
What is the primary purpose of the boot partition in Android?

**A)** To store user data and applications  
**B)** To contain the bootloader, kernel, and initial ramdisk needed to boot the device  
**C)** To store system applications and framework  
**D)** To cache temporary files

**Answer: B** - The boot partition contains the essential boot components: bootloader code (optional), kernel image, ramdisk (initramfs), and device tree blob. These are loaded by the bootloader to start the Android system.

### Question 2
What format is used for the ramdisk in Android boot images?

**A)** ext4 filesystem  
**B)** CPIO archive  
**C)** tar archive  
**D)** zip archive

**Answer: B** - The ramdisk in Android boot images is stored as a CPIO (Copy In, Copy Out) archive, typically compressed with gzip. This archive contains the initial root filesystem with init and early boot scripts.

### Question 3
What is the purpose of A/B boot partitions?

**A)** To double the storage capacity  
**B)** To allow seamless system updates without rebooting into recovery  
**C)** To improve security  
**D)** To reduce boot time

**Answer: B** - A/B boot partitions allow the system to install updates to an inactive boot partition slot while the device continues running on the active slot. After reboot, the device boots from the updated slot, enabling seamless updates.

### Question 4
Which component in the boot image describes the hardware configuration to the kernel?

**A)** Ramdisk  
**B)** Kernel image  
**C)** Device Tree Blob (DTB)  
**D)** Boot header

**Answer: C** - The Device Tree Blob (DTB) contains hardware configuration information that describes the device's hardware to the kernel, enabling a single kernel to work with multiple device variants.

### Question 5
What tool is commonly used to unpack Android boot images?

**A)** `tar`  
**B)** `unpack_bootimg`  
**C)** `unzip`  
**D)** `mount`

**Answer: B** - The `unpack_bootimg` tool (part of Android build tools) is specifically designed to unpack Android boot images, extracting the kernel, ramdisk, device tree, and other components from the boot.img file.

## Related Topics

- [Android Partitions](./08.%20Android%20Partitions.md)
- [Boot Process Overview](./03.%20Boot%20Process%20Overview.md)
- [Initramfs in Android](./14.%20Initramfs%20in%20Android.md)

