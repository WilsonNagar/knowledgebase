---
number: 38
title: Wakelocks
slug: wakelocks
level: beginner
tags:
  - aosp
  - wakelocks
  - power-management
  - kernel
  - battery
  - sleep
  - suspend
prerequisites:
  - differences-android-kernel-linux-kernel
  - boot-process-overview
estimated_minutes: 75
contributors: []
diagrams: []
examples: []
canonical_id: aosp-beginner-38
---

# Wakelocks

## Overview

Wakelocks are Android's mechanism for preventing the system from entering sleep mode. They allow applications and system components to keep the device awake when necessary, such as during downloads, music playback, or network operations. Understanding wakelocks is essential for AOSP development, as they're critical for power management, battery life, and ensuring that background operations can complete successfully.

Think of wakelocks like a "do not disturb" sign with a twist: instead of preventing interruptions, wakelocks prevent the device from sleeping. Just as you might put a "do not disturb" sign on your door to keep people from interrupting you, wakelocks tell the system "don't go to sleep right now, I'm doing something important." When the important work is done, the wakelock is released, and the device can sleep normally.

## Deep Explanation

### What are Wakelocks?

Wakelocks are kernel-level mechanisms that prevent the Android system from entering suspend (sleep) mode. They're part of Android's power management system and allow processes to keep the device awake when needed.

**Key Characteristics:**
- **Kernel-Level:** Implemented in the kernel
- **Power Management:** Part of Android PM system
- **Prevent Sleep:** Keep device awake
- **Time-Limited:** Should be released when done

**Why Wakelocks?**
- **Background Operations:** Apps need to complete tasks
- **Network Operations:** Downloads, syncs need connectivity
- **Media Playback:** Music/video needs device awake
- **System Services:** Services need to run

### Wakelock Types

#### Kernel Wakelocks

**What They Are:**
- Kernel-level wakelocks
- Managed by kernel
- Low-level power control
- Direct kernel API

**Characteristics:**
- Kernel space
- Direct hardware control
- Fast operations
- System-level

**Usage:**
- Kernel drivers
- Hardware operations
- Low-level system
- Critical operations

#### User-Space Wakelocks

**What They Are:**
- User-space wakelocks
- Managed by PowerManager
- Application-level
- Framework API

**Characteristics:**
- User space
- Framework managed
- Application API
- Higher-level

**Usage:**
- Applications
- System services
- Framework components
- User-facing features

### Wakelock Categories

#### WAKE_LOCK_SUSPEND

**Purpose:**
Prevents system from entering suspend.

**Behavior:**
- Prevents CPU suspend
- Keeps system running
- Full power consumption
- Maximum wakefulness

**Use Cases:**
- Critical operations
- Time-sensitive tasks
- System services
- Important background work

#### PARTIAL_WAKE_LOCK

**Purpose:**
Keeps CPU awake but allows screen off.

**Behavior:**
- CPU stays on
- Screen can turn off
- Reduced power (vs. full)
- Background work

**Use Cases:**
- Background downloads
- Music playback
- Sync operations
- Network operations

### Wakelock API

#### Kernel API

**Acquiring Wakelock:**
```c
// Kernel space
wake_lock_init(&my_wakelock, WAKE_LOCK_SUSPEND, "my_wakelock");
wake_lock(&my_wakelock);
```

**Releasing Wakelock:**
```c
wake_unlock(&my_wakelock);
wake_lock_destroy(&my_wakelock);
```

**Kernel Functions:**
- `wake_lock_init()` - Initialize wakelock
- `wake_lock()` - Acquire wakelock
- `wake_unlock()` - Release wakelock
- `wake_lock_destroy()` - Cleanup wakelock

#### User-Space API

**PowerManager API:**
```java
// Acquire wakelock
PowerManager pm = (PowerManager) getSystemService(POWER_SERVICE);
PowerManager.WakeLock wakeLock = pm.newWakeLock(
    PowerManager.PARTIAL_WAKE_LOCK,
    "MyApp::MyWakeLock"
);
wakeLock.acquire();

// Release wakelock
wakeLock.release();
```

**WakeLock Types:**
- `PARTIAL_WAKE_LOCK` - CPU awake, screen off
- `FULL_WAKE_LOCK` - Screen and keyboard on
- `SCREEN_BRIGHT_WAKE_LOCK` - Screen bright
- `SCREEN_DIM_WAKE_LOCK` - Screen dim

### Wakelock Lifecycle

#### Acquisition

**When to Acquire:**
- Starting background operation
- Beginning network transfer
- Starting media playback
- Critical system operation

**Process:**
1. Identify need for wakefulness
2. Acquire appropriate wakelock
3. Perform operation
4. Release wakelock when done

**Best Practices:**
- Acquire only when needed
- Use appropriate type
- Release promptly
- Handle errors

#### Release

**When to Release:**
- Operation completes
- No longer needed
- Error occurs
- App/service stops

**Process:**
1. Operation completes
2. Release wakelock
3. System can sleep
4. Power saved

**Critical:**
- Must release wakelocks
- Prevents battery drain
- System stability
- User experience

### Wakelock Management

#### PowerManager Service

**Role:**
- Manages user-space wakelocks
- Tracks wakelock usage
- Enforces policies
- Monitors battery

**Functions:**
- Acquire/release wakelocks
- Track wakelock holders
- Enforce time limits
- Battery optimization

#### Kernel Management

**Role:**
- Manages kernel wakelocks
- Controls hardware
- Power state transitions
- System suspend

**Functions:**
- Track active wakelocks
- Prevent suspend when held
- Allow suspend when released
- Hardware power control

### Wakelock and Power States

#### Power States

**Active:**
- Device fully on
- Screen on
- CPU running
- Full functionality

**Doze:**
- Device partially asleep
- Reduced functionality
- Wakelocks can wake
- Battery optimized

**Deep Sleep:**
- Device fully asleep
- Minimal power
- Wakelocks prevent this
- Maximum battery savings

#### State Transitions

**Active → Doze:**
- Screen turns off
- Some wakelocks allowed
- Reduced power
- Background work continues

**Doze → Deep Sleep:**
- All operations stop
- Wakelocks prevent this
- Maximum power savings
- Only wake on interrupt

**Deep Sleep → Active:**
- Wakeup interrupt
- Wakelock acquired
- System resumes
- Full functionality

### Common Wakelock Patterns

#### Network Operations

**Pattern:**
```java
WakeLock wakeLock = pm.newWakeLock(PARTIAL_WAKE_LOCK, "Network");
wakeLock.acquire();
try {
    // Network operation
    downloadFile();
} finally {
    wakeLock.release();
}
```

**Why:**
- Network operations need connectivity
- Device must stay awake
- Prevent sleep during transfer
- Ensure completion

#### Media Playback

**Pattern:**
```java
WakeLock wakeLock = pm.newWakeLock(PARTIAL_WAKE_LOCK, "Media");
wakeLock.acquire();
// Start playback
mediaPlayer.start();
// Release when paused/stopped
wakeLock.release();
```

**Why:**
- Media needs CPU
- Audio processing
- Keep device awake
- Smooth playback

#### Background Sync

**Pattern:**
```java
WakeLock wakeLock = pm.newWakeLock(PARTIAL_WAKE_LOCK, "Sync");
wakeLock.acquire();
syncData();
wakeLock.release();
```

**Why:**
- Sync needs network
- Device must stay awake
- Complete operation
- Prevent interruption

### Wakelock Debugging

#### Identifying Wakelocks

**dumpsys power:**
```bash
adb shell dumpsys power
```

**Output:**
- Active wakelocks
- Wakelock holders
- Power state
- Battery information

**Kernel Wakelocks:**
```bash
adb shell cat /proc/wakelocks
# Or
adb shell dmesg | grep wakelock
```

#### Common Issues

**Battery Drain:**
- Wakelock held too long
- Not released properly
- Leaked wakelock
- Check wakelock holders

**System Won't Sleep:**
- Wakelock preventing sleep
- Check active wakelocks
- Find holder
- Release if needed

**App Issues:**
- Wakelock not acquired
- Operation interrupted
- Check wakelock usage
- Verify acquisition

### Wakelock Best Practices

#### Proper Usage

**Acquire When Needed:**
- Only when necessary
- Appropriate type
- Minimal duration
- Release promptly

**Error Handling:**
- Always release in finally
- Handle exceptions
- Prevent leaks
- Cleanup properly

**Naming:**
- Descriptive names
- Include app/component
- Easy to identify
- Debugging friendly

#### Avoid Common Mistakes

**Don't:**
- Hold wakelocks unnecessarily
- Forget to release
- Use wrong type
- Hold indefinitely

**Do:**
- Release when done
- Use appropriate type
- Handle errors
- Monitor usage

### Wakelock Evolution

#### Historical Context

**Early Android:**
- Kernel wakelocks only
- Direct kernel API
- Limited management
- Battery issues

**Modern Android:**
- User-space wakelocks
- Framework management
- Better optimization
- Improved battery

#### Current State

**Hybrid System:**
- Both kernel and user-space
- Framework management
- Battery optimization
- Doze mode integration

**Future:**
- Better optimization
- Automatic management
- Smarter wakelocks
- Improved battery life

## Key Takeaways

1. **Wakelocks prevent the system from sleeping** and are essential for allowing background operations to complete.

2. **Wakelocks come in two types:** kernel wakelocks (kernel-level) and user-space wakelocks (application-level via PowerManager).

3. **PARTIAL_WAKE_LOCK** keeps the CPU awake while allowing the screen to turn off, balancing functionality and power consumption.

4. **Wakelocks must be released** when operations complete to prevent battery drain and allow the system to sleep.

5. **PowerManager Service** manages user-space wakelocks and enforces policies for battery optimization.

6. **Common use cases** include network operations, media playback, and background synchronization that need the device to stay awake.

7. **Wakelock debugging** uses `dumpsys power` and kernel logs to identify active wakelocks and their holders.

8. **Understanding wakelocks** is essential for power management, battery optimization, and ensuring background operations work correctly.

## Related Topics

- **Differences between Android kernel & Linux kernel:** How wakelocks are part of Android's kernel modifications
- **Power Management:** Overall Android power management system that includes wakelocks
- **Binder IPC Basics:** How system services use wakelocks during IPC operations
- **Boot Process Overview:** How wakelocks affect system power states

