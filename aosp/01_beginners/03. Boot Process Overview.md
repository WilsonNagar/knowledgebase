---
number: 3
title: Boot Process Overview
slug: boot-process-overview
level: beginner
tags:
  - aosp
  - boot
  - startup
  - init
  - zygote
  - system-server
prerequisites:
  - android-architecture-complete-overview
estimated_minutes: 75
contributors: []
diagrams: []
examples: []
canonical_id: aosp-beginner-03
---

# Boot Process Overview

## Overview

Understanding the Android boot process is crucial for AOSP development. The boot process is a complex sequence of events that transforms a powered-off device into a fully functional Android system. This guide provides a comprehensive overview of the Android boot process, from the moment power is applied to when the user can interact with the device. Understanding this process is essential for debugging boot issues, customizing the system, and developing system-level features.

Think of the boot process like starting a car: you turn the key (power on), the engine starts (bootloader), the car's systems initialize (kernel), the dashboard lights up (init), the radio starts (Zygote), all systems become operational (System Server), and finally you can drive (Launcher ready). Each step depends on the previous one, and if any step fails, the whole process stops.

## Deep Explanation

### Boot Process Stages

The Android boot process consists of several distinct stages, each with specific responsibilities:

1. **Boot ROM** - Hardware initialization
2. **Bootloader** - Hardware setup and kernel loading
3. **Kernel** - Low-level system initialization
4. **Init Process** - System daemon startup
5. **Zygote** - Application runtime preparation
6. **System Server** - Core services startup
7. **Launcher** - User interface startup

### Stage 1: Boot ROM (Boot Read-Only Memory)

#### What is Boot ROM?

Boot ROM is firmware embedded in the device's processor. It's the first code that executes when the device is powered on. This code is read-only and cannot be modified, making it the most trusted component in the boot chain.

**Physical Location:**
- Stored in ROM (Read-Only Memory) on the CPU chip itself
- Not in flash memory or storage
- Hard-wired into the processor
- Cannot be erased or modified (even by manufacturers after production)

**Why Read-Only?**
- **Security:** Prevents tampering with the boot process
- **Reliability:** Always works, even if storage is corrupted
- **Trust:** Provides root of trust for verified boot
- **Simplicity:** Minimal code, less chance of bugs

#### Boot ROM Responsibilities

**Hardware Initialization:**

When power is first applied, the CPU is in a minimal state. Boot ROM performs the most basic initialization:

**CPU Initialization:**
- Reset CPU to known state
- Set up CPU registers
- Initialize CPU caches
- Configure CPU clock (may start slow, speed up later)

**Memory Initialization:**
- Detect installed RAM
- Initialize memory controller
- Set up basic memory mapping
- Test memory (basic checks)

**Clock Configuration:**
- Initialize clock sources (crystal oscillators)
- Set up PLLs (Phase-Locked Loops) for CPU clock
- Configure peripheral clocks
- This is critical - without clocks, nothing works!

**Minimal I/O:**
- Initialize UART (serial port) for debugging
- Set up basic GPIO (General Purpose I/O)
- Enable minimal peripherals needed for boot

**Boot Source Selection:**

The Boot ROM must decide where to load the bootloader from. Modern devices have multiple options:

**Possible Boot Sources:**
1. **eMMC/UFS:** Internal storage (normal boot)
2. **USB:** Fastboot mode (development/recovery)
3. **Recovery Partition:** Recovery mode
4. **Download Mode:** OEM-specific (Samsung, etc.)

**Boot Source Detection:**
```
Boot ROM checks:
1. Hardware buttons pressed? (Volume Down + Power = Fastboot)
2. Recovery trigger? (Volume Up + Power = Recovery)
3. Normal boot? (No buttons = Normal)
4. Download mode? (OEM-specific combination)
```

**Security Initialization:**

Before loading any code, Boot ROM establishes security:

**Root of Trust:**
- Loads device-specific keys (burned into chip during manufacturing)
- These keys are unique to each device
- Cannot be extracted or modified
- Used to verify bootloader signature

**Secure Boot Chain:**
- Boot ROM verifies bootloader signature
- If signature invalid, boot stops (security feature)
- This prevents running unauthorized code
- Foundation for Android Verified Boot (AVB)

**Secure Storage:**
- Initializes secure storage areas
- Sets up encryption keys
- Prepares for verified boot measurements

#### Boot ROM Execution

**Execution Flow:**

Let's trace through exactly what happens:

**Step 1: Power Applied**
- User presses power button or device is plugged in
- Power management IC (PMIC) supplies power to CPU
- CPU receives power-on reset signal
- CPU starts executing from a fixed address (Boot ROM start)

**Step 2: CPU Starts Executing**
- CPU's program counter (PC) points to Boot ROM start address
- First instruction executes (typically a jump to initialization code)
- CPU is in privileged mode (can access all hardware)

**Step 3: Minimal Hardware Initialization**
- Initialize CPU: Set registers, enable caches
- Initialize Memory: Detect RAM, set up controller
- Initialize Clocks: Start oscillators, configure PLLs
- Initialize I/O: UART for debugging, basic GPIO

**Step 4: Boot Source Detection**
- Read hardware pins (button states)
- Check for special boot modes
- Determine boot source (normal/recovery/fastboot)

**Step 5: Load Bootloader**
- Read bootloader from selected source (usually eMMC)
- Load into RAM at predetermined address
- Verify bootloader signature (if secure boot enabled)

**Step 6: Transfer Control**
- Set CPU registers for bootloader
- Jump to bootloader entry point
- Boot ROM execution complete

**Timeline:**
- Power applied: 0ms
- Boot ROM starts: < 1ms
- Hardware init: 1-5ms
- Bootloader load: 5-50ms (depends on storage speed)
- **Total Boot ROM time: ~10-100ms**

**Characteristics:**
- Executes in milliseconds
- Minimal functionality (just enough to load bootloader)
- Cannot be modified (hardware-level)
- Highest security level (most trusted code)
- Very fast (optimized assembly code)

### Stage 2: Bootloader

#### Bootloader Overview

The bootloader is the first software component that can be updated. It's responsible for initializing more hardware, loading the kernel, and starting the verified boot process.

#### Bootloader Responsibilities

**Hardware Initialization:**
- Initialize display (for boot logo)
- Initialize storage (eMMC/UFS)
- Initialize USB (for fastboot)
- Initialize other peripherals

**Partition Management:**
- Read partition table
- Locate boot partition
- Verify partition integrity
- Load kernel and device tree

**Verified Boot:**
- Verify boot partition signature
- Check rollback protection
- Validate kernel integrity
- Enforce security policies

**Boot Mode Selection:**
- Normal boot
- Recovery mode
- Fastboot mode
- Download mode (OEM-specific)

#### Fastboot Mode

**Fastboot Overview:**
- Diagnostic and flashing mode
- Accessed via hardware key combination
- Allows partition flashing
- Used for development and recovery

**Fastboot Commands:**
```bash
fastboot devices          # List connected devices
fastboot reboot           # Reboot device
fastboot flash boot boot.img  # Flash boot partition
fastboot unlock           # Unlock bootloader (if supported)
```

#### Bootloader Unlocking

**Unlocking Process:**
- OEM-specific procedure
- Usually requires developer options
- Wipes user data (security measure)
- Allows custom ROM installation

**Security Implications:**
- Disables verified boot
- Allows unsigned code execution
- Reduces device security
- Required for AOSP development

### Stage 3: Kernel Initialization

#### Kernel Loading

**Kernel Image:**
- Loaded from boot partition
- Contains kernel binary (Image or zImage)
- Device Tree Blob (DTB) for hardware description
- Initial RAM filesystem (initramfs)

**Kernel Execution:**
1. Bootloader loads kernel into memory
2. Sets up kernel parameters
3. Passes device tree
4. Jumps to kernel entry point

#### Kernel Initialization

**Early Kernel Initialization:**
- CPU setup and configuration
- Memory management initialization
- Interrupt controller setup
- Early console output

**Hardware Detection:**
- Device Tree parsing
- Hardware device discovery
- Driver initialization
- Resource allocation

**Driver Loading:**
- Built-in drivers initialize
- Loadable modules (if any)
- Device-specific drivers
- Android-specific drivers (Binder, ashmem, etc.)

**File System Initialization:**
- Root filesystem mounting
- Essential filesystems (proc, sys, dev)
- Android-specific mounts
- SELinux initialization

#### Kernel to Userspace Transition

**Init Process Creation:**
- Kernel creates first userspace process
- PID 1 (init process)
- Runs as root initially
- Transitions to proper context

### Stage 4: Init Process

#### Init Overview

The init process (PID 1) is the first userspace process and the ancestor of all other processes. It's responsible for starting system daemons, mounting filesystems, and setting up the Android environment.

**Why PID 1?**
In Unix/Linux systems, PID 1 is special:
- It's the first process created by the kernel
- It cannot be killed (kernel prevents it)
- It becomes the parent of all orphaned processes
- It's responsible for system initialization
- If init dies, kernel panics (system crash)

**Init's Role:**
Init is like the "manager" of the Android system:
- Starts all system services
- Monitors service health
- Restarts crashed services
- Manages system properties
- Handles system shutdown

#### Init Responsibilities

**File System Setup:**

Before anything else can run, the file system must be set up:

**Essential Mounts:**
```
/proc     - Process information (virtual filesystem)
/sys      - System information (virtual filesystem)
/dev      - Device nodes (virtual filesystem)
/sys/kernel/debug - Debug information
```

**Android-Specific Mounts:**
```
/system   - System partition (read-only, contains Android)
/vendor   - Vendor partition (OEM-specific)
/product  - Product partition (device-specific)
/data     - User data partition (read-write)
/cache    - Cache partition
```

**Directory Structure:**
Init creates essential directories:
- `/data/data/` - App data directories
- `/data/system/` - System data
- `/data/misc/` - Miscellaneous data
- `/dev/` - Device nodes
- `/sys/` - System information

**Device Nodes:**
Init creates device nodes (special files that represent hardware):
- `/dev/null` - Null device (discards data)
- `/dev/zero` - Zero device (provides zeros)
- `/dev/random` - Random number generator
- `/dev/urandom` - Non-blocking random
- `/dev/binder` - Binder IPC device
- And many more...

**Property System:**

Android's property system is a key-value store for system configuration:

**Property Types:**
- **ro.* (read-only):** Set once, never change (e.g., `ro.build.version`)
- **persist.*:** Survive reboots (e.g., `persist.sys.timezone`)
- **ctl.*:** Control properties (trigger actions)

**Property Files:**
Init loads properties from:
- `/system/build.prop` - Build properties
- `/vendor/build.prop` - Vendor properties
- `/default.prop` - Default properties
- `/data/local.prop` - Local overrides (if exists)

**Property Service:**
Init starts property service daemon that:
- Listens on `/dev/socket/property_service`
- Allows processes to read/write properties
- Broadcasts property changes
- Handles property triggers

**Example Properties:**
```
ro.build.version.release=13
ro.product.model=Pixel 7
ro.debuggable=0
persist.sys.timezone=America/New_York
```

**SELinux Setup:**

SELinux (Security-Enhanced Linux) provides mandatory access control:

**Policy Loading:**
1. Init loads SELinux policy from `/sepolicy` or `/sys/fs/selinux/policy`
2. Policy defines what processes can access what resources
3. Policy is compiled binary format (fast to load)

**Context Setting:**
- Each process gets a SELinux context (domain)
- Each file gets a SELinux context (type)
- Contexts determine what's allowed

**Transition to Enforcing:**
- Starts in permissive mode (logs violations, doesn't block)
- After policy loaded, transitions to enforcing mode
- In enforcing mode, violations are blocked
- Critical for security

**File Contexts:**
Init applies file contexts from `/file_contexts`:
- Sets SELinux labels on all files
- Ensures proper security contexts
- Required for SELinux to work correctly

**Service Management:**

Init's most visible job is starting and managing services:

**Service Definition:**
Services are defined in init scripts (`.rc` files):
```
service myservice /system/bin/myservice
    class main
    user system
    group system
    oneshot
```

**Service Lifecycle:**
1. **Parse:** Init parses service definition
2. **Create:** Init creates service object
3. **Start:** Init starts service when triggered
4. **Monitor:** Init monitors service (if not oneshot)
5. **Restart:** Init restarts service if it crashes

**Service Classes:**
- `core` - Critical system services
- `main` - Normal services
- `late_start` - Services that start later
- `charger` - Services for charger mode

**Service Triggers:**
Services start based on triggers:
- `on early-init` - Very early
- `on init` - Main initialization
- `on late-init` - After main init
- `on property:name=value` - When property changes
- `on boot` - After boot completes

#### Init Scripts (init.rc)

**Script Structure:**
- Written in init language
- Defines services and actions
- Specifies service properties
- Controls service lifecycle

**Service Definition Example:**
```
service zygote /system/bin/app_process64 -Xzygote /system/bin --zygote --start-system-server
    class main
    priority -20
    user root
    group root readproc
    socket zygote stream 660 root system
    onrestart write /sys/power/state on
    onrestart restart audioserver
    writepid /dev/cpuset/foreground/tasks
```

**Action Triggers:**
- `on early-init`: Very early initialization
- `on init`: Main initialization
- `on late-init`: After main init
- `on property:ro.debuggable=1`: When property changes

#### Init Phases

**Early Init:**
- Critical system setup
- SELinux policy loading
- Essential mounts
- Security initialization

**Init:**
- Main initialization
- Service startup begins
- Property system ready
- Most services start here

**Late Init:**
- Non-critical services
- User-space daemons
- Application-related services
- Final system setup

### Stage 5: Zygote

#### Zygote Overview

Zygote is a special process that preloads common classes and resources, allowing Android apps to start quickly by forking from Zygote rather than starting from scratch.

#### Zygote Startup

**Process Creation:**
- Init starts Zygote service
- Zygote process forks from init
- Runs as root initially
- Transitions to appropriate user

**Preloading:**
- Preloads common Java classes
- Preloads system resources
- Initializes ART runtime
- Sets up JNI environment

**Socket Creation:**
- Creates Zygote socket
- Listens for fork requests
- Handles app process creation
- Manages process lifecycle

#### Zygote Responsibilities

**App Process Creation:**
- Fork new process for app
- Inherit preloaded classes
- Set up app-specific environment
- Transfer control to app

**System Server Fork:**
- Fork System Server process
- Inherit preloaded resources
- Start System Server main
- System Server takes over

**Resource Management:**
- Manage preloaded resources
- Handle memory efficiently
- Optimize class loading
- Support multidex

### Stage 6: System Server

#### System Server Startup

**Process Creation:**
- Forked from Zygote
- Runs as system user (UID 1000)
- High system privileges
- Critical system process

**Service Initialization:**
- Bootstrap services first
- Core services second
- Other services last
- Respects dependencies

**Service Registration:**
- Services register with ServiceManager
- Get Binder tokens
- Become available to apps
- Start accepting requests

#### Critical Services

**Bootstrap Services:**
- ActivityManagerService
- PowerManagerService
- DisplayManagerService
- PackageManagerService

**Core Services:**
- WindowManagerService
- InputManagerService
- ConnectivityService
- UserManagerService

**Other Services:**
- Network services
- Media services
- Hardware services
- Application services

### Stage 7: Launcher and User Interface

#### Launcher Startup

**Process Creation:**
- System Server starts Launcher
- Launcher runs as separate app process
- Standard app privileges
- User-facing interface

**UI Initialization:**
- Load home screen
- Initialize widgets
- Set up navigation
- Ready for user interaction

#### Boot Complete

**Boot Complete Signal:**
- System Server sends `BOOT_COMPLETED` broadcast
- Apps can receive this signal
- Indicates system is ready
- User can interact with device

**Boot Animation:**
- Shown during boot process
- Hides boot complexity
- Provides user feedback
- Stops when boot completes

## Boot Time Optimization

### Optimization Strategies

**Parallel Initialization:**
- Start independent services in parallel
- Reduce sequential dependencies
- Optimize service startup order
- Minimize blocking operations

**Lazy Loading:**
- Load services on demand
- Defer non-critical initialization
- Reduce boot-time memory usage
- Speed up boot process

**Preloading:**
- Preload common resources
- Cache frequently used data
- Optimize class loading
- Reduce app startup time

### Measuring Boot Time

**Boot Time Metrics:**
- Time to first frame
- Time to interactive
- Time to boot complete
- Service startup times

**Tools:**
- `bootchart` - Visual boot analysis
- `init` logs - Service startup times
- `dmesg` - Kernel boot messages
- Custom timing instrumentation

## Boot Issues and Debugging

### Common Boot Issues

**Boot Loop:**
- System crashes during boot
- Repeats boot sequence
- Usually service crash
- Check logs for errors

**Slow Boot:**
- Excessive initialization time
- Blocking operations
- Too many services
- Resource contention

**Boot Hang:**
- System stops during boot
- No response to input
- Service deadlock
- Kernel issue

### Debugging Techniques

**Logs:**
```bash
adb logcat -b all    # All log buffers
adb shell dmesg     # Kernel messages
adb shell getprop   # System properties
```

**Boot Modes:**
- Recovery mode for debugging
- Safe mode (minimal services)
- Debug mode (verbose logging)
- Factory reset

**Tools:**
- `logcat` for application logs
- `dmesg` for kernel logs
- `init` logs for service logs
- `tombstones` for crashes

## Security Considerations

### Verified Boot

**Boot Chain Verification:**
- Each stage verifies next stage
- Cryptographic signatures
- Rollback protection
- Integrity checking

**AVB (Android Verified Boot):**
- Modern verified boot implementation
- Part of Android 8.0+
- Stronger security guarantees
- Supports A/B partitions

### Boot Security

**Secure Boot:**
- Hardware-backed root of trust
- Chain of trust from Boot ROM
- Prevents unauthorized code
- Protects system integrity

**Bootloader Locking:**
- Prevents bootloader modification
- Protects verified boot
- Required for security features
- Can be unlocked for development

## Real-World Examples

### Normal Boot Sequence Timeline

1. **0ms**: Power applied, Boot ROM starts
2. **100ms**: Bootloader loaded and running
3. **500ms**: Kernel loaded, initialization begins
4. **1000ms**: Init process starts
5. **2000ms**: Zygote started
6. **3000ms**: System Server starting services
7. **5000ms**: Launcher starting
8. **6000ms**: Boot complete, user can interact

*Times are approximate and vary by device*

### Recovery Boot

1. Boot ROM detects recovery trigger
2. Bootloader loads recovery partition
3. Recovery kernel starts
4. Recovery init process
5. Recovery UI available
6. Can flash updates, wipe data, etc.

## Edge Cases and Pitfalls

### Common Mistakes

**Blocking Init:**
- Never block init process
- Use background threads
- Async operations only
- Quick service startup

**Circular Dependencies:**
- Avoid service dependency cycles
- Use lazy initialization
- Dependency injection
- Careful service ordering

**Resource Exhaustion:**
- Don't exhaust resources during boot
- Limit concurrent operations
- Monitor resource usage
- Optimize memory usage

### Best Practices

- Keep boot process fast
- Minimize blocking operations
- Optimize service startup
- Handle errors gracefully
- Log appropriately
- Follow security guidelines

## References and Further Reading

- [AOSP Init Process Source](https://cs.android.com/android/platform/superproject/+/master:system/core/init/)
- [Android Boot Process Documentation](https://source.android.com/docs/core/architecture/bootloader)
- [Verified Boot Documentation](https://source.android.com/docs/security/features/verifiedboot)

## Quiz

### Question 1
What is the first code that executes when an Android device is powered on?

**A)** Bootloader  
**B)** Boot ROM  
**C)** Kernel  
**D)** Init process

**Answer: B** - Boot ROM is firmware embedded in the processor and is the first code that executes when power is applied.

### Question 2
What is the primary purpose of Zygote in the boot process?

**A)** To manage system services  
**B)** To preload classes and resources for fast app startup  
**C)** To handle graphics rendering  
**D)** To manage network connections

**Answer: B** - Zygote preloads common classes and resources, allowing apps to start quickly by forking from Zygote.

### Question 3
In what order are init phases executed?

**A)** init → early-init → late-init  
**B)** early-init → init → late-init  
**C)** late-init → init → early-init  
**D)** All simultaneously

**Answer: B** - Init phases execute in order: early-init (critical setup), init (main initialization), late-init (non-critical services).

### Question 4
What process ID does the init process have?

**A)** 0  
**B)** 1  
**C)** 1000  
**D)** Varies

**Answer: B** - Init is always PID 1, as it's the first userspace process created by the kernel.

### Question 5
What signal indicates that the Android boot process is complete?

**A)** Zygote started  
**B)** System Server started  
**C)** BOOT_COMPLETED broadcast  
**D)** Launcher visible

**Answer: C** - The BOOT_COMPLETED broadcast is sent when the system is fully booted and ready for user interaction.

## Related Topics

- [Android Architecture - Complete Overview](./01.%20Android%20Architecture%20-%20Complete%20Overview.md)
- [System Server Overview](./02.%20System%20Server%20Overview.md)
- [Init System in Android](./04.%20Init%20System%20in%20Android.md)

