---
number: 1
title: "Android Architecture - Complete Overview"
slug: "android-architecture-complete-overview"
level: "beginner"
tags: ["aosp", "architecture", "fundamentals", "linux-kernel", "hal", "runtime", "framework"]
prerequisites: []
estimated_minutes: 90
contributors: []
diagrams: []
examples: []
canonical_id: "aosp-beginner-01"
---

# Android Architecture - Complete Overview

## Overview

Android is built on a layered architecture that provides a robust, secure, and efficient platform for mobile devices. Understanding the Android architecture is fundamental to working with AOSP (Android Open Source Project). This guide provides a comprehensive overview of the Android architecture stack, from the Linux kernel at the bottom to applications at the top, explaining how each layer interacts and contributes to the overall system.

Think of Android architecture like a multi-story building: each floor (layer) has a specific purpose, and you can only access the floor above through well-defined stairs and elevators (interfaces). The foundation (Linux Kernel) supports everything, while the top floor (Applications) is where users interact. This separation ensures that changes in one layer don't break others, making the system maintainable, secure, and efficient.

## Deep Explanation

### Architecture Layers Overview

Android follows a layered architecture model with clear separation of concerns. Each layer has specific responsibilities and communicates with adjacent layers through well-defined interfaces. The architecture consists of six main layers:

1. **Linux Kernel** - Hardware abstraction and core system services
2. **Hardware Abstraction Layer (HAL)** - Standardized interface to hardware
3. **Native Libraries** - C/C++ libraries for system functionality
4. **Android Runtime (ART)** - Application execution environment
5. **Java API Framework** - High-level APIs for application development
6. **Applications** - User-facing apps and system apps

#### Why Layered Architecture?

The layered approach provides several critical benefits:

**1. Separation of Concerns:**
Each layer focuses on a specific aspect of the system. The kernel handles hardware, HAL abstracts hardware differences, native libraries provide system functionality, ART executes code, the framework provides APIs, and apps provide user functionality. This separation makes the system easier to understand, maintain, and modify.

**2. Modularity:**
Layers can be developed, tested, and updated independently. For example, you can update the framework without modifying the kernel, or add new hardware support by implementing a HAL without changing the framework.

**3. Portability:**
The abstraction layers allow Android to run on different hardware platforms. The same framework code works whether the device has a Qualcomm, MediaTek, or Samsung processor, because the HAL and kernel handle hardware-specific details.

**4. Security:**
Each layer enforces its own security boundaries. Apps can't directly access hardware - they must go through the framework, which enforces permissions and security policies.

**5. Performance:**
Lower layers (closer to hardware) are optimized for performance, while higher layers provide convenience and ease of use. Critical operations can be done in native code or the kernel for maximum speed.

#### Communication Between Layers

Layers communicate through well-defined interfaces:

- **Upward Communication (Hardware → Apps):** Data flows upward through function calls, callbacks, and events. For example, when you touch the screen, the hardware generates an interrupt, the kernel processes it, HAL formats it, native libraries handle it, framework delivers it, and your app receives it.

- **Downward Communication (Apps → Hardware):** Commands flow downward through API calls. When you want to take a photo, your app calls the Camera API, which goes through the framework, native libraries, HAL, kernel drivers, and finally to the camera hardware.

- **Horizontal Communication (Same Layer):** Components in the same layer can communicate directly. For example, two apps can communicate via Binder IPC, or two services in System Server can call each other directly.

#### Visualizing the Stack

Imagine the layers stacked vertically:

```
┌─────────────────────────────────────┐
│   Applications (User Apps)          │  ← Top: User interaction
├─────────────────────────────────────┤
│   Java API Framework                │  ← High-level APIs
├─────────────────────────────────────┤
│   Android Runtime (ART)             │  ← Code execution
├─────────────────────────────────────┤
│   Native Libraries (C/C++)          │  ← System functionality
├─────────────────────────────────────┤
│   Hardware Abstraction Layer (HAL) │  ← Hardware interface
├─────────────────────────────────────┤
│   Linux Kernel                      │  ← Hardware control
└─────────────────────────────────────┘  ← Bottom: Direct hardware
```

Each layer only knows about its immediate neighbors. An app doesn't need to know about the kernel, and the kernel doesn't need to know about apps. This abstraction is what makes Android powerful and flexible.

### Layer 1: Linux Kernel

The Linux kernel forms the foundation of the Android operating system. It's a modified version of the standard Linux kernel with Android-specific enhancements. Think of the kernel as the "operating system's operating system" - it's the first software layer that directly interacts with hardware and provides fundamental services to everything else.

#### Understanding the Kernel's Role

The kernel is like the foundation and infrastructure of a building. Just as a building's foundation provides structural support, the kernel provides:
- **Hardware Access:** Direct control over all hardware components
- **Resource Management:** CPU, memory, storage, and network resources
- **Security Foundation:** Process isolation and access control
- **System Services:** Core functionality that everything else depends on

The kernel runs in a privileged mode (kernel space) with full access to hardware, while applications run in user space with restricted access. This separation is fundamental to security and stability.

#### Core Responsibilities

**Process Management:**

The kernel is responsible for creating, managing, and terminating processes. Here's how it works:

**Process Creation:**
When you launch an app, the kernel:
1. Allocates a new process ID (PID)
2. Creates a process control block (PCB) to track the process
3. Allocates memory space for the process
4. Sets up the process's execution context
5. Assigns the process to a user ID (UID) for security

**Process Scheduling:**
The kernel uses a scheduler to decide which process runs on the CPU at any given time. Android uses the Completely Fair Scheduler (CFS) with modifications:
- **Priority-based scheduling:** Important processes (like System Server) get higher priority
- **CPU affinity:** Processes can be bound to specific CPU cores
- **Load balancing:** Distributes processes across multiple CPU cores
- **Real-time support:** Some processes (like audio) can have real-time scheduling

**Process Lifecycle:**
The kernel manages the entire lifecycle:
- **Creation:** `fork()` or `clone()` system calls create new processes
- **Execution:** Process runs on CPU according to scheduler
- **Sleeping:** Process waits for events (I/O, timers, etc.)
- **Termination:** Process exits, kernel cleans up resources

**Process Isolation:**
Each process runs in its own isolated space:
- Separate memory address space (can't access other process's memory)
- Separate file descriptors
- Separate security context (UID, GID, SELinux context)
- This isolation is crucial for security - a buggy app can't crash the system or access other apps' data

**Real-World Example:**
When you open a messaging app:
1. Zygote forks a new process for the app
2. Kernel assigns PID 12345 and UID 10123 (unique to this app)
3. Kernel allocates memory (e.g., 50MB initial heap)
4. Kernel sets up security context (SELinux domain: `untrusted_app`)
5. Process starts executing, kernel schedules it on CPU
6. If app misbehaves, kernel can kill it without affecting other apps

**Memory Management:**

Memory management is one of the kernel's most critical responsibilities. Android devices have limited RAM (typically 4-12GB), and the kernel must efficiently manage it among many processes.

**Virtual Memory:**
Android uses virtual memory, where each process sees a large, continuous address space (e.g., 4GB on 32-bit, much larger on 64-bit), but the kernel maps these virtual addresses to actual physical RAM pages. This provides:
- **Memory Protection:** Processes can't access each other's memory
- **Memory Overcommitment:** Can allocate more virtual memory than physical RAM exists
- **Efficient Sharing:** Multiple processes can share the same physical pages (e.g., shared libraries)

**How Virtual Memory Works:**
1. Process requests memory (e.g., `malloc()` in C or `new` in Java)
2. Kernel allocates virtual address space
3. Physical pages are allocated on-demand (lazy allocation)
4. If physical memory is full, kernel swaps pages to storage (though Android minimizes swapping)
5. Memory Management Unit (MMU) in CPU translates virtual to physical addresses

**Physical Memory Allocation:**
The kernel maintains pools of free physical memory pages:
- **Buddy System:** Manages page allocation efficiently
- **Slab Allocator:** Manages small object allocations (kernel data structures)
- **ION Allocator:** Android-specific allocator for graphics and media buffers

**Memory Protection:**
Each memory page has protection flags:
- **Read-only:** Code pages, prevents modification
- **Read-write:** Data pages
- **Execute:** Code pages that can be executed
- **No-execute (NX):** Data pages that can't be executed (security feature)

**Low Memory Killer (LMK):**
When memory becomes scarce, Android's Low Memory Killer kills processes to free memory. It uses an "oom_adj" score (out-of-memory adjustment) to determine which processes to kill:

**Process Priority Levels (from lowest to highest oom_adj):**
- **-1000:** System processes (never killed)
- **-900:** Persistent services (very unlikely to be killed)
- **0:** Foreground app (last to be killed)
- **100-900:** Background apps (killed as memory pressure increases)
- **1000:** Empty processes (first to be killed)

**LMK Thresholds:**
Android defines memory pressure thresholds (in pages):
- **Critical:** Kill empty processes
- **Low:** Kill background processes
- **Medium:** Kill more background processes
- **High:** Kill cached processes

**Example Scenario:**
Device has 6GB RAM, currently using 5.5GB:
1. New app needs 200MB
2. Kernel checks available memory: only 500MB free
3. Kernel triggers LMK at "low" threshold
4. LMK calculates oom_adj scores for all processes
5. Kills background music app (oom_adj: 700) to free 150MB
6. Kills cached browser (oom_adj: 900) to free 300MB
7. Now has 950MB free, can allocate to new app
8. Foreground app (oom_adj: 0) remains untouched

**Device Drivers:**

Device drivers are kernel modules that provide an interface between the kernel and hardware devices. They translate high-level operations (like "play audio") into low-level hardware commands.

**How Drivers Work:**
1. **Hardware Interrupt:** Device signals the CPU (e.g., "touchscreen was touched")
2. **Interrupt Handler:** Kernel's interrupt handler receives the signal
3. **Driver Processing:** Driver reads data from device registers
4. **Kernel Processing:** Kernel processes the data and makes it available to userspace
5. **Event Delivery:** Data flows up through HAL, framework, to apps

**Display Drivers:**
- **Frame Buffer Driver:** Manages the display buffer
- **GPU Driver:** Handles graphics acceleration
- **Display Controller Driver:** Controls display hardware (resolution, refresh rate)
- **Example:** When you swipe on screen, the touch driver detects it, GPU renders the animation, display driver updates the screen

**Audio Drivers:**
- **ALSA (Advanced Linux Sound Architecture):** Core audio subsystem
- **Audio Codec Driver:** Controls audio hardware (DAC, ADC)
- **Example:** When playing music, app sends audio data → framework → HAL → audio driver → hardware DAC → speakers

**Camera Drivers:**
- **V4L2 (Video4Linux2):** Standard interface for video devices
- **Camera Sensor Driver:** Controls image sensor
- **ISP Driver:** Controls Image Signal Processor
- **Example:** Taking a photo: app requests → framework → HAL → camera driver → sensor captures → ISP processes → image data returned

**Network Drivers:**
- **Wi-Fi Driver:** Manages Wi-Fi chipset (often proprietary)
- **Bluetooth Driver:** Manages Bluetooth controller
- **Cellular Modem Driver:** Manages baseband processor
- **Example:** Sending data over Wi-Fi: app → network stack → Wi-Fi driver → Wi-Fi chip → radio transmission

**Storage Drivers:**
- **eMMC/UFS Driver:** Manages internal storage
- **SD Card Driver:** Manages external storage
- **File System Drivers:** ext4, f2fs (Flash-Friendly File System)
- **Example:** Saving a file: app writes → file system → storage driver → eMMC controller → flash memory

**Input Device Drivers:**
- **Touchscreen Driver:** Processes touch input
- **Keyboard Driver:** Processes key presses
- **Example:** Tapping screen: touch sensor → touch driver → kernel input subsystem → framework → app receives touch event

**Power Management:**
- CPU frequency scaling
- CPU hotplugging
- Power state management
- Wake locks (prevent system sleep)

**Security:**
- User and group management
- File system permissions
- SELinux integration
- Process sandboxing

#### Android-Specific Kernel Features

**Binder Driver:**

Binder is Android's primary IPC mechanism, implemented as a kernel driver. It's more efficient than traditional IPC methods (sockets, pipes, shared memory) for Android's use case.

**Why Binder Instead of Traditional IPC?**

Traditional Linux IPC has limitations:
- **Sockets:** High overhead, requires serialization
- **Pipes:** One-way only, limited capacity
- **Shared Memory:** Complex synchronization, no built-in security
- **Message Queues:** Limited functionality

Binder solves these by providing:
- **Efficient:** Single copy of data (zero-copy for small messages)
- **Secure:** Built-in security with caller identity
- **Synchronous:** Request-reply semantics
- **Object-oriented:** Supports remote object references

**How Binder Works:**

**1. Service Registration:**
```
Service (e.g., ActivityManagerService) registers with ServiceManager
→ Gets unique Binder token (handle)
→ ServiceManager stores: "activity" → token 42
```

**2. Client Discovery:**
```
App wants to use ActivityManager
→ Queries ServiceManager: "Give me activity service"
→ ServiceManager returns: token 42
→ App gets Binder proxy (BpBinder)
```

**3. Remote Method Call:**
```
App calls: activityManager.startActivity(intent)
→ Binder driver packages call into transaction
→ Kernel copies data to service's process
→ Service's Binder thread receives transaction
→ ActivityManagerService.onTransact() processes it
→ Result flows back through Binder
→ App receives result
```

**Binder Performance:**
- **Small messages (< 1KB):** Zero-copy (data stays in kernel buffer)
- **Large messages:** One copy (more efficient than sockets which require two copies)
- **Typical latency:** < 1ms for local calls
- **Throughput:** Can handle thousands of transactions per second

**Security Features:**
- **Caller Identity:** Service knows which process/app made the call
- **Permission Checking:** Service can check if caller has required permissions
- **SELinux Integration:** Binder calls are subject to SELinux policies

**Real-World Example:**
When you tap an app icon:
1. Launcher calls `startActivity()` 
2. Framework makes Binder call to ActivityManagerService
3. Binder driver copies Intent data to System Server process
4. ActivityManagerService receives call, validates permissions
5. AMS creates new process for target app
6. Result (success/failure) returns through Binder
7. Launcher receives callback

**Ashmem (Anonymous Shared Memory):**
- Shared memory allocator
- Used for efficient data sharing between processes
- Garbage-collected shared memory
- Better than standard Linux shared memory for Android's use case

**ION Memory Allocator:**
- Unified memory allocator for various hardware components
- Handles memory allocation for graphics, camera, video
- Supports multiple memory pools
- Replaces PMEM (deprecated)

**Wakelocks:**
- Mechanism to prevent system from entering sleep
- Used by apps and services that need to keep system awake
- Kernel-level implementation for efficiency
- Prevents unnecessary power consumption

**Logger:**
- Kernel-level logging system
- Efficient logging for Android's logcat
- Multiple log buffers (main, system, radio, events)
- Used for debugging and system monitoring

### Layer 2: Hardware Abstraction Layer (HAL)

The HAL provides a standardized interface between the Android framework and device hardware. It abstracts hardware-specific details, allowing the framework to work with different hardware implementations. Think of HAL as a "translator" - the framework speaks a standard language, and HAL translates it to whatever language the hardware understands.

#### Why HAL Exists

Imagine if the framework had to know about every possible camera sensor, display controller, and audio chip. The code would be massive, unmaintainable, and device-specific. HAL solves this by:

**1. Hardware Independence:**
The framework code is the same whether you have:
- A Qualcomm Snapdragon or MediaTek processor
- A Sony or Samsung camera sensor
- An AMOLED or LCD display
- Different audio codecs

**2. Vendor Flexibility:**
Hardware vendors (OEMs) can:
- Implement device-specific optimizations
- Add proprietary features
- Update hardware support without framework changes
- Customize for their hardware's unique capabilities

**3. Updateability:**
With Treble (Android 8.0+), HAL can be updated independently:
- Framework updates don't require HAL changes
- HAL updates don't require framework changes
- Faster security updates
- Easier to support new hardware

#### HAL Architecture

**Purpose:**
- Decouples Android framework from hardware
- Enables hardware vendors to implement device-specific functionality
- Provides consistent API to framework regardless of hardware
- Facilitates hardware updates without framework changes

**The Abstraction Principle:**

HAL defines a standard interface (contract) that all hardware implementations must follow. For example, the Camera HAL interface defines:
- `open_camera()` - Open camera device
- `get_camera_characteristics()` - Get camera capabilities
- `configure_streams()` - Set up image streams
- `process_capture_request()` - Take a photo

The framework calls these standard functions, and each vendor's HAL implementation translates them to their specific hardware commands. A Qualcomm device might use different register writes than a MediaTek device, but the framework doesn't care - it just calls the standard HAL functions.

**HAL Types:**

**Legacy HAL (Pre-Treble):**
- C-based modules in `hw/` directory
- Loaded dynamically via `libhardware`
- Tightly coupled with Android framework
- Difficult to update independently

**HIDL HAL (Treble - Android 8.0+):**
- Hardware Interface Definition Language
- Interface-based design
- Can be updated independently of framework
- Better separation between system and vendor
- Deprecated in favor of AIDL HAL

**AIDL HAL (Android 11+):**
- Android Interface Definition Language
- Modern replacement for HIDL
- Better performance and tooling
- Recommended for new HAL implementations

#### Common HAL Modules

**Camera HAL:**
- Interface for camera hardware
- Handles image capture, video recording
- Manages camera sensors and ISP (Image Signal Processor)
- Provides camera metadata

**Audio HAL:**
- Audio input/output management
- Handles audio routing
- Manages audio effects
- Supports various audio formats

**Graphics HAL:**
- Display controller interface
- Handles frame buffer management
- GPU acceleration
- Hardware Composer (HWC) integration

**Sensor HAL:**
- Interface for various sensors
- Accelerometer, gyroscope, magnetometer
- Proximity, light, pressure sensors
- Unified sensor framework

**Bluetooth HAL:**
- Bluetooth stack interface
- Handles Bluetooth Classic and BLE
- Manages Bluetooth profiles
- Audio routing for Bluetooth

### Layer 3: Native Libraries

Native libraries are C/C++ libraries that provide core system functionality. They're compiled for specific CPU architectures (ARM, ARM64, x86, x86_64).

#### Core Native Libraries

**Bionic (C Library):**
- Android's C standard library
- Optimized for mobile devices
- Smaller footprint than glibc
- Android-specific extensions
- Used by all native code

**Surface Manager:**
- Manages display surfaces
- Handles window composition
- Integrates with graphics drivers
- Part of graphics pipeline

**Media Framework:**
- Media codecs (audio/video encoding/decoding)
- Media playback
- Media recording
- Supports various formats (MP4, H.264, AAC, etc.)
- Uses OpenMAX for hardware acceleration

**SQLite:**
- Embedded database engine
- Used by Android framework and apps
- ACID-compliant
- Lightweight and efficient
- Core of Android's data storage

**WebKit/Chromium:**
- Web browser engine
- Used by WebView
- HTML rendering
- JavaScript execution
- Modern Android uses Chromium

**OpenGL ES:**
- Graphics rendering API
- 2D and 3D graphics
- Hardware-accelerated
- Used by games and graphics apps

**SSL/TLS:**
- Secure communication
- Cryptographic operations
- Certificate management
- Network security

**libc, libm, libdl:**
- Standard C library functions
- Mathematical functions
- Dynamic linking
- System calls

### Layer 4: Android Runtime (ART)

ART (Android Runtime) is the application runtime environment that executes Android applications. It replaced Dalvik in Android 5.0 (Lollipop). Think of ART as the "engine" that runs your Android apps - it takes the compiled app code (DEX bytecode) and executes it on the device's CPU.

#### Why ART Replaced Dalvik

**Dalvik's Limitations:**
- **Interpreted Execution:** Dalvik interpreted DEX bytecode at runtime, which was slow
- **JIT Only:** Just-In-Time compilation happened during execution, causing startup delays
- **Memory Overhead:** Multiple copies of code in memory
- **Performance:** Slower than native code execution

**ART's Advantages:**
- **AOT Compilation:** Compiles apps at install time to native code
- **Better Performance:** Native code runs much faster than interpreted bytecode
- **Lower Memory:** More efficient memory usage
- **Faster Startup:** Pre-compiled code starts faster
- **Better Battery:** Less CPU usage means better battery life

#### ART Architecture

**Execution Model:**
- Ahead-of-Time (AOT) compilation
- Just-In-Time (JIT) compilation (Android 7.0+)
- Hybrid compilation strategy
- Converts DEX bytecode to native machine code

**Understanding DEX Bytecode:**

When you write an Android app in Java or Kotlin:
1. **Compilation:** Java/Kotlin compiler converts source code to `.class` files (Java bytecode)
2. **DEX Conversion:** `dx` tool converts `.class` files to `.dex` files (Dalvik Executable format)
3. **Optimization:** DEX files are optimized and packaged into APK
4. **Installation:** APK is installed on device
5. **ART Processing:** ART converts DEX to native code (OAT files)

**DEX Format:**
- Compact binary format optimized for mobile
- Contains classes, methods, fields, strings, etc.
- Designed for efficient parsing and execution
- Supports multidex (multiple DEX files per app)

**AOT Compilation Process:**

When you install an app:
1. **APK Installation:** Package manager installs APK
2. **DEX Extraction:** DEX files extracted to `/data/dalvik-cache/`
3. **dex2oat Execution:** ART's `dex2oat` compiler runs
4. **Compilation:** DEX bytecode compiled to native machine code
5. **OAT File Creation:** Compiled code saved as OAT (Optimized Android Type) file
6. **Optimization:** Code optimized (inlining, dead code elimination, etc.)
7. **Storage:** OAT file stored (typically 2-3x larger than DEX)

**Example:**
```
App: MyApp.apk (10MB)
├── classes.dex (5MB)
└── After installation:
    ├── classes.dex (5MB) - original
    └── classes.odex (12MB) - compiled native code
```

**JIT Compilation (Android 7.0+):**

ART also uses JIT for runtime optimization:
1. **Profile Collection:** ART profiles which methods are called frequently
2. **Hot Method Detection:** Identifies "hot" code paths
3. **JIT Compilation:** Compiles hot methods at runtime
4. **Optimization:** Applies aggressive optimizations to hot code
5. **Profile Updates:** Saves profiles for future AOT compilation

**Hybrid Approach Benefits:**
- **Fast Startup:** AOT ensures apps start quickly
- **Adaptive Optimization:** JIT optimizes based on actual usage
- **Storage Balance:** Not everything needs to be AOT compiled
- **Best of Both Worlds:** Fast startup + optimized runtime performance

**Key Components:**

**Dex2oat:**
- DEX to OAT compiler
- Compiles DEX files to native code
- Creates OAT (Optimized Android Type) files
- Performs optimizations during compilation

**Garbage Collector:**

The garbage collector (GC) automatically manages memory, freeing developers from manual memory management. It's one of ART's most critical components.

**Why Garbage Collection?**

In languages like C/C++, you must manually allocate and free memory:
```c
void* ptr = malloc(100);  // Allocate
// ... use memory ...
free(ptr);  // Must remember to free!
```

In Java/Kotlin (and thus Android), memory is managed automatically:
```kotlin
val list = ArrayList<String>()  // Allocate
// ... use list ...
// No need to free - GC handles it!
```

**How Garbage Collection Works:**

**1. Object Allocation:**
When you create an object:
```kotlin
val user = User("John", 30)
```
- ART allocates memory from the heap
- Object is created and reference stored
- If heap is full, GC is triggered

**2. Garbage Detection:**
GC identifies "garbage" (unreachable objects):
- **Root Set:** Objects that are definitely alive (static variables, stack variables, etc.)
- **Reachability:** Any object reachable from root set is alive
- **Unreachable Objects:** Objects not reachable are garbage

**3. Garbage Collection:**
- **Mark:** Mark all reachable objects
- **Sweep:** Free memory of unmarked (garbage) objects
- **Compact:** Move objects to reduce fragmentation (optional)

**GC Strategies in ART:**

**1. Concurrent Mark-Sweep (CMS):**
- Marks objects while app is running (concurrent)
- Minimal pause times
- Good for interactive apps
- Used in older Android versions

**2. Generational GC:**
- Divides heap into generations (young, old)
- Most objects die young (temporary objects)
- Young generation collected frequently (fast)
- Old generation collected less frequently (slower but thorough)
- More efficient overall

**3. G1 Garbage Collector (Android 8.0+):**
- Divides heap into regions
- Collects regions with most garbage first
- Predictable pause times
- Better for large heaps
- Default in modern Android

**GC Pause Times:**

GC must pause the app briefly to ensure consistency:
- **Young Generation GC:** < 10ms (very fast)
- **Full GC:** 50-200ms (noticeable but usually acceptable)
- **Concurrent Phases:** Run while app executes (no pause)

**Real-World Example:**

You're using a photo editing app:
1. App loads 10 photos into memory (100MB)
2. You edit photos, creating temporary objects (50MB)
3. You finish editing, close editor
4. Temporary objects become unreachable
5. GC runs, frees 50MB of temporary objects
6. App continues smoothly with 100MB of photo data

**GC Tuning:**

ART provides GC tuning options:
- Heap size limits
- GC frequency
- Pause time targets
- Generation sizes

**Common GC Issues:**

**1. Memory Leaks:**
Objects that should be garbage aren't:
```kotlin
// BAD: Static reference prevents GC
object Cache {
    val items = mutableListOf<LargeObject>()
}

// GOOD: Weak reference allows GC
object Cache {
    val items = WeakHashMap<Key, LargeObject>()
}
```

**2. Too Many Allocations:**
Creating many temporary objects triggers frequent GC:
```kotlin
// BAD: Creates new string each time
for (i in 0..1000000) {
    val str = "Number: $i"  // Allocates 1M strings
}

// GOOD: Reuse or use StringBuilder
val sb = StringBuilder()
for (i in 0..1000000) {
    sb.append("Number: $i")
}
```

**3. Large Object Allocation:**
Large objects can cause long GC pauses:
- Bitmaps, large arrays, etc.
- Consider object pooling for frequently allocated large objects

**Class Loader:**
- Loads classes from DEX files
- Manages class hierarchy
- Handles class verification
- Supports multidex

**JNI Bridge:**
- Java Native Interface
- Allows Java code to call native code
- Enables native libraries integration
- Performance-critical operations

#### ART Features

**AOT Compilation:**
- Compiles apps at install time
- Faster app startup
- Better performance
- Larger storage footprint

**JIT Compilation:**
- Compiles code at runtime
- Profiles hot code paths
- Optimizes frequently used code
- Balances performance and storage

**Profile-Guided Optimization:**
- Uses usage profiles
- Optimizes based on actual usage
- Improves performance over time
- Background optimization

### Layer 5: Java API Framework

The Java API Framework provides high-level APIs that applications use to interact with the Android system. It's written primarily in Java and Kotlin. This is the layer that most Android developers interact with daily - it provides the building blocks for creating Android apps.

#### Understanding the Framework

The framework is like a "toolkit" that provides everything you need to build Android apps:
- **UI Components:** Buttons, text views, layouts
- **System Services:** Access to camera, location, notifications
- **Lifecycle Management:** Handle app state changes
- **Data Storage:** Databases, shared preferences, files
- **Networking:** HTTP clients, connectivity management
- **Multimedia:** Audio, video, image processing

**Framework vs. Libraries:**

- **Framework:** Provides structure and calls your code (inversion of control)
  - Example: Framework calls your `onCreate()` method
- **Libraries:** You call library functions
  - Example: You call `Math.sqrt()` function

Android framework uses inversion of control - the framework controls the flow, and your code responds to framework callbacks.

#### Framework Components

**Activity Manager:**

The Activity Manager is the "traffic controller" for Android apps. It manages which apps are running, which screens are visible, and how apps transition between states.

**Application Lifecycle Management:**

When you launch an app:
1. **ActivityManagerService** (in System Server) receives launch request
2. AMS checks if app process exists
3. If not, AMS asks Zygote to fork new process
4. AMS creates Activity instance
5. AMS calls lifecycle methods: `onCreate()`, `onStart()`, `onResume()`
6. App becomes visible and interactive

**Activity Stack Management:**

Android uses a stack (LIFO - Last In, First Out) to manage activities:
```
Stack (top to bottom):
┌─────────────────┐
│ SettingsActivity│  ← Currently visible
├─────────────────┤
│ MainActivity    │  ← Press back to return here
├─────────────────┤
│ Launcher        │  ← Home screen
└─────────────────┘
```

When you press back:
1. Top activity finishes (`onPause()`, `onStop()`, `onDestroy()`)
2. Previous activity resumes (`onRestart()`, `onStart()`, `onResume()`)
3. Stack pops the finished activity

**Task Management:**

A task is a collection of activities that work together:
- **Single Task:** All activities in one task (normal case)
- **Multiple Tasks:** App can have activities in different tasks
- **Task Affinity:** Activities can belong to specific tasks

**Example Scenario:**
1. You're in Email app (MainActivity)
2. Click link → Opens Browser (new task)
3. Browser has its own back stack
4. Press home → Both tasks preserved
5. Return to Email → Email task resumes
6. Return to Browser → Browser task resumes

**Process Management:**

AMS manages app processes:
- **Foreground Process:** App with visible activity (highest priority)
- **Visible Process:** App with paused but visible activity
- **Service Process:** App with running service
- **Background Process:** App in background
- **Empty Process:** App with no active components (lowest priority)

AMS can kill processes when memory is low, starting with lowest priority.

**Window Manager:**
- Manages windows and views
- Handles window composition
- Manages display configuration
- Input event distribution

**Content Providers:**
- Data sharing between apps
- Database abstraction
- URI-based data access
- Permissions and security

**View System:**
- UI component framework
- Layout management
- Event handling
- Drawing and animation

**Package Manager:**
- Application installation
- Package information
- Permissions management
- Component discovery

**Resource Manager:**
- Resource access
- Localization
- Asset management
- Configuration handling

**Notification Manager:**
- System notifications
- Notification channels
- User notification preferences
- Notification display

**Location Manager:**
- GPS and network location
- Location providers
- Location updates
- Geofencing

#### System Services

System services are long-running processes that provide system-wide functionality:

**ActivityManagerService:**
- Core activity management
- Process lifecycle
- Task management
- Memory management

**WindowManagerService:**
- Window management
- Display configuration
- Input event routing
- Window animations

**PackageManagerService:**
- Package installation
- Permission management
- Component resolution
- Package verification

**PowerManagerService:**
- Power state management
- Wake locks
- Battery optimization
- Doze mode

**ConnectivityService:**
- Network management
- Wi-Fi, Bluetooth, cellular
- Network state monitoring
- VPN support

### Layer 6: Applications

Applications are the top layer where user-facing software runs. They can be:

**System Apps:**
- Pre-installed applications
- System UI, Settings, Launcher
- Core system functionality
- Higher privileges

**User Apps:**
- Third-party applications
- Downloaded from Play Store
- Sandboxed execution
- Standard permissions

**Privileged Apps:**
- System apps with additional permissions
- Can access protected APIs
- Pre-installed in system partition
- Examples: Dialer, Contacts

## Architecture Communication Flow

### How Layers Interact

**Application → Framework:**
- Apps use Java/Kotlin APIs
- Framework handles requests
- Manages resources and lifecycle

**Framework → Native Libraries:**
- Framework calls native code via JNI
- Native libraries perform system operations
- Returns results to framework

**Native Libraries → HAL:**
- Native code calls HAL interfaces
- HAL abstracts hardware details
- Hardware-specific implementation

**HAL → Kernel:**
- HAL uses kernel drivers
- Direct hardware access
- System calls for kernel services

**Kernel → Hardware:**
- Direct hardware control
- Device driver communication
- Hardware interrupts

### IPC Mechanisms

**Binder IPC:**
- Primary IPC mechanism
- Used throughout the system
- Efficient message passing
- Security and permissions

**Socket Communication:**
- Network communication
- Local sockets for IPC
- Used by some services

**Shared Memory:**
- High-performance data sharing
- Used for graphics, media
- Ashmem and ION allocators

## Security Architecture

### Process Isolation

**Linux User IDs:**
- Each app runs as separate user
- File system isolation
- Process-level security

**SELinux:**
- Mandatory Access Control
- Fine-grained permissions
- Policy enforcement
- Prevents privilege escalation

**App Sandbox:**
- Isolated execution environment
- Restricted system access
- Permission-based access control
- Secure inter-process communication

### Permission System

**Install-time Permissions:**
- Declared in manifest
- Granted at install time
- Legacy permission model

**Runtime Permissions:**
- User grants at runtime
- Better user control
- Introduced in Android 6.0
- Sensitive permissions

**Signature Permissions:**
- System-level permissions
- Only granted to system apps
- Higher security level

## Performance Considerations

### Memory Management

**Low Memory Killer:**
- Kills processes when memory is low
- Priority-based killing
- Preserves important processes
- Configurable thresholds

**Memory Mapping:**
- Efficient memory usage
- Shared libraries
- Memory-mapped files
- Copy-on-write

### Optimization Strategies

**AOT Compilation:**
- Faster app startup
- Better runtime performance
- Trade-off: larger storage

**JIT Compilation:**
- Adaptive optimization
- Profile-guided optimization
- Balances performance and storage

**Resource Optimization:**
- Efficient resource loading
- Caching strategies
- Lazy loading

## Development Implications

### For Application Developers

**Understanding the Stack:**
- Know which layer handles what
- Choose appropriate APIs
- Understand performance implications
- Debug effectively

**Best Practices:**
- Use framework APIs correctly
- Avoid direct native calls when possible
- Understand lifecycle management
- Follow security best practices

### For System Developers

**Modifying the System:**
- Understand layer boundaries
- Maintain interface contracts
- Consider backward compatibility
- Test thoroughly

**Adding Features:**
- Choose appropriate layer
- Follow architecture patterns
- Maintain separation of concerns
- Document changes

## Real-World Examples

### Camera Capture Flow

1. **Application:** App calls Camera API
2. **Framework:** CameraManager handles request
3. **Native:** Camera service processes request
4. **HAL:** Camera HAL interfaces with hardware
5. **Kernel:** Camera driver controls sensor
6. **Hardware:** Image sensor captures image
7. **Flow Reverses:** Image data flows back up

### Network Request Flow

1. **Application:** App makes HTTP request
2. **Framework:** Network stack processes request
3. **Native:** SSL/TLS libraries handle encryption
4. **HAL:** Network HAL (if applicable)
5. **Kernel:** Network driver sends packets
6. **Hardware:** Wi-Fi/cellular modem transmits

## Edge Cases and Pitfalls

### Common Issues

**Layer Violations:**
- Direct hardware access from apps (not allowed)
- Bypassing framework APIs
- Inappropriate layer usage

**Performance Issues:**
- Inefficient IPC
- Memory leaks
- Resource contention

**Security Vulnerabilities:**
- Permission bypasses
- Privilege escalation
- Data leakage

### Best Practices

- Respect layer boundaries
- Use appropriate APIs
- Follow security guidelines
- Optimize carefully
- Test thoroughly

## References and Further Reading

- [AOSP Architecture Documentation](https://source.android.com/docs/core/architecture)
- [Android System Architecture](https://developer.android.com/guide/platform)
- [Linux Kernel Documentation](https://www.kernel.org/doc/)
- [ART Runtime Documentation](https://source.android.com/docs/core/runtime)

## Quiz

### Question 1
What is the primary purpose of the Hardware Abstraction Layer (HAL)?

**A)** To provide Java APIs to applications  
**B)** To abstract hardware-specific details and provide a standardized interface  
**C)** To manage application lifecycle  
**D)** To compile DEX files to native code

**Answer: B** - The HAL abstracts hardware-specific details, allowing the Android framework to work with different hardware implementations through a standardized interface.

### Question 2
Which component replaced Dalvik as the Android runtime?

**A)** JVM  
**B)** ART (Android Runtime)  
**C)** Native libraries  
**D)** Binder

**Answer: B** - ART (Android Runtime) replaced Dalvik starting with Android 5.0 (Lollipop), providing AOT compilation and better performance.

### Question 3
What is the primary IPC mechanism used throughout Android?

**A)** Sockets  
**B)** Pipes  
**C)** Binder  
**D)** Shared memory

**Answer: C** - Binder is the primary IPC mechanism in Android, used for efficient inter-process communication throughout the system.

### Question 4
Which layer directly interfaces with hardware devices?

**A)** Framework  
**B)** Native Libraries  
**C)** HAL  
**D)** Applications

**Answer: C** - The HAL (Hardware Abstraction Layer) directly interfaces with hardware, though it uses kernel drivers for actual hardware control.

### Question 5
What is the purpose of SELinux in Android?

**A)** To manage memory allocation  
**B)** To provide Mandatory Access Control and enhance security  
**C)** To compile applications  
**D)** To manage network connections

**Answer: B** - SELinux provides Mandatory Access Control (MAC), adding fine-grained security policies and preventing privilege escalation attacks.

## Related Topics

- [System Server Overview](./02.%20System%20Server%20Overview.md)
- [Boot Process Overview](./03.%20Boot%20Process%20Overview.md)
- [Init System in Android](./04.%20Init%20System%20in%20Android.md)

