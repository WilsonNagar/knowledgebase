---
number: 43
title: Building the kernel
slug: building-the-kernel
level: beginner
tags:
  - aosp
  - kernel
  - build
  - compilation
  - cross-compilation
  - toolchain
prerequisites:
  - kernel-configuration-defconfig
  - build-system-structure
  - boardconfig
estimated_minutes: 90
contributors: []
diagrams: []
examples: []
canonical_id: aosp-beginner-43
---

# Building the kernel

## Overview

Building the kernel is the process of compiling the kernel source code into a binary image that can be booted on a device. Understanding how to build the Android kernel is essential for AOSP development, as it's required for device porting, kernel customization, driver development, and system debugging. This guide provides a comprehensive overview of the kernel build process, build tools, cross-compilation, and how kernel building integrates with the Android build system.

Think of building the kernel like constructing a building: you start with architectural plans (source code and configuration), gather materials (toolchain and dependencies), follow construction steps (compilation process), and end up with a finished structure (kernel image). Each step must be done correctly, in the right order, with the right tools, to produce a working kernel that boots on your device.

## Deep Explanation

### What is Kernel Building?

Kernel building is the process of transforming kernel source code into executable binary images. It involves compilation, linking, and packaging the kernel and its components into bootable images.

**Key Characteristics:**
- **Cross-Compilation:** Build for different architecture
- **Configuration-Based:** Uses defconfig
- **Modular:** Can build modules separately
- **Device-Specific:** Tailored to hardware

**Why Build the Kernel?**
- **Device Porting:** Port Android to new hardware
- **Customization:** Add custom features
- **Debugging:** Debug kernel issues
- **Development:** Develop drivers and features

### Build Prerequisites

#### Required Tools

**Build Tools:**
- **Compiler:** GCC or Clang
- **Linker:** GNU ld or lld
- **Make:** Build system
- **Binutils:** Binary utilities

**Cross-Compilation Toolchain:**
- Architecture-specific compiler
- Target architecture tools
- Libraries and headers
- Build utilities

**Other Tools:**
- **dtc:** Device Tree Compiler
- **mkbootimg:** Boot image creator
- **Python:** Build scripts
- **Git:** Source control

#### Environment Setup

**Build Environment:**
```bash
# Set architecture
export ARCH=arm64

# Set cross-compiler
export CROSS_COMPILE=aarch64-linux-gnu-

# Set toolchain path (if needed)
export PATH=$PATH:/path/to/toolchain/bin
```

**Android Build Integration:**
- Uses Android build system
- Automatic toolchain selection
- Environment configured by build system
- No manual setup needed

### Kernel Build Process

#### Step 1: Configuration

**Load Configuration:**
```bash
cd kernel/
make ARCH=arm64 defconfig
# Or device-specific:
make ARCH=arm64 <device>_defconfig
```

**Verify Configuration:**
```bash
make ARCH=arm64 oldconfig
```

**Configuration File:**
- `.config` - Active configuration
- Generated from defconfig
- Used during build
- Can be edited manually

#### Step 2: Build Kernel

**Basic Build:**
```bash
make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu-
```

**With Android Build:**
```bash
# From AOSP root
source build/envsetup.sh
lunch <device>-<variant>
make kernel
```

**Build Output:**
- `arch/arm64/boot/Image` - Kernel image
- `vmlinux` - Uncompressed kernel
- `System.map` - Symbol map
- Modules in respective directories

#### Step 3: Build Device Tree

**Device Tree Build:**
```bash
make ARCH=arm64 dtbs
```

**Output:**
- `*.dtb` files - Device Tree Blobs
- Device-specific
- Hardware description
- Required for boot

#### Step 4: Build Modules (Optional)

**Build All Modules:**
```bash
make ARCH=arm64 modules
```

**Build Specific Module:**
```bash
make ARCH=arm64 M=drivers/staging/android modules
```

**Module Output:**
- `*.ko` files - Kernel objects
- Loadable modules
- Can be installed separately

### Build Commands

#### Standard Build Commands

**Clean Build:**
```bash
make ARCH=arm64 clean
```

**Full Clean:**
```bash
make ARCH=arm64 mrproper
```

**Incremental Build:**
```bash
make ARCH=arm64
# Only rebuilds changed files
```

**Parallel Build:**
```bash
make ARCH=arm64 -j$(nproc)
# Uses all CPU cores
```

#### Android Build Integration

**Build from AOSP:**
```bash
# Setup environment
source build/envsetup.sh
lunch <device>-<variant>

# Build kernel only
make kernel

# Or build everything (includes kernel)
make -j$(nproc)
```

**Build Output Location:**
```
out/target/product/<device>/obj/KERNEL_OBJ/
out/target/product/<device>/kernel
```

### Build Variants

#### Build Types

**Standard Build:**
- Production kernel
- Optimized
- Release configuration
- Device-specific

**Debug Build:**
```bash
make ARCH=arm64 KCFLAGS="-g -O0"
```

**Features:**
- Debug symbols
- Less optimization
- Easier debugging
- Larger binary

**Development Build:**
- Additional logging
- Debug features enabled
- More verbose
- Development tools

### Cross-Compilation

#### What is Cross-Compilation?

Cross-compilation is building code for a different architecture than the build host. For Android, you typically build ARM/ARM64 kernels on x86_64 hosts.

**Why Cross-Compile?**
- **Different Architectures:** Host â‰  Target
- **Performance:** Faster builds on x86
- **Standard Practice:** Common in embedded systems
- **Toolchain:** Specialized compilers

#### Toolchain Selection

**GCC Toolchain:**
```bash
export CROSS_COMPILE=aarch64-linux-gnu-
# Uses: aarch64-linux-gnu-gcc
```

**Clang Toolchain:**
```bash
export CC=clang
export CLANG_TRIPLE=aarch64-linux-gnu-
```

**Android Prebuilt Toolchain:**
- Included in AOSP
- Pre-configured
- Architecture-specific
- Automatically selected

#### Architecture-Specific Builds

**ARM64:**
```bash
export ARCH=arm64
export CROSS_COMPILE=aarch64-linux-gnu-
make defconfig
make -j$(nproc)
```

**ARM:**
```bash
export ARCH=arm
export CROSS_COMPILE=arm-linux-gnueabi-
make defconfig
make -j$(nproc)
```

**x86:**
```bash
export ARCH=x86
# Native compilation, no cross-compiler needed
make defconfig
make -j$(nproc)
```

### Build Outputs

#### Kernel Images

**Uncompressed Kernel:**
- `vmlinux` - ELF format, full symbols
- `arch/<arch>/boot/Image` - ARM64 uncompressed
- `arch/<arch>/boot/zImage` - ARM compressed
- `arch/<arch>/boot/bzImage` - x86 compressed

**Compressed Kernel:**
- Gzip compression
- LZ4 compression
- Smaller size
- Faster loading

#### Device Tree

**Device Tree Blobs:**
- `*.dtb` files
- Binary format
- Hardware description
- Device-specific

**Device Tree Overlays:**
- `*.dtbo` files
- Runtime modifications
- Hardware variants
- Optional

#### Modules

**Kernel Modules:**
- `*.ko` files
- Loadable modules
- Architecture-specific
- Versioned

**Module Installation:**
```bash
make ARCH=arm64 modules_install INSTALL_MOD_PATH=/path/to/rootfs
```

### Build Optimization

#### Build Speed

**Parallel Builds:**
```bash
make -j$(nproc)
# Use all CPU cores
```

**ccache:**
```bash
export CC="ccache gcc"
# Or in Android build system
export USE_CCACHE=1
```

**Incremental Builds:**
- Only rebuild changed files
- Faster iteration
- Dependency tracking
- Make handles automatically

#### Size Optimization

**Compiler Flags:**
```bash
KCFLAGS="-Os -ffunction-sections -fdata-sections"
```

**Linker Flags:**
```bash
LDFLAGS="--gc-sections"
```

**Configuration:**
- Disable unused features
- Build drivers as modules
- Optimize for size
- Remove debug code

### Integration with Android Build

#### Android Build System

**Automatic Kernel Build:**
- Build system handles kernel build
- Uses BoardConfig settings
- Integrates with image creation
- Packages in boot image

**BoardConfig.mk:**
```makefile
TARGET_KERNEL_ARCH := arm64
TARGET_KERNEL_CONFIG := mydevice_defconfig
TARGET_KERNEL_SOURCE := kernel/vendor/device
TARGET_KERNEL_CROSS_COMPILE := aarch64-linux-gnu-
```

#### Build Integration

**Build Flow:**
1. Build system reads BoardConfig
2. Configures kernel build
3. Builds kernel
4. Builds device tree
5. Creates boot image
6. Packages in system

**Output Integration:**
- Kernel in boot image
- Device tree in boot image
- Modules in system image
- Integrated build

### Build Troubleshooting

#### Common Build Errors

**Configuration Errors:**
```
Error: Missing configuration option
```
**Solution:**
- Run `make oldconfig`
- Enable required options
- Check dependencies

**Compilation Errors:**
```
Error: Undefined reference
```
**Solution:**
- Check dependencies
- Verify configuration
- Review source code
- Check toolchain

**Toolchain Issues:**
```
Error: Cannot find compiler
```
**Solution:**
- Verify CROSS_COMPILE path
- Check toolchain installation
- Set PATH correctly
- Use Android toolchain

#### Debugging Build Issues

**Verbose Build:**
```bash
make V=1
# Shows all commands
```

**Check Configuration:**
```bash
make menuconfig
# Verify settings
```

**Review Logs:**
- Check build output
- Review error messages
- Check configuration
- Verify toolchain

### Build Best Practices

#### Development Workflow

**1. Start with Known Good Config:**
- Use device defconfig
- Start from working config
- Test incrementally

**2. Make Incremental Changes:**
- Change one thing at a time
- Test after each change
- Keep working config
- Document changes

**3. Version Control:**
- Commit defconfig changes
- Tag working builds
- Document modifications
- Track history

**4. Test Thoroughly:**
- Build successfully
- Boot on device
- Test functionality
- Verify stability

#### Build Maintenance

**Regular Updates:**
- Update kernel source
- Merge new changes
- Update defconfig
- Test compatibility

**Configuration Management:**
- Keep defconfigs clean
- Document options
- Version control
- Device-specific

### Advanced Build Topics

#### Custom Build Scripts

**Build Script Example:**
```bash
#!/bin/bash
export ARCH=arm64
export CROSS_COMPILE=aarch64-linux-gnu-
export KBUILD_OUTPUT=./out

make defconfig
make -j$(nproc)
make dtbs
```

**Automation:**
- Custom build scripts
- CI/CD integration
- Automated testing
- Build verification

#### Multiple Device Builds

**Build Multiple Devices:**
```bash
for device in device1 device2 device3; do
    make ARCH=arm64 ${device}_defconfig
    make -j$(nproc)
    # Package results
done
```

**Batch Building:**
- Build multiple configs
- Automated process
- Parallel builds
- Result management

## Key Takeaways

1. **Kernel building transforms source code** into bootable binary images through compilation, linking, and packaging.

2. **Cross-compilation is essential** for building ARM/ARM64 kernels on x86_64 build hosts.

3. **The build process involves** configuration (defconfig), compilation, device tree building, and optional module building.

4. **Android build system integrates** kernel building automatically using BoardConfig settings.

5. **Build optimization includes** parallel builds, ccache, incremental builds, and size optimization.

6. **Build outputs include** kernel images (Image, zImage), device tree blobs (.dtb), and kernel modules (.ko).

7. **Common build issues** include configuration errors, compilation errors, and toolchain problems that require careful debugging.

8. **Understanding kernel building** is essential for device porting, kernel customization, and AOSP development.

## Related Topics

- **Kernel configuration (defconfig):** How configuration determines what gets built
- **Kernel modules:** How modules are built separately from the main kernel
- **Building boot.img, system.img manually:** How kernel images are packaged
- **BoardConfig:** How kernel build is configured in Android build system
- **Build System Structure:** How kernel build integrates with Android build system

