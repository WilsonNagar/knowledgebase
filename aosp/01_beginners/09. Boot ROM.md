---
number: 9
title: Boot ROM
slug: boot-rom
level: beginner
tags:
  - aosp
  - boot
  - boot-rom
  - hardware
  - security
  - verified-boot
prerequisites:
  - boot-process-overview
estimated_minutes: 60
contributors: []
diagrams: []
examples: []
canonical_id: aosp-beginner-09
---

# Boot ROM

## Overview

Boot ROM (Boot Read-Only Memory) is the first code that executes when an Android device is powered on. It's firmware embedded directly in the device's processor chip, making it the most fundamental and trusted component in the entire boot chain. Understanding Boot ROM is essential for comprehending how Android devices start up, how security is established from the very beginning, and how the boot process transitions from hardware to software.

Think of Boot ROM like the ignition system in a car: when you turn the key (apply power), the ignition system (Boot ROM) is the first thing that activates. It performs the most basic checks, initializes critical systems, and then hands control to the starter motor (bootloader). Just as you can't modify the ignition system without replacing the entire car, Boot ROM cannot be modified - it's permanently burned into the chip during manufacturing.

## Deep Explanation

### What is Boot ROM?

Boot ROM is firmware code that is physically embedded in the processor chip itself. Unlike software stored in flash memory or on storage devices, Boot ROM is hard-wired into the silicon during chip manufacturing. This makes it:

**Physical Characteristics:**
- **Location:** Inside the CPU/SoC chip itself
- **Storage Type:** Read-Only Memory (ROM) - cannot be erased or rewritten
- **Manufacturing:** Burned into the chip during fabrication
- **Modification:** Impossible to modify after manufacturing (even by chip manufacturers)
- **Size:** Typically very small (a few kilobytes to tens of kilobytes)

**Why Read-Only?**
The read-only nature of Boot ROM provides several critical benefits:

1. **Security:** Cannot be tampered with or infected by malware
2. **Reliability:** Always works, even if all other storage is corrupted
3. **Trust:** Provides the "root of trust" for the entire security chain
4. **Simplicity:** Minimal code reduces attack surface and bugs

### Boot ROM Execution Context

When Boot ROM executes, the device is in its most primitive state:

**System State:**
- CPU just received power-on reset
- No memory is initialized (except CPU caches)
- No storage is accessible yet
- No peripherals are initialized
- No software has run before

**Execution Environment:**
- Boot ROM runs directly from CPU-internal ROM
- Executes in privileged mode (full hardware access)
- No operating system or drivers available
- Minimal resources available
- Must be self-contained

**Constraints:**
- Very limited code size (must fit in chip ROM)
- Must execute quickly (milliseconds)
- Cannot use external libraries
- Must work with minimal hardware initialization

### Boot ROM Responsibilities

Boot ROM has a very focused set of responsibilities, all critical for getting the device to a state where the bootloader can run:

#### 1. CPU Initialization

**Reset State:**
When power is first applied, the CPU is in an unknown or reset state. Boot ROM must bring it to a known, working state:

**Register Initialization:**
- Set CPU control registers to known values
- Configure CPU mode (ARM mode, Thumb mode, etc.)
- Set up stack pointer (if needed)
- Initialize general-purpose registers

**Cache Configuration:**
- Enable or disable CPU caches (depending on design)
- Configure cache policies
- Set up cache coherency (if multi-core)

**CPU Clock Setup:**
- Start with slow, safe clock frequency
- Initialize clock sources (crystal oscillators)
- Configure PLLs (Phase-Locked Loops) for higher frequencies
- Gradually increase clock speed if needed

**Why This Matters:**
Without proper CPU initialization, the CPU might execute instructions incorrectly, run at wrong speeds, or fail to access memory properly. Boot ROM ensures the CPU is in a known, stable state before any other code runs.

#### 2. Memory Initialization

**Memory Controller Setup:**
Before any code can run from RAM or load data, the memory controller must be initialized:

**RAM Detection:**
- Detect what type of RAM is installed (DDR3, DDR4, LPDDR4, etc.)
- Detect RAM size and configuration
- Identify memory timing parameters

**Memory Controller Configuration:**
- Set up memory controller registers
- Configure memory timing (CAS latency, RAS, etc.)
- Set up memory mapping
- Enable memory refresh

**Memory Testing:**
- Basic memory integrity checks
- Verify memory is accessible
- Test critical memory regions

**Memory Mapping:**
- Set up basic memory map
- Define which addresses map to which memory regions
- Configure memory protection (if available)

**Why This Matters:**
The bootloader and kernel need RAM to run. Boot ROM must ensure RAM is accessible and working before loading the bootloader. If memory initialization fails, the device cannot boot.

#### 3. Clock and Power Management

**Clock Tree Initialization:**
Modern SoCs have complex clock trees with multiple clock domains:

**Clock Sources:**
- Initialize crystal oscillators (reference clocks)
- Set up PLLs for generating higher frequencies
- Configure clock dividers and multipliers

**Clock Domains:**
- CPU clock domain
- Memory clock domain
- Peripheral clock domains
- System bus clocks

**Power Management:**
- Initialize Power Management IC (PMIC) communication
- Set up voltage regulators
- Configure power domains
- Enable power to necessary components

**Why This Matters:**
Without proper clocks, nothing can run. The CPU needs a clock to execute instructions, memory needs a clock to operate, and peripherals need clocks to function. Boot ROM establishes the fundamental timing for the entire system.

#### 4. Minimal I/O Initialization

**Debug Interface:**
- Initialize UART (Universal Asynchronous Receiver-Transmitter) for serial debugging
- Set up basic console output
- Enable early debugging capabilities

**GPIO (General Purpose I/O):**
- Configure critical GPIO pins
- Set up button detection (for boot mode selection)
- Enable LED indicators (if present)

**Storage Interface:**
- Initialize basic storage controller (eMMC/UFS interface)
- Set up minimal communication with storage
- Prepare for bootloader loading

**Why This Matters:**
Boot ROM needs to read the bootloader from storage, so it must initialize the storage interface. It also needs to detect button presses to determine boot mode (normal, recovery, fastboot).

#### 5. Boot Source Detection

**Boot Mode Selection:**
Boot ROM must determine where to load the bootloader from and what mode to boot in:

**Hardware Button Detection:**
- Read GPIO pins for button states
- Volume Down + Power = Fastboot mode
- Volume Up + Power = Recovery mode
- No buttons = Normal boot

**Boot Source Options:**
1. **Normal Boot:** Load from eMMC/UFS internal storage
2. **Fastboot Mode:** Wait for USB connection, don't load bootloader
3. **Recovery Mode:** Load from recovery partition
4. **Download Mode:** OEM-specific (Samsung, etc.)

**Detection Logic:**
```
Boot ROM checks:
1. Are hardware buttons pressed?
   - Volume Down + Power → Fastboot mode
   - Volume Up + Power → Recovery mode
2. Is there a recovery trigger flag?
3. Is there a download mode trigger?
4. Default → Normal boot from internal storage
```

**Why This Matters:**
Different boot modes serve different purposes. Fastboot allows flashing and debugging, recovery allows system recovery, and normal boot is the standard operation. Boot ROM must correctly detect the intended mode.

#### 6. Security Initialization

**Root of Trust Establishment:**
Boot ROM establishes the foundation for all security on the device:

**Device Keys:**
- Load device-specific cryptographic keys
- These keys are burned into the chip during manufacturing
- Unique to each device (or device batch)
- Cannot be extracted or modified
- Used to verify bootloader signatures

**Secure Boot Chain:**
- Boot ROM verifies the bootloader signature before loading it
- Uses device keys to validate bootloader authenticity
- If signature is invalid, boot stops (prevents unauthorized code)
- This is the foundation for Android Verified Boot (AVB)

**Secure Storage:**
- Initialize secure storage areas (if available)
- Set up encryption keys
- Prepare for verified boot measurements
- Initialize Trusted Execution Environment (TEE) if present

**Security Measurements:**
- Measure (hash) the bootloader before loading
- Store measurements for chain of trust
- Enable rollback protection mechanisms

**Why This Matters:**
Security must start at the very beginning. If Boot ROM doesn't establish proper security, the entire device can be compromised. Boot ROM's security initialization is the foundation for Android's verified boot and device security.

### Boot ROM Execution Flow

Let's trace through exactly what happens when Boot ROM executes:

#### Step 1: Power Applied

**Trigger:**
- User presses power button
- Device is plugged into charger/USB
- Scheduled power-on (alarm, etc.)

**Hardware Response:**
- Power Management IC (PMIC) supplies power to CPU
- CPU receives power-on reset signal
- All CPU registers reset to default values
- CPU's program counter (PC) points to Boot ROM start address

**Timing:**
- This happens within microseconds of power application
- Boot ROM execution begins almost immediately

#### Step 2: CPU Starts Executing

**Initial State:**
- CPU program counter points to Boot ROM start address (hardware-defined)
- CPU is in privileged mode (can access all hardware)
- No memory is accessible yet (except Boot ROM itself)

**First Instructions:**
- First instruction is typically a jump to initialization code
- CPU begins executing from Boot ROM
- All code runs directly from CPU-internal ROM

**Execution Characteristics:**
- Very fast execution (no memory access delays)
- Direct hardware access
- No software layers or abstractions

#### Step 3: Minimal Hardware Initialization

**CPU Setup:**
- Initialize CPU registers to known values
- Configure CPU mode and features
- Set up CPU caches
- Configure CPU clocks

**Memory Initialization:**
- Detect installed RAM type and size
- Initialize memory controller
- Set up memory timing parameters
- Test memory accessibility
- Configure memory mapping

**Clock Configuration:**
- Initialize clock sources (crystals, oscillators)
- Set up PLLs for higher frequencies
- Configure clock dividers
- Enable necessary clock domains

**I/O Initialization:**
- Initialize UART for debugging
- Configure critical GPIO pins
- Set up storage interface basics

**Timing:**
- This phase typically takes 1-5 milliseconds
- Must be fast but thorough

#### Step 4: Boot Source Detection

**Button Reading:**
- Read GPIO pins for button states
- Detect button combinations
- Determine intended boot mode

**Boot Source Selection:**
- Based on button states, select boot source
- Normal: eMMC/UFS internal storage
- Fastboot: Wait for USB, don't load bootloader
- Recovery: Recovery partition
- Download: OEM-specific mode

**Timing:**
- Button detection is nearly instantaneous
- Boot source selection happens in microseconds

#### Step 5: Load Bootloader

**Bootloader Location:**
- Bootloader is stored in a specific partition on storage
- Location is hardware-defined (typically boot partition)
- Boot ROM knows where to find it

**Loading Process:**
1. Initialize storage interface fully
2. Read bootloader from storage partition
3. Load bootloader into RAM at predetermined address
4. Verify bootloader integrity (size, basic checks)

**Signature Verification:**
- If secure boot is enabled, verify bootloader signature
- Use device keys to validate signature
- If signature invalid, stop boot (security feature)
- If signature valid, proceed to next step

**Timing:**
- Loading time depends on storage speed
- eMMC: 5-20ms
- UFS: 3-10ms
- USB (fastboot): N/A (waits for connection)

#### Step 6: Transfer Control

**Preparation:**
- Set CPU registers for bootloader entry
- Configure CPU state as expected by bootloader
- Set up stack pointer (if needed)
- Disable Boot ROM (if possible)

**Jump to Bootloader:**
- CPU program counter jumps to bootloader entry point
- Boot ROM execution completes
- Bootloader now has control

**Timing:**
- Control transfer is nearly instantaneous
- Boot ROM execution complete

### Boot ROM Timeline

**Total Execution Time:**
- Power applied: 0ms
- Boot ROM starts: < 1ms
- Hardware initialization: 1-5ms
- Bootloader loading: 5-50ms (depends on storage)
- **Total Boot ROM time: ~10-100ms**

**Breakdown:**
- CPU initialization: < 1ms
- Memory initialization: 1-3ms
- Clock setup: < 1ms
- I/O initialization: < 1ms
- Boot source detection: < 1ms
- Bootloader loading: 5-50ms (varies by storage type)
- Control transfer: < 1ms

**Optimization:**
Boot ROM is highly optimized because:
- Every millisecond counts in boot time
- Runs on every boot (frequent execution)
- User experience depends on fast boot
- Battery life (if booting from deep sleep)

### Boot ROM Characteristics

**Size:**
- Typically 8KB to 64KB
- Must fit in CPU chip ROM
- Very limited space forces minimal code

**Language:**
- Written in assembly language or C
- Highly optimized
- Platform-specific (ARM, x86, etc.)

**Modification:**
- Cannot be modified after manufacturing
- Chip must be replaced to change Boot ROM
- Manufacturers test extensively before production

**Security:**
- Highest security level (most trusted code)
- Foundation for all device security
- Cannot be compromised by software attacks

**Performance:**
- Executes very quickly (milliseconds)
- Optimized for speed
- Minimal functionality (just enough to load bootloader)

### Boot ROM and Verified Boot

Boot ROM plays a critical role in Android Verified Boot (AVB):

**Chain of Trust:**
1. Boot ROM (most trusted) verifies bootloader
2. Bootloader verifies kernel
3. Kernel verifies init/system
4. System verifies apps

**Boot ROM's Role:**
- Loads device keys (root of trust)
- Verifies bootloader signature
- Enforces security policies
- Prevents unauthorized code execution

**If Verification Fails:**
- Boot stops immediately
- Device may show error message
- User cannot proceed (security feature)
- Prevents compromised devices from booting

### Boot ROM Variants

Different chip manufacturers implement Boot ROM differently:

**Qualcomm:**
- PBL (Primary Boot Loader) in Boot ROM
- Supports multiple boot sources
- Extensive security features

**MediaTek:**
- Preloader in Boot ROM
- Similar functionality
- OEM-specific customizations

**Samsung Exynos:**
- iROM (internal ROM)
- Supports download mode
- Samsung-specific features

**Allwinner/Rockchip:**
- Simpler Boot ROM
- Less security features
- More open for development

### Debugging Boot ROM

**Challenges:**
- Boot ROM executes before any debugging infrastructure
- No operating system or drivers available
- Limited output capabilities

**Debugging Methods:**
- UART serial output (if initialized early)
- JTAG debugging (hardware-level)
- LED indicators
- Oscilloscope/logic analyzer

**What Can Be Debugged:**
- Boot ROM execution flow
- Hardware initialization
- Boot source detection
- Security verification

**Limitations:**
- Cannot modify Boot ROM behavior
- Limited visibility into execution
- Hardware-level debugging required

### Common Boot ROM Issues

**Boot Loops:**
- Boot ROM loads bootloader, but bootloader fails
- Boot ROM keeps trying to load bootloader
- Usually indicates bootloader corruption

**No Boot:**
- Boot ROM cannot initialize hardware
- Memory initialization fails
- Clock setup fails
- Usually indicates hardware failure

**Security Errors:**
- Bootloader signature verification fails
- Device keys corrupted
- Usually indicates security violation or hardware issue

**Fastboot Not Working:**
- Boot ROM not detecting button combination
- USB not initializing
- Usually indicates hardware issue or incorrect procedure

### Boot ROM in Development

**For AOSP Developers:**
- Boot ROM is typically not modifiable
- Must work with existing Boot ROM
- Understanding Boot ROM helps debug boot issues
- Important for custom bootloader development

**For OEMs:**
- Boot ROM is designed during chip development
- Must be finalized before chip production
- Critical for device security
- Affects all devices using that chip

**For Security Researchers:**
- Boot ROM is the root of trust
- Vulnerabilities in Boot ROM are critical
- Research focuses on verification bypass
- Important for device security assessment

## Key Takeaways

1. **Boot ROM is the first code that executes** when a device is powered on, embedded directly in the processor chip.

2. **Boot ROM cannot be modified** - it's read-only memory burned into the chip during manufacturing.

3. **Boot ROM initializes critical hardware** including CPU, memory, clocks, and basic I/O before any other code can run.

4. **Boot ROM establishes security** by loading device keys and verifying the bootloader signature, forming the root of trust.

5. **Boot ROM detects boot mode** by reading hardware buttons and selecting the appropriate boot source (normal, recovery, fastboot).

6. **Boot ROM execution is very fast** (typically 10-100ms) and highly optimized for speed.

7. **Boot ROM transfers control to the bootloader** after loading and verifying it, completing its role in the boot process.

8. **Understanding Boot ROM is essential** for debugging boot issues, understanding device security, and developing custom bootloaders.

## Related Topics

- **Bootloader and Fastboot:** The next stage in the boot process that Boot ROM loads
- **Boot Process Overview:** The complete boot sequence that Boot ROM initiates
- **Android Verified Boot (AVB):** Security system that Boot ROM helps establish
- **Init System in Android:** Later stage that depends on Boot ROM's initialization

