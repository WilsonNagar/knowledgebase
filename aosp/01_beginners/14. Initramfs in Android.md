---
number: 14
title: Initramfs in Android
slug: initramfs-in-android
level: beginner
tags:
  - aosp
  - initramfs
  - ramdisk
  - boot
  - init
  - early-boot
  - filesystem
prerequisites:
  - boot-partitions
  - boot-process-overview
  - init-system-in-android
estimated_minutes: 90
contributors: []
diagrams: []
examples: []
canonical_id: aosp-beginner-14
---

# Initramfs in Android

## Overview

Initramfs (Initial RAM File System) is a temporary root filesystem that is loaded into memory during the early boot process, before the main system partitions are mounted. In Android, the initramfs is packaged as part of the boot image and provides the minimal environment needed to initialize the system, mount the real root filesystem, and start the init process. Understanding initramfs is crucial for AOSP development, as it's the bridge between the kernel and the full Android system.

Think of initramfs like a "starter kit" that the kernel uses to get the system running. Just as you need basic tools to set up a campsite before you can use all your equipment, the kernel needs initramfs to set up the basic environment before it can mount and use the full system partitions. It's temporary, minimal, but absolutely essential for the boot process.

## Deep Explanation

### What is Initramfs?

Initramfs is a compressed archive (CPIO format) that contains a minimal root filesystem. When the kernel boots, it extracts this archive into a temporary filesystem in RAM, mounts it as the root filesystem, and executes the `/init` binary from it. This init process then takes over, mounts the real system partitions, and transitions to the full Android system.

**Key Characteristics:**
- **Temporary:** Exists only in RAM during early boot
- **Minimal:** Contains only essential files and binaries
- **Self-Contained:** Includes all necessary tools and libraries
- **Compressed:** Stored as compressed CPIO archive in boot image
- **Replaced:** Real root filesystem replaces it after mounting

**Why Initramfs?**
- Kernel needs a filesystem to mount as root
- System partitions may not be accessible yet
- Need to initialize system before mounting partitions
- Provides environment for early boot scripts
- Enables modular kernel (no hardcoded init path)

### Initramfs vs Ramdisk

**Historical Context:**
- **Ramdisk (Legacy):** Fixed-size block device in RAM, required formatting
- **Initramfs (Modern):** Flexible filesystem in RAM, no size limit, more efficient

**Android Uses Initramfs:**
- Modern Android uses initramfs (not traditional ramdisk)
- Stored as CPIO archive in boot image
- Extracted to tmpfs (RAM-based filesystem)
- More flexible and efficient than ramdisk

**Terminology Note:**
- "Ramdisk" often used interchangeably with "initramfs" in Android context
- Both refer to the initial root filesystem in RAM
- Technically, Android uses initramfs (CPIO-based)

### Initramfs Structure

#### Typical Initramfs Contents

```
/                          - Root directory
├── init                   - Init binary (first user-space process)
├── init.rc                - Init configuration script
├── init.environ.rc        - Environment setup
├── init.usb.rc            - USB configuration
├── ueventd.rc             - Uevent daemon configuration
├── default.prop           - Default system properties
├── file_contexts          - SELinux file contexts
├── sepolicy               - SELinux policy binary
├── sbin/                  - System binaries
│   ├── adbd               - ADB daemon (if enabled)
│   ├── ueventd            - Uevent daemon
│   └── watchdogd          - Watchdog daemon
├── system/                - System partition mount point
├── vendor/                - Vendor partition mount point
├── data/                  - Data partition mount point
├── dev/                   - Device nodes
│   ├── null
│   ├── zero
│   ├── console
│   └── ...
├── proc/                  - Proc filesystem mount point
├── sys/                   - Sysfs filesystem mount point
├── tmp/                   - Temporary files
└── lib/                   - Shared libraries (if needed)
    └── ...
```

#### Key Files and Directories

**1. /init**
- First user-space process (PID 1)
- Started by kernel after mounting initramfs
- Responsible for early system initialization
- Parses init.rc and starts services
- Mounts system partitions
- Transitions to full Android system

**2. /init.rc**
- Init configuration script
- Defines services, actions, and triggers
- Written in Android Init Language
- Controls early boot sequence
- Sets up environment and mounts filesystems

**3. /default.prop**
- Default system properties
- Set before system partition mounts
- Can be overridden by system properties
- Used for early configuration

**4. /file_contexts**
- SELinux file context mappings
- Used to label filesystem during boot
- Maps file paths to SELinux contexts
- Critical for SELinux initialization

**5. /sepolicy**
- Compiled SELinux policy binary
- Loaded early in boot process
- Defines security rules
- Required for SELinux enforcement

**6. Mount Points**
- `/system` - Mount point for system partition
- `/vendor` - Mount point for vendor partition
- `/data` - Mount point for data partition
- `/proc` - Proc filesystem
- `/sys` - Sysfs filesystem

### Initramfs Creation Process

#### Build-Time Generation

Initramfs is created during AOSP build:

**Build Process:**
```
1. Collect initramfs source files
   - Init binary (from system/core/init)
   - Init scripts (from system/core/rootdir)
   - SELinux policy (from system/sepolicy)
   - Device-specific files (from device/*/)

2. Create directory structure
   - Copy files to staging directory
   - Set permissions and ownership
   - Create device nodes

3. Package as CPIO archive
   - Use cpio to create archive
   - Compress with gzip or lz4
   - Include in boot image

4. Embed in boot image
   - mkbootimg combines kernel + ramdisk
   - Creates boot.img
   - Ready for device flashing
```

**Source Locations:**
- `system/core/rootdir/` - Default initramfs files
- `device/*/rootdir/` - Device-specific files
- `system/core/init/` - Init binary source
- `system/sepolicy/` - SELinux policy

#### Manual Initramfs Creation

**Creating Initramfs from Scratch:**
```bash
# 1. Create directory structure
$ mkdir -p initramfs/{bin,sbin,dev,proc,sys,system,vendor,data}

# 2. Copy init binary
$ cp init initramfs/

# 3. Copy init scripts
$ cp init.rc initramfs/
$ cp ueventd.rc initramfs/

# 4. Create device nodes
$ mknod initramfs/dev/null c 1 3
$ mknod initramfs/dev/zero c 1 5
$ mknod initramfs/dev/console c 5 1

# 5. Package as CPIO
$ cd initramfs
$ find . | cpio -o -H newc | gzip > ../ramdisk.cpio.gz

# 6. Include in boot image
$ mkbootimg --ramdisk ramdisk.cpio.gz --output boot.img
```

### Initramfs in Boot Process

#### Boot Sequence with Initramfs

```
1. Bootloader loads boot image
   ↓
2. Bootloader extracts kernel and initramfs
   ↓
3. Bootloader loads kernel into memory
   ↓
4. Kernel starts executing
   ↓
5. Kernel extracts initramfs to tmpfs (RAM)
   ↓
6. Kernel mounts initramfs as root filesystem (/)
   ↓
7. Kernel executes /init from initramfs
   ↓
8. Init process starts (PID 1)
   ↓
9. Init parses init.rc
   ↓
10. Init mounts system partitions
    ↓
11. Init switches root to system partition
    ↓
12. Init starts system services
    ↓
13. Android system fully operational
```

#### Early Boot Phase

**Kernel → Initramfs Transition:**
- Kernel decompresses initramfs
- Creates tmpfs filesystem in RAM
- Extracts CPIO archive to tmpfs
- Mounts tmpfs as root filesystem
- Executes `/init` binary

**Init Process Startup:**
- Init reads `/init.rc`
- Sets up early environment
- Creates device nodes
- Mounts proc and sys
- Loads SELinux policy
- Sets up logging

#### Partition Mounting

**Mount Sequence:**
```bash
# Initramfs init.rc typically contains:
on early-init
    # Set up basic environment
    mkdir /dev
    mkdir /proc
    mkdir /sys
    mount tmpfs tmpfs /dev
    mount proc proc /proc
    mount sysfs sysfs /sys

on init
    # Mount system partitions
    mount ext4 /dev/block/... /system ro
    mount ext4 /dev/block/... /vendor ro
    mount ext4 /dev/block/... /data rw
```

**Root Filesystem Switch:**
- After mounting system partition
- Init switches root to `/system`
- Initramfs becomes unused
- System partition becomes new root
- Full Android environment available

### Initramfs Contents Deep Dive

#### Init Binary

The init binary is the first user-space process:

**Init Responsibilities:**
- Parse init.rc configuration
- Start services defined in init.rc
- Handle property changes
- Manage service lifecycle
- Handle signals and restarts
- Mount filesystems

**Init Source:**
- Located in `system/core/init/`
- Written in C++
- Compiles to static binary (no dependencies)
- Must be self-contained

**Init Execution:**
```bash
# Init starts as PID 1
$ ps aux | grep init
root      1     0 init

# Init reads configuration
$ cat /init.rc
```

#### Init Scripts (init.rc)

Init scripts define the boot sequence:

**Init.rc Structure:**
```
on early-init
    # Early initialization actions
    mkdir /dev
    mount tmpfs tmpfs /dev

on init
    # Main initialization
    mount ext4 /dev/block/... /system

on late-init
    # Late initialization
    start zygote

service zygote /system/bin/app_process
    class main
```

**Common Actions:**
- `mkdir` - Create directories
- `mount` - Mount filesystems
- `chmod` - Change permissions
- `write` - Write to files
- `setprop` - Set properties
- `start` - Start services

#### SELinux in Initramfs

SELinux policy is loaded early from initramfs:

**SELinux Files:**
- `/sepolicy` - Compiled policy binary
- `/file_contexts` - File context mappings
- `/property_contexts` - Property contexts
- `/service_contexts` - Service contexts

**SELinux Initialization:**
```
1. Init loads /sepolicy
2. Init sets SELinux to enforcing mode
3. Init labels filesystem using /file_contexts
4. SELinux policies enforced
```

**Early SELinux:**
- Policy loaded before system mounts
- Protects early boot process
- Prevents tampering during boot
- Critical for security

#### Device Nodes

Initramfs contains essential device nodes:

**Essential Device Nodes:**
- `/dev/null` - Null device (discards data)
- `/dev/zero` - Zero device (provides zeros)
- `/dev/console` - Console device (kernel messages)
- `/dev/random` - Random number generator
- `/dev/urandom` - Non-blocking random

**Device Node Creation:**
```bash
# Created in initramfs or by ueventd
mknod /dev/null c 1 3
mknod /dev/zero c 1 5
mknod /dev/console c 5 1
```

### Initramfs Customization

#### Device-Specific Customization

**Device Tree Override:**
- Device-specific initramfs files in `device/*/rootdir/`
- Override default files
- Add device-specific scripts
- Customize boot behavior

**Example Structure:**
```
device/mydevice/
└── rootdir/
    ├── init.mydevice.rc
    ├── ueventd.mydevice.rc
    └── fstab.mydevice
```

**Build System Integration:**
```makefile
# In device.mk
PRODUCT_COPY_FILES += \
    device/mydevice/rootdir/init.mydevice.rc:root/init.mydevice.rc
```

#### Adding Custom Files

**Adding Binaries:**
```bash
# 1. Build static binary (no dependencies)
$ gcc -static mytool.c -o mytool

# 2. Add to initramfs source
$ cp mytool device/mydevice/rootdir/sbin/

# 3. Update init.rc to use it
service mytool /sbin/mytool
    class main
```

**Adding Scripts:**
```bash
# 1. Create script
$ cat > device/mydevice/rootdir/init.custom.rc <<EOF
on boot
    exec /sbin/mytool
EOF

# 2. Include in build
# Build system automatically includes rootdir files
```

### Initramfs Extraction and Analysis

#### Extracting Initramfs from Boot Image

**Method 1: Using unpack_bootimg**
```bash
# Unpack boot image
$ unpack_bootimg --boot_img boot.img --out boot_unpacked/

# Extract ramdisk
$ cd boot_unpacked/
$ mkdir ramdisk
$ cd ramdisk
$ gunzip -c ../boot.img-ramdisk.cpio | cpio -i

# View contents
$ ls -la
$ cat init.rc
```

**Method 2: Manual Extraction**
```bash
# Extract boot image components
$ dd if=boot.img of=kernel.img bs=1 skip=<kernel_offset> count=<kernel_size>
$ dd if=boot.img of=ramdisk.cpio.gz bs=1 skip=<ramdisk_offset> count=<ramdisk_size>

# Extract CPIO
$ gunzip ramdisk.cpio.gz
$ cpio -i < ramdisk.cpio
```

**Method 3: Using abootimg**
```bash
# Extract with abootimg
$ abootimg -x boot.img

# Extract ramdisk
$ mkdir ramdisk && cd ramdisk
$ gunzip -c ../initrd.img | cpio -i
```

#### Analyzing Initramfs Contents

**Viewing Init Scripts:**
```bash
# View main init script
$ cat init.rc

# View device-specific scripts
$ cat init.*.rc

# View ueventd configuration
$ cat ueventd.rc
```

**Checking SELinux Policy:**
```bash
# Check if sepolicy exists
$ ls -l sepolicy

# View file contexts
$ cat file_contexts

# Analyze policy (requires tools)
$ sepolicy-analyze sepolicy
```

**Inspecting Binaries:**
```bash
# Check init binary
$ file init
init: ELF 64-bit LSB executable, ARM aarch64, version 1 (SYSV), statically linked

# Check dependencies (should be none for static)
$ ldd init
not a dynamic executable  # Good - static binary
```

### Initramfs Debugging

#### Common Issues

**Issue 1: Initramfs Not Loading**
- **Symptom:** Kernel panic, "VFS: Unable to mount root fs"
- **Cause:** Corrupted initramfs, wrong format, or missing in boot image
- **Solution:** Verify boot image, check initramfs format, rebuild if needed

**Issue 2: Init Process Fails**
- **Symptom:** Boot hangs, no services start
- **Cause:** Corrupted init binary, missing init.rc, or syntax errors
- **Solution:** Check init binary, verify init.rc syntax, check logs

**Issue 3: Partitions Not Mounting**
- **Symptom:** System doesn't boot, mount errors
- **Cause:** Wrong partition paths, missing device nodes, or filesystem issues
- **Solution:** Check fstab, verify partition paths, check device nodes

**Issue 4: SELinux Issues**
- **Symptom:** SELinux errors, services fail to start
- **Cause:** Missing sepolicy, wrong file contexts, or policy errors
- **Solution:** Verify SELinux files, check file contexts, review policy

#### Debugging Techniques

**Enable Early Logging:**
```bash
# In init.rc, add early logging
on early-init
    # Enable console logging
    write /proc/sys/kernel/printk "7 4 1 7"
    
    # Log to console
    log "Early init starting"
```

**Check Initramfs Contents:**
```bash
# Extract and verify initramfs
$ unpack_bootimg --boot_img boot.img --out boot_unpacked/
$ cd boot_unpacked/
$ gunzip -c boot.img-ramdisk.cpio | cpio -t
# Lists all files in initramfs
```

**Verify Init Binary:**
```bash
# Check if init exists and is executable
$ ls -l init
-rwxr-xr-x 1 root root ... init

# Test init binary (on host, if compatible)
$ file init
$ readelf -h init
```

**Check Init Scripts:**
```bash
# Validate init.rc syntax (requires Android tools)
$ android-base-init_parser init.rc

# Manually review for errors
$ cat init.rc | grep -E "(on |service |import )"
```

### Real-World Examples

#### Example 1: Extracting and Modifying Initramfs

```bash
# Extract boot image
$ unpack_bootimg --boot_img boot.img --out boot_unpacked/

# Extract initramfs
$ cd boot_unpacked/
$ mkdir ramdisk && cd ramdisk
$ gunzip -c ../boot.img-ramdisk.cpio | cpio -i

# Modify init.rc (add custom action)
$ cat >> init.rc <<EOF

on boot
    # Custom action
    exec /sbin/mytool
EOF

# Repackage initramfs
$ find . | cpio -o -H newc | gzip > ../ramdisk_new.cpio.gz

# Create new boot image
$ mkbootimg \
  --kernel boot_unpacked/boot.img-kernel \
  --ramdisk ramdisk_new.cpio.gz \
  --output boot_modified.img
```

#### Example 2: Adding Custom Binary to Initramfs

```bash
# 1. Build static binary
$ cat > mytool.c <<EOF
#include <stdio.h>
int main() {
    printf("Custom tool in initramfs\n");
    return 0;
}
EOF
$ gcc -static -o mytool mytool.c

# 2. Add to initramfs source
$ mkdir -p device/mydevice/rootdir/sbin
$ cp mytool device/mydevice/rootdir/sbin/

# 3. Update init.rc
$ cat >> device/mydevice/rootdir/init.mydevice.rc <<EOF
on boot
    exec /sbin/mytool
EOF

# 4. Rebuild boot image
$ m bootimage
```

#### Example 3: Debugging Initramfs Boot Issues

```bash
# Extract initramfs from problematic boot image
$ unpack_bootimg --boot_img boot_problem.img --out debug/

# Check init binary
$ file debug/ramdisk/init
$ ls -l debug/ramdisk/init

# Check init.rc syntax
$ cat debug/ramdisk/init.rc

# Check for missing files
$ ls -la debug/ramdisk/

# Compare with working initramfs
$ diff -r debug/ramdisk/ working/ramdisk/
```

### Best Practices

#### For System Developers

**1. Initramfs Design:**
- Keep initramfs minimal (only essential files)
- Use static binaries (no dynamic dependencies)
- Minimize size (faster boot, less RAM)
- Document custom additions

**2. Init Scripts:**
- Follow Android Init Language best practices
- Keep scripts simple and readable
- Use proper error handling
- Test thoroughly before deployment

**3. SELinux Integration:**
- Include complete SELinux policy
- Label all files correctly
- Test in enforcing mode
- Document policy requirements

**4. Device Customization:**
- Use device-specific directories
- Don't modify core initramfs unnecessarily
- Maintain compatibility with updates
- Document device-specific changes

#### For Application Developers

**1. Understanding Initramfs:**
- Initramfs is temporary and read-only
- Don't try to modify from applications
- Understand it's replaced by system partition
- Be aware of boot sequence implications

**2. Boot-Related Debugging:**
- Initramfs issues cause boot failures
- Check kernel logs for initramfs errors
- Understand early boot process
- Report issues to system team

### Edge Cases and Pitfalls

#### Common Mistakes

**1. Dynamic Binaries in Initramfs:**
```bash
# BAD: Dynamic binary (requires libraries)
$ gcc mytool.c -o mytool  # Links against libc

# GOOD: Static binary (self-contained)
$ gcc -static mytool.c -o mytool  # No dependencies
```

**2. Missing Essential Files:**
```bash
# BAD: Missing init binary
# Boot will fail - kernel can't find /init

# GOOD: Ensure init exists and is executable
$ ls -l init
-rwxr-xr-x 1 root root ... init
```

**3. Incorrect Init.rc Syntax:**
```bash
# BAD: Syntax error
on boot
    mount ext4 /dev/block/... /system  # Missing 'ro' or 'rw'

# GOOD: Correct syntax
on boot
    mount ext4 /dev/block/... /system ro
```

**4. SELinux Policy Issues:**
```bash
# BAD: Missing sepolicy
# SELinux won't initialize properly

# GOOD: Include complete SELinux files
$ ls -l sepolicy file_contexts
```

## References and Further Reading

- [AOSP Init Process](https://source.android.com/docs/core/architecture/init)
- [Android Init Language](https://source.android.com/docs/core/architecture/init/init-language)
- [Boot Process Overview](https://source.android.com/docs/core/architecture/bootloader)
- [SELinux in Android](https://source.android.com/docs/security/features/selinux)
- [CPIO Archive Format](https://en.wikipedia.org/wiki/Cpio)

## Quiz

### Question 1
What is the primary purpose of initramfs in Android?

**A)** To store user data and applications  
**B)** To provide a temporary root filesystem in RAM during early boot before system partitions are mounted  
**C)** To cache system files for faster access  
**D)** To store recovery system files

**Answer: B** - Initramfs provides a minimal, temporary root filesystem loaded into RAM during early boot. It contains the init process and essential files needed to mount the real system partitions and start the Android system.

### Question 2
What format is used for the initramfs archive in Android boot images?

**A)** tar.gz archive  
**B)** CPIO archive (typically compressed with gzip)  
**C)** zip archive  
**D)** ext4 filesystem image

**Answer: B** - Android initramfs is stored as a CPIO (Copy In, Copy Out) archive, typically compressed with gzip or lz4. This archive is extracted to a tmpfs (RAM-based filesystem) during boot.

### Question 3
What is the first user-space process that runs from initramfs?

**A)** zygote  
**B)** system_server  
**C)** init (PID 1)  
**D)** kernel

**Answer: C** - The `/init` binary is the first user-space process (PID 1) executed by the kernel from the initramfs. It parses init.rc, mounts system partitions, and starts the Android system services.

### Question 4
What happens to initramfs after the system partitions are mounted?

**A)** It remains as the root filesystem  
**B)** It is deleted from memory  
**C)** It becomes unused as the system switches root to the system partition  
**D)** It is copied to the data partition

**Answer: C** - After mounting the system partition, init switches the root filesystem from initramfs to the system partition. The initramfs becomes unused but may remain in memory until the system needs that RAM.

### Question 5
Why should binaries in initramfs be statically linked?

**A)** To improve performance  
**B)** To reduce file size  
**C)** To avoid dependencies on shared libraries that may not be available in the minimal initramfs environment  
**D)** To enable encryption

**Answer: C** - Binaries in initramfs should be statically linked because initramfs is a minimal environment that may not have the shared libraries (like libc) available. Static linking ensures the binaries are self-contained and can run without external dependencies.

## Related Topics

- [Boot Partitions](./13.%20Boot%20Partitions.md)
- [Boot Process Overview](./03.%20Boot%20Process%20Overview.md)
- [Init System in Android](./04.%20Init%20System%20in%20Android.md)

