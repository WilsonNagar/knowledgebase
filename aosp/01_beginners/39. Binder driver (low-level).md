---
number: 39
title: Binder driver (low-level)
slug: binder-driver-low-level
level: beginner
tags:
  - aosp
  - binder
  - driver
  - kernel
  - ipc
  - low-level
  - device-driver
prerequisites:
  - binder-ipc-basics
  - differences-android-kernel-linux-kernel
estimated_minutes: 85
contributors: []
diagrams: []
examples: []
canonical_id: aosp-beginner-39
---

# Binder driver (low-level)

## Overview

The Binder driver is a kernel-level device driver that implements Android's Binder IPC mechanism at the lowest level. While Binder IPC Basics covers the high-level usage, understanding the Binder driver is essential for comprehending how Binder actually works, how transactions are processed, and how the kernel facilitates inter-process communication. This guide provides a deep dive into the Binder driver implementation, its architecture, and how it processes IPC transactions.

Think of the Binder driver like the postal service's sorting facility: while the high-level Binder API (covered in Binder IPC Basics) is like the post office where you drop off mail, the Binder driver is the actual sorting facility that routes mail (transactions) to the right destination, handles the logistics (memory management, security), and ensures delivery (transaction processing). It's the engine that makes Binder IPC actually work.

## Deep Explanation

### What is the Binder Driver?

The Binder driver is a Linux kernel device driver (`/dev/binder`) that implements the low-level mechanism for Android's Binder IPC. It's written in C and runs in kernel space, providing the foundation for all Binder communication.

**Key Characteristics:**
- **Kernel Driver:** Runs in kernel space
- **Device File:** `/dev/binder` character device
- **IPC Foundation:** Enables all Binder IPC
- **Android-Specific:** Not in mainline Linux

**Why a Kernel Driver?**
- **Performance:** Kernel-space is faster
- **Security:** Kernel enforces security
- **Memory Management:** Direct memory access
- **Hardware Integration:** Can use hardware features

### Binder Driver Location

#### Source Code

**Kernel Source:**
- `drivers/android/binder.c`
- `drivers/android/binder.h`
- Android kernel tree
- Not in mainline Linux

**File Structure:**
```
kernel/drivers/android/
├── binder.c          # Main driver implementation
├── binder.h          # Driver headers
└── binder_alloc.c    # Memory allocator (newer)
```

**Compilation:**
- Compiled as kernel module or built-in
- Enabled via `CONFIG_ANDROID_BINDER_IPC`
- Required for Android
- Core Android feature

### Binder Driver Architecture

#### Device File Interface

**Device File:**
- `/dev/binder` - Character device
- Opened by processes
- Used for IPC operations
- Kernel interface

**Operations:**
- `open()` - Open binder device
- `ioctl()` - IPC operations
- `mmap()` - Memory mapping
- `close()` - Close device

**Usage:**
```c
// Open binder device
int fd = open("/dev/binder", O_RDWR);

// Perform operations via ioctl
ioctl(fd, BINDER_WRITE_READ, &bwr);

// Close when done
close(fd);
```

#### Driver Components

**Core Components:**
- **Binder Context Manager:** Special service registry
- **Binder Nodes:** Represent Binder objects
- **Binder References:** References to remote objects
- **Transaction Queue:** Pending transactions
- **Memory Management:** Shared memory handling

### Binder Driver Operations

#### Opening Binder Device

**Process:**
1. Process opens `/dev/binder`
2. Driver creates binder_proc structure
3. Allocates process context
4. Returns file descriptor

**binder_proc Structure:**
- Process information
- Binder nodes
- Binder references
- Transaction queues
- Memory mappings

#### Memory Mapping

**mmap() Operation:**
```c
mmap(NULL, BINDER_VM_SIZE, PROT_READ, MAP_PRIVATE, fd, 0);
```

**Purpose:**
- Maps shared memory
- Transaction buffer
- Efficient data transfer
- Zero-copy for small data

**Memory Layout:**
- User-space buffer
- Kernel-space buffer
- Shared mapping
- Transaction data

#### Transaction Processing

**Transaction Flow:**
1. Client prepares transaction
2. Writes to binder device (ioctl)
3. Driver processes transaction
4. Delivers to target process
5. Target processes transaction
6. Response sent back

**ioctl Operations:**
- `BINDER_WRITE_READ` - Send/receive transactions
- `BINDER_SET_CONTEXT_MGR` - Set context manager
- `BINDER_THREAD_EXIT` - Thread cleanup
- `BINDER_VERSION` - Get driver version

### Binder Driver Data Structures

#### binder_proc

**Purpose:**
Represents a process using Binder.

**Contains:**
- Process information (PID, etc.)
- List of binder nodes
- List of binder references
- Transaction queues
- Memory mappings

**Lifecycle:**
- Created on device open
- Maintained during process lifetime
- Destroyed on device close

#### binder_node

**Purpose:**
Represents a Binder object (service).

**Contains:**
- Object reference
- Process owner
- Reference counts
- Death notifications
- Object data

**Lifecycle:**
- Created when service registered
- Referenced by clients
- Destroyed when no references

#### binder_ref

**Purpose:**
Reference to a remote Binder object.

**Contains:**
- Reference to binder_node
- Reference number (handle)
- Reference counts
- Process that holds reference

**Lifecycle:**
- Created when object referenced
- Maintained during reference
- Destroyed when released

### Transaction Processing

#### Transaction Structure

**binder_transaction_data:**
```c
struct binder_transaction_data {
    union {
        size_t handle;      // Target handle
        void *ptr;          // Target object
    } target;
    void *cookie;           // Object cookie
    unsigned int code;      // Transaction code
    unsigned int flags;     // Transaction flags
    pid_t sender_pid;       // Sender PID
    uid_t sender_euid;     // Sender UID
    size_t data_size;       // Data size
    size_t offsets_size;    // Offsets size
    union {
        struct {
            const void *buffer;  // Transaction data
            const void *offsets; // Object offsets
        } ptr;
        uint8_t buf[8];
    } data;
};
```

**Components:**
- Target (handle or object)
- Transaction code
- Data buffer
- Object offsets
- Security info (PID, UID)

#### Transaction Flow

**Step 1: Client Prepares Transaction**
- Creates transaction data
- Sets target handle
- Prepares data buffer
- Includes object references

**Step 2: Write to Driver**
- Calls ioctl(BINDER_WRITE_READ)
- Driver receives transaction
- Validates transaction
- Processes transaction

**Step 3: Driver Processing**
- Looks up target node
- Validates permissions
- Copies data to target
- Queues transaction

**Step 4: Target Receives**
- Target process reads
- Driver delivers transaction
- Target processes data
- Executes transaction

**Step 5: Response**
- Target prepares response
- Writes response to driver
- Driver delivers to client
- Client receives response

### Memory Management

#### Shared Memory

**Binder Buffer:**
- Mapped via mmap()
- Shared between processes
- Transaction data storage
- Efficient transfer

**Buffer Allocation:**
- Allocated per process
- Fixed size (typically 1MB)
- Managed by driver
- Used for transactions

#### Data Copying

**Small Data:**
- Copied directly
- In transaction buffer
- Fast for small data
- Simple mechanism

**Large Data:**
- May use ashmem
- Shared memory
- Zero-copy possible
- Efficient for large data

**Object References:**
- Binder objects referenced
- Not copied
- Reference counts maintained
- Efficient object passing

### Security and Permissions

#### Permission Checking

**Process Identity:**
- Driver tracks PID/UID
- Validates permissions
- Enforces security
- Prevents unauthorized access

**Transaction Security:**
- Sender identity tracked
- Target can verify
- Permission checks
- Security enforcement

#### SELinux Integration

**SELinux Context:**
- Driver checks SELinux
- Enforces policies
- Process isolation
- Security boundaries

**Binder Security:**
- SELinux for Binder
- Context checking
- Policy enforcement
- Enhanced security

### Binder Driver Features

#### Object References

**Reference Counting:**
- Objects reference counted
- Automatic cleanup
- Prevents leaks
- Memory management

**Remote References:**
- References to remote objects
- Handles (reference numbers)
- Cross-process references
- Efficient object passing

#### Death Notifications

**Purpose:**
Notify when object dies.

**Mechanism:**
- Register death notification
- Driver monitors object
- Notifies on death
- Cleanup references

**Use Cases:**
- Service death detection
- Cleanup on death
- Error handling
- Resource management

### Binder Driver API

#### ioctl Commands

**BINDER_WRITE_READ:**
- Main transaction command
- Send and receive
- Bidirectional
- Core operation

**BINDER_SET_CONTEXT_MGR:**
- Set context manager
- ServiceManager uses this
- Special service
- Service registry

**BINDER_THREAD_EXIT:**
- Thread cleanup
- Release resources
- Cleanup on exit
- Resource management

#### Memory Operations

**mmap():**
- Map binder buffer
- Shared memory
- Transaction buffer
- Efficient operations

**munmap():**
- Unmap buffer
- Release memory
- Cleanup
- Resource release

### Binder Driver Implementation Details

#### Transaction Queues

**Per-Process Queues:**
- Each process has queues
- Pending transactions
- Thread queues
- Delivery mechanism

**Thread Selection:**
- Driver selects thread
- Load balancing
- Thread pool management
- Efficient delivery

#### Synchronous vs Asynchronous

**Synchronous:**
- Wait for response
- Blocking operation
- Request-reply
- Most common

**Asynchronous:**
- Fire and forget
- Non-blocking
- One-way
- Less common

### Debugging Binder Driver

#### Kernel Logs

**dmesg:**
```bash
adb shell dmesg | grep binder
```

**Log Information:**
- Transaction logs
- Error messages
- Debug information
- Driver state

#### Binder Statistics

**Proc Filesystem:**
```bash
adb shell cat /proc/binder/stats
adb shell cat /proc/binder/state
adb shell cat /proc/binder/transactions
```

**Information:**
- Transaction counts
- Object counts
- Memory usage
- Driver statistics

### Binder Driver Evolution

#### Historical Development

**Early Android:**
- Basic implementation
- Simple transactions
- Limited features
- Performance issues

**Modern Android:**
- Optimized implementation
- Better memory management
- Enhanced features
- Improved performance

#### Current Implementation

**Features:**
- Efficient memory management
- Better security
- Performance optimizations
- Enhanced debugging

**Improvements:**
- Binder allocator
- Better reference counting
- Optimized transactions
- Enhanced security

## Key Takeaways

1. **Binder driver is a kernel device driver** (`/dev/binder`) that implements the low-level Binder IPC mechanism.

2. **Binder driver runs in kernel space** and provides the foundation for all Binder communication between processes.

3. **Binder driver uses ioctl operations** for IPC transactions, with `BINDER_WRITE_READ` being the main transaction command.

4. **Memory mapping (mmap)** is used to create shared memory buffers for efficient transaction data transfer.

5. **Binder driver manages objects** through binder_node (objects), binder_ref (references), and binder_proc (processes).

6. **Transaction processing** involves driver routing transactions from sender to target process with security and permission checks.

7. **Binder driver provides security** through PID/UID tracking, permission checking, and SELinux integration.

8. **Understanding the Binder driver** is essential for understanding how Binder IPC works at the lowest level and debugging Binder issues.

## Related Topics

- **Binder IPC Basics:** High-level Binder IPC usage and APIs
- **Differences between Android kernel & Linux kernel:** How Binder driver is an Android-specific kernel feature
- **ServiceManager Startup:** How ServiceManager uses the Binder driver
- **Android Architecture - Complete Overview:** How Binder driver fits into Android architecture

