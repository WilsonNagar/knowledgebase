---
number: 8
title: Android Partitions
slug: android-partitions
level: beginner
tags:
  - aosp
  - partitions
  - storage
  - boot
  - system
  - vendor
  - data
  - filesystem
prerequisites:
  - android-architecture-complete-overview
  - boot-process-overview
estimated_minutes: 90
contributors: []
diagrams: []
examples: []
canonical_id: aosp-beginner-08
---

# Android Partitions

## Overview

Android devices use a partitioned storage model where different parts of the system are stored in separate partitions on the device's storage. Each partition has a specific purpose, mount point, and access permissions. Understanding Android partitions is essential for AOSP development, as it affects how the system boots, how updates are applied, and how different components are organized and protected.

Think of Android partitions like separate rooms in a building - each room has a specific purpose, different access rules, and different contents. The boot partition is like the building's entrance and security system, the system partition is like the main building with standard features, the vendor partition is like specialized equipment rooms, and the data partition is like personal storage lockers that can be cleared without affecting the building structure.

## Deep Explanation

### What are Partitions?

A partition is a logical division of a storage device (like eMMC or UFS) that acts as a separate storage area. Each partition can have its own file system, mount point, and access permissions.

**Physical Storage:**
- Device has physical storage (eMMC, UFS, NVMe)
- Storage is divided into logical partitions
- Each partition is like a separate disk
- Partitions are defined in a partition table

**Partition Table:**
- Defines partition layout on the device
- Stored in partition table (GPT - GUID Partition Table or MBR - Master Boot Record)
- Maps partition names to storage locations
- Contains partition metadata (size, type, flags)
- Located at the beginning of the storage device

**File Systems:**
- Each partition has a file system
- Common file systems: ext4, f2fs, erofs
- Determines how data is organized and accessed
- File system choice affects performance and features

**Why Partitions?**

**1. Separation of Concerns:**
- System files separate from user data
- Read-only system vs. writable data
- Different update mechanisms
- Independent management of components

**2. Security:**
- System partition can be read-only
- Prevents accidental modification
- Different security contexts (SELinux)
- Enables verified boot and integrity checking

**3. Update Management:**
- Update system without touching data
- A/B partitions for seamless updates
- Rollback capabilities
- Independent vendor/system updates (Treble)

**4. Performance:**
- Optimize each partition for its purpose
- System: read-optimized (erofs, read-only ext4)
- Data: read-write optimized (f2fs, ext4)
- Cache: optimized for temporary storage

**5. Recovery:**
- Can wipe data without affecting system
- Factory reset clears data partition
- System remains intact
- Recovery partition for system repair

### Partition Layout Overview

Android devices typically have these partitions:

```
┌─────────────────────────────────────────┐
│         Storage Device                  │
│  (eMMC/UFS, typically 64GB-512GB)     │
├─────────────────────────────────────────┤
│  boot          - Bootloader & kernel   │
│  dtbo          - Device tree overlay   │
│  system        - Android system        │
│  vendor        - Vendor components    │
│  product       - Product features     │
│  system_ext    - System extensions    │
│  odm           - ODM customizations  │
│  data          - User data            │
│  cache         - Cache data           │
│  userdata      - User data (alt)      │
│  metadata      - Metadata             │
│  misc          - Miscellaneous        │
│  recovery      - Recovery partition   │
└─────────────────────────────────────────┘
```

### Core Partitions

#### Boot Partition

**Purpose:**
Contains the bootloader, kernel, and initial ramdisk needed to boot the device.

**Contents:**
- **Bootloader:** Initial code that runs when device powers on
- **Kernel:** Linux kernel image
- **Device Tree:** Hardware configuration
- **Initramfs:** Initial root filesystem
- **Ramdisk:** Early boot files

**Mount Point:**
- Not mounted in normal operation
- Accessed during boot process
- Read-only after boot

**Characteristics:**
- Small size (typically 64-128 MB)
- Critical for booting
- Must be signed for verified boot
- Updated via OTA or fastboot

**Location:**
```
/dev/block/bootdevice/by-name/boot
# or
/dev/block/mmcblk0pX (where X is partition number)
```

**File System:**
- Not a traditional file system
- Raw binary format
- Contains boot.img structure

**Boot Image Structure:**
```
boot.img:
├── Boot Header
├── Kernel (compressed)
├── Ramdisk (cpio archive)
├── Second Stage (optional)
└── Device Tree (dtb)
```

**Boot Image Format:**
- Android-specific format
- Created by `mkbootimg` tool
- Contains kernel, ramdisk, and metadata
- Can be unpacked with `unpackbootimg` or `unpack_bootimg`

**Access:**
```bash
# View boot partition info
$ lsblk | grep boot

# Extract boot image (requires root)
$ dd if=/dev/block/bootdevice/by-name/boot of=/sdcard/boot.img

# Unpack boot image (on host)
$ unpack_bootimg --boot_img boot.img --out boot_unpacked/
```

**Security:**
- Verified Boot checks boot partition
- Must be signed with device keys
- Prevents tampering
- Critical for device security

#### System Partition

**Purpose:**
Contains the core Android system - framework, system apps, libraries, and core services.

**Contents:**
- Android framework (frameworks/base)
- System apps (Settings, SystemUI, etc.)
- Core libraries (libc, libm, etc.)
- Native binaries (/system/bin, /system/xbin)
- System configuration files
- Build properties

**Mount Point:**
```
/system
```

**Characteristics:**
- Read-only in normal operation
- Large size (typically 2-4 GB, varies by Android version)
- Contains core Android functionality
- Updated via OTA

**File System:**
- **ext4:** Traditional, widely used, read-only
- **f2fs:** Flash-Friendly File System, optimized for flash storage
- **erofs:** Enhanced Read-Only File System, Android 9+, optimized for read-only partitions

**Structure:**
```
/system/
├── app/              - System apps (APKs)
├── priv-app/         - Privileged system apps
├── framework/        - Framework JARs
├── lib/              - Native libraries (32-bit)
├── lib64/            - Native libraries (64-bit)
├── bin/              - Native binaries
├── xbin/             - Additional binaries
├── etc/              - Configuration files
├── fonts/            - System fonts
├── media/            - System media files
├── usr/              - User data (keyboard layouts, etc.)
└── build.prop        - Build properties
```

**Access:**
```bash
# View system partition
$ ls -la /system/

# Check mount options
$ mount | grep system
/dev/block/... on /system type ext4 (ro,seclabel,relatime)

# Remount as read-write (requires root)
$ mount -o remount,rw /system
```

**Mount Options:**
- Mounted as read-only
- Can be remounted read-write (requires root)
- Protected by SELinux
- Verified by dm-verity

**Update Mechanism:**
- OTA updates modify system partition
- A/B partitions allow seamless updates
- System partition is verified on boot

**Security:**
- Read-only prevents modification
- SELinux policies protect system files
- Verified Boot verifies system partition
- dm-verity verifies file system integrity

#### Vendor Partition

**Purpose:**
Contains vendor-specific components - HAL implementations, vendor libraries, and hardware-specific code.

**Contents:**
- Hardware Abstraction Layer (HAL) implementations
- Vendor libraries (proprietary)
- Vendor binaries
- Vendor configuration files
- Hardware-specific drivers (if not in kernel)
- Vendor build properties

**Mount Point:**
```
/vendor
```

**Characteristics:**
- Read-only
- Vendor-specific (OEM/SoC manufacturer)
- Separated from system (Treble requirement)
- Can be updated independently
- Size: 500 MB - 2 GB (varies by device)

**File System:**
- ext4 (traditional)
- erofs (Android 9+, optimized for read-only)
- Read-only

**Structure:**
```
/vendor/
├── bin/              - Vendor binaries
├── lib/              - Vendor libraries (32-bit)
├── lib64/            - Vendor libraries (64-bit)
├── etc/              - Vendor configuration
├── firmware/         - Firmware files
├── hw/               - HAL modules (legacy)
├── manifest.xml      - VINTF manifest
└── build.prop        - Vendor properties
```

**Why Separate Vendor Partition?**

**Treble Architecture:**
- Android 8.0+ requires vendor/system separation
- Allows framework updates without vendor changes
- Vendor can update independently
- Better security isolation

**Benefits:**
- Faster Android updates
- Vendor can update HALs independently
- Framework doesn't depend on vendor
- Better testing (GSI - Generic System Image)

**Access:**
```bash
# View vendor partition
$ ls -la /vendor/

# Check vendor properties
$ getprop | grep vendor

# List vendor HALs
$ ls /vendor/lib64/hw/
```

**VINTF (Vendor Interface):**
- Vendor Interface Object (VIO)
- Defines vendor capabilities
- Framework queries VINTF for hardware info
- Manifest in `/vendor/manifest.xml`

#### Data Partition

**Purpose:**
Contains user data, app data, and runtime information.

**Contents:**
- User-installed apps
- App private data (/data/data/)
- App APKs (/data/app/)
- User files (/data/media/)
- System runtime data
- Databases
- Shared preferences
- Cache files

**Mount Point:**
```
/data
```

**Characteristics:**
- Read-write
- Largest partition (typically 20-100+ GB, remaining storage)
- User-specific data
- Cleared on factory reset
- Encrypted (File-Based Encryption - FBE)

**File System:**
- **ext4:** Traditional, reliable, widely used
- **f2fs:** Flash-Friendly File System, optimized for flash storage, better performance for read-write operations

**Structure:**
```
/data/
├── app/              - Installed app APKs
├── data/             - App private data
│   └── com.example.app/
│       ├── files/    - App files
│       ├── databases/ - SQLite databases
│       ├── shared_prefs/ - SharedPreferences
│       └── cache/    - App cache
├── media/            - User media (photos, videos)
│   └── 0/           - Primary user
├── system/           - System runtime data
│   ├── users/       - Multi-user data
│   ├── packages.xml - Installed packages
│   └── ...
├── misc/             - Miscellaneous data
├── local/            - Local temporary files
└── property/         - Persistent properties
```

**Access:**
```bash
# View data partition (requires root)
$ ls -la /data/

# Check mount options
$ mount | grep data
/dev/block/... on /data type ext4 (rw,seclabel,nosuid,nodev,noatime)

# Check encryption status
$ getprop ro.crypto.state
encrypted
```

**Mount Options:**
- Mounted as read-write
- Encrypted (File-Based Encryption, FBE)
- Protected by SELinux
- Isolated per app (UID-based)

**Encryption:**
- **Full Disk Encryption (FDE):** Android 5.0-6.0, entire partition encrypted
- **File-Based Encryption (FBE):** Android 7.0+, each file encrypted with different key
- **Metadata Encryption:** Android 9+, encrypts file metadata
- User credentials unlock encryption

**Security:**
- Each app has isolated directory
- SELinux contexts protect app data
- Encryption protects data at rest
- Factory reset clears all data

**Factory Reset:**
- Wipes /data partition
- Keeps system intact
- Removes all user data
- Apps must be reinstalled

#### Product Partition

**Purpose:**
Contains product-specific features and customizations.

**Contents:**
- Product-specific apps
- Product configuration
- Product resources
- Product-specific HALs (if needed)

**Mount Point:**
```
/product
```

**Characteristics:**
- Read-only
- Product line specific
- Can vary by device model
- Updated via OTA

**Use Cases:**
- Different features for different product lines
- Carrier-specific customizations
- Regional variations
- Product branding

**Structure:**
```
/product/
├── app/              - Product apps
├── etc/              - Product configuration
├── overlay/          - Resource overlays
└── build.prop        - Product properties
```

#### System Extension Partition (system_ext)

**Purpose:**
Contains system extensions that are separate from core system.

**Mount Point:**
```
/system_ext
```

**Characteristics:**
- Read-only
- System-level extensions
- Can be updated independently
- Used for modular system components

**Use Cases:**
- System extensions
- Additional system services
- Extended framework features
- Modular system components

#### ODM Partition

**Purpose:**
Contains ODM (Original Design Manufacturer) customizations.

**Mount Point:**
```
/odm
```

**Characteristics:**
- Read-only
- ODM-specific
- Device-specific customizations
- Can vary by manufacturer

**Use Cases:**
- Device-specific features
- Manufacturer customizations
- Hardware-specific configurations
- OEM-specific implementations

### Additional Partitions

#### DTBO Partition (Device Tree Overlay)

**Purpose:**
Contains Device Tree Overlays for hardware configuration.

**Contents:**
- Device Tree Blob Overlays (DTBO)
- Hardware configuration overlays
- Device-specific kernel configurations
- Hardware variant configurations

**Characteristics:**
- Read-only
- Small size (typically 8-16 MB)
- Updated via OTA or fastboot
- Used for hardware variants

**Why DTBO?**
- Allows different hardware configurations
- Supports multiple device variants
- Can update hardware config without kernel change
- Enables device tree modularity

**Access:**
```bash
# View DTBO partition
$ ls -la /dev/block/bootdevice/by-name/dtbo

# Extract DTBO (requires root)
$ dd if=/dev/block/bootdevice/by-name/dtbo of=/sdcard/dtbo.img
```

#### Recovery Partition

**Purpose:**
Contains recovery system for device maintenance and updates.

**Contents:**
- Recovery kernel
- Recovery ramdisk
- Recovery binaries
- Update scripts

**Access:**
- Booted into recovery mode
- Used for OTA updates
- Factory reset
- System maintenance

**Recovery Mode:**
- Boots into recovery instead of Android
- Limited functionality
- Can install updates
- Can wipe data partition

**Boot into Recovery:**
```bash
# From fastboot
$ fastboot boot recovery.img

# From device (with root)
$ reboot recovery

# From ADB
$ adb reboot recovery
```

**Recovery Operations:**
- Apply update from ADB
- Wipe data/factory reset
- Reboot system
- Mount /system (if supported)
- ADB sideload

#### Cache Partition

**Purpose:**
Temporary storage for OTA updates and cache data.

**Characteristics:**
- Can be cleared
- Used for OTA downloads
- Temporary storage
- Can be wiped without issues
- Read-write

**Location:**
```
/cache
```

**Use Cases:**
- OTA update downloads
- Temporary system files
- Recovery logs
- Cache data

#### Metadata Partition

**Purpose:**
Stores metadata about encryption and other system state.

**Characteristics:**
- Small size (typically 16-32 MB)
- Critical for encryption
- System-managed
- Not directly accessible
- Contains encryption keys metadata

**Contents:**
- Encryption metadata
- System state information
- Boot state flags
- Recovery state

#### Misc Partition

**Purpose:**
Stores miscellaneous boot-time information.

**Contents:**
- Bootloader communication
- Recovery commands
- Boot state information
- System flags

**Use Cases:**
- Bootloader-to-Android communication
- Recovery command passing
- Boot state tracking
- System flags storage

### Partition Block Devices

**Block Device Names:**
- Partitions accessed via block devices
- Path: `/dev/block/`
- Named by partition or by-name symlinks

**By-Name Symlinks:**
```bash
# View partition by-name symlinks
$ ls -l /dev/block/by-name/

# Output:
# boot -> /dev/block/sda1
# system -> /dev/block/sda2
# vendor -> /dev/block/sda3
# data -> /dev/block/sda4
```

**Using by-name:**
```bash
# Access partition by name
$ ls -l /dev/block/by-name/boot
# Output: /dev/block/by-name/boot -> /dev/block/sda1

# Access partition directly
$ ls -l /dev/block/mmcblk0p1  # First partition
```

**Partition Numbering:**
- Partitions numbered sequentially (p1, p2, p3, etc.)
- By-name symlinks provide human-readable names
- Block devices provide direct access

### Partition Mounting

#### Mount Process

**During Boot:**
```
1. Kernel loads
   ↓
2. Init starts
   ↓
3. Mount root filesystem
   ↓
4. Mount /system (read-only)
   ↓
5. Mount /vendor (read-only)
   ↓
6. Mount /product (read-only)
   ↓
7. Mount /odm (read-only)
   ↓
8. Mount /data (read-write, after encryption unlock)
   ↓
9. Mount /cache
   ↓
10. System ready
```

**Mount Order:**
- Root filesystem first
- Read-only partitions early
- Read-write partitions after encryption
- User partitions last

#### Mount Points

**Standard Mount Points:**
```bash
$ mount
/dev/block/... on / type ext4 (ro,seclabel,relatime)
/dev/block/... on /system type ext4 (ro,seclabel,relatime)
/dev/block/... on /vendor type ext4 (ro,seclabel,relatime)
/dev/block/... on /product type ext4 (ro,seclabel,relatime)
/dev/block/... on /odm type ext4 (ro,seclabel,relatime)
/dev/block/... on /data type ext4 (rw,seclabel,nosuid,nodev,noatime)
/dev/block/... on /cache type ext4 (rw,seclabel,nosuid,nodev,noatime)
```

**Checking Mounts:**
```bash
# List all mounts
$ mount

# Check specific partition
$ mount | grep system

# Check mount options
$ mount -o remount,ro /system  # Remount as read-only
$ mount -o remount,rw /system  # Remount as read-write (requires root)
```

### A/B Partitions (Seamless Updates)

**Purpose:**
Allow system updates without rebooting into recovery.

**How It Works:**
- Two sets of partitions (A and B)
- Device boots from one set
- Update installs to other set
- Next boot uses updated set
- Allows rollback if update fails

**Partition Layout:**
```
system_a    - System partition slot A
system_b    - System partition slot B
vendor_a    - Vendor partition slot A
vendor_b    - Vendor partition slot B
boot_a      - Boot partition slot A
boot_b      - Boot partition slot B
```

**Update Process:**
```
1. Device running on slot A
   ↓
2. OTA downloads update
   ↓
3. Update installs to slot B
   ↓
4. Device reboots
   ↓
5. Bootloader boots from slot B
   ↓
6. Updated system runs
```

**Benefits:**
- No downtime during update
- Can rollback if update fails
- Faster updates
- Better user experience

**Checking Current Slot:**
```bash
$ getprop ro.boot.slot_suffix
_a  # or _b

# Check if device supports A/B
$ getprop ro.build.ab_update
true
```

**Viewing A/B Partitions:**
```bash
# View both slot partitions
$ ls /dev/block/by-name/ | grep -E "(boot|system|vendor)_[ab]"

# Check current active slot
$ getprop ro.boot.slot_suffix
```

### Dynamic Partitions

**Purpose:**
Allow flexible partition sizing for modern Android devices.

**How It Works:**
- Partitions are logical, not physical
- Can resize partitions as needed
- Better space utilization
- Supports A/B updates

**Partition Groups:**
```
system_a    - Logical partition in system_a group
system_b    - Logical partition in system_b group
vendor_a    - Logical partition in vendor_a group
vendor_b    - Logical partition in vendor_b group
```

**Benefits:**
- Flexible sizing
- Better space management
- Easier to add new partitions
- Supports modern update mechanisms
- No wasted space

**Traditional vs Dynamic:**
- **Traditional:** Fixed sizes defined at build time, cannot be resized
- **Dynamic:** Flexible sizing, partitions can grow/shrink, managed by Logical Volume Manager (LVM)

**Real-World Example:**
```bash
# View dynamic partitions
$ lsmem

# View super partition (contains dynamic partitions)
$ lsblk | grep super
```

### Partition Security

#### Verified Boot

**Purpose:**
- Verify partition integrity
- Prevent tampering
- Ensure system authenticity
- Chain of trust from bootloader to system

**How It Works:**
- Partitions signed with cryptographic keys
- Bootloader verifies signatures
- System verifies partitions at runtime
- dm-verity for runtime verification

**Boot Chain:**
```
Boot ROM → Bootloader → Boot Partition → System Partition
   (verified)    (verified)      (verified)        (verified)
```

#### dm-verity

**Purpose:**
- Runtime partition verification
- Detects tampering
- Prevents execution of modified code
- Transparent to applications

**How It Works:**
- Hash tree stored in partition
- Hashes verified at runtime
- Blocks access if verification fails
- Transparent to applications
- Protects read-only partitions

**Benefits:**
- Detects any modification
- Prevents rootkits
- Ensures system integrity
- No performance impact for reads

### Partition Updates

#### OTA Updates

**How OTA Works:**
1. Download update package to `/data/ota_package/`
2. Verify package signature
3. Apply update to inactive partition set (B if on A)
4. Reboot to new partition set
5. Verify new partition set
6. Commit update or rollback

**Update Package:**
- Contains partition images
- Signed with release keys
- Incremental or full updates
- Applied in recovery or A/B mode

**Partitions Updated:**
- `system_b` - New system image
- `vendor_b` - New vendor image (if included)
- `boot_b` - New boot image
- `dtbo_b` - New device tree (if changed)

**OTA Update Process:**
```
1. OTA downloads to /data/ota_package/
2. Recovery verifies package signature
3. Update script extracts files
4. Files written to inactive slot (B if on A)
5. Bootloader updated to boot from new slot
6. Device reboots into updated system
```

#### Fastboot Updates

**Using Fastboot:**
```bash
# Flash boot partition
$ fastboot flash boot boot.img

# Flash system partition
$ fastboot flash system system.img

# Flash vendor partition
$ fastboot flash vendor vendor.img

# Flash DTBO partition
$ fastboot flash dtbo dtbo.img

# Flash all partitions
$ fastboot flashall

# Flash to specific slot (A/B)
$ fastboot flash boot_a boot.img
$ fastboot flash boot_b boot.img
```

**Requirements:**
- Bootloader unlocked
- Fastboot mode
- Appropriate images
- Device-specific tools

**Fastboot Mode:**
```bash
# Boot into fastboot
$ adb reboot bootloader

# Or from device
$ reboot bootloader

# Check fastboot connection
$ fastboot devices
```

### Partition Management

#### Viewing Partitions

**List All Partitions:**
```bash
# Using lsblk
$ lsblk

# Using block devices
$ ls -la /dev/block/bootdevice/by-name/

# Using fdisk (requires root on host)
$ adb shell
# su
# fdisk -l /dev/block/mmcblk0
```

**Partition Information:**
```bash
# Get partition size
$ blockdev --getsize64 /dev/block/bootdevice/by-name/system

# Get partition info
$ tune2fs -l /dev/block/bootdevice/by-name/system

# View partition usage
$ df -h
```

**Using mount:**
```bash
# View mounted partitions
$ mount

# Check specific partition
$ mount | grep system
```

**Using df:**
```bash
# View partition usage
$ df -h

# Output:
# Filesystem      Size  Used Avail Use% Mounted on
# /dev/block/...  4.0G  3.2G  800M  80% /system
# /dev/block/...  2.0G  1.5G  500M  75% /vendor
# /dev/block/...   58G   20G   38G  35% /data
```

#### Partition Operations

**Backup Partition:**
```bash
# Backup system partition (requires root)
$ dd if=/dev/block/bootdevice/by-name/system of=/sdcard/system.img bs=4096

# Backup boot partition
$ dd if=/dev/block/bootdevice/by-name/boot of=/sdcard/boot.img bs=4096
```

**Restore Partition:**
```bash
# Restore system partition (requires root, DANGEROUS!)
$ dd if=/sdcard/system.img of=/dev/block/bootdevice/by-name/system bs=4096
```

**Format Partition:**
```bash
# Format data partition (DANGEROUS - wipes all data!)
$ make_ext4fs /dev/block/bootdevice/by-name/userdata
```

**⚠️ Warning:**
- Partition operations can brick device
- Always backup before modifying
- Understand what you're doing
- Test on non-critical devices first
- Some operations are irreversible

### Real-World Examples

#### Example 1: Checking Partition Layout

```bash
# List all partitions
$ lsblk

# View partition sizes
$ df -h

# Check partition file systems
$ mount | grep -E "(system|vendor|data)"

# Output:
# Filesystem      Size  Used Avail Use% Mounted on
# /dev/root        2.0G  1.8G  150M  93% /
# /system          3.5G  3.2G  300M  92% /system
# /vendor          500M  450M   50M  90% /vendor
# /data           50.0G  25.0G  25.0G  50% /data
# /cache           500M   50M  450M  10% /cache
```

#### Example 2: Understanding OTA Update

**OTA Update Process:**
1. OTA downloads to `/data/ota_package/`
2. Recovery verifies package signature
3. Update script extracts files
4. Files written to inactive slot (B if on A)
5. Bootloader updated to boot from new slot
6. Device reboots into updated system

**Partitions Updated:**
- `system_b` - New system image
- `vendor_b` - New vendor image (if included)
- `boot_b` - New boot image
- `dtbo_b` - New device tree (if changed)

#### Example 3: Factory Reset

**What Happens:**
1. Recovery boots
2. `/data` partition is wiped
3. `/cache` partition is wiped
4. `/data/media/` (user files) are wiped
5. System partitions remain intact
6. Device reboots to setup screen

**Partitions Affected:**
- ✅ `/data` - Wiped
- ✅ `/cache` - Wiped
- ❌ `/system` - Not affected
- ❌ `/vendor` - Not affected
- ❌ `/product` - Not affected

#### Example 4: Accessing Partition Contents

```bash
# View system partition
$ ls /system/app/

# View vendor HALs
$ ls /vendor/lib64/hw/

# Check partition usage
$ du -sh /system /vendor /data

# List installed apps
$ pm list packages
```

### Best Practices

#### For System Developers

**1. Partition Organization:**
- Keep system and vendor separate
- Use appropriate partitions for content
- Follow partition purposes
- Respect partition boundaries

**2. Read-Only Partitions:**
- Keep system partitions read-only
- Don't modify at runtime
- Use overlays for customization
- Understand mount options

**3. Update Considerations:**
- Design for A/B updates
- Consider partition sizes
- Test update mechanisms
- Plan for rollback scenarios

**4. Security:**
- Verify partition integrity
- Use verified boot
- Protect partition access
- Implement proper SELinux policies

#### For Application Developers

**1. Storage Locations:**
- Use `/data/data/` for app data
- Use `/data/media/` for user files
- Don't write to system partitions
- Use proper storage APIs

**2. Permissions:**
- Apps can't modify system partitions
- Use proper storage APIs
- Respect partition boundaries
- Understand app sandbox

**3. Data Management:**
- Clean up cache files
- Don't fill `/data` partition
- Use appropriate storage locations
- Manage storage efficiently

### Common Issues and Debugging

#### Issue 1: Partition Full

**Symptom:**
Device runs out of space.

**Diagnosis:**
```bash
$ df -h
# Check which partition is full
```

**Solutions:**
- Clear app cache
- Remove unused apps
- Move files to external storage
- Factory reset (last resort)

#### Issue 2: Read-Only File System

**Symptom:**
Cannot write to `/system` or `/vendor`.

**Cause:**
- Partitions are read-only by design
- This is normal and expected

**Solution:**
- Don't write to read-only partitions
- Use `/data` for writable data
- Use overlays for system customization

#### Issue 3: Partition Corruption

**Symptom:**
Device won't boot or has errors.

**Diagnosis:**
- Check dmesg for I/O errors
- Verify partition integrity
- Check file system
- Look for mount errors

**Solution:**
- Boot into recovery
- Wipe cache partition
- Factory reset if needed
- Reflash if necessary

#### Issue 4: Update Failures

**Symptom:**
OTA update fails or device won't boot after update.

**Diagnosis:**
- Check recovery logs
- Verify update package
- Check partition space
- Verify A/B slot status

**Solution:**
- A/B partitions provide rollback
- Boot into recovery mode
- Try recovery update
- Factory reset if needed

### Edge Cases and Pitfalls

#### Common Mistakes

**1. Writing to Read-Only Partitions:**
```bash
# BAD: Trying to write to system
$ echo "test" > /system/test.txt  # Fails!

# GOOD: Use data partition
$ echo "test" > /data/test.txt  # Works
```

**2. Assuming Partition Sizes:**
- Partition sizes vary by device
- Don't assume specific sizes
- Check available space before writing
- Use dynamic partitions when possible

**3. Modifying Critical Partitions:**
- Don't modify boot partition without understanding
- Don't modify system without proper tools
- Always backup before modifying
- Understand verified boot implications

**4. Ignoring A/B Partitions:**
- Check current slot before operations
- Understand which slot is active
- Don't assume single partition layout
- Test on both slots if possible

## References and Further Reading

- [AOSP Partition Documentation](https://source.android.com/docs/core/ota/partitions)
- [Android Partition Layout](https://source.android.com/docs/core/bootloader/partitions)
- [Dynamic Partitions](https://source.android.com/docs/core/ota/dynamic_partitions)
- [A/B Partitions](https://source.android.com/docs/core/ota/ab_partitions)
- [Android Verified Boot](https://source.android.com/docs/security/features/verifiedboot)
- [dm-verity](https://source.android.com/docs/security/features/verifiedboot/dm-verity)

## Quiz

### Question 1
What is the primary purpose of separating the system and vendor partitions in Android?

**A)** To reduce storage usage  
**B)** To allow independent updates of framework and vendor components (Treble)  
**C)** To improve boot time  
**D)** To simplify the file system

**Answer: B** - The separation of system and vendor partitions is a key requirement of Project Treble, allowing the Android framework to be updated independently of vendor-specific components like HALs, enabling faster Android updates and better modularity.

### Question 2
Which partition contains user-installed apps and their data?

**A)** `/system`  
**B)** `/vendor`  
**C)** `/data`  
**D)** `/cache`

**Answer: C** - The `/data` partition contains user-installed apps (in `/data/app/`), app private data (in `/data/data/`), and user files. This partition is read-write and is cleared during a factory reset.

### Question 3
What is the purpose of A/B partitions in Android?

**A)** To double the storage capacity  
**B)** To allow seamless system updates without rebooting into recovery  
**C)** To improve security  
**D)** To reduce boot time

**Answer: B** - A/B partitions allow the system to install updates to an inactive partition slot while the device continues running on the active slot. After reboot, the device boots from the updated slot, enabling seamless updates without requiring recovery mode.

### Question 4
Which partition is typically read-only and contains the core Android framework?

**A)** `/data`  
**B)** `/system`  
**C)** `/cache`  
**D)** `/misc`

**Answer: B** - The `/system` partition is read-only and contains the core Android framework, system apps, and essential system components. It's mounted read-only to prevent modification and ensure system integrity.

### Question 5
What happens to the `/data` partition during a factory reset?

**A)** It is reformatted  
**B)** It is wiped (all contents deleted)  
**C)** It is backed up  
**D)** Nothing, it remains unchanged

**Answer: B** - During a factory reset, the `/data` partition is wiped, removing all user-installed apps, app data, and user files. The system partitions (`/system`, `/vendor`, etc.) remain intact, allowing the device to return to its original state while keeping the Android version.

### Question 6
What technology provides runtime verification of partition integrity to detect tampering?

**A)** SELinux  
**B)** dm-verity  
**C)** File-Based Encryption  
**D)** Verified Boot

**Answer: B** - dm-verity (device-mapper verity) provides runtime verification of partition integrity by checking hash trees, detecting any tampering with partition contents and blocking access if verification fails.

## Related Topics

- [Android Architecture - Complete Overview](./01.%20Android%20Architecture%20-%20Complete%20Overview.md)
- [Boot Process Overview](./03.%20Boot%20Process%20Overview.md)
- [Init System in Android](./04.%20Init%20System%20in%20Android.md)
