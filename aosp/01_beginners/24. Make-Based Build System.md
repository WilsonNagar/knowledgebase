---
number: 24
title: Make-Based Build System
slug: make-based-build-system
level: beginner
tags:
  - aosp
  - build-system
  - make
  - android.mk
  - legacy
  - compilation
prerequisites:
  - build-system-structure
estimated_minutes: 85
contributors: []
diagrams: []
examples: []
canonical_id: aosp-beginner-24
---

# Make-Based Build System

## Overview

The Make-based build system is Android's original build framework, using GNU Make and Android.mk files to describe how modules are built. While Android is transitioning to Soong, the Make-based system is still widely used for legacy code and provides the foundation for understanding Android's build process. Understanding the Make-based build system is essential for working with existing AOSP code, maintaining legacy modules, and comprehending how Android builds evolved.

Think of the Make-based build system like a traditional recipe book: each Android.mk file is a recipe that describes ingredients (source files), steps (compilation commands), and the final dish (output file). The Make system reads these recipes, figures out what depends on what, and executes the steps in the right order to produce the final Android system.

## Deep Explanation

### What is the Make-Based Build System?

The Make-based build system uses GNU Make, a build automation tool, along with Android-specific Makefiles (Android.mk) to build Android modules. It was Android's primary build system from the beginning until Android 7.0, when Soong was introduced.

**Key Characteristics:**
- **Make-Based:** Uses GNU Make as the build executor
- **Android.mk Files:** Module build descriptions
- **Legacy System:** Being replaced by Soong
- **Still Supported:** Works alongside Soong
- **Widely Used:** Many modules still use it

**Why It Exists:**
- Original Android build system
- Proven and stable
- Extensive module support
- Well-understood by developers

**Current Status:**
- Still functional and supported
- Being gradually replaced by Soong
- New code should use Soong
- Legacy code continues using Make

### Make Fundamentals

#### What is Make?

Make is a build automation tool that:
- Reads Makefiles describing build rules
- Determines what needs to be built
- Executes commands to build targets
- Handles dependencies automatically

**Make Concepts:**
- **Target:** What to build (output file)
- **Prerequisite:** What target depends on (input files)
- **Recipe:** Commands to build target
- **Rule:** Target + Prerequisites + Recipe

**Example Makefile:**
```makefile
myapp: main.o utils.o
    gcc -o myapp main.o utils.o

main.o: main.c
    gcc -c main.c

utils.o: utils.c
    gcc -c utils.c
```

**How Make Works:**
1. Reads Makefile
2. Determines targets and dependencies
3. Builds dependency graph
4. Executes recipes in order
5. Produces output files

#### Make in Android Context

**Android's Use of Make:**
- Android extends Make with custom functions
- Android.mk files use Android-specific syntax
- Build system provides Android build functions
- Integrates with Android toolchain

**Android Make Extensions:**
- Module definitions
- Build templates
- Android-specific variables
- Integration with Android tools

### Android.mk Files

#### Structure of Android.mk

An Android.mk file describes how to build an Android module:

**Basic Structure:**
```makefile
LOCAL_PATH := $(call my-dir)

include $(CLEAR_VARS)

LOCAL_MODULE := mymodule
LOCAL_SRC_FILES := file1.c file2.c
LOCAL_C_INCLUDES := $(LOCAL_PATH)/include

include $(BUILD_SHARED_LIBRARY)
```

**Key Components:**
- **LOCAL_PATH:** Module's directory
- **LOCAL_MODULE:** Module name
- **LOCAL_SRC_FILES:** Source files
- **BUILD_*:** Build type template

#### Common Variables

**Module Identification:**
- `LOCAL_MODULE` - Module name (output file name)
- `LOCAL_MODULE_CLASS` - Module class (APPS, SHARED_LIBRARIES, etc.)
- `LOCAL_MODULE_TAGS` - Module tags (optional, eng, tests, etc.)

**Source Files:**
- `LOCAL_SRC_FILES` - Source files to compile
- `LOCAL_SRC_FILES_<arch>` - Architecture-specific sources
- `LOCAL_GENERATED_SOURCES` - Generated source files

**Include Paths:**
- `LOCAL_C_INCLUDES` - C/C++ include paths
- `LOCAL_EXPORT_C_INCLUDE_DIRS` - Exported include paths

**Compilation Flags:**
- `LOCAL_CFLAGS` - C compilation flags
- `LOCAL_CPPFLAGS` - C++ compilation flags
- `LOCAL_LDFLAGS` - Linker flags

**Dependencies:**
- `LOCAL_STATIC_LIBRARIES` - Static libraries to link
- `LOCAL_SHARED_LIBRARIES` - Shared libraries to link
- `LOCAL_WHOLE_STATIC_LIBRARIES` - Whole archive linking

**Other Variables:**
- `LOCAL_PACKAGE_NAME` - Package name (for apps)
- `LOCAL_CERTIFICATE` - Signing certificate
- `LOCAL_PRIVATE_PLATFORM_APIS` - Use private APIs

#### Build Templates

**BUILD_SHARED_LIBRARY:**
Builds a shared library (.so file):
```makefile
include $(BUILD_SHARED_LIBRARY)
```

**BUILD_STATIC_LIBRARY:**
Builds a static library (.a file):
```makefile
include $(BUILD_STATIC_LIBRARY)
```

**BUILD_EXECUTABLE:**
Builds an executable binary:
```makefile
include $(BUILD_EXECUTABLE)
```

**BUILD_PACKAGE:**
Builds an Android application (APK):
```makefile
include $(BUILD_PACKAGE)
```

**BUILD_JAVA_LIBRARY:**
Builds a Java library (JAR):
```makefile
include $(BUILD_JAVA_LIBRARY)
```

**BUILD_PREBUILT:**
Includes a prebuilt file:
```makefile
include $(BUILD_PREBUILT)
```

### Android.mk Examples

#### Example 1: Shared Library

```makefile
LOCAL_PATH := $(call my-dir)

include $(CLEAR_VARS)

LOCAL_MODULE := libmymodule
LOCAL_SRC_FILES := \
    src/file1.c \
    src/file2.c \
    src/file3.cpp

LOCAL_C_INCLUDES := \
    $(LOCAL_PATH)/include \
    external/somelib/include

LOCAL_SHARED_LIBRARIES := \
    liblog \
    libutils

LOCAL_CFLAGS := -Wall -Werror
LOCAL_CPPFLAGS := -std=c++11

include $(BUILD_SHARED_LIBRARY)
```

**What This Does:**
- Builds a shared library named `libmymodule.so`
- Compiles C and C++ source files
- Links against liblog and libutils
- Sets compilation flags

#### Example 2: Android Application

```makefile
LOCAL_PATH := $(call my-dir)

include $(CLEAR_VARS)

LOCAL_PACKAGE_NAME := MyApp
LOCAL_SRC_FILES := $(call all-java-files-under, src)
LOCAL_RESOURCE_DIR := $(LOCAL_PATH)/res

LOCAL_STATIC_ANDROID_LIBRARIES := \
    android-support-v4

LOCAL_STATIC_JAVA_LIBRARIES := \
    some-library

LOCAL_CERTIFICATE := platform
LOCAL_PRIVILEGED_MODULE := true

include $(BUILD_PACKAGE)
```

**What This Does:**
- Builds an Android app APK
- Compiles Java source files
- Includes resources
- Links against libraries
- Signs with platform certificate

#### Example 3: Executable

```makefile
LOCAL_PATH := $(call my-dir)

include $(CLEAR_VARS)

LOCAL_MODULE := mytool
LOCAL_SRC_FILES := main.c utils.c

LOCAL_SHARED_LIBRARIES := \
    liblog \
    libcutils

LOCAL_CFLAGS := -Wall

include $(BUILD_EXECUTABLE)
```

**What This Does:**
- Builds an executable binary
- Compiles C source files
- Links against system libraries
- Produces `mytool` executable

### Build System Integration

#### How Make Integrates with Android

**Core Makefiles:**
- `build/core/main.mk` - Main Make entry point
- `build/core/config.mk` - Build configuration
- `build/core/definitions.mk` - Build definitions
- `build/core/base_rules.mk` - Base build rules

**Build Process:**
1. Main Makefile includes core files
2. Scans for Android.mk files
3. Processes each Android.mk
4. Builds dependency graph
5. Executes builds

#### Module Discovery

**How Android Finds Modules:**
- Recursively scans source tree
- Looks for Android.mk files
- Processes each Android.mk
- Builds module list
- Resolves dependencies

**Module Paths:**
- Modules in their own directories
- Android.mk in module root
- Relative paths for sources
- Absolute paths for includes

#### Dependency Resolution

**How Dependencies Work:**
- Modules declare dependencies
- Build system resolves them
- Builds dependencies first
- Links in correct order

**Dependency Types:**
- **Static Libraries:** Linked into module
- **Shared Libraries:** Linked at runtime
- **Headers:** Include paths
- **Resources:** Resource dependencies

### Make Build Process

#### Build Execution Flow

**1. Initialization:**
```bash
source build/envsetup.sh
lunch <device>-<variant>
```

**2. Make Invocation:**
```bash
make -j8
```

**3. Make Processing:**
- Reads main Makefile
- Includes core Makefiles
- Scans for Android.mk files
- Processes module definitions

**4. Dependency Graph:**
- Builds dependency graph
- Determines build order
- Identifies what to build
- Plans execution

**5. Build Execution:**
- Executes compilation commands
- Links libraries
- Packages components
- Generates outputs

#### Parallel Builds

**How Parallel Builds Work:**
- Make supports `-j` option
- Specifies number of parallel jobs
- Builds independent modules simultaneously
- Utilizes multiple CPU cores

**Usage:**
```bash
make -j8        # 8 parallel jobs
make -j$(nproc) # Use all CPU cores
```

**Benefits:**
- Faster builds
- Better resource utilization
- Scalable performance
- Reduced build time

#### Incremental Builds

**How Incremental Builds Work:**
- Make tracks file timestamps
- Compares source and output timestamps
- Rebuilds only changed modules
- Skips unchanged modules

**Benefits:**
- Faster development cycles
- Saves compilation time
- Efficient iteration
- Quick testing

**Limitations:**
- Can miss some dependencies
- May need clean builds
- Timestamp-based (not perfect)
- Can have stale builds

### Make System Limitations

#### Performance Issues

**Problems:**
- Slow for large projects
- Limited parallelization
- Inefficient dependency resolution
- Long build times

**Why:**
- Make's design limitations
- Complex dependency graphs
- Sequential processing bottlenecks
- Inefficient file scanning

#### Maintenance Issues

**Problems:**
- Hard to maintain Android.mk files
- Complex syntax
- Error-prone
- Difficult to debug

**Why:**
- Make syntax complexity
- Android-specific extensions
- Lack of type checking
- Limited tooling support

#### Scalability Issues

**Problems:**
- Doesn't scale well
- Performance degrades with size
- Limited optimization
- Resource intensive

**Why:**
- Make's architecture
- File-based dependency tracking
- Limited caching
- Inefficient algorithms

### Migration to Soong

#### Why Migrate?

**Soong Advantages:**
- Faster builds
- Better parallelization
- Easier to maintain
- Better tooling

**Migration Benefits:**
- Improved build performance
- Easier maintenance
- Better developer experience
- Modern build system

#### Migration Process

**How to Migrate:**
1. Convert Android.mk to Android.bp
2. Test build
3. Verify functionality
4. Remove Android.mk

**Status:**
- Ongoing migration
- New code uses Soong
- Legacy code still uses Make
- Both systems coexist

### Make System Best Practices

#### Writing Android.mk Files

**Best Practices:**
- Use clear module names
- Organize source files clearly
- Document dependencies
- Follow conventions

**Common Patterns:**
- Clear variable names
- Organized source lists
- Proper include paths
- Correct build templates

#### Module Organization

**Structure:**
- One module per Android.mk
- Clear module boundaries
- Logical grouping
- Consistent naming

**Naming:**
- Descriptive module names
- Follow naming conventions
- Avoid conflicts
- Be consistent

#### Dependency Management

**Best Practices:**
- Declare all dependencies
- Use correct dependency types
- Avoid circular dependencies
- Keep dependencies minimal

**Common Issues:**
- Missing dependencies
- Wrong dependency types
- Circular dependencies
- Unnecessary dependencies

### Debugging Make Builds

#### Common Issues

**Build Failures:**
- Missing dependencies
- Incorrect paths
- Wrong build templates
- Syntax errors

**Debugging:**
- Check build logs
- Verify Android.mk syntax
- Check file paths
- Verify dependencies

#### Build Logs

**Understanding Logs:**
- Make outputs build commands
- Shows compilation errors
- Displays dependency issues
- Provides error messages

**Useful Commands:**
```bash
make -n          # Dry run (show commands)
make V=1         # Verbose output
make showcommands # Show all commands
```

### Make vs Soong

#### Comparison

**Make:**
- Legacy system
- Android.mk files
- Slower builds
- More complex syntax

**Soong:**
- Modern system
- Android.bp files
- Faster builds
- Simpler syntax

#### When to Use What

**Use Make:**
- Legacy modules
- Existing Android.mk files
- When Soong doesn't support feature
- During migration period

**Use Soong:**
- New modules
- New code
- Preferred for new development
- Modern build system

## Key Takeaways

1. **Make-based build system** is Android's original build framework using GNU Make and Android.mk files.

2. **Android.mk files** describe how modules are built using Android-specific Make syntax and build templates.

3. **Make system is still supported** but being gradually replaced by Soong for new development.

4. **Build process** involves scanning Android.mk files, resolving dependencies, and executing builds.

5. **Make system has limitations** in performance, maintenance, and scalability compared to Soong.

6. **Understanding Make system** is essential for working with legacy code and understanding Android's build evolution.

7. **Migration to Soong** is ongoing, with new code using Soong and legacy code still using Make.

8. **Both systems coexist** in current Android builds, with Make handling legacy modules and Soong handling new modules.

## Related Topics

- **Build System Structure:** The overall architecture that includes both Make and Soong
- **Soong Build System:** The modern build system that's replacing Make
- **Blueprint Language Fundamentals:** The language used in Android.bp files (Soong)
- **Understanding Android.bp Files:** How to write build descriptions in Soong

