---
number: 7
title: SELinux Overview
slug: selinux-overview
level: beginner
tags:
  - aosp
  - selinux
  - security
  - mandatory-access-control
  - sepolicy
  - android-security
prerequisites:
  - android-architecture-complete-overview
  - init-system-in-android
estimated_minutes: 90
contributors: []
diagrams: []
examples: []
canonical_id: aosp-beginner-07
---

# SELinux Overview

## Overview

SELinux (Security-Enhanced Linux) is a mandatory access control (MAC) system that provides fine-grained security policies for Android. It enforces security rules that go beyond traditional Linux permissions, preventing privilege escalation attacks and limiting the damage that can be caused by compromised processes. Understanding SELinux is crucial for AOSP development, as it's a fundamental security mechanism that affects how processes interact with each other and with system resources.

Think of SELinux as a "security guard" that enforces strict rules about who can do what, even if they have the technical capability. Traditional Linux permissions might allow a process to access a file, but SELinux can deny that access based on security policies, providing defense in depth.

## Deep Explanation

### What is SELinux?

SELinux is a Linux kernel security module that implements Mandatory Access Control (MAC). Unlike Discretionary Access Control (DAC) - the traditional Linux permission system - SELinux policies are enforced by the system and cannot be bypassed by users or processes, even if they have root privileges.

**Key Concepts:**

**Mandatory Access Control (MAC):**
- Security policies are defined by administrators (not users)
- Policies are enforced by the kernel
- Cannot be overridden by user permissions
- Provides defense in depth

**Discretionary Access Control (DAC):**
- Traditional Linux permissions (owner, group, others)
- Users can change permissions on files they own
- Root user can bypass all restrictions
- Less secure but more flexible

**Why SELinux Matters:**

**1. Defense in Depth:**
- Even if a process is compromised, SELinux limits what it can do
- Prevents privilege escalation
- Isolates processes from each other

**2. Principle of Least Privilege:**
- Each process gets only the minimum permissions needed
- Reduces attack surface
- Limits damage from vulnerabilities

**3. Policy-Based Security:**
- Security rules are explicit and auditable
- Policies can be reviewed and updated
- Centralized security management

### SELinux Architecture in Android

#### Components

**1. SELinux Kernel Module:**
- Integrated into Android's Linux kernel
- Enforces security policies
- Intercepts system calls
- Makes access control decisions

**2. SELinux Policy (sepolicy):**
- Defines security rules
- Located in `/system/etc/selinux/` or `/vendor/etc/selinux/`
- Compiled from source files
- Loaded at boot time

**3. SELinux Contexts:**
- Labels attached to processes, files, and objects
- Format: `user:role:type:level`
- Used for access control decisions

**4. Policy Compiler:**
- Compiles policy source to binary format
- Part of AOSP build system
- Creates policy files for device

#### SELinux Modes

Android supports three SELinux modes:

**1. Permissive Mode:**
- SELinux policies are checked but not enforced
- Violations are logged but allowed
- Used for development and debugging
- Can be set via: `setenforce 0` or `adb shell setenforce 0`

**2. Enforcing Mode:**
- SELinux policies are enforced
- Violations are denied and logged
- Production mode for security
- Can be set via: `setenforce 1` or `adb shell setenforce 1`

**3. Disabled Mode:**
- SELinux is completely disabled
- No policy checking
- Not recommended (security risk)
- Requires kernel rebuild

**Checking Current Mode:**
```bash
# Check SELinux status
getenforce
# Returns: Enforcing, Permissive, or Disabled

# Check detailed status
sestatus
```

**Real-World Example:**
```bash
# Development: Set permissive to debug
adb shell setenforce 0
# Now test your changes - violations logged but allowed

# Production: Ensure enforcing
adb shell setenforce 1
# Security policies enforced
```

### SELinux Contexts

SELinux uses contexts (labels) to identify subjects (processes) and objects (files, sockets, etc.). These contexts are used to make access control decisions.

#### Context Format

SELinux contexts have the format:
```
user:role:type:level
```

**In Android, typically simplified to:**
```
type:level
```

**Components:**

**1. User:**
- SELinux user identity
- Rarely used in Android
- Usually omitted

**2. Role:**
- Role-based access control
- Rarely used in Android
- Usually omitted

**3. Type (Domain for processes, Type for files):**
- Most important component
- Defines security context
- Used for access control decisions
- Examples: `untrusted_app`, `system_server`, `system_file`

**4. Level (MLS/MCS):**
- Multi-Level Security / Multi-Category Security
- Used for data isolation
- Format: `s0`, `s0:c0.c1023`, etc.

#### Process Contexts

Every process has a SELinux context that determines what it can do:

**Common Process Contexts:**

**1. untrusted_app:**
- Regular user applications
- Most restrictive context
- Limited system access
- Example: `untrusted_app:s0:c512,c768`

**2. system_server:**
- System Server process
- Runs framework services
- More privileges than apps
- Example: `system_server:s0`

**3. init:**
- Init process (PID 1)
- Highest privileges
- Manages system startup
- Example: `init:s0`

**4. kernel:**
- Kernel threads
- Kernel space execution
- Example: `kernel:s0`

**5. shell:**
- ADB shell sessions
- Debugging context
- Example: `shell:s0`

**Viewing Process Contexts:**
```bash
# View process contexts
ps -Z
# Output:
# LABEL                              PID   TTY      TIME     CMD
# u:r:untrusted_app:s0:c512,c768    1234  ?        00:00:01 com.example.app
# u:r:system_server:s0               567   ?        00:00:05 system_server

# View specific process
ls -Z /proc/1234/
```

#### File Contexts

Files and directories have SELinux contexts that determine access:

**Common File Contexts:**

**1. system_file:**
- Files in `/system` partition
- System files
- Example: `/system/bin/app_process`

**2. app_data_file:**
- Application data directories
- User app storage
- Example: `/data/data/com.example.app/`

**3. vendor_file:**
- Files in `/vendor` partition
- Vendor-specific files
- Example: `/vendor/bin/hw/android.hardware.camera@2.4-service`

**4. rootfs:**
- Root filesystem
- Example: `/`

**5. untrusted_app_data_file:**
- Untrusted app data
- Isolated storage
- Example: `/data/user/0/com.example.app/`

**Viewing File Contexts:**
```bash
# View file contexts
ls -Z /system/bin/
# Output:
# -rwxr-xr-x  root   shell   u:object_r:system_file:s0  app_process

# View directory context
ls -dZ /data/data/
# Output:
# drwxrwx--x system  system  u:object_r:app_data_file:s0  /data/data/
```

### SELinux Policies

SELinux policies define what actions are allowed or denied. Policies are written in a special language and compiled to binary format.

#### Policy Structure

**Policy Files Location:**
- Source: `external/selinux/` or `device/*/sepolicy/`
- Compiled: `/system/etc/selinux/` or `/vendor/etc/selinux/`
- Binary: `sepolicy`, `file_contexts`, `property_contexts`, etc.

**Policy Components:**

**1. Type Definitions:**
```
# Define a type for untrusted apps
type untrusted_app, domain;
```

**2. Domain Transitions:**
```
# Allow init to transition to untrusted_app
init_daemon_domain(untrusted_app)
```

**3. File Contexts:**
```
# Label app data directory
/data/data(/.*)? u:object_r:app_data_file:s0
```

**4. Access Rules:**
```
# Allow untrusted_app to read app_data_file
allow untrusted_app app_data_file:file { read write };
```

#### Policy Syntax

**Basic Allow Rule:**
```
allow source_type target_type:class { permissions };
```

**Components:**
- **source_type:** Subject (process context)
- **target_type:** Object (file, socket, etc.)
- **class:** Object class (file, dir, socket, etc.)
- **permissions:** Actions allowed (read, write, execute, etc.)

**Examples:**

**1. File Access:**
```
# Allow app to read its own data
allow untrusted_app app_data_file:file { read write };
```

**2. Directory Access:**
```
# Allow app to create files in its data directory
allow untrusted_app app_data_file:dir { add_name write };
```

**3. Socket Access:**
```
# Allow app to connect to network
allow untrusted_app socket:udp_socket { create bind };
```

**4. Binder IPC:**
```
# Allow app to call ActivityManager
allow untrusted_app activity_service:binder { call };
```

**5. Property Access:**
```
# Allow app to read system properties
get_prop(untrusted_app, system_prop)
```

#### Common Policy Macros

Android provides macros to simplify policy writing:

**1. app_domain:**
```
# Define app domain with common permissions
app_domain(untrusted_app)
```

**2. init_daemon_domain:**
```
# Define daemon started by init
init_daemon_domain(my_service)
```

**3. r_dir_file:**
```
# Allow reading directory and files
r_dir_file(untrusted_app, app_data_file)
```

**4. get_prop:**
```
# Allow reading property
get_prop(untrusted_app, system_prop)
```

### SELinux in Android Boot Process

#### Policy Loading

**1. Early Init:**
- Kernel loads initial SELinux policy
- Sets SELinux to enforcing mode
- Labels initial filesystem

**2. Init Process:**
- Loads additional policy files
- Sets up SELinux contexts
- Starts services with proper contexts

**3. Service Startup:**
- Each service runs in its SELinux domain
- Domain transitions occur as needed
- Policies enforced throughout

#### Context Transitions

Processes can transition from one SELinux context to another:

**Example: Zygote → App:**
```
1. Zygote runs as: zygote:s0
2. App forks from Zygote
3. Domain transition: zygote → untrusted_app
4. App runs as: untrusted_app:s0
```

**Policy for Transition:**
```
# Allow zygote to transition to untrusted_app
allow zygote untrusted_app:process { transition };
type_transition zygote untrusted_app:process untrusted_app;
```

### SELinux Policy Files

#### Key Policy Files

**1. sepolicy:**
- Main binary policy file
- Contains all access rules
- Loaded by kernel

**2. file_contexts:**
- Maps file paths to SELinux contexts
- Used during boot to label filesystem
- Format: `path regex context`

**3. property_contexts:**
- Maps system properties to contexts
- Controls property access
- Format: `property_name context`

**4. service_contexts:**
- Maps Binder service names to contexts
- Controls service access
- Format: `service_name context`

**5. seapp_contexts:**
- Maps app attributes to contexts
- Determines app SELinux context
- Based on UID, package name, etc.

#### File Contexts Format

```
# Format: path_regex context [file_type]
/system/bin/.* u:object_r:system_file:s0
/data/data(/.*)? u:object_r:app_data_file:s0
/vendor/bin/.* u:object_r:vendor_file:s0
```

#### Property Contexts Format

```
# Format: property_name context
ro.build.version.release u:object_r:system_prop:s0
persist.sys.timezone u:object_r:system_prop:s0
```

#### Service Contexts Format

```
# Format: service_name context
activity u:object_r:activity_service:s0
window u:object_r:window_service:s0
```

### SELinux Violations

When SELinux denies an action, it logs a violation. Understanding these logs is crucial for debugging.

#### Reading Violations

**Logcat:**
```bash
# View SELinux violations
adb logcat | grep avc
```

**dmesg:**
```bash
# View kernel SELinux messages
adb shell dmesg | grep avc
```

#### Violation Format

```
avc: denied { permission } for pid=1234 comm="app_process" 
scontext=u:r:untrusted_app:s0:c512,c768 
tcontext=u:object_r:system_file:s0 
tclass=file permissive=0
```

**Components:**
- **avc:** Access Vector Cache (SELinux decision)
- **denied:** Action was denied
- **permission:** What was attempted (read, write, etc.)
- **pid:** Process ID
- **comm:** Command name
- **scontext:** Source context (process)
- **tcontext:** Target context (object)
- **tclass:** Object class (file, dir, etc.)
- **permissive:** Whether in permissive mode

#### Fixing Violations

**1. Identify the Violation:**
```
avc: denied { read } for pid=1234 scontext=u:r:untrusted_app:s0 
tcontext=u:object_r:system_file:s0 tclass=file
```

**2. Understand What's Needed:**
- App (untrusted_app) trying to read system_file
- This is likely a security issue (app shouldn't read system files)
- Or legitimate need (requires policy change)

**3. Add Policy (if legitimate):**
```
# In sepolicy file
allow untrusted_app system_file:file { read };
```

**4. Rebuild and Test:**
- Recompile policy
- Flash to device
- Test again
- Verify violation is resolved

### SELinux and Android Security

#### How SELinux Protects Android

**1. Process Isolation:**
- Apps cannot access each other's data
- System services isolated from apps
- Prevents privilege escalation

**2. File System Protection:**
- System files protected from apps
- Vendor files isolated
- Prevents unauthorized modifications

**3. IPC Protection:**
- Binder calls subject to SELinux policies
- Services can restrict access
- Prevents unauthorized service calls

**4. Network Protection:**
- Network access controlled by policy
- Prevents unauthorized connections
- Isolates network traffic

#### Common Security Scenarios

**Scenario 1: App Trying to Access System Files**
```
Violation: App tries to read /system/build.prop
SELinux: Denies access (untrusted_app cannot read system_file)
Result: Access denied, violation logged
```

**Scenario 2: App Trying to Call System Service**
```
Violation: App tries to call ActivityManager without permission
SELinux: Checks policy
Result: Allowed if policy permits, denied otherwise
```

**Scenario 3: Compromised Process**
```
Situation: Process compromised by exploit
SELinux: Limits what process can do based on its context
Result: Damage limited to process's SELinux domain
```

### SELinux Tools and Commands

#### Development Tools

**1. getenforce:**
```bash
# Check SELinux mode
getenforce
# Returns: Enforcing, Permissive, or Disabled
```

**2. setenforce:**
```bash
# Set SELinux mode (requires root)
setenforce 0  # Permissive
setenforce 1  # Enforcing
```

**3. sestatus:**
```bash
# Detailed SELinux status
sestatus
```

**4. chcon:**
```bash
# Change file context (requires root, temporary)
chcon u:object_r:my_file:s0 /path/to/file
```

**5. restorecon:**
```bash
# Restore file context from policy
restorecon -R /path/to/directory
```

**6. getfilecon:**
```bash
# Get file context
getfilecon /path/to/file
```

**7. getcon:**
```bash
# Get current process context
getcon
```

#### Policy Development Tools

**1. checkpolicy:**
```bash
# Check policy syntax
checkpolicy -M -c 30 policy.conf
```

**2. sepolicy-analyze:**
```bash
# Analyze SELinux policy
sepolicy-analyze policy_file
```

**3. audit2allow:**
```bash
# Generate policy from violations
audit2allow -i violations.log
```

### Real-World Examples

#### Example 1: Adding New System Service

**Scenario:**
You're adding a new system service that needs to be called by apps.

**Steps:**

**1. Define Service Context:**
```
# In service_contexts
my_service u:object_r:my_service:s0
```

**2. Define Service Type:**
```
# In sepolicy
type my_service, service_manager_type;
```

**3. Allow Apps to Call Service:**
```
# In sepolicy
allow untrusted_app my_service:service_manager { find };
allow untrusted_app my_service:binder { call };
```

**4. Allow Service to Receive Calls:**
```
# In sepolicy
allow my_service untrusted_app:binder { call receive };
```

#### Example 2: App Accessing Custom File

**Scenario:**
Your app needs to read a custom configuration file.

**Steps:**

**1. Define File Type:**
```
# In sepolicy
type my_config_file, file_type;
```

**2. Label the File:**
```
# In file_contexts
/data/myconfig u:object_r:my_config_file:s0
```

**3. Allow App Access:**
```
# In sepolicy
allow untrusted_app my_config_file:file { read };
```

**4. Apply Context:**
```bash
# On device
restorecon /data/myconfig
```

#### Example 3: Debugging SELinux Violations

**Scenario:**
Your app is getting SELinux violations.

**Steps:**

**1. Enable Permissive Mode:**
```bash
adb shell setenforce 0
```

**2. Reproduce Issue:**
- Run your app
- Trigger the action causing violation

**3. Collect Violations:**
```bash
adb logcat | grep avc > violations.log
```

**4. Analyze Violations:**
```bash
# Use audit2allow to generate policy
audit2allow -i violations.log
```

**5. Review Generated Policy:**
- Check if violations are legitimate
- Add appropriate policies
- Test in enforcing mode

### Edge Cases and Pitfalls

#### Common Mistakes

**1. Too Permissive Policies:**
```
# BAD: Too broad
allow untrusted_app *:file { read write execute };

# GOOD: Specific
allow untrusted_app app_data_file:file { read write };
```

**2. Missing File Contexts:**
```
# BAD: File not labeled
# File created without context

# GOOD: Proper labeling
# In file_contexts: /data/myapp(/.*)? u:object_r:app_data_file:s0
```

**3. Incorrect Domain Transitions:**
```
# BAD: No transition policy
# Process tries to change context without policy

# GOOD: Proper transition
type_transition init my_service:process my_service;
```

**4. Ignoring Violations:**
```
# BAD: Set permissive and forget
setenforce 0  # Never fix violations

# GOOD: Fix violations properly
# Analyze, add policies, test in enforcing
```

### Best Practices

**For Policy Development:**
- Follow principle of least privilege
- Be specific in policies (avoid wildcards)
- Test in permissive mode first
- Always test in enforcing mode before release
- Document policy decisions
- Review policies regularly

**For Debugging:**
- Use permissive mode for development
- Collect all violations before fixing
- Understand why violation occurred
- Add minimal policies needed
- Test thoroughly after changes

**For Production:**
- Always use enforcing mode
- Regularly audit policies
- Monitor for violations
- Update policies as needed
- Keep policies minimal

## References and Further Reading

- [AOSP SELinux Documentation](https://source.android.com/docs/security/features/selinux)
- [SELinux Project](https://selinuxproject.org/)
- [SELinux Policy Documentation](https://selinuxproject.org/page/Documentation)
- [Android SELinux Policy](https://source.android.com/docs/security/features/selinux/device-policy)

## Quiz

### Question 1
What does SELinux stand for and what is its primary purpose in Android?

**A)** Secure Enhanced Linux - provides file encryption  
**B)** Security-Enhanced Linux - provides mandatory access control  
**C)** System Enhanced Linux - provides process management  
**D)** Service Enhanced Linux - provides IPC security

**Answer: B** - SELinux (Security-Enhanced Linux) implements Mandatory Access Control (MAC), providing fine-grained security policies that enforce access control decisions beyond traditional Linux permissions.

### Question 2
What is the difference between permissive and enforcing mode in SELinux?

**A)** Permissive mode is more secure than enforcing mode  
**B)** Enforcing mode logs violations but allows them, permissive mode denies them  
**C)** Permissive mode logs violations but allows them, enforcing mode denies and logs them  
**D)** There is no difference

**Answer: C** - In permissive mode, SELinux checks policies and logs violations but allows the actions to proceed. In enforcing mode, violations are denied and logged, providing actual security enforcement.

### Question 3
What is the format of a SELinux context?

**A)** user:role:type:level  
**B)** type:permission:class  
**C)** domain:object:action  
**D)** process:file:access

**Answer: A** - SELinux contexts use the format `user:role:type:level`, though in Android it's often simplified to just `type:level` since user and role are rarely used.

### Question 4
How do you check the current SELinux mode on an Android device?

**A)** `selinux status`  
**B)** `getenforce`  
**C)** `checkmode`  
**D)** `getpolicy`

**Answer: B** - The `getenforce` command returns the current SELinux mode (Enforcing, Permissive, or Disabled).

### Question 5
What tool can generate SELinux policy rules from violation logs?

**A)** `policygen`  
**B)** `audit2allow`  
**C)** `violation2policy`  
**D)** `sepolicy-gen`

**Answer: B** - The `audit2allow` tool analyzes SELinux violation logs (AVC denials) and generates policy rules that would allow those actions, though the generated policies should be reviewed for security before use.

## Related Topics

- [Android Architecture - Complete Overview](./01.%20Android%20Architecture%20-%20Complete%20Overview.md)
- [Init System in Android](./04.%20Init%20System%20in%20Android.md)
- [System Properties](./05.%20System%20Properties.md)

