---
number: 33
title: ccache & build acceleration
slug: ccache-build-acceleration
level: beginner
tags:
  - aosp
  - ccache
  - build
  - optimization
  - acceleration
  - caching
  - performance
prerequisites:
  - build-system-structure
  - soong-build-system
estimated_minutes: 70
contributors: []
diagrams: []
examples: []
canonical_id: aosp-beginner-33
---

# ccache & build acceleration

## Overview

ccache (compiler cache) is a tool that speeds up C/C++ compilation by caching compilation results and reusing them when the same compilation is requested again. Build acceleration techniques like ccache are essential for AOSP development, as they can dramatically reduce build times, especially for incremental builds. Understanding ccache and build acceleration is crucial for efficient AOSP development, as build times can be a significant bottleneck in the development workflow.

Think of ccache like a smart assistant who remembers all the work you've done before: when you ask to compile the same code again (even if it's in a different location or context), ccache recognizes it and instantly provides the previously compiled result instead of recompiling from scratch. This is like having a photographic memory for compilation work, saving enormous amounts of time.

## Deep Explanation

### What is ccache?

ccache is a compiler cache that acts as a wrapper around C/C++ compilers (like GCC and Clang). It intercepts compilation requests, checks if the same compilation has been done before, and if so, returns the cached result instead of recompiling.

**Key Characteristics:**
- **Compiler Wrapper:** Intercepts compiler calls
- **Caching:** Stores compilation results
- **Transparent:** Works with existing build systems
- **Fast:** Dramatically speeds up builds

**Why ccache?**
- **Speed:** Much faster incremental builds
- **Efficiency:** Reuses previous work
- **Transparency:** Works automatically
- **Compatibility:** Works with GCC, Clang, etc.

### How ccache Works

#### Basic Operation

**Compilation Flow:**
1. Build system calls compiler
2. ccache intercepts the call
3. ccache checks cache for previous result
4. If found, returns cached result (fast!)
5. If not found, runs compiler and caches result

**Cache Key:**
- Source file content (hash)
- Compiler flags
- Compiler version
- Include paths
- Preprocessor defines

**Cache Hit:**
- Same source + same flags = cache hit
- Returns cached object file
- No compilation needed
- Very fast (milliseconds)

**Cache Miss:**
- New source or different flags
- Runs actual compiler
- Caches result for future use
- Normal compilation time

#### Cache Storage

**Cache Directory:**
- Default: `~/.ccache/`
- Configurable location
- Stores object files
- Manages cache size

**Cache Structure:**
```
~/.ccache/
├── 0/    # Hash directories
├── 1/
├── ...
└── stats # Statistics
```

**Cache Management:**
- Automatic size management
- LRU (Least Recently Used) eviction
- Configurable size limits
- Cache statistics

### Enabling ccache in AOSP

#### Setup

**Enable ccache:**
```bash
export USE_CCACHE=1
export CCACHE_DIR=/path/to/ccache
```

**Set Cache Size:**
```bash
ccache -M 50G  # Set cache size to 50GB
```

**Verify:**
```bash
ccache -s  # Show statistics
```

#### Build System Integration

**AOSP Integration:**
- AOSP build system supports ccache
- Automatically uses if enabled
- Works with both Make and Soong
- Transparent to build process

**Configuration:**
```bash
# In build environment
export USE_CCACHE=1
export CCACHE_EXEC=/usr/bin/ccache
```

**Build System Detection:**
- Build system checks `USE_CCACHE`
- Wraps compiler with ccache
- Uses ccache automatically
- No code changes needed

### ccache Configuration

#### Cache Size

**Setting Size:**
```bash
ccache -M 50G  # 50 GB cache
ccache -M 100G # 100 GB cache
```

**Size Considerations:**
- Larger cache = more hits
- But uses more disk space
- Balance between size and hits
- Typical: 50-100 GB

**Size Management:**
- Automatic eviction when full
- LRU algorithm
- Configurable limits
- Prevents unlimited growth

#### Cache Location

**Default Location:**
- `~/.ccache/` (home directory)
- Per-user cache
- Can be shared (with care)

**Custom Location:**
```bash
export CCACHE_DIR=/shared/ccache
```

**Shared Cache:**
- Multiple users can share
- Network storage possible
- Requires proper permissions
- Can improve team efficiency

#### Advanced Configuration

**Compression:**
```bash
ccache -z  # Enable compression
```

**Hard Links:**
```bash
ccache -H  # Use hard links
```

**Statistics:**
```bash
ccache -s  # Show statistics
```

**Statistics Include:**
- Cache hits/misses
- Cache size
- Hit rate
- Performance metrics

### ccache Performance

#### Performance Benefits

**First Build:**
- No cache hits
- Normal compilation time
- Populates cache
- Baseline performance

**Subsequent Builds:**
- Many cache hits
- Much faster compilation
- Significant time savings
- Dramatic speedup

**Typical Improvements:**
- 5-10x faster for incremental builds
- 2-3x faster for clean builds (with warm cache)
- 90%+ cache hit rate (common)
- Minutes saved per build

#### Cache Hit Rates

**Good Hit Rates:**
- 80-90%: Excellent
- 70-80%: Good
- 50-70%: Acceptable
- <50%: May need tuning

**Factors Affecting Hit Rate:**
- Code change frequency
- Compiler flag stability
- Include path changes
- Preprocessor defines

### Build Acceleration Techniques

#### Parallel Builds

**Multiple Jobs:**
```bash
m -j16        # 16 parallel jobs
m -j$(nproc)  # Use all CPU cores
```

**Benefits:**
- Utilizes all CPU cores
- Faster overall builds
- Better resource usage
- Scalable performance

**Limitations:**
- Memory usage increases
- I/O bottlenecks possible
- Dependency constraints
- Diminishing returns

#### Incremental Builds

**What It Does:**
- Only rebuilds changed files
- Skips unchanged modules
- Fast iteration cycles
- Essential for development

**Benefits:**
- Much faster than clean builds
- Quick testing cycles
- Efficient development
- Time savings

**Best Practices:**
- Use for development
- Clean build occasionally
- Verify incremental builds
- Monitor for issues

#### Build Caching

**Multiple Levels:**
- ccache (compiler cache)
- Build system cache
- Dependency cache
- Artifact cache

**Combined Benefits:**
- Multi-level caching
- Maximum speedup
- Comprehensive optimization
- Best performance

### ccache Best Practices

#### Setup

**Initial Setup:**
1. Install ccache
2. Enable in environment
3. Set cache size
4. Verify configuration

**Verification:**
```bash
ccache -s  # Check statistics
m -j8      # Test build
ccache -s  # Check hit rate
```

#### Maintenance

**Regular Maintenance:**
- Monitor cache size
- Check hit rates
- Clean if needed
- Optimize configuration

**Cache Cleaning:**
```bash
ccache -C  # Clear cache
ccache -c  # Clear statistics
```

**When to Clean:**
- Cache corruption
- Disk space issues
- Testing purposes
- Rarely needed

#### Optimization

**Maximize Hits:**
- Stable compiler flags
- Consistent include paths
- Minimize preprocessor changes
- Use consistent toolchains

**Cache Sharing:**
- Share cache in teams
- Use network storage
- Proper permissions
- Monitor conflicts

### Troubleshooting ccache

#### Common Issues

**Cache Not Used:**
- Check `USE_CCACHE=1`
- Verify ccache installation
- Check compiler wrapper
- Review build logs

**Low Hit Rate:**
- Check compiler flags
- Verify include paths
- Review preprocessor defines
- Analyze cache statistics

**Cache Corruption:**
- Rare but possible
- Clear cache if needed
- Rebuild cache
- Monitor for issues

#### Debugging

**Enable Debugging:**
```bash
export CCACHE_DEBUG=1
```

**Check Statistics:**
```bash
ccache -s
```

**Verify Operation:**
```bash
ccache -z  # Show configuration
```

### Other Build Acceleration Techniques

#### Distributed Builds

**distcc:**
- Distributed compilation
- Uses multiple machines
- Network-based
- Complex setup

**icecc:**
- Improved distcc
- Better caching
- More efficient
- Alternative to distcc

#### Build Optimization

**Compiler Optimization:**
- Use appropriate optimization levels
- Profile-guided optimization
- Link-time optimization
- Balance speed vs. size

**Build System Optimization:**
- Optimize dependency graphs
- Reduce unnecessary builds
- Parallel execution
- Efficient scheduling

### ccache Limitations

#### What ccache Doesn't Cache

**Not Cached:**
- Link operations
- Archive creation
- Final linking
- Packaging steps

**Why:**
- Different optimization
- Linker-specific
- Final artifacts
- Different requirements

#### When ccache Doesn't Help

**Scenarios:**
- First build (no cache)
- Major code changes
- Clean builds (sometimes)
- Link operations

**Still Beneficial:**
- Incremental builds
- Repeated compilations
- Development cycles
- Most common scenarios

## Key Takeaways

1. **ccache is a compiler cache** that speeds up C/C++ compilation by caching and reusing compilation results.

2. **ccache works transparently** by intercepting compiler calls and returning cached results when available.

3. **ccache can provide 5-10x speedup** for incremental builds with typical hit rates of 80-90%.

4. **Enable ccache** by setting `USE_CCACHE=1` and configuring cache size with `ccache -M <size>`.

5. **ccache is automatically integrated** with AOSP build system and works with both Make and Soong.

6. **Cache hit rate** depends on code change frequency, compiler flag stability, and include path consistency.

7. **ccache works best** for incremental builds and repeated compilations, providing less benefit for first builds or major changes.

8. **Understanding ccache and build acceleration** is essential for efficient AOSP development and reducing build times.

## Related Topics

- **Build System Structure:** How ccache integrates with the build system
- **Soong Build System:** How ccache works with Soong builds
- **Build Optimization:** Other build acceleration techniques
- **ART boot image & dex pre-optimization:** Runtime optimization techniques

