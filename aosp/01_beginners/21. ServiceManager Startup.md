---
number: 21
title: ServiceManager Startup
slug: servicemanager-startup
level: beginner
tags:
  - aosp
  - servicemanager
  - binder
  - boot
  - startup
  - services
  - ipc
prerequisites:
  - binder-ipc-basics
  - init-system-in-android
  - boot-process-overview
estimated_minutes: 70
contributors: []
diagrams: []
examples: []
canonical_id: aosp-beginner-21
---

# ServiceManager Startup

## Overview

ServiceManager is a critical native service that starts very early in the Android boot sequence, before System Server and most other services. It acts as the "directory" or "registry" for all Binder services, allowing services to register themselves and clients to discover services by name. Understanding ServiceManager startup is essential for comprehending how Android's service discovery works, how the Binder IPC system is initialized, and how services become available to the system.

Think of ServiceManager like a phone book or directory service: just as you need a phone book to look up someone's phone number, Android services need ServiceManager to find other services. ServiceManager starts before anyone else needs to use it, ensuring the "phone book" is ready when services want to register or when clients want to discover services.

## Deep Explanation

### What is ServiceManager?

ServiceManager is a native (C/C++) daemon process that maintains a registry of all Binder services in the Android system. It's the first service to start and the foundation for all service discovery in Android.

**Key Characteristics:**
- **Native Process:** Written in C/C++, not Java
- **Early Startup:** Starts before System Server
- **Critical Service:** System cannot function without it
- **Service Registry:** Maintains mapping of service names to Binder tokens
- **Singleton:** Only one ServiceManager process runs

**ServiceManager's Role:**
1. **Service Registration:** Services register with ServiceManager using a name
2. **Service Discovery:** Clients query ServiceManager by name to get Binder tokens
3. **Service Management:** Maintains the service registry
4. **Binder Foundation:** Provides the foundation for Binder IPC

### Why ServiceManager is Critical

**Service Discovery Problem:**
Without ServiceManager, services would have no way to find each other:
- Services don't know each other's Binder tokens
- No centralized way to discover services
- Clients can't find services they need
- System would be non-functional

**ServiceManager Solution:**
- Centralized registry of all services
- Services register with human-readable names
- Clients query by name to get Binder tokens
- Enables service discovery and communication

**Early Startup Requirement:**
ServiceManager must start before other services because:
- Services need to register when they start
- System Server needs ServiceManager to register its services
- Apps need ServiceManager to discover services
- Binder IPC depends on ServiceManager

### ServiceManager Startup Sequence

ServiceManager startup is a carefully orchestrated process that happens very early in boot. Let's trace through each step:

#### Step 1: Init Service Definition

**Location:** `init.rc` or device-specific init files

**Service Declaration:**
```bash
service servicemanager /system/bin/servicemanager
    class core
    user system
    group system
    critical
    onrestart restart healthd
    onrestart restart zygote
    onrestart restart audioserver
    onrestart restart mediaserver
    onrestart restart surfaceflinger
    onrestart restart drm
    onrestart restart cameraserver
    onrestart restart keystore
    onrestart restart gatekeeperd
    onrestart restart vold
    onrestart restart netd
    onrestart restart wificond
    onrestart restart wpa_supplicant
    writepid /dev/cpuset/system-background/tasks
```

**Key Elements:**
- **Executable:** `/system/bin/servicemanager` (native binary)
- **Class:** `core` (starts in early-init or init phase)
- **User:** `system` (UID 1000)
- **Group:** `system` (GID 1000)
- **Critical:** Marked as critical (system restarts if it dies)

**When It Starts:**
- Triggered during `early-init` or early `init` phase
- Before most other services
- After basic system initialization
- Before System Server

**Timing:**
- Typically starts 100-200ms after kernel init
- One of the first services to start
- Critical path for boot time

#### Step 2: Init Launches ServiceManager Process

**Process Creation:**
1. Init reads service definition from `init.rc`
2. Init forks a new process
3. New process executes `/system/bin/servicemanager`
4. Process runs as system user
5. Process enters main execution

**Initial State:**
- **PID:** New process ID
- **PPID:** 1 (parent is init)
- **UID:** 1000 (system)
- **GID:** 1000 (system)
- **State:** Just started, entering main()

**Environment:**
- Minimal environment variables
- Basic file descriptors
- No Java runtime (native process)
- Direct system calls

#### Step 3: Native Code Entry Point

**main() Function:**
ServiceManager's main function is in native C++ code:

```cpp
int main(int argc, char** argv) {
    // Initialize Binder
    // Set up service registry
    // Enter service loop
    // Handle service registration/discovery
}
```

**Initialization Steps:**
1. Parse command-line arguments (if any)
2. Initialize Binder framework
3. Set up service registry
4. Register with Binder driver
5. Enter main service loop

**Binder Initialization:**
- Initialize Binder driver connection
- Set up Binder context
- Prepare for service registration
- Configure Binder limits

#### Step 4: Binder Driver Setup

**Binder Context Manager:**
ServiceManager registers itself as the Binder context manager:

```cpp
// ServiceManager becomes context manager
binder_become_context_manager(bs);
```

**What This Means:**
- ServiceManager is the special Binder service
- Handles context manager operations
- Manages service registry
- Receives all service registration requests

**Binder Driver Communication:**
- Opens `/dev/binder` device
- Sets up Binder communication
- Registers as context manager
- Prepares for service requests

#### Step 5: Service Registry Initialization

**Registry Structure:**
ServiceManager creates an in-memory registry:

**Data Structure:**
- **Service Name → Binder Token mapping**
- Hash table or similar structure
- Fast lookup by name
- Thread-safe access

**Initial State:**
- Registry is empty initially
- Ready to accept registrations
- No services registered yet
- Waiting for services to register

**Registry Operations:**
- `addService(name, binder)` - Register service
- `getService(name)` - Get service by name
- `listServices()` - List all services
- `checkService(name)` - Check if service exists

#### Step 6: Main Service Loop

**Event Loop:**
ServiceManager enters its main event loop:

```cpp
for (;;) {
    // Read Binder transaction
    // Process request
    // Send response
    // Continue loop
}
```

**Loop Function:**
1. Wait for Binder transactions
2. Receive service registration requests
3. Receive service discovery requests
4. Process requests
5. Send responses
6. Repeat indefinitely

**Transaction Handling:**
- **ADD_SERVICE:** Register a new service
- **CHECK_SERVICE:** Check if service exists
- **GET_SERVICE:** Get service Binder token
- **LIST_SERVICES:** List all registered services

**Blocking Behavior:**
- Loop blocks waiting for transactions
- Wakes up when transaction arrives
- Processes transaction immediately
- Returns to waiting state

#### Step 7: Service Registration Ready

**State:**
After initialization, ServiceManager is ready to:
- Accept service registrations
- Handle service discovery requests
- Manage service registry
- Support Binder IPC

**Availability:**
- ServiceManager is now available
- Other services can register
- Clients can discover services
- Binder IPC is functional

**Timing:**
- Typically ready 200-300ms after boot
- Before System Server starts
- Before most services start
- Critical for system operation

### ServiceManager Variants

**Standard ServiceManager:**
- Main ServiceManager for framework services
- Handles most Android services
- Started by init
- Runs as system user

**HWServiceManager:**
- Hardware Service Manager
- For HIDL services (Hardware Interface Definition Language)
- Separate process
- Handles hardware abstraction services

**VNDServiceManager:**
- Vendor Service Manager
- For vendor-specific services
- Separate process
- Handles vendor HAL services

**Why Multiple ServiceManagers?**
- Separation of concerns
- Security isolation
- Different service types
- Vendor/system separation

### Service Registration Process

**How Services Register:**
When a service starts and wants to register:

**1. Service Gets Binder Token:**
```java
// Service creates Binder object
IBinder service = new MyService();

// Service gets its Binder token
int token = service.getBinderToken();
```

**2. Service Calls ServiceManager:**
```java
// Register with ServiceManager
ServiceManager.addService("myservice", service);
```

**3. ServiceManager Processing:**
- Receives ADD_SERVICE transaction
- Extracts service name and Binder token
- Stores in registry: "myservice" → token
- Returns success status

**4. Registration Complete:**
- Service is now discoverable
- Clients can find it by name
- Service is part of system

**Registration Timing:**
- Services register when they start
- System Server registers its services early
- Native services register when initialized
- All registrations go through ServiceManager

### Service Discovery Process

**How Clients Discover Services:**
When a client needs to use a service:

**1. Client Queries ServiceManager:**
```java
// Get service from ServiceManager
IBinder binder = ServiceManager.getService("activity");
```

**2. ServiceManager Processing:**
- Receives GET_SERVICE transaction
- Looks up "activity" in registry
- Returns Binder token if found
- Returns null if not found

**3. Client Gets Service Proxy:**
```java
// Convert Binder token to service interface
IActivityManager am = IActivityManager.Stub.asInterface(binder);
```

**4. Client Uses Service:**
- Client can now call service methods
- Binder IPC handles communication
- Service processes requests

**Discovery Timing:**
- Happens on-demand when needed
- Cached by clients for performance
- Re-queried if service unavailable
- Transparent to application code

### ServiceManager API

**Native API (C/C++):**
```cpp
// Add service
status_t addService(const String16& name, const sp<IBinder>& service);

// Get service
sp<IBinder> getService(const String16& name);

// Check service
sp<IBinder> checkService(const String16& name);

// List services
Vector<String16> listServices();
```

**Java API:**
```java
// Add service
ServiceManager.addService(String name, IBinder service);

// Get service
IBinder getService(String name);

// Check service
IBinder checkService(String name);

// List services
String[] listServices();
```

**Usage Patterns:**
- Services use `addService()` to register
- Clients use `getService()` to discover
- System uses `listServices()` for debugging
- All go through ServiceManager

### ServiceManager Startup Timeline

**Typical Timeline:**
- **0ms:** Init reads service definition
- **10ms:** Init forks ServiceManager process
- **20ms:** Native code initialization
- **50ms:** Binder driver setup
- **80ms:** Service registry initialized
- **100ms:** Main loop starts
- **120ms:** ServiceManager ready
- **150ms:** First service can register

**Factors Affecting Time:**
- Device performance
- Binder driver initialization
- System load
- Storage speed

### Critical Service Handling

**Why ServiceManager is Critical:**
ServiceManager is marked as `critical` in init.rc:

**Critical Service Behavior:**
- If ServiceManager crashes, system may reboot
- Init monitors ServiceManager
- Automatic restart on crash
- System depends on ServiceManager

**Restart Impact:**
- All services become unavailable
- System Server may restart
- Apps lose service access
- System becomes non-functional

**Restart Handling:**
- Init detects ServiceManager death
- Init restarts ServiceManager
- ServiceManager reinitializes
- Services re-register (if still running)

### ServiceManager and System Server

**Relationship:**
System Server depends on ServiceManager:

**1. System Server Starts:**
- System Server starts after ServiceManager
- ServiceManager must be ready
- System Server registers its services

**2. Service Registration:**
- System Server services register with ServiceManager
- ActivityManager, WindowManager, etc.
- All get registered names
- Become discoverable

**3. Service Discovery:**
- Apps discover System Server services via ServiceManager
- Framework uses ServiceManager
- All service access goes through ServiceManager

**Dependency Chain:**
```
ServiceManager (starts first)
    ↓
System Server (starts second, registers services)
    ↓
Apps (discover services via ServiceManager)
```

### Debugging ServiceManager

**Logging:**
ServiceManager logs to logcat:
- Tag: `ServiceManager`
- Filter: `adb logcat -s ServiceManager`

**Common Issues:**
- ServiceManager not starting
- Service registration failures
- Service discovery failures
- Binder driver issues

**Debugging Tools:**
- `adb logcat` - View ServiceManager logs
- `adb shell service list` - List all services
- `adb shell dumpsys` - Service state
- `adb shell ps | grep servicemanager` - Check if running

**Service List Command:**
```bash
adb shell service list
```
Shows all registered services and their Binder tokens.

### ServiceManager Security

**Security Context:**
- Runs as system user (UID 1000)
- Has system-level permissions
- Critical for system security
- Protected by SELinux

**SELinux Policy:**
- ServiceManager has specific SELinux context
- Only authorized processes can register
- Service discovery is controlled
- Security enforced at Binder level

**Access Control:**
- Services must have permission to register
- Clients must have permission to discover
- Binder enforces permissions
- ServiceManager validates access

### ServiceManager Optimization

**Performance Considerations:**
- Fast service lookup (hash table)
- Efficient registry management
- Minimal overhead per request
- Optimized for common operations

**Memory Usage:**
- Small memory footprint
- Efficient data structures
- Minimal overhead
- Scales with number of services

**Startup Optimization:**
- Minimal initialization
- Fast startup time
- Early availability
- Critical path optimization

## Key Takeaways

1. **ServiceManager is a native service** that starts very early in boot, before System Server and most other services.

2. **ServiceManager acts as a service registry** maintaining a mapping of service names to Binder tokens for service discovery.

3. **ServiceManager must start first** because all other services depend on it to register themselves and be discovered by clients.

4. **Services register with ServiceManager** using human-readable names, making service discovery simple and intuitive.

5. **Clients discover services** by querying ServiceManager by name, receiving Binder tokens to communicate with services.

6. **ServiceManager is marked as critical** - if it crashes, the system may reboot because the system cannot function without it.

7. **ServiceManager provides the foundation** for all Binder IPC service discovery in Android.

8. **Understanding ServiceManager startup** is essential for comprehending how Android's service architecture works and how services become available to the system.

## Related Topics

- **Binder IPC Basics:** The IPC mechanism that ServiceManager supports
- **System Server Launch:** The process that registers its services with ServiceManager
- **Init System in Android:** The init system that starts ServiceManager as a service
- **Boot Process Overview:** The complete boot sequence that includes ServiceManager startup

