---
number: 12
title: Android Verified Boot 2.0 (AVB)
slug: android-verified-boot-2-0-avb
level: beginner
tags:
  - aosp
  - avb
  - verified-boot
  - security
  - boot
  - integrity
  - rollback-protection
prerequisites:
  - verified-boot-vboot
  - android-partitions
  - boot-process-overview
estimated_minutes: 90
contributors: []
diagrams: []
examples: []
canonical_id: aosp-beginner-12
---

# Android Verified Boot 2.0 (AVB)

## Overview

Android Verified Boot 2.0 (AVB) is the modern implementation of verified boot in Android, introduced in Android 8.0 (Oreo). AVB provides a standardized, flexible, and robust system for verifying the integrity of boot components and system partitions. It improves upon the original Verified Boot (vboot) with better rollback protection, more flexible verification policies, and support for A/B partitions. Understanding AVB is essential for AOSP development, as it's the current standard for boot verification and affects how devices boot, how updates are applied, and how security is maintained.

Think of AVB as an upgraded security system - while the original Verified Boot was like a basic lock, AVB is like a smart lock system with multiple security layers, rollback protection, flexible access policies, and better integration with modern Android features like A/B partitions and seamless updates.

## Deep Explanation

### What is Android Verified Boot 2.0?

Android Verified Boot 2.0 (AVB) is Google's specification and implementation for verified boot on Android devices. It provides:

1. **Standardized Verification:** Consistent verification across all Android devices
2. **Rollback Protection:** Prevents downgrade attacks using rollback indexes
3. **Flexible Policies:** Different verification modes for different use cases
4. **A/B Partition Support:** Works seamlessly with A/B partition scheme
5. **Better Integration:** Better integration with Android build system and tools

**Key Improvements over vboot:**

**1. Standardization:**
- Consistent across all devices
- Well-documented specification
- Standard tools and workflows
- Better interoperability

**2. Rollback Protection:**
- Rollback indexes prevent downgrades
- Protects against version rollback attacks
- Stored in secure hardware (when available)
- Critical for security updates

**3. Flexible Verification Modes:**
- Different modes for different partitions
- Can verify boot, system, vendor separately
- Supports different security levels
- Configurable per partition

**4. Better Tooling:**
- `avbtool` for image management
- Integration with build system
- Better debugging tools
- Standardized workflows

### AVB Architecture

#### Components

**1. AVB Footer:**
- Metadata appended to partition images
- Contains verification information
- Includes hash, signature, rollback index
- Read by bootloader/kernel

**2. AVB Hash Tree:**
- Merkle tree for partition verification
- Used by dm-verity
- Enables block-level verification
- Transparent to applications

**3. AVB Descriptors:**
- Describe partition verification method
- Hash descriptor (for small partitions)
- Hashtree descriptor (for large partitions)
- Contains verification metadata

**4. Rollback Index:**
- Prevents version rollback
- Stored per partition
- Compared against stored value
- Incremented with each update

#### AVB Verification Flow

**Complete AVB Flow:**
```
1. Bootloader loads partition
   ↓
2. Bootloader reads AVB footer
   ↓
3. Bootloader verifies AVB footer signature
   ↓
4. Bootloader checks rollback index
   ↓
5. Bootloader extracts hash/hashtree
   ↓
6. Bootloader verifies partition content
   ↓
7. If valid: Boot continues
   ↓
8. If invalid: Boot halted
```

**Each Step:**
- Cryptographic verification
- Rollback protection check
- Integrity verification
- Fail-safe behavior

### AVB Descriptors

#### Hash Descriptor

**Use Case:**
- Small partitions (boot, dtbo)
- Entire partition fits in memory
- Simple verification
- Fast verification

**Structure:**
```
Hash Descriptor:
├── Partition name
├── Partition size
├── Digest (hash of partition)
├── Flags
└── Salt (for hash)
```

**Verification:**
1. Read entire partition
2. Calculate hash
3. Compare with hash in descriptor
4. Accept if match

**Example Partitions:**
- `boot` partition
- `dtbo` partition
- Small system partitions

#### Hashtree Descriptor

**Use Case:**
- Large partitions (system, vendor)
- Partition too large for memory
- Block-level verification
- Used with dm-verity

**Structure:**
```
Hashtree Descriptor:
├── Partition name
├── Partition size
├── Hash tree offset
├── Hash tree size
├── Root hash
├── Block size
└── Salt
```

**Verification:**
1. Set up dm-verity with hashtree
2. Verify blocks as accessed
3. Transparent to applications
4. Continuous verification

**Example Partitions:**
- `system` partition
- `vendor` partition
- `product` partition
- Large read-only partitions

### AVB Footer

#### Footer Structure

**AVB Footer Format:**
```
┌─────────────────────┐
│   Partition Data    │
│   (actual content)  │
├─────────────────────┤
│   AVB Footer        │
│   (metadata)        │
└─────────────────────┘
```

**Footer Contents:**
- Magic string ("AVBf")
- Footer version
- Original partition size
- Authentication data block
- Auxiliary data block
- Descriptors
- Rollback index
- Flags

**Footer Location:**
- Appended to end of partition
- Last 64 bytes (minimum)
- Can be larger for metadata
- Read by bootloader

#### Reading AVB Footer

**From Bootloader:**
```c
// Bootloader reads footer from partition end
avb_footer footer;
read_partition_end(partition, &footer, sizeof(footer));

// Verify footer magic
if (memcmp(footer.magic, "AVBf", 4) != 0) {
    // Invalid footer
    return AVB_IO_RESULT_ERROR_NO_SUCH_PARTITION;
}
```

**From Host Tools:**
```bash
# Extract AVB footer
$ avbtool info_image --image boot.img

# Output shows:
# Footer version: 1.0
# Original partition size: 67108864
# Rollback index: 0
# Descriptors: [hash descriptor for boot]
```

### AVB Verification Modes

#### Verification Modes

**1. AVB_SLOT_VERIFY_MODE_VERIFY:**
- Full verification enabled
- All checks performed
- Production mode
- Maximum security

**2. AVB_SLOT_VERIFY_MODE_CHECK:**
- Verification checked but not enforced
- Logs violations
- Development mode
- Permissive behavior

**3. AVB_SLOT_VERIFY_MODE_LOGGING:**
- Only logging, no enforcement
- For debugging
- Development only
- Not for production

**Mode Selection:**
- Set in bootloader
- Based on device state
- Can vary by partition
- Configurable per device

#### Lock State and Verification

**Locked Bootloader:**
- Full verification enforced
- All checks mandatory
- No bypass possible
- Production security

**Unlocked Bootloader:**
- Verification can be disabled
- Warning shown
- Reduced security
- Development/testing

**Checking Lock State:**
```bash
# From fastboot
$ fastboot getvar unlocked
unlocked: no  # Locked

# From device
$ getprop ro.boot.verifiedbootstate
green  # Verified and locked
```

### Rollback Protection

#### What is Rollback Protection?

Rollback protection prevents attackers from installing older, vulnerable versions of the system. This is critical because:

1. **Security Updates:** Newer versions fix security vulnerabilities
2. **Downgrade Attacks:** Attackers might try to install vulnerable versions
3. **Version Control:** Ensures devices run current or newer versions
4. **Update Integrity:** Protects update mechanism

#### How Rollback Protection Works

**Rollback Index:**
- Each partition has a rollback index
- Incremented with each update
- Stored in secure hardware (preferred)
- Or in persistent storage

**Verification Process:**
```
1. Partition has rollback index N
2. Stored rollback index is M
3. If N >= M: Accept (newer or same)
4. If N < M: Reject (older version)
```

**Example:**
```
Current rollback index: 5
New partition index: 6
Result: Accept (6 >= 5)

Current rollback index: 5
New partition index: 3
Result: Reject (3 < 5, downgrade attempt)
```

#### Rollback Index Storage

**Secure Hardware (Preferred):**
- Stored in secure element
- Tamper-resistant
- Cannot be modified by software
- Best security

**Persistent Storage:**
- Stored in dedicated partition
- Protected by filesystem
- Can be updated securely
- Fallback option

**Storage Location:**
- Varies by device
- Usually in `misc` partition
- Or secure hardware
- Device-specific

#### Rollback Index Management

**Incrementing Index:**
```bash
# When building new image
$ avbtool add_hash_footer \
    --image system.img \
    --partition_name system \
    --rollback_index 6  # Increment from 5

# Bootloader checks:
# - New index (6) >= stored index (5)? Yes → Accept
# - Update stored index to 6
```

**Checking Rollback Index:**
```bash
# View rollback index in image
$ avbtool info_image --image system.img
Rollback index: 6

# Bootloader enforces:
# Must be >= stored value
```

### AVB and A/B Partitions

#### A/B Partition Support

AVB works seamlessly with A/B partitions:

**Dual Slot Verification:**
- Each slot verified independently
- Rollback index per slot
- Can have different versions
- Seamless updates

**Update Process:**
```
1. Device on slot A (index 5)
2. Update installs to slot B (index 6)
3. Slot B verified (index 6 >= 5) ✓
4. Device reboots to slot B
5. Slot B becomes active
6. Rollback index updated to 6
```

**Rollback Protection:**
- Each slot has own index
- Cannot downgrade either slot
- Protects both slots
- Maintains security

#### Slot Selection

**Bootloader Logic:**
```c
// Bootloader selects slot
if (slot_a_verified && slot_a_index >= stored_index) {
    boot_slot_a();
} else if (slot_b_verified && slot_b_index >= stored_index) {
    boot_slot_b();
} else {
    // Both slots invalid
    enter_recovery();
}
```

**Priority:**
- Usually boot from active slot
- Fallback to other slot if needed
- Both must pass verification
- Rollback protection applies

### AVB Tools

#### avbtool

**Purpose:**
- Create and verify AVB images
- Manage AVB metadata
- Generate keys
- Debug AVB issues

**Common Operations:**
```bash
# Add AVB footer to image
$ avbtool add_hash_footer \
    --image boot.img \
    --partition_name boot \
    --partition_size 67108864 \
    --key keys/test_key.pem \
    --algorithm SHA256_RSA2048

# Verify AVB image
$ avbtool verify_image --image boot.img

# Extract AVB info
$ avbtool info_image --image boot.img

# Make bootable image
$ avbtool make_vbmeta_image \
    --output vbmeta.img \
    --include_descriptors_from_image boot.img \
    --include_descriptors_from_image system.img \
    --key keys/test_key.pem \
    --algorithm SHA256_RSA2048
```

#### Key Generation

**Generate AVB Key:**
```bash
# Generate RSA key pair
$ openssl genrsa -out test_key.pem 2048

# Extract public key
$ avbtool extract_public_key \
    --key test_key.pem \
    --output test_key_pub.bin

# Public key goes in bootloader
# Private key used for signing
```

**Key Management:**
- Keep private keys secret
- Store public keys in bootloader
- Use different keys for different partitions (optional)
- Rotate keys if compromised

### AVB Integration

#### Build System Integration

**Android.bp Integration:**
```python
# In Android.bp
android_boot_image {
    name: "boot",
    base: "kernel",
    ramdisk: "ramdisk",
    avb_enable: true,
    avb_key: "keys/test_key.pem",
    avb_algorithm: "SHA256_RSA2048",
}
```

**Build Process:**
```
1. Build boot image
2. Add AVB footer
3. Sign with key
4. Include in build output
```

#### Bootloader Integration

**Bootloader AVB Support:**
- Bootloader must support AVB
- Reads AVB footers
- Verifies signatures
- Checks rollback indexes
- Enforces verification

**Bootloader Code:**
```c
// Bootloader verifies partition
AvbSlotVerifyResult result = avb_slot_verify(
    &ops,
    requested_partitions,
    slot_suffix,
    flags,
    &out_data);

if (result != AVB_SLOT_VERIFY_RESULT_OK) {
    // Verification failed
    show_error();
    return;
}

// Verification passed, boot
boot_kernel(out_data);
```

### Real-World Examples

#### Example 1: Booting with AVB

**Boot Sequence:**
```
1. Bootloader loads boot partition
2. Bootloader reads AVB footer
3. Bootloader verifies footer signature ✓
4. Bootloader checks rollback index (6 >= 5) ✓
5. Bootloader verifies partition hash ✓
6. Kernel loads
7. Kernel sets up dm-verity for system
8. System partition verified via dm-verity ✓
9. Android boots normally
```

**Result:**
- All AVB checks pass
- Device boots normally
- Security maintained
- Rollback protection active

#### Example 2: Rollback Attempt

**Scenario:**
- Current system: rollback index 6
- Attacker tries to install: rollback index 4

**Boot Sequence:**
```
1. Bootloader loads system partition
2. Bootloader reads AVB footer
3. Bootloader verifies footer signature ✓
4. Bootloader checks rollback index (4 >= 6?) ✗
5. Bootloader rejects partition
6. Boot halted
7. Error shown
```

**Result:**
- Rollback detected
- Boot rejected
- Security maintained
- Downgrade prevented

#### Example 3: A/B Update with AVB

**Update Process:**
```
1. Device on slot A (index 5)
2. OTA downloads update
3. Update installs to slot B
4. Slot B image has index 6
5. Bootloader verifies slot B:
   - Signature ✓
   - Rollback index (6 >= 5) ✓
   - Partition integrity ✓
6. Device reboots to slot B
7. Slot B becomes active
8. Rollback index updated to 6
```

**Result:**
- Seamless update
- AVB verification passes
- Rollback protection maintained
- Both slots protected

### AVB vs. Original Verified Boot

#### Key Differences

**1. Standardization:**
- **vboot:** Device-specific implementations
- **AVB:** Standardized specification
- **AVB:** Consistent across devices
- **AVB:** Better tooling

**2. Rollback Protection:**
- **vboot:** Limited or no rollback protection
- **AVB:** Built-in rollback protection
- **AVB:** Rollback indexes
- **AVB:** Prevents downgrade attacks

**3. Flexibility:**
- **vboot:** Rigid verification
- **AVB:** Flexible verification modes
- **AVB:** Per-partition policies
- **AVB:** Configurable security levels

**4. A/B Support:**
- **vboot:** Limited A/B support
- **AVB:** Native A/B support
- **AVB:** Dual slot verification
- **AVB:** Seamless updates

**5. Tooling:**
- **vboot:** Device-specific tools
- **AVB:** Standard `avbtool`
- **AVB:** Build system integration
- **AVB:** Better debugging

### Best Practices

#### For System Developers

**1. Always Use AVB:**
- Use AVB for all partitions
- Follow AVB specification
- Use standard tools
- Test thoroughly

**2. Implement Rollback Protection:**
- Always increment rollback index
- Store index securely
- Enforce rollback checks
- Test rollback scenarios

**3. Key Management:**
- Protect private keys
- Use secure key storage
- Rotate keys if needed
- Document key management

**4. Testing:**
- Test verification on locked bootloader
- Test rollback protection
- Test A/B scenarios
- Test failure cases

#### For Bootloader Developers

**1. Implement AVB Support:**
- Support AVB specification
- Verify all partitions
- Check rollback indexes
- Handle errors gracefully

**2. Secure Storage:**
- Store rollback indexes securely
- Use secure hardware when available
- Protect stored values
- Implement atomic updates

**3. Error Handling:**
- Show clear error messages
- Provide recovery options
- Log verification failures
- Support debugging

### Edge Cases and Pitfalls

#### Common Mistakes

**1. Forgetting Rollback Index:**
```bash
# BAD: Same index for update
$ avbtool add_hash_footer --rollback_index 5 ...
# Update also has index 5
# Result: May be rejected or cause issues

# GOOD: Increment index
$ avbtool add_hash_footer --rollback_index 6 ...
# New version has higher index
# Result: Update accepted
```

**2. Wrong Partition Size:**
```bash
# BAD: Wrong partition size
$ avbtool add_hash_footer \
    --partition_size 33554432 \  # Wrong size
    --image boot.img

# GOOD: Correct partition size
$ avbtool add_hash_footer \
    --partition_size 67108864 \  # Actual size
    --image boot.img
```

**3. Missing AVB Footer:**
```bash
# BAD: Image without AVB footer
$ fastboot flash boot boot.img
# Bootloader can't verify
# Result: Boot fails (on locked bootloader)

# GOOD: Add AVB footer first
$ avbtool add_hash_footer --image boot.img ...
$ fastboot flash boot boot.img
# Result: Boot succeeds
```

**4. Rollback Index Not Updated:**
```bash
# BAD: Stored index not updated
# New partition has index 6
# Stored index still 5
# Next boot: index 6 >= 5, but stored not updated
# Future updates may fail

# GOOD: Update stored index
# After successful boot, update stored index to 6
# Ensures future rollback protection
```

## References and Further Reading

- [AOSP AVB Documentation](https://source.android.com/docs/security/features/verifiedboot/avb)
- [AVB Specification](https://source.android.com/docs/security/features/verifiedboot/avb#avb-2-0)
- [AVB Implementation Guide](https://source.android.com/docs/security/features/verifiedboot/avb/avb-implementation)
- [Rollback Protection](https://source.android.com/docs/security/features/verifiedboot/avb/rollback-protection)
- [AVB Tools](https://source.android.com/docs/security/features/verifiedboot/avb#avbtool)

## Quiz

### Question 1
What is the primary improvement of Android Verified Boot 2.0 (AVB) over the original Verified Boot (vboot)?

**A)** Faster boot times  
**B)** Standardized specification, rollback protection, better A/B partition support, and improved tooling  
**C)** Smaller image sizes  
**D)** Reduced memory usage

**Answer: B** - AVB provides a standardized specification that works consistently across devices, built-in rollback protection to prevent downgrade attacks, native support for A/B partitions enabling seamless updates, and better tooling with `avbtool` and build system integration.

### Question 2
What is rollback protection in AVB and why is it important?

**A)** It speeds up the boot process  
**B)** It prevents attackers from installing older, vulnerable versions of the system by enforcing that partition rollback indexes must be greater than or equal to stored values  
**C)** It allows easy downgrades  
**D)** It reduces storage usage

**Answer: B** - Rollback protection uses rollback indexes that increment with each update. The bootloader verifies that new partitions have a rollback index greater than or equal to the stored value, preventing downgrade attacks where attackers might try to install older versions with known vulnerabilities.

### Question 3
What is the difference between a hash descriptor and a hashtree descriptor in AVB?

**A)** They are the same  
**B)** Hash descriptor is for small partitions that fit in memory, while hashtree descriptor is for large partitions and works with dm-verity for block-level verification  
**C)** Hash descriptor is for large partitions, hashtree is for small  
**D)** Hash descriptor is deprecated

**Answer: B** - Hash descriptors are used for small partitions (like boot, dtbo) where the entire partition can be verified by comparing a single hash. Hashtree descriptors are used for large partitions (like system, vendor) and work with dm-verity to provide block-level verification as data is accessed.

### Question 4
How does AVB work with A/B partitions?

**A)** It doesn't support A/B partitions  
**B)** Each slot is verified independently with its own rollback index, allowing seamless updates while maintaining security  
**C)** Only one slot can be verified  
**D)** A/B partitions bypass AVB verification

**Answer: B** - AVB natively supports A/B partitions by verifying each slot independently. Each slot has its own rollback index, and updates can be installed to the inactive slot while the device continues running on the active slot. After reboot, the updated slot is verified (including rollback index check) before booting.

### Question 5
What tool is used to create and manage AVB images?

**A)** `fastboot`  
**B)** `avbtool`  
**C)** `adb`  
**D)** `mkbootimg`

**Answer: B** - `avbtool` is the standard tool for creating AVB footers, verifying AVB images, managing rollback indexes, generating keys, and extracting AVB metadata. It's part of the AVB specification and is integrated into the Android build system.

## Related Topics

- [Verified Boot (vboot)](./11.%20Verified%20Boot%20(vboot).md)
- [Boot Process Overview](./03.%20Boot%20Process%20Overview.md)
- [Android Partitions](./08.%20Android%20Partitions.md)

