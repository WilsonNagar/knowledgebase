---
number: 47
title: Memory management internals
slug: memory-management-internals
level: beginner
tags:
  - aosp
  - kernel
  - memory
  - management
  - virtual-memory
  - paging
  - allocation
prerequisites:
  - differences-android-kernel-linux-kernel
  - ashmem-ion-dma-buf
  - android-architecture-complete-overview
estimated_minutes: 90
contributors: []
diagrams: []
examples: []
canonical_id: aosp-beginner-47
---

# Memory management internals

## Overview

Memory management is one of the kernel's most critical responsibilities, handling physical and virtual memory allocation, paging, swapping, and memory protection. Understanding kernel memory management internals is essential for AOSP development, as it affects system performance, application behavior, and how Android handles limited RAM. This guide provides a comprehensive overview of kernel memory management, virtual memory, physical memory allocation, paging, memory protection, and Android-specific memory management features.

Think of kernel memory management like a sophisticated library system: just as a library manages books (allocating shelf space, tracking what's checked out, organizing by category), the kernel manages memory pages (allocating physical RAM, tracking what's in use, organizing by process). The kernel must efficiently allocate limited physical memory among many processes, protect memory from unauthorized access, and optimize for performance while managing the constraints of mobile devices.

## Deep Explanation

### What is Kernel Memory Management?

Kernel memory management is the subsystem responsible for managing physical and virtual memory, allocating memory to processes, handling paging and swapping, and enforcing memory protection. It's fundamental to how the operating system works.

**Key Responsibilities:**
- **Physical Memory:** Manage physical RAM
- **Virtual Memory:** Provide virtual address spaces
- **Allocation:** Allocate memory to processes
- **Protection:** Enforce memory security
- **Optimization:** Optimize memory usage

**Why It Matters:**
- **Limited Resources:** Mobile devices have limited RAM
- **Performance:** Memory management affects performance
- **Security:** Memory protection is critical
- **Stability:** Poor management causes crashes

### Virtual Memory

#### What is Virtual Memory?

Virtual memory provides each process with its own virtual address space, independent of physical memory layout. This enables memory protection, efficient sharing, and allows processes to use more memory than physically available.

**Key Concepts:**
- **Virtual Address Space:** Each process sees large address space
- **Physical Memory:** Actual RAM pages
- **Page Tables:** Maps virtual to physical addresses
- **MMU:** Memory Management Unit translates addresses

**Benefits:**
- **Protection:** Processes can't access each other's memory
- **Sharing:** Multiple processes can share physical pages
- **Overcommitment:** Can allocate more virtual than physical
- **Flexibility:** Memory can be moved/swapped

#### Virtual Address Space

**Address Space Layout:**
```
High Address (0xFFFFFFFF)
┌─────────────────────┐
│   Kernel Space      │  (Protected, kernel-only)
├─────────────────────┤
│   Stack             │  (Grows downward)
├─────────────────────┤
│   (gap)             │
├─────────────────────┤
│   Heap              │  (Grows upward)
├─────────────────────┤
│   BSS               │  (Uninitialized data)
├─────────────────────┤
│   Data              │  (Initialized data)
├─────────────────────┤
│   Text/Code         │  (Executable code)
└─────────────────────┘
Low Address (0x00000000)
```

**Process Isolation:**
- Each process has separate virtual address space
- Process A's 0x1000 ≠ Process B's 0x1000
- Kernel enforces isolation
- MMU prevents cross-process access

#### Page Tables

**Page Table Structure:**
- Maps virtual pages to physical pages
- Hierarchical structure (multi-level)
- Stored in memory
- Cached in TLB (Translation Lookaside Buffer)

**Page Table Levels (ARM64):**
```
Virtual Address: [63:48] [47:39] [38:30] [29:21] [20:12] [11:0]
                 └─────┘ └─────┘ └─────┘ └─────┘ └─────┘ └────┘
                  unused  L0     L1      L2      L3      offset
```

**Translation Process:**
1. CPU generates virtual address
2. MMU looks up in page table
3. Finds physical page
4. Accesses physical memory
5. TLB caches translation

### Physical Memory Management

#### Page Frame Allocation

**Page Frames:**
- Physical memory divided into pages (typically 4KB)
- Each page frame can be allocated
- Kernel tracks free/used pages
- Buddy system manages allocation

**Page Frame States:**
- **Free:** Available for allocation
- **Used:** Allocated to process
- **Reserved:** Reserved for kernel
- **Cached:** File system cache

#### Buddy System

**Buddy Allocator:**
- Manages page frame allocation
- Organizes pages in power-of-2 blocks
- Fast allocation/deallocation
- Reduces fragmentation

**How It Works:**
```
Free pages organized by order (size):
Order 0: 4KB pages
Order 1: 8KB blocks
Order 2: 16KB blocks
Order 3: 32KB blocks
...
```

**Allocation:**
1. Request size determines order
2. Find free block of that order
3. If not available, split larger block
4. Allocate requested block
5. Mark as used

**Deallocation:**
1. Free allocated block
2. Check if buddy is free
3. Merge with buddy if free
4. Continue merging up orders
5. Add to free list

#### Slab Allocator

**Slab Allocator:**
- Manages small object allocation
- Reduces internal fragmentation
- Fast allocation for common sizes
- Used for kernel data structures

**Slab Caches:**
- Pre-allocated object caches
- Common sizes (kmalloc sizes)
- Per-CPU caches
- Reduces allocation overhead

**Common Slab Caches:**
- `kmalloc-8`, `kmalloc-16`, `kmalloc-32`, etc.
- Process descriptors
- File descriptors
- Network buffers

### Paging and Swapping

#### What is Paging?

Paging is the mechanism of moving pages between physical memory and storage (swap space). When physical memory is full, less-used pages can be swapped out to make room.

**Page States:**
- **Resident:** In physical memory
- **Swapped Out:** On swap device
- **Dirty:** Modified, needs writing
- **Clean:** Unmodified, can discard

#### Page Replacement

**When Memory is Full:**
1. Kernel needs to allocate page
2. No free pages available
3. Select page to evict (LRU, etc.)
4. Write to swap if dirty
5. Free page frame
6. Allocate to new request

**Replacement Algorithms:**
- **LRU (Least Recently Used):** Evict least recently used
- **Clock Algorithm:** Circular scan
- **Android:** Aggressive swapping (minimal)

#### Android and Swapping

**Android Approach:**
- Minimal swapping (if any)
- Prefers killing processes (LMK)
- Swapping is slow on flash storage
- Better to free memory by killing apps

**Why Minimal Swapping:**
- Flash storage slower than RAM
- Swapping causes lag
- Battery impact
- Better UX to kill background apps

### Memory Protection

#### Page Protection

**Protection Flags:**
- **Read (R):** Page can be read
- **Write (W):** Page can be written
- **Execute (X):** Page can be executed
- **User/Supervisor (U/S):** Access level

**Common Combinations:**
- **Code:** R-X (read, execute, no write)
- **Data:** RW- (read, write, no execute)
- **Read-only Data:** R-- (read only)
- **Stack:** RW- (read, write, no execute)

#### Memory Protection Enforcement

**MMU Enforcement:**
- MMU checks page permissions
- Violations trigger page fault
- Kernel handles fault
- Can kill process if violation

**Security Benefits:**
- Prevents code injection
- Protects kernel from userspace
- Enforces read-only code
- Prevents stack execution

### Android-Specific Memory Management

#### Low Memory Killer (LMK)

**LMK Overview:**
- Android-specific memory management
- Kills processes when memory low
- More aggressive than swapping
- Better for mobile devices

**How LMK Works:**
1. Monitor available memory
2. Compare to thresholds
3. Calculate oom_score for processes
4. Kill highest-scoring processes
5. Free memory
6. Repeat if needed

**LMK Thresholds:**
```
Foreground:    18432 KB (never kill)
Visible:       22528 KB
Secondary:     26624 KB
Hidden:        30720 KB
Content:       34816 KB
Empty:         38912 KB (kill first)
```

#### ION Memory Allocator

**ION Overview:**
- Android unified memory allocator
- Hardware-accessible memory
- Graphics and media optimized
- Replaces PMEM

**ION Heaps:**
- **System Heap:** General-purpose
- **System Contiguous:** Physically contiguous
- **Carveout Heap:** Reserved memory
- **DMA Heap:** DMA-accessible

**Use Cases:**
- Graphics frame buffers
- Media processing
- Camera buffers
- Hardware-accelerated operations

#### ashmem (Android Shared Memory)

**ashmem Overview:**
- Android shared memory allocator
- Process-to-process sharing
- Garbage-collected
- Graphics and Binder optimized

**Features:**
- Pin/unpin mechanism
- Automatic garbage collection
- Efficient sharing
- Android-optimized

### Memory Allocation APIs

#### User-Space Allocation

**malloc() / free():**
```c
void *ptr = malloc(1024);  // Allocate 1KB
free(ptr);                 // Free memory
```

**How It Works:**
1. Application calls malloc()
2. C library requests memory from kernel
3. Kernel allocates pages
4. Maps to process address space
5. Returns virtual address

**System Calls:**
- `brk()` - Adjust heap size
- `mmap()` - Map memory/ files
- `munmap()` - Unmap memory
- `mprotect()` - Change protection

#### Kernel-Space Allocation

**kmalloc() / kfree():**
```c
void *ptr = kmalloc(1024, GFP_KERNEL);
kfree(ptr);
```

**Allocation Flags:**
- `GFP_KERNEL` - Normal allocation
- `GFP_ATOMIC` - Atomic context
- `GFP_DMA` - DMA-accessible
- `GFP_HIGHMEM` - High memory

**vmalloc() / vfree():**
```c
void *ptr = vmalloc(1024 * 1024);  // Large allocation
vfree(ptr);
```

**Use Cases:**
- Large kernel allocations
- Non-contiguous memory
- Module loading
- Special cases

### Memory Statistics

#### Viewing Memory Information

**/proc/meminfo:**
```bash
cat /proc/meminfo
```

**Key Metrics:**
- `MemTotal` - Total physical memory
- `MemFree` - Free memory
- `MemAvailable` - Available memory
- `Buffers` - Buffer cache
- `Cached` - Page cache
- `SwapTotal` - Total swap
- `SwapFree` - Free swap

**/proc/pid/status:**
```bash
cat /proc/1234/status
```

**Process Memory:**
- `VmSize` - Virtual memory size
- `VmRSS` - Resident set size
- `VmData` - Data segment
- `VmStk` - Stack size

#### Android Memory Tools

**dumpsys meminfo:**
```bash
adb shell dumpsys meminfo
adb shell dumpsys meminfo <package>
```

**Information:**
- Total memory usage
- Per-process memory
- Native heap
- Dalvik heap
- Graphics memory

### Memory Optimization

#### Kernel Optimizations

**Page Cache:**
- Caches file data in memory
- Speeds up file access
- Automatically managed
- Can be reclaimed

**Memory Compaction:**
- Moves pages to create contiguous blocks
- Reduces fragmentation
- Improves allocation
- Background process

**KSM (Kernel Same-page Merging):**
- Merges identical pages
- Saves memory
- Used for virtualization
- Less common in Android

#### Android Optimizations

**Aggressive Memory Reclaim:**
- Early process killing
- Minimal caching
- Fast memory freeing
- Optimized for mobile

**Memory Pressure Handling:**
- Multiple thresholds
- Progressive killing
- Priority-based
- User experience focused

### Memory Debugging

#### Common Issues

**Memory Leaks:**
- Memory allocated but never freed
- Causes memory exhaustion
- Detect with tools
- Fix by freeing memory

**Out of Memory (OOM):**
- No memory available
- Kernel kills processes
- Check memory usage
- Optimize allocations

**Memory Fragmentation:**
- Free memory fragmented
- Can't allocate large blocks
- Compaction helps
- May need reboot

#### Debugging Tools

**Kernel Logs:**
```bash
dmesg | grep -i memory
dmesg | grep -i oom
```

**Memory Tools:**
- `free` - Memory usage
- `top` / `htop` - Process memory
- `valgrind` - Memory debugging
- `AddressSanitizer` - Memory errors

## Key Takeaways

1. **Kernel memory management** handles physical and virtual memory, allocation, paging, and protection.

2. **Virtual memory** provides each process with its own address space, enabling protection and efficient memory sharing.

3. **Physical memory** is managed by the buddy system (pages) and slab allocator (small objects).

4. **Paging and swapping** move pages between RAM and storage, though Android minimizes swapping in favor of process killing.

5. **Memory protection** is enforced by the MMU using page table permissions (read, write, execute).

6. **Android-specific features** include Low Memory Killer (LMK), ION allocator, and ashmem for specialized memory needs.

7. **Memory allocation** uses system calls (brk, mmap) from userspace and kmalloc/vmalloc in kernel space.

8. **Understanding memory management** is essential for performance optimization, debugging memory issues, and AOSP development.

## Related Topics

- **Differences between Android kernel & Linux kernel:** Android-specific memory management features
- **ashmem, ion, dma-buf:** Android memory allocators
- **Low Memory Killer (LMK) / ActivityManager interactions:** How Android manages low memory
- **Android Architecture - Complete Overview:** How memory management fits into Android architecture

