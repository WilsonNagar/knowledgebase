---
number: 50
title: Low Memory Killer (LMK) / ActivityManager interactions
slug: low-memory-killer-lmk-activitymanager-interactions
level: beginner
tags:
  - aosp
  - kernel
  - lmk
  - low-memory-killer
  - activitymanager
  - oom
  - process-management
prerequisites:
  - memory-management-internals
  - system-server-overview
  - android-architecture-complete-overview
estimated_minutes: 90
contributors: []
diagrams: []
examples: []
canonical_id: aosp-beginner-50
---

# Low Memory Killer (LMK) / ActivityManager interactions

## Overview

Low Memory Killer (LMK) is Android's kernel-level mechanism for killing processes when memory becomes scarce, working in coordination with ActivityManagerService to manage process priorities and determine which processes to kill. Understanding LMK and its interaction with ActivityManager is essential for AOSP development, as it directly affects app lifecycle, memory management, and system stability. This guide provides a comprehensive overview of LMK, oom_adj scoring, ActivityManager interactions, process priorities, and how Android manages low memory situations.

Think of LMK and ActivityManager like a hospital's triage system: just as a hospital triage system prioritizes patients based on severity and available resources, LMK and ActivityManager work together to prioritize processes based on importance and available memory. When resources (memory) are limited, the system must make difficult decisions about which processes (patients) to keep running and which to terminate to ensure critical processes (foreground apps) continue functioning.

## Deep Explanation

### What is Low Memory Killer (LMK)?

Low Memory Killer is an Android kernel driver that monitors available memory and kills processes when memory falls below certain thresholds. It's more aggressive than standard Linux OOM killer and is optimized for mobile devices with limited RAM.

**Key Characteristics:**
- **Kernel-Level:** Implemented as kernel driver
- **Proactive:** Kills before OOM condition
- **Priority-Based:** Uses oom_adj scores
- **Android-Specific:** Not in mainline Linux

**Why LMK?**
- **Limited RAM:** Mobile devices have limited memory
- **Better UX:** Kill background apps before system hangs
- **Proactive:** Prevent OOM conditions
- **Mobile-Optimized:** Better than swapping for mobile

### How LMK Works

#### LMK Process Flow

**1. Memory Monitoring:**
- LMK continuously monitors available memory
- Compares against configured thresholds
- Triggers when memory falls below threshold

**2. Process Scoring:**
- Calculates oom_score for each process
- Based on oom_adj and memory usage
- Higher score = more likely to be killed

**3. Process Selection:**
- Selects process with highest oom_score
- Kills selected process
- Frees memory

**4. Iteration:**
- Repeats until memory sufficient
- Stops when memory above threshold
- May kill multiple processes

#### LMK Thresholds

**Memory Pressure Levels:**
```
Foreground:    18432 KB (18 MB) - Never kill
Visible:       22528 KB (22 MB) - Kill empty processes
Secondary:     26624 KB (26 MB) - Kill cached apps
Hidden:        30720 KB (30 MB) - Kill background apps
Content:       34816 KB (34 MB) - Kill more background
Empty:         38912 KB (38 MB) - Kill empty processes first
```

**Threshold Behavior:**
- When memory falls below threshold, kill processes at that level and below
- Multiple thresholds allow progressive killing
- Lower thresholds kill less important processes first
- Higher thresholds kill more important processes

**Configurable:**
- Thresholds can be adjusted per device
- Based on device RAM size
- Tuned for device characteristics
- Stored in `/sys/module/lowmemorykiller/parameters/`

### OOM Scoring System

#### OOM_ADJ Values

**OOM_ADJ Range:**
- -1000 to 1000
- Lower value = less likely to be killed
- Higher value = more likely to be killed
- Set by ActivityManagerService

**System Processes:**
```
-1000: System processes (never killed)
-900:  Core system services
-800:  Persistent services
-700:  System services
```

**App Processes:**
```
0:     Foreground app (user interacting)
100:   Visible app (visible but not foreground)
200:   Perceptible app (background music, etc.)
300:   Service (background service)
400:   Home app (launcher)
500:   Previous app (recently used)
600:   Background app
700:   Cached app (empty process)
```

#### OOM Score Calculation

**Base Score:**
- Calculated from memory usage
- Higher memory usage = higher score
- Considers RSS (Resident Set Size)
- Accounts for shared memory

**Final Score:**
```
oom_score = base_oom_score + oom_adj
```

**Scoring Factors:**
- Memory usage (RSS)
- Process importance (oom_adj)
- Time running
- Child processes

**Selection:**
- Process with highest oom_score is killed
- Multiple processes may be killed
- Continues until memory sufficient

### ActivityManagerService Integration

#### ActivityManager Role

**Process Management:**
- Tracks all app processes
- Manages process lifecycle
- Updates oom_adj values
- Communicates with LMK

**Priority Management:**
- Determines process importance
- Updates oom_adj based on app state
- Responds to app lifecycle changes
- Maintains priority hierarchy

#### OOM_ADJ Updates

**When Updated:**
- App state changes (foreground/background)
- Component state changes
- Service start/stop
- Activity lifecycle changes

**Update Process:**
1. ActivityManager detects state change
2. Calculates new oom_adj value
3. Writes to `/proc/<pid>/oom_score_adj`
4. Kernel updates oom_score
5. LMK uses updated score

**State-Based Updates:**
```
Foreground Activity → oom_adj = 0
Visible Activity → oom_adj = 100
Background Service → oom_adj = 300
Background App → oom_adj = 600
Empty Process → oom_adj = 700
```

### Process Priority Hierarchy

#### Android Process Importance

**1. Foreground Process:**
- User is interacting with app
- Highest priority
- oom_adj = 0
- Never killed by LMK

**2. Visible Process:**
- App has visible activity
- High priority
- oom_adj = 100
- Killed only in extreme memory pressure

**3. Service Process:**
- Running background service
- Medium priority
- oom_adj = 300-400
- Killed when memory low

**4. Background Process:**
- App in background
- Low priority
- oom_adj = 600
- Killed when memory low

**5. Empty Process:**
- No active components
- Lowest priority
- oom_adj = 700
- Killed first when memory low

#### Component-Based Priority

**Activity Components:**
- Foreground activity → higher priority
- Visible activity → medium priority
- Background activity → lower priority

**Service Components:**
- Foreground service → higher priority
- Background service → lower priority
- Bound service → depends on binding process

**Broadcast Receivers:**
- Currently executing → temporary priority boost
- Not executing → no priority impact

### LMK Implementation

#### Kernel Driver

**Location:**
- `drivers/staging/android/lowmemorykiller.c`
- Android-specific kernel driver
- Not in mainline Linux
- Loaded as module or built-in

**Key Functions:**
- `lowmem_shrink()` - Memory pressure handler
- `lowmem_scan()` - Process scanning
- `lowmem_kill()` - Process killing

**Integration:**
- Registered with shrinker framework
- Called when memory pressure detected
- Scans processes and kills highest score

#### Shrinker Framework

**What is Shrinker?**
- Kernel framework for memory reclaim
- Allows subsystems to free memory
- Called when memory pressure
- LMK registered as shrinker

**Shrinker Callback:**
```c
static unsigned long lowmem_scan(struct shrinker *s,
                                  struct shrink_control *sc)
{
    // Scan processes
    // Calculate scores
    // Kill highest score
    // Return freed pages
}
```

### ActivityManager Process Management

#### Process Tracking

**ProcessRecord:**
- Tracks each app process
- Maintains process state
- Stores oom_adj value
- Links to app components

**ProcessList:**
- Manages all processes
- Maintains priority order
- Updates oom_adj values
- Coordinates with LMK

#### Priority Updates

**updateOomAdjLocked():**
- Main function for updating priorities
- Called on state changes
- Calculates new oom_adj
- Writes to kernel

**Update Triggers:**
- Activity state changes
- Service start/stop
- Process binding
- Component visibility changes

**Update Process:**
1. Scan all processes
2. Determine importance
3. Calculate oom_adj
4. Write to `/proc/<pid>/oom_score_adj`
5. Kernel updates oom_score

### LMK Configuration

#### Threshold Configuration

**Location:**
```
/sys/module/lowmemorykiller/parameters/minfree
```

**Format:**
```
18432,22528,26624,30720,34816,38912
```

**Values:**
- Comma-separated list
- In pages (typically 4KB per page)
- Six thresholds
- Device-specific

**Setting Thresholds:**
```bash
# Set thresholds (in pages)
echo "18432,22528,26624,30720,34816,38912" > \
    /sys/module/lowmemorykiller/parameters/minfree
```

#### OOM_ADJ Mapping

**Location:**
```
/sys/module/lowmemorykiller/parameters/adj
```

**Format:**
```
0,100,200,300,400,700
```

**Mapping:**
- Maps to minfree thresholds
- First threshold → first adj value
- Defines which processes killed at each threshold

**Example:**
```
minfree: 18432,22528,26624,30720,34816,38912
adj:     0,100,200,300,400,700

At 18432 KB: Kill processes with oom_adj >= 0
At 22528 KB: Kill processes with oom_adj >= 100
At 26624 KB: Kill processes with oom_adj >= 200
...
```

### Process Killing

#### Kill Process

**Kill Signal:**
- LMK sends SIGKILL to process
- Process cannot catch or ignore
- Immediate termination
- No cleanup opportunity

**Kill Process:**
```c
// Send SIGKILL
send_sig(SIGKILL, selected_process, 0);
```

**Memory Reclamation:**
- Process memory freed
- Pages returned to system
- Memory available for allocation
- System continues operation

#### Process Death Handling

**App Recovery:**
- App may be restarted later
- State should be saved
- User may return to app
- System restores if needed

**State Preservation:**
- Activity state saved
- Service may restart
- Data should be persisted
- User experience maintained

### Interaction Flow

#### Complete Flow

**1. Memory Pressure:**
- Available memory decreases
- Falls below threshold
- LMK triggered

**2. Process Scanning:**
- LMK scans all processes
- Reads oom_score for each
- Finds highest score

**3. Process Selection:**
- Selects process with highest oom_score
- Verifies it's killable
- Proceeds with kill

**4. Process Killing:**
- Sends SIGKILL
- Process terminated
- Memory freed

**5. ActivityManager Notification:**
- Kernel notifies ActivityManager
- ActivityManager updates process list
- May restart process if needed
- Updates UI if necessary

### Debugging LMK

#### Viewing LMK Activity

**Kernel Logs:**
```bash
dmesg | grep -i "lowmemory\|oom"
```

**Process Information:**
```bash
# View oom_score
cat /proc/<pid>/oom_score

# View oom_adj
cat /proc/<pid>/oom_score_adj

# View oom_adj (old)
cat /proc/<pid>/oom_adj
```

**LMK Statistics:**
```bash
# View thresholds
cat /sys/module/lowmemorykiller/parameters/minfree

# View adj mapping
cat /sys/module/lowmemorykiller/parameters/adj
```

#### Common Issues

**Too Aggressive:**
- Kills processes too early
- Poor user experience
- Adjust thresholds
- Review oom_adj values

**Not Aggressive Enough:**
- System runs out of memory
- OOM conditions
- Increase thresholds
- Review process priorities

**Wrong Processes Killed:**
- Important processes killed
- Check oom_adj values
- Review ActivityManager logic
- Verify process states

### Best Practices

#### For App Developers

**Save State:**
- Save important state
- Handle process death
- Restore on restart
- Maintain user experience

**Release Resources:**
- Release memory when not needed
- Close unused resources
- Minimize memory footprint
- Lower oom_score

**Background Work:**
- Use appropriate services
- Consider foreground services
- Batch operations
- Minimize background memory

#### For System Developers

**Threshold Tuning:**
- Tune for device RAM
- Balance responsiveness and memory
- Test thoroughly
- Monitor system behavior

**Priority Management:**
- Ensure correct priorities
- Update on state changes
- Verify oom_adj values
- Test edge cases

## Key Takeaways

1. **Low Memory Killer (LMK)** is an Android kernel driver that proactively kills processes when memory falls below thresholds to prevent OOM conditions.

2. **OOM scoring system** uses oom_adj values (-1000 to 1000) to determine process kill priority, with lower values being less likely to be killed.

3. **ActivityManagerService** manages process priorities and updates oom_adj values based on app state (foreground, visible, background, etc.).

4. **LMK thresholds** define memory pressure levels at which processes of different priorities are killed, allowing progressive memory reclamation.

5. **Process priority hierarchy** ranges from foreground processes (never killed) to empty processes (killed first), based on component state.

6. **LMK and ActivityManager work together** to manage memory: ActivityManager sets priorities, LMK enforces them by killing processes when needed.

7. **Process killing** is immediate (SIGKILL) and apps should save state to handle unexpected termination gracefully.

8. **Understanding LMK** is essential for app development, system tuning, and ensuring good user experience under memory pressure.

## Related Topics

- **Memory management internals:** How LMK fits into kernel memory management
- **System Server Overview:** How ActivityManagerService manages processes
- **Android Architecture - Complete Overview:** How LMK fits into Android architecture
- **Process Lifecycle:** How apps handle process death from LMK

