---
number: 27
title: Understanding Android.bp Files
slug: understanding-android-bp-files
level: beginner
tags:
  - aosp
  - android.bp
  - soong
  - blueprint
  - build
  - modules
  - practical
prerequisites:
  - blueprint-language-fundamentals
  - soong-build-system
estimated_minutes: 85
contributors: []
diagrams: []
examples: []
canonical_id: aosp-beginner-27
---

# Understanding Android.bp Files

## Overview

Android.bp files are the modern way to describe Android build modules using the Blueprint language. They replace Android.mk files for new code and provide a simpler, more maintainable way to define how modules are built. Understanding how to write and work with Android.bp files is essential for AOSP development, as it's the preferred method for defining new modules and the direction Android is moving toward. This guide provides a practical, hands-on approach to understanding and writing Android.bp files.

Think of Android.bp files like recipe cards in a modern kitchen: each card (Android.bp file) describes how to make a dish (build a module) using clear, standardized instructions (Blueprint syntax). Unlike old handwritten recipes (Android.mk), these modern recipe cards are easier to read, have better formatting, and include all the information needed in a structured way.

## Deep Explanation

### What are Android.bp Files?

Android.bp files are build description files that use Blueprint language syntax to define how Android modules are built. They're processed by Soong to generate build rules and are the modern replacement for Android.mk files.

**Key Characteristics:**
- **File Extension:** `.bp` (Android.bp)
- **Language:** Blueprint
- **Purpose:** Define build modules
- **Processor:** Soong
- **Location:** Same directory as source code

**File Naming:**
- Standard name: `Android.bp`
- One file per directory (usually)
- Contains one or more module definitions
- Soong automatically discovers them

**Why Android.bp?**
- Simpler than Android.mk
- More readable
- Type-safe
- Better tooling support
- Modern build system

### Android.bp File Structure

#### Basic File Layout

**Simple Example:**
```blueprint
// Android.bp
cc_library {
    name: "mylib",
    srcs: ["file1.c", "file2.c"],
    shared_libs: ["liblog"],
}
```

**File Components:**
1. **Comments** (optional) - Documentation
2. **Module Definitions** - One or more modules
3. **Properties** - Module configuration

#### Multiple Modules in One File

**Multiple Modules:**
```blueprint
// Android.bp - Multiple modules

cc_library {
    name: "libcommon",
    srcs: ["common.c"],
}

cc_library {
    name: "libspecific",
    srcs: ["specific.c"],
    static_libs: ["libcommon"],
}

cc_binary {
    name: "mytool",
    srcs: ["main.c"],
    static_libs: ["libcommon", "libspecific"],
}
```

**When to Use:**
- Related modules in same directory
- Shared configuration
- Logical grouping
- Convenience

### Common Module Types in Android.bp

#### C/C++ Libraries

**Shared Library:**
```blueprint
cc_library {
    name: "libmymodule",
    srcs: [
        "src/file1.c",
        "src/file2.cpp",
    ],
    shared_libs: [
        "liblog",
        "libutils",
    ],
    cflags: ["-Wall", "-Werror"],
    export_include_dirs: ["include"],
}
```

**Static Library:**
```blueprint
cc_library_static {
    name: "libmystatic",
    srcs: ["file.c"],
    cflags: ["-Wall"],
}
```

**Key Properties:**
- `name` - Module name (required)
- `srcs` - Source files
- `shared_libs` - Runtime dependencies
- `static_libs` - Link-time dependencies
- `cflags` - Compilation flags

#### C/C++ Executables

**Binary:**
```blueprint
cc_binary {
    name: "mytool",
    srcs: [
        "main.c",
        "utils.c",
    ],
    shared_libs: [
        "liblog",
        "libcutils",
    ],
    cflags: ["-Wall"],
}
```

**Key Properties:**
- Similar to libraries
- Produces executable
- Can have `main()` function
- Installed to system/bin

#### Java Libraries

**Java Library:**
```blueprint
java_library {
    name: "mylib",
    srcs: [
        "src/**/*.java",
    ],
    static_libs: [
        "android-support-v4",
    ],
}
```

**Static Java Library:**
```blueprint
java_library_static {
    name: "mystaticlib",
    srcs: ["file.java"],
}
```

**Key Properties:**
- `srcs` - Java source files
- `static_libs` - Java library dependencies
- Produces JAR file

#### Android Applications

**Android App:**
```blueprint
android_app {
    name: "MyApp",
    srcs: [
        "src/**/*.java",
    ],
    resource_dirs: ["res"],
    manifest: "AndroidManifest.xml",
    static_libs: [
        "android-support-v4",
    ],
    platform_apis: true,
    certificate: "platform",
}
```

**Key Properties:**
- `name` - App name
- `srcs` - Java/Kotlin sources
- `resource_dirs` - Resource directories
- `manifest` - AndroidManifest.xml
- `certificate` - Signing certificate

### Property Patterns

#### Source File Patterns

**Glob Patterns:**
```blueprint
srcs: [
    "src/**/*.java",        // All Java files recursively
    "src/**/*.kt",          // All Kotlin files
    "src/main/**/*.cpp",    // C++ files in main/
],
```

**Explicit Files:**
```blueprint
srcs: [
    "file1.c",
    "file2.c",
    "subdir/file3.c",
],
```

**Exclude Patterns:**
```blueprint
exclude_srcs: [
    "file_to_exclude.c",
    "test/**/*.c",
],
```

#### Dependency Patterns

**Shared Libraries:**
```blueprint
shared_libs: [
    "liblog",      // System library
    "libutils",    // Framework library
    "libmylib",    // Custom library
],
```

**Static Libraries:**
```blueprint
static_libs: [
    "libmystatic",
    "libanother",
],
```

**Header Libraries:**
```blueprint
header_libs: [
    "libheaders",  // Header-only dependency
],
```

**Whole Static Libraries:**
```blueprint
whole_static_libs: [
    "libwhole",    // Whole archive linking
],
```

#### Compilation Flags

**C Flags:**
```blueprint
cflags: [
    "-Wall",
    "-Werror",
    "-O2",
    "-DDEBUG=1",
],
```

**C++ Flags:**
```blueprint
cppflags: [
    "-std=c++11",
    "-fno-exceptions",
],
```

**Architecture-Specific:**
```blueprint
arch: {
    arm: {
        cflags: ["-marm"],
    },
    x86: {
        cflags: ["-m32"],
    },
},
```

### Advanced Android.bp Patterns

#### Conditional Compilation

**Target-Specific:**
```blueprint
cc_library {
    name: "mylib",
    srcs: ["common.c"],
    target: {
        android: {
            srcs: ["android.c"],
        },
        host: {
            srcs: ["host.c"],
        },
    },
}
```

**Variant-Specific:**
```blueprint
cc_library {
    name: "mylib",
    variant: {
        eng: {
            cflags: ["-DDEBUG"],
        },
        user: {
            cflags: ["-DRELEASE"],
        },
    },
}
```

#### Generated Sources

**Using Genrule:**
```blueprint
genrule {
    name: "generate_version",
    cmd: "echo '#define VERSION \"1.0\"' > $(out)",
    out: ["version.h"],
}

cc_library {
    name: "mylib",
    generated_headers: [":generate_version"],
    srcs: ["file.c"],
}
```

#### Prebuilt Modules

**Prebuilt Library:**
```blueprint
cc_prebuilt_library {
    name: "libprebuilt",
    srcs: ["libprebuilt.so"],
    export_include_dirs: ["include"],
}
```

**Prebuilt Binary:**
```blueprint
cc_prebuilt_binary {
    name: "prebuilttool",
    srcs: ["tool"],
}
```

### File Organization

#### Directory Structure

**Typical Layout:**
```
mymodule/
├── Android.bp          # Build file
├── src/                # Source files
│   ├── file1.c
│   └── file2.c
├── include/            # Headers
│   └── mymodule.h
└── AndroidManifest.xml # (for apps)
```

**Android.bp Location:**
- Same directory as source code
- One Android.bp per directory (usually)
- Contains module definitions for that directory

#### Module Naming

**Naming Conventions:**
- Libraries: `lib<name>` (e.g., `libmymodule`)
- Binaries: `<name>` (e.g., `mytool`)
- Apps: `<Name>` (e.g., `MyApp`)
- Be descriptive and consistent

**Name Conflicts:**
- Module names must be unique
- Use descriptive names
- Follow conventions
- Avoid conflicts

### Real-World Examples

#### Example 1: System Library

```blueprint
// frameworks/native/libs/mymodule/Android.bp
cc_library {
    name: "libmymodule",
    srcs: [
        "src/file1.cpp",
        "src/file2.cpp",
    ],
    shared_libs: [
        "liblog",
        "libutils",
        "libbinder",
    ],
    export_include_dirs: ["include"],
    cflags: [
        "-Wall",
        "-Werror",
        "-Wextra",
    ],
    cppflags: ["-std=c++14"],
    vendor: false,
}
```

#### Example 2: System Application

```blueprint
// packages/apps/MyApp/Android.bp
android_app {
    name: "MyApp",
    srcs: [
        "src/**/*.java",
    ],
    resource_dirs: ["res"],
    manifest: "AndroidManifest.xml",
    static_libs: [
        "android-support-v4",
        "android-support-v7-appcompat",
    ],
    platform_apis: true,
    certificate: "platform",
    privileged: true,
}
```

#### Example 3: Native Tool

```blueprint
// system/core/mytool/Android.bp
cc_binary {
    name: "mytool",
    srcs: [
        "main.c",
        "utils.c",
    ],
    shared_libs: [
        "liblog",
        "libcutils",
        "libbase",
    ],
    cflags: [
        "-Wall",
        "-Werror",
    ],
}
```

### Common Patterns and Best Practices

#### Property Ordering

**Recommended Order:**
1. `name` (required, first)
2. `srcs` (source files)
3. Dependencies (`shared_libs`, `static_libs`)
4. Flags (`cflags`, `cppflags`)
5. Includes (`include_dirs`, `export_include_dirs`)
6. Other properties
7. `visibility` (last)

**Example:**
```blueprint
cc_library {
    name: "mylib",
    srcs: ["file.c"],
    shared_libs: ["liblog"],
    cflags: ["-Wall"],
    include_dirs: ["include"],
    export_include_dirs: ["include"],
    visibility: [":__subpackages__"],
}
```

#### Module Organization

**Best Practices:**
- One module per Android.bp (when possible)
- Group related modules together
- Use clear, descriptive names
- Follow AOSP conventions

**File Organization:**
- Keep Android.bp near sources
- Organize sources logically
- Use subdirectories for large modules
- Maintain consistency

#### Dependency Management

**Best Practices:**
- Declare all dependencies
- Use correct dependency types
- Avoid unnecessary dependencies
- Keep dependencies minimal

**Dependency Types:**
- `shared_libs` - Runtime dependencies
- `static_libs` - Link-time dependencies
- `header_libs` - Header-only dependencies
- `whole_static_libs` - Whole archive

### Migration from Android.mk

#### Conversion Process

**Step 1: Identify Module Type**
- `BUILD_SHARED_LIBRARY` → `cc_library`
- `BUILD_STATIC_LIBRARY` → `cc_library_static`
- `BUILD_EXECUTABLE` → `cc_binary`
- `BUILD_PACKAGE` → `android_app`

**Step 2: Convert Properties**
- `LOCAL_MODULE` → `name`
- `LOCAL_SRC_FILES` → `srcs`
- `LOCAL_SHARED_LIBRARIES` → `shared_libs`
- `LOCAL_STATIC_LIBRARIES` → `static_libs`
- `LOCAL_CFLAGS` → `cflags`
- `LOCAL_C_INCLUDES` → `include_dirs`

**Step 3: Test Build**
- Build with Soong
- Verify output
- Check dependencies
- Test functionality

#### Example Conversion

**Android.mk:**
```makefile
LOCAL_PATH := $(call my-dir)
include $(CLEAR_VARS)
LOCAL_MODULE := libmymodule
LOCAL_SRC_FILES := file1.c file2.c
LOCAL_SHARED_LIBRARIES := liblog libutils
LOCAL_CFLAGS := -Wall -Werror
include $(BUILD_SHARED_LIBRARY)
```

**Android.bp:**
```blueprint
cc_library {
    name: "libmymodule",
    srcs: ["file1.c", "file2.c"],
    shared_libs: ["liblog", "libutils"],
    cflags: ["-Wall", "-Werror"],
}
```

### Debugging Android.bp Files

#### Common Errors

**Syntax Errors:**
```blueprint
// Missing comma
cc_library {
    name: "mylib"
    srcs: ["file.c"],  // Error
}
```

**Type Errors:**
```blueprint
// Wrong type
cc_library {
    name: ["mylib"],  // Error: should be string
}
```

**Missing Properties:**
```blueprint
// Missing required property
cc_library {
    srcs: ["file.c"],  // Error: name is required
}
```

#### Error Messages

**Soong Provides:**
- Clear error messages
- File and line numbers
- Property name in error
- Suggested fixes

**Reading Errors:**
- Check file path
- Check line number
- Read error message
- Fix syntax/type issues

### Android.bp File Tools

#### Validation

**Build Test:**
```bash
m mymodule  # Build specific module
```

**Syntax Check:**
- Soong validates on parse
- Errors shown immediately
- Type checking included
- Dependency validation

#### Documentation

**Module Documentation:**
- Soong generates docs
- Module type reference
- Property descriptions
- Examples

**Accessing Docs:**
```bash
soong_docs  # Generate documentation
```

### Android.bp vs Android.mk

#### Comparison

**Android.mk:**
- Make syntax
- More verbose
- Harder to read
- Legacy system

**Android.bp:**
- Blueprint syntax
- Simpler
- More readable
- Modern system

#### When to Use What

**Use Android.bp:**
- New modules
- New code
- Preferred method
- Modern development

**Use Android.mk:**
- Legacy modules
- During migration
- When Soong doesn't support feature
- Temporary compatibility

## Key Takeaways

1. **Android.bp files** are the modern way to define Android build modules using Blueprint language syntax.

2. **Android.bp files** are processed by Soong and provide a simpler, more maintainable alternative to Android.mk files.

3. **Common module types** include `cc_library`, `cc_binary`, `java_library`, and `android_app` for different build outputs.

4. **Property patterns** like `srcs`, `shared_libs`, and `cflags` are used consistently across module types.

5. **File organization** follows AOSP conventions with Android.bp files located alongside source code.

6. **Migration from Android.mk** involves converting module types and properties to Blueprint syntax.

7. **Best practices** include proper property ordering, clear naming, and correct dependency management.

8. **Understanding Android.bp files** is essential for modern AOSP development and working with the Soong build system.

## Related Topics

- **Blueprint Language Fundamentals:** The language syntax used in Android.bp files
- **Soong Build System:** The build system that processes Android.bp files
- **Build System Structure:** The overall build system architecture
- **Build Variants & Product Flavors:** How to configure different build variants

