---
number: 35
title: 'Building boot.img, system.img manually'
slug: building-boot-img-system-img-manually
level: beginner
tags:
  - aosp
  - boot.img
  - system.img
  - image
  - building
  - manual
  - partitions
prerequisites:
  - build-system-structure
  - android-partitions
  - boardconfig
estimated_minutes: 90
contributors: []
diagrams: []
examples: []
canonical_id: aosp-beginner-35
---

# Building boot.img, system.img manually

## Overview

Building boot.img and system.img manually involves creating Android partition images outside of the standard build process. Understanding how to build these images manually is essential for AOSP development, debugging build issues, creating custom images, and understanding how Android system images are constructed. This guide provides a comprehensive overview of manually building boot and system images, the tools involved, and the processes required.

Think of building images manually like assembling a custom car from parts: instead of using the automated assembly line (standard build), you manually select each component (kernel, ramdisk, system files), assemble them in the right order (create partitions), and package them into the final product (flashable images). This gives you complete control and understanding of what goes into each image.

## Deep Explanation

### What are boot.img and system.img?

**boot.img:**
- Contains kernel, device tree, and initramfs
- Booted by bootloader
- Critical for system startup
- Architecture-specific

**system.img:**
- Contains Android system partition
- Framework, apps, libraries
- Read-only system files
- Complete Android system

**Why Build Manually?**
- **Understanding:** Learn how images are created
- **Debugging:** Troubleshoot build issues
- **Customization:** Create custom images
- **Control:** Full control over contents

### boot.img Structure

#### Components

**Kernel:**
- Linux kernel binary
- Architecture-specific
- Device-specific configuration
- Booted by bootloader

**Device Tree:**
- Hardware description
- Device Tree Blob (DTB)
- Hardware configuration
- Device-specific

**Initramfs:**
- Initial RAM filesystem
- Early boot files
- Init scripts
- Boot-time resources

**Ramdisk:**
- Root filesystem for early boot
- Init process
- Early system files
- Boot scripts

#### boot.img Format

**Android Boot Image Format:**
- Header with metadata
- Kernel image
- Ramdisk image
- Second stage (optional)
- Device tree (if separate)

**Header Fields:**
- Magic number
- Kernel size and address
- Ramdisk size and address
- Page size
- Tags address

### Building boot.img Manually

#### Step 1: Prepare Components

**Kernel:**
```bash
# Build kernel
cd kernel/
make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- defconfig
make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu-
# Result: arch/arm64/boot/Image
```

**Device Tree:**
```bash
# Build device tree
dtc -I dts -O dtb -o device.dtb device.dts
# Or from kernel:
make ARCH=arm64 dtbs
# Result: *.dtb files
```

**Ramdisk:**
```bash
# Create ramdisk directory
mkdir ramdisk
cd ramdisk

# Create initramfs structure
mkdir -p bin sbin etc proc sys dev

# Copy init
cp /path/to/init .

# Create initramfs
find . | cpio -o -H newc | gzip > ../initramfs.cpio.gz
```

#### Step 2: Use mkbootimg

**mkbootimg Tool:**
```bash
mkbootimg \
    --kernel Image \
    --ramdisk initramfs.cpio.gz \
    --dtb device.dtb \
    --base 0x80000000 \
    --pagesize 4096 \
    --kernel_offset 0x00008000 \
    --ramdisk_offset 0x01000000 \
    --dtb_offset 0x01f00000 \
    --tags_offset 0x00000100 \
    --cmdline "console=ttyMSM0,115200,n8" \
    --output boot.img
```

**Parameters:**
- `--kernel` - Kernel image path
- `--ramdisk` - Ramdisk image path
- `--dtb` - Device tree blob
- `--base` - Base address
- `--pagesize` - Page size (usually 4096)
- `--output` - Output boot.img

#### Step 3: Verify boot.img

**unpackbootimg:**
```bash
unpackbootimg -i boot.img -o output/
```

**Check Contents:**
- Verify header
- Check kernel size
- Verify ramdisk
- Validate format

### system.img Structure

#### Components

**System Files:**
- Framework JARs
- System apps (APKs)
- Native libraries (.so)
- System binaries
- Configuration files

**Directory Structure:**
```
system/
├── app/          # System apps
├── framework/    # Framework JARs
├── lib/          # Native libraries (32-bit)
├── lib64/        # Native libraries (64-bit)
├── bin/          # System binaries
├── etc/          # Configuration files
└── ...
```

#### system.img Format

**Image Types:**
- **Raw ext4:** Raw ext4 filesystem image
- **Sparse:** Sparse image format (compressed)
- **File-based:** File-based system image

**Sparse Format:**
- Compressed ext4 image
- Smaller file size
- Faster flashing
- Standard format

### Building system.img Manually

#### Step 1: Prepare System Directory

**Create Structure:**
```bash
mkdir -p system/{app,framework,lib,lib64,bin,etc}
```

**Copy System Files:**
```bash
# Copy framework JARs
cp -r frameworks/base/out/*.jar system/framework/

# Copy system apps
cp -r packages/apps/*/out/*.apk system/app/

# Copy native libraries
cp -r out/target/product/device/system/lib/* system/lib/
cp -r out/target/product/device/system/lib64/* system/lib64/

# Copy binaries
cp -r out/target/product/device/system/bin/* system/bin/
```

#### Step 2: Set Permissions

**Set Ownership:**
```bash
# Set ownership
sudo chown -R root:root system/

# Set permissions
find system/ -type d -exec chmod 755 {} \;
find system/ -type f -exec chmod 644 {} \;
find system/bin -type f -exec chmod 755 {} \;
```

**SELinux Contexts:**
```bash
# Set SELinux contexts (if needed)
# Use setfiles or restorecon
```

#### Step 3: Create ext4 Image

**Using make_ext4fs:**
```bash
make_ext4fs \
    -s \
    -l 3221225472 \
    -a system \
    system.img \
    system/
```

**Parameters:**
- `-s` - Create sparse image
- `-l` - Image size (in bytes)
- `-a` - Mount point
- Output file
- Source directory

**Using mke2fs:**
```bash
# Create empty image
dd if=/dev/zero of=system.img bs=1M count=3072

# Create filesystem
mke2fs -t ext4 -b 4096 system.img

# Mount and copy
sudo mount -o loop system.img /mnt
sudo cp -r system/* /mnt/
sudo umount /mnt
```

#### Step 4: Convert to Sparse (Optional)

**img2simg:**
```bash
img2simg system.img system_sparse.img
```

**Benefits:**
- Smaller file size
- Faster flashing
- Standard format
- Better compression

### Tools for Image Creation

#### mkbootimg

**Purpose:**
Creates Android boot images.

**Usage:**
```bash
mkbootimg [options] -o boot.img
```

**Key Options:**
- `--kernel` - Kernel image
- `--ramdisk` - Ramdisk image
- `--dtb` - Device tree
- `--base` - Base address
- `--pagesize` - Page size
- `--output` - Output file

**Location:**
- `system/core/mkbootimg/`
- Built during AOSP build
- Available in out/host/

#### unpackbootimg

**Purpose:**
Extracts components from boot images.

**Usage:**
```bash
unpackbootimg -i boot.img -o output/
```

**Output:**
- Extracts kernel
- Extracts ramdisk
- Extracts device tree
- Shows header info

#### make_ext4fs

**Purpose:**
Creates ext4 filesystem images.

**Usage:**
```bash
make_ext4fs [options] image.img directory/
```

**Key Options:**
- `-s` - Sparse image
- `-l` - Image size
- `-a` - Mount point
- `-S` - SELinux file contexts

#### img2simg / simg2img

**Purpose:**
Converts between raw and sparse images.

**Usage:**
```bash
img2simg system.img system_sparse.img  # Raw to sparse
simg2img system_sparse.img system.img  # Sparse to raw
```

### Manual Build Process

#### Complete Workflow

**1. Prepare Components:**
- Build kernel
- Build device tree
- Create ramdisk
- Prepare system files

**2. Create boot.img:**
- Use mkbootimg
- Combine components
- Set addresses
- Verify format

**3. Create system.img:**
- Prepare system directory
- Set permissions
- Create ext4 image
- Convert to sparse

**4. Verify Images:**
- Check image sizes
- Verify formats
- Test mounting
- Validate contents

### Common Use Cases

#### Custom Boot Image

**Scenarios:**
- Custom kernel
- Modified init scripts
- Custom device tree
- Debugging boot

**Process:**
1. Modify components
2. Rebuild kernel/ramdisk
3. Create boot.img
4. Flash and test

#### Custom System Image

**Scenarios:**
- Custom apps
- Modified framework
- System customizations
- Testing changes

**Process:**
1. Modify system files
2. Rebuild components
3. Create system.img
4. Flash and test

#### Debugging Builds

**Scenarios:**
- Build failures
- Image issues
- Verification problems
- Understanding process

**Process:**
1. Identify issue
2. Build manually
3. Test components
4. Debug step by step

### Best Practices

#### Image Creation

**Verify Components:**
- Check kernel builds
- Verify device tree
- Validate ramdisk
- Test system files

**Set Correct Sizes:**
- Match partition sizes
- Account for growth
- Leave headroom
- Verify fits partition

**Test Images:**
- Mount and verify
- Check permissions
- Validate contents
- Test flashing

#### Troubleshooting

**Common Issues:**
- Wrong image size
- Permission problems
- Missing files
- Format errors

**Debugging:**
- Unpack and inspect
- Check logs
- Verify tools
- Test components

## Key Takeaways

1. **boot.img contains** kernel, device tree, and ramdisk needed to boot the Android system.

2. **system.img contains** the complete Android system including framework, apps, libraries, and configuration files.

3. **mkbootimg tool** is used to create boot.img by combining kernel, ramdisk, and device tree with proper addresses and parameters.

4. **make_ext4fs tool** is used to create system.img by creating an ext4 filesystem image from a system directory.

5. **Manual image building** provides complete control over image contents and is useful for debugging, customization, and understanding the build process.

6. **Image formats** include raw ext4 and sparse formats, with sparse being the standard for flashing due to smaller size.

7. **Proper permissions and SELinux contexts** must be set when creating system images to ensure correct system operation.

8. **Understanding manual image building** is essential for AOSP development, debugging build issues, and creating custom Android images.

## Related Topics

- **Android Partitions:** Understanding partition layout and sizes
- **BoardConfig:** Hardware configuration that determines image requirements
- **Build System Structure:** How standard builds create these images
- **Bootloader and Fastboot:** How to flash manually created images

