---
number: 11
title: Verified Boot (vboot)
slug: verified-boot-vboot
level: beginner
tags:
  - aosp
  - verified-boot
  - security
  - boot
  - vboot
  - chain-of-trust
  - integrity
prerequisites:
  - boot-process-overview
  - android-partitions
estimated_minutes: 90
contributors: []
diagrams: []
examples: []
canonical_id: aosp-beginner-11
---

# Verified Boot (vboot)

## Overview

Verified Boot (also known as vboot) is a security mechanism that ensures the integrity and authenticity of the Android boot process. It establishes a chain of trust from the hardware to the operating system, verifying that each component in the boot sequence has not been tampered with. Understanding Verified Boot is essential for AOSP development, as it affects how the system boots, how updates are applied, and how security is maintained throughout the device lifecycle.

Think of Verified Boot like a security checkpoint system at an airport - each stage of the boot process must present valid credentials (cryptographic signatures) before proceeding to the next stage. If any component fails verification, the boot process is halted, preventing potentially malicious code from running.

## Deep Explanation

### What is Verified Boot?

Verified Boot is a security feature that cryptographically verifies the integrity of boot components before they are executed. It ensures that:

1. **Integrity:** Boot components have not been modified or corrupted
2. **Authenticity:** Boot components come from a trusted source (OEM/manufacturer)
3. **Chain of Trust:** Each stage verifies the next before passing control
4. **Tamper Detection:** Any unauthorized modifications are detected and prevented

**Key Principles:**

**1. Chain of Trust:**
```
Boot ROM → Bootloader → Kernel → System
   (trusted)   (verified)  (verified)  (verified)
```

Each component verifies the next before executing it, creating an unbroken chain from hardware to software.

**2. Cryptographic Verification:**
- Components are signed with cryptographic keys
- Signatures are verified before execution
- Public keys are stored in secure hardware (when available)
- Private keys are kept secret by manufacturers

**3. Fail-Safe Behavior:**
- If verification fails, boot is halted
- Device enters recovery mode or shows error
- Prevents execution of potentially malicious code
- Protects user data and system integrity

### Why Verified Boot Matters

**1. Security:**
- Prevents rootkits and bootkits
- Protects against firmware-level attacks
- Ensures system integrity
- Prevents unauthorized modifications

**2. User Trust:**
- Users can trust their device hasn't been tampered with
- Protects against supply chain attacks
- Ensures updates come from legitimate sources
- Maintains device security posture

**3. Enterprise Requirements:**
- Many enterprises require verified boot
- Compliance with security standards
- Device attestation capabilities
- Remote verification of device state

**4. Update Security:**
- Ensures OTA updates are legitimate
- Prevents malicious update packages
- Protects update mechanism
- Maintains update integrity

### Verified Boot Architecture

#### Components

**1. Boot ROM (Root of Trust):**
- First code that executes
- Hard-coded in processor
- Contains public keys or key derivation
- Cannot be modified (read-only)
- Most trusted component

**2. Bootloader:**
- Loaded and verified by Boot ROM
- Verifies kernel and ramdisk
- Manages boot process
- Can be locked or unlocked
- Contains verification logic

**3. Kernel:**
- Verified by bootloader
- Loads and initializes system
- Can verify system partitions
- Sets up dm-verity (if enabled)
- Critical for system security

**4. System Partitions:**
- Verified at runtime (dm-verity)
- Read-only partitions
- Hash tree verification
- Transparent to applications

#### Boot Chain

**Complete Boot Chain:**
```
1. Boot ROM (Hardware)
   ↓ (verifies)
2. Bootloader (Verified Boot)
   ↓ (verifies)
3. Kernel + Ramdisk (Boot Partition)
   ↓ (verifies)
4. System Partition (dm-verity)
   ↓ (verifies)
5. Vendor Partition (dm-verity)
   ↓
6. Android System Running
```

**Each Stage:**
- Receives control from previous stage
- Verifies next stage before executing
- Passes control only if verification succeeds
- Halts boot if verification fails

### Verified Boot Process

#### Stage 1: Boot ROM Verification

**What Happens:**
1. Device powers on
2. Boot ROM executes (hardware)
3. Boot ROM loads bootloader from storage
4. Boot ROM verifies bootloader signature
5. If valid: Execute bootloader
6. If invalid: Halt or enter recovery

**Boot ROM Responsibilities:**
- Load bootloader from storage
- Verify bootloader signature
- Check for hardware tampering
- Initialize secure hardware (if available)
- Provide root of trust

**Signature Verification:**
- Bootloader signed with manufacturer's private key
- Boot ROM contains manufacturer's public key
- Signature verified using public key
- Only signed bootloaders can execute

#### Stage 2: Bootloader Verification

**What Happens:**
1. Bootloader executes (verified by Boot ROM)
2. Bootloader loads kernel and ramdisk
3. Bootloader verifies kernel signature
4. Bootloader verifies ramdisk signature
5. If valid: Load kernel and ramdisk
6. If invalid: Halt or enter recovery

**Bootloader Responsibilities:**
- Verify kernel signature
- Verify ramdisk signature
- Load kernel into memory
- Set up kernel parameters
- Pass control to kernel

**Kernel Verification:**
- Kernel image signed with manufacturer's key
- Bootloader verifies signature
- Only signed kernels can boot
- Prevents kernel-level rootkits

**Ramdisk Verification:**
- Ramdisk contains early boot files
- Verified before mounting
- Ensures early boot integrity
- Critical for system initialization

#### Stage 3: Kernel Verification

**What Happens:**
1. Kernel executes (verified by bootloader)
2. Kernel mounts system partitions
3. Kernel sets up dm-verity (if enabled)
4. Kernel verifies partition integrity
5. If valid: Continue boot
6. If invalid: Halt or enter recovery

**Kernel Responsibilities:**
- Set up dm-verity for partitions
- Verify partition hash trees
- Mount verified partitions
- Initialize security subsystems
- Start init process

**Partition Verification:**
- System partitions have hash trees
- Kernel verifies hash trees on mount
- Blocks access if verification fails
- Transparent to applications

### Verified Boot States

#### Locked Bootloader

**Characteristics:**
- Bootloader is locked
- Only signed images can boot
- Prevents unauthorized modifications
- Standard for consumer devices
- Required for some security features

**Benefits:**
- Maximum security
- Prevents tampering
- Protects user data
- Maintains warranty
- Enterprise compliance

**Limitations:**
- Cannot install custom ROMs
- Cannot modify boot components
- Limited customization
- OEM-controlled updates

**Checking Lock Status:**
```bash
# From fastboot
$ fastboot getvar unlocked
unlocked: no  # Bootloader is locked

# From device (requires root)
$ getprop ro.boot.verifiedbootstate
green  # Verified boot state
```

#### Unlocked Bootloader

**Characteristics:**
- Bootloader is unlocked
- Can boot unsigned images
- Allows custom ROMs
- Development and testing
- Warning shown on boot

**Benefits:**
- Custom ROM support
- Development flexibility
- Testing capabilities
- Root access possible
- Full system control

**Risks:**
- Reduced security
- Potential data loss
- Warranty void
- Malware risk
- Enterprise non-compliance

**Warning Screen:**
- Shows "Bootloader Unlocked" warning
- Cannot be disabled
- Indicates reduced security
- User must acknowledge

**Unlocking Process:**
```bash
# Warning: This wipes user data!
$ fastboot oem unlock
# or
$ fastboot flashing unlock

# Confirm unlock
$ fastboot flashing unlock_critical  # For critical partitions
```

### Verified Boot Implementation

#### Signature Scheme

**RSA Signatures:**
- Most common signature scheme
- RSA-2048 or RSA-4096 keys
- Public key in Boot ROM or bootloader
- Private key kept secret by manufacturer
- Standard PKCS#1 v1.5 padding

**ECDSA Signatures:**
- Elliptic Curve signatures
- Smaller key size
- Faster verification
- Growing adoption
- ECDSA-P256 or ECDSA-P384

**Signature Format:**
```
[Component Data]
[Signature]
[Metadata]
```

**Verification Process:**
1. Extract signature from component
2. Hash component data
3. Decrypt signature with public key
4. Compare hash with decrypted signature
5. Accept if match, reject otherwise

#### Key Management

**Manufacturer Keys:**
- Private keys kept secret
- Public keys in Boot ROM
- Used to sign boot components
- Cannot be changed after production
- Critical for security

**Key Storage:**
- Public keys in Boot ROM (read-only)
- Public keys in bootloader
- Secure hardware storage (when available)
- Cannot be modified
- Root of trust

**Key Rotation:**
- Difficult after production
- Requires Boot ROM update (impossible)
- Or bootloader update (if supported)
- Usually not possible
- Keys are permanent

#### Boot Image Format

**Android Boot Image:**
```
┌─────────────────────┐
│   Boot Header       │
│   (metadata)        │
├─────────────────────┤
│   Kernel            │
│   (compressed)      │
├─────────────────────┤
│   Ramdisk           │
│   (cpio archive)    │
├─────────────────────┤
│   Second Stage      │
│   (optional)        │
├─────────────────────┤
│   Device Tree       │
│   (dtb)             │
└─────────────────────┘
```

**Verification:**
- Entire boot image is signed
- Signature appended to image
- Bootloader verifies signature
- Only signed images boot
- Prevents tampering

**Boot Image Signing:**
```bash
# Sign boot image (on build system)
$ avbtool add_hash_footer \
    --image boot.img \
    --partition_name boot \
    --partition_size 67108864 \
    --key keys/test_key.pem \
    --algorithm SHA256_RSA2048

# Verify boot image
$ avbtool verify_image --image boot.img
```

### Verified Boot vs. Other Security Features

#### Verified Boot vs. dm-verity

**Verified Boot:**
- Verifies boot components (bootloader, kernel)
- Happens during boot
- One-time verification
- Prevents boot-level attacks
- Chain of trust establishment

**dm-verity:**
- Verifies system partitions at runtime
- Continuous verification
- Detects runtime tampering
- Protects read-only partitions
- Works with Verified Boot

**Relationship:**
- Verified Boot verifies kernel
- Kernel sets up dm-verity
- dm-verity verifies partitions
- Both work together
- Complete security solution

#### Verified Boot vs. Secure Boot

**Verified Boot (Android):**
- Android-specific implementation
- Verifies Android boot components
- Flexible verification policies
- Supports locked/unlocked states
- Android ecosystem standard

**Secure Boot (UEFI):**
- UEFI standard
- Verifies UEFI firmware
- More rigid policies
- PC/Server focused
- Different ecosystem

**Similarities:**
- Both verify boot components
- Both use cryptographic signatures
- Both establish chain of trust
- Both prevent tampering
- Both enhance security

### Verified Boot States and Indicators

#### Boot State Colors

Android uses color-coded boot states to indicate verification status:

**Green State:**
- All components verified
- Bootloader locked
- System integrity confirmed
- Highest security level
- Standard consumer state

**Yellow State:**
- Bootloader unlocked
- Custom components possible
- Reduced security
- Warning shown
- Development/testing state

**Orange State:**
- Device corrupted
- Verification failed
- Recovery needed
- Error state
- User intervention required

**Red State:**
- Critical error
- Cannot boot
- Hardware issue possible
- Requires service
- Severe problem

**Checking Boot State:**
```bash
# From device
$ getprop ro.boot.verifiedbootstate
green  # or yellow, orange, red

# From fastboot
$ fastboot getvar all | grep verified
(bootloader) verified: yes
(bootloader) verified-boot: yes
```

### Verified Boot in Development

#### Development Workflow

**1. Building Images:**
```bash
# Build boot image
$ m bootimage

# Boot image is unsigned by default
# Must sign for production devices
```

**2. Signing Images:**
```bash
# Sign boot image with test key
$ avbtool add_hash_footer \
    --image $OUT/boot.img \
    --partition_name boot \
    --partition_size 67108864 \
    --key vendor/keys/test_key.pem \
    --algorithm SHA256_RSA2048
```

**3. Flashing Images:**
```bash
# Flash signed boot image
$ fastboot flash boot boot.img

# On locked bootloader, only signed images work
# On unlocked bootloader, any image works
```

**4. Testing:**
```bash
# Boot device
$ fastboot reboot

# Check verification status
$ adb shell getprop ro.boot.verifiedbootstate
```

#### Debugging Verified Boot Issues

**Common Issues:**

**1. Boot Loop:**
- Verification failure
- Corrupted boot image
- Wrong signature
- Check boot logs

**2. "Device is Corrupted" Error:**
- Verification failed
- Tampered system
- Check boot state
- May need recovery

**3. Cannot Boot Custom Image:**
- Bootloader locked
- Image not signed
- Unlock bootloader (wipes data)
- Or sign image properly

**Debugging Steps:**
```bash
# Check bootloader status
$ fastboot getvar unlocked

# Check boot state
$ adb shell getprop ro.boot.verifiedbootstate

# View boot logs
$ adb shell dmesg | grep -i verif

# Check partition integrity
$ adb shell dmctl table_status
```

### Real-World Examples

#### Example 1: Normal Boot with Verified Boot

**Boot Sequence:**
```
1. Power on
2. Boot ROM executes
3. Boot ROM verifies bootloader ✓
4. Bootloader executes
5. Bootloader verifies kernel ✓
6. Kernel loads
7. Kernel sets up dm-verity
8. System partitions verified ✓
9. Android boots normally
```

**Result:**
- All verifications pass
- Device boots normally
- Green boot state
- Full security enabled

#### Example 2: Tampered Boot Image

**Boot Sequence:**
```
1. Power on
2. Boot ROM executes
3. Boot ROM verifies bootloader ✓
4. Bootloader executes
5. Bootloader verifies kernel ✗ (signature invalid)
6. Boot halted
7. Error screen shown
8. Recovery mode entered
```

**Result:**
- Verification fails
- Boot halted
- Orange/Red boot state
- User must fix issue

#### Example 3: Unlocked Bootloader

**Boot Sequence:**
```
1. Power on
2. Boot ROM executes
3. Boot ROM verifies bootloader ✓
4. Bootloader executes
5. Bootloader checks lock status: UNLOCKED
6. Warning screen shown
7. Bootloader allows unsigned kernel
8. Custom kernel loads (if present)
9. Android boots
```

**Result:**
- Bootloader unlocked
- Can boot unsigned images
- Yellow boot state
- Reduced security
- Warning displayed

### Best Practices

#### For System Developers

**1. Always Sign Images:**
- Sign all boot images
- Use proper keys
- Test signature verification
- Never ship unsigned images

**2. Protect Private Keys:**
- Keep private keys secret
- Use secure key storage
- Limit key access
- Rotate keys if compromised

**3. Test Verification:**
- Test with locked bootloader
- Verify signature checking
- Test failure scenarios
- Ensure proper error handling

**4. Document Key Management:**
- Document key locations
- Document signing process
- Document key rotation (if any)
- Maintain key inventory

#### For Application Developers

**1. Understand Boot States:**
- Check boot state if needed
- Handle different states
- Don't assume locked bootloader
- Respect security boundaries

**2. Don't Bypass Security:**
- Don't try to bypass verification
- Work within security model
- Use proper APIs
- Respect system security

**3. Test on Different States:**
- Test on locked devices
- Test on unlocked devices
- Handle state differences
- Ensure compatibility

### Edge Cases and Pitfalls

#### Common Mistakes

**1. Forgetting to Sign Images:**
```bash
# BAD: Unsigned image on locked bootloader
$ fastboot flash boot boot.img
# Result: Boot fails

# GOOD: Sign image first
$ avbtool add_hash_footer --image boot.img ...
$ fastboot flash boot boot.img
# Result: Boot succeeds
```

**2. Using Wrong Keys:**
```bash
# BAD: Signing with wrong key
$ avbtool add_hash_footer --key wrong_key.pem ...
# Result: Verification fails

# GOOD: Use correct key
$ avbtool add_hash_footer --key correct_key.pem ...
# Result: Verification succeeds
```

**3. Assuming Unlocked Bootloader:**
```bash
# BAD: Assuming unlocked
# Code that only works unlocked
if (bootloader_unlocked) {
    // This may not be true
}

# GOOD: Check and handle both
if (bootloader_locked) {
    // Use signed images
} else {
    // Can use unsigned (with warning)
}
```

**4. Ignoring Boot State:**
```bash
# BAD: Ignoring boot state
# Code that doesn't check state
# May fail on corrupted devices

# GOOD: Check boot state
boot_state = getprop("ro.boot.verifiedbootstate");
if (boot_state == "orange" || boot_state == "red") {
    // Handle error state
}
```

## References and Further Reading

- [AOSP Verified Boot Documentation](https://source.android.com/docs/security/features/verifiedboot)
- [Android Verified Boot 2.0](https://source.android.com/docs/security/features/verifiedboot/avb)
- [Boot Image Format](https://source.android.com/docs/core/boot/boot-image-format)
- [dm-verity](https://source.android.com/docs/security/features/verifiedboot/dm-verity)

## Quiz

### Question 1
What is the primary purpose of Verified Boot in Android?

**A)** To speed up the boot process  
**B)** To ensure the integrity and authenticity of boot components through cryptographic verification  
**C)** To enable custom ROM installation  
**D)** To reduce boot time

**Answer: B** - Verified Boot cryptographically verifies that boot components (bootloader, kernel, etc.) have not been tampered with and come from a trusted source, establishing a chain of trust from hardware to software.

### Question 2
What happens when Verified Boot detects a tampered or unsigned boot component on a device with a locked bootloader?

**A)** The device boots normally with a warning  
**B)** The boot process is halted and the device enters recovery mode or shows an error  
**C)** The device automatically unlocks the bootloader  
**D)** The device skips verification and continues booting

**Answer: B** - When verification fails on a locked bootloader, the boot process is halted to prevent potentially malicious code from executing. The device typically enters recovery mode or displays an error screen requiring user intervention.

### Question 3
What is the "chain of trust" in Verified Boot?

**A)** A sequence where each boot component verifies the next before passing control  
**B)** A method to speed up boot time  
**C)** A way to unlock the bootloader  
**D)** A technique to reduce memory usage

**Answer: A** - The chain of trust is a sequence where each component (Boot ROM → Bootloader → Kernel → System) verifies the next component's integrity and authenticity before executing it, creating an unbroken security chain from hardware to software.

### Question 4
What does a "green" boot state indicate in Android Verified Boot?

**A)** The bootloader is unlocked  
**B)** All components are verified, bootloader is locked, and system integrity is confirmed  
**C)** The device is corrupted  
**D)** Custom components are installed

**Answer: B** - A green boot state indicates the highest security level where all boot components have been successfully verified, the bootloader is locked, and the system integrity is confirmed. This is the standard state for consumer devices.

### Question 5
What is the difference between Verified Boot and dm-verity?

**A)** They are the same thing  
**B)** Verified Boot verifies boot components during boot, while dm-verity verifies system partitions at runtime  
**C)** Verified Boot is for unlocked bootloaders, dm-verity is for locked bootloaders  
**D)** Verified Boot is deprecated, dm-verity replaced it

**Answer: B** - Verified Boot verifies boot components (bootloader, kernel) during the boot process, while dm-verity provides continuous runtime verification of system partitions. They work together: Verified Boot verifies the kernel, and the kernel sets up dm-verity to verify partitions.

## Related Topics

- [Boot Process Overview](./03.%20Boot%20Process%20Overview.md)
- [Android Partitions](./08.%20Android%20Partitions.md)
- [Android Verified Boot 2.0 (AVB)](./12.%20Android%20Verified%20Boot%202.0%20(AVB).md)

