---
number: 48
title: Scheduler internals
slug: scheduler-internals
level: beginner
tags:
  - aosp
  - kernel
  - scheduler
  - cfs
  - cpu
  - scheduling
  - process-management
prerequisites:
  - memory-management-internals
  - android-architecture-complete-overview
estimated_minutes: 85
contributors: []
diagrams: []
examples: []
canonical_id: aosp-beginner-48
---

# Scheduler internals

## Overview

The kernel scheduler is responsible for deciding which process or thread runs on the CPU at any given time. Understanding scheduler internals is essential for AOSP development, as it affects system responsiveness, process execution, CPU utilization, and overall system performance. This guide provides a comprehensive overview of the Linux kernel scheduler, CFS (Completely Fair Scheduler), scheduling algorithms, priorities, context switching, and how scheduling works in Android.

Think of the kernel scheduler like a traffic controller at a busy intersection: just as a traffic controller decides which cars get to go through the intersection and when, the scheduler decides which processes get to use the CPU and for how long. It must balance fairness (everyone gets a turn), responsiveness (important tasks get priority), and efficiency (minimize overhead) to keep the system running smoothly.

## Deep Explanation

### What is the Kernel Scheduler?

The kernel scheduler is the component that decides which process or thread should run on the CPU at any given time. It manages process execution, CPU time distribution, and ensures system responsiveness and fairness.

**Key Responsibilities:**
- **Process Selection:** Choose next process to run
- **Time Slicing:** Allocate CPU time to processes
- **Priority Management:** Handle process priorities
- **Load Balancing:** Distribute load across CPUs
- **Context Switching:** Switch between processes

**Why It Matters:**
- **Responsiveness:** Affects system responsiveness
- **Fairness:** Ensures fair CPU distribution
- **Performance:** Impacts overall performance
- **Battery Life:** Affects power consumption

### Process States

#### Process State Machine

**States:**
```
TASK_RUNNING    - Ready to run or currently running
TASK_INTERRUPTIBLE - Sleeping, can be woken by signal
TASK_UNINTERRUPTIBLE - Sleeping, cannot be interrupted
TASK_STOPPED    - Stopped by signal
TASK_TRACED     - Being debugged
EXIT_ZOMBIE     - Process terminated, waiting for parent
EXIT_DEAD       - Process fully terminated
```

**State Transitions:**
```
NEW → RUNNING → WAITING → RUNNING → TERMINATED
       ↑         ↓
       └─────────┘
```

#### Running State

**TASK_RUNNING:**
- Process is ready to run
- May be currently running on CPU
- Or waiting in runqueue
- Can be scheduled immediately

**Runqueue:**
- Queue of runnable processes
- Per-CPU runqueue
- Scheduler selects from runqueue
- Priority-ordered

### Linux CFS (Completely Fair Scheduler)

#### What is CFS?

CFS is Linux's default scheduler since kernel 2.6.23. It aims to provide fair CPU time distribution among all processes while maintaining good responsiveness.

**Key Principles:**
- **Fairness:** All processes get proportional CPU time
- **Efficiency:** Low overhead scheduling
- **Responsiveness:** Good interactive performance
- **Scalability:** Works with many processes

**Core Concept:**
- Uses virtual runtime (vruntime)
- Tracks CPU time used by each process
- Normalized by process weight (priority)
- Selects process with lowest vruntime

#### Virtual Runtime (vruntime)

**What is vruntime?**
- Tracks how much CPU time a process has used
- Normalized by process weight (nice value)
- Lower vruntime = needs more CPU time
- Used for scheduling decisions

**Calculation:**
```
vruntime += (actual_time * NICE_0_LOAD) / process_weight
```

**Properties:**
- Processes with same priority have similar vruntime
- Higher priority processes accumulate vruntime slower
- Lower priority processes accumulate vruntime faster
- Fair distribution over time

#### CFS Scheduling Algorithm

**Selection Process:**
1. Calculate vruntime for all processes
2. Select process with lowest vruntime
3. Run process for time slice
4. Update vruntime
5. Re-select process with lowest vruntime

**Time Slicing:**
```
time_slice = target_latency / number_of_processes
minimum: 1ms
maximum: target_latency
```

**Target Latency:**
- Default: 6ms (single CPU)
- Scales with number of processes
- Ensures all processes run within latency
- Balances fairness and overhead

#### Red-Black Tree

**Data Structure:**
- CFS uses red-black tree for process storage
- Key: vruntime
- Leftmost node: Next process to run
- O(log n) insertion/deletion
- Efficient process selection

**Tree Operations:**
- **Insert:** When process becomes runnable
- **Delete:** When process blocks or exits
- **Select:** Leftmost node (lowest vruntime)
- **Update:** Rebalance after vruntime update

### Process Priorities

#### Nice Values

**Nice Value Range:**
- -20 (highest priority) to +19 (lowest priority)
- Default: 0 (nice value)
- Lower nice = higher priority
- Affects CPU time allocation

**Priority Mapping:**
```
Nice -20:  Highest priority (more CPU time)
Nice 0:    Normal priority (default)
Nice +19:  Lowest priority (less CPU time)
```

**Weight Calculation:**
```
weight = 1024 / (1.25 ^ nice_value)
```

#### Real-Time Priorities

**Real-Time Classes:**
- **SCHED_FIFO:** First In, First Out
- **SCHED_RR:** Round Robin
- **SCHED_DEADLINE:** Deadline-based

**Priority Range:**
- 1 (lowest) to 99 (highest)
- Higher than normal processes
- Preempt normal processes
- Used for time-critical tasks

**Use Cases:**
- Audio processing
- Real-time applications
- System critical tasks
- Low-latency requirements

### Context Switching

#### What is Context Switching?

Context switching is the process of saving the state of one process and loading the state of another, allowing the CPU to switch between processes.

**Context Includes:**
- CPU registers
- Program counter
- Stack pointer
- Memory mappings (page tables)
- Floating-point registers
- Other processor state

#### Context Switch Process

**Steps:**
1. **Save Current Process:**
   - Save CPU registers to process structure
   - Save program counter
   - Save stack pointer
   - Save other state

2. **Update Process State:**
   - Mark current process as not running
   - Update statistics
   - Update vruntime (for CFS)

3. **Select Next Process:**
   - Scheduler selects next process
   - From runqueue
   - Based on scheduling policy

4. **Load Next Process:**
   - Load CPU registers
   - Load program counter
   - Load stack pointer
   - Load page tables
   - Flush TLB (if needed)

5. **Switch to New Process:**
   - Jump to new process's program counter
   - Resume execution

#### Context Switch Cost

**Overhead:**
- Time: Typically 1-10 microseconds
- Cache: Cache misses (new process uses different memory)
- TLB: Translation Lookaside Buffer flush
- Pipeline: CPU pipeline stalls

**Optimization:**
- Lazy TLB flush (don't flush if not needed)
- Process affinity (keep on same CPU)
- Cache-aware scheduling
- Efficient context switch code

### Multi-CPU Scheduling

#### SMP (Symmetric Multiprocessing)

**Multiple CPUs:**
- Multiple CPUs share workload
- Each CPU has own runqueue
- Load balancing between CPUs
- Cache affinity considerations

**Per-CPU Runqueues:**
- Each CPU maintains own runqueue
- Reduces lock contention
- Better cache locality
- Faster scheduling decisions

#### Load Balancing

**Purpose:**
- Distribute processes across CPUs
- Balance CPU utilization
- Improve performance
- Reduce idle time

**When It Happens:**
- Periodic (every few milliseconds)
- When CPU becomes idle
- When process wakes up
- When load imbalance detected

**Load Balancing Process:**
1. Identify busiest CPU
2. Identify least busy CPU
3. Move processes from busy to idle
4. Consider cache affinity
5. Minimize migration cost

#### CPU Affinity

**What is Affinity?**
- Preference for process to run on specific CPU
- Can improve cache performance
- Reduces migration overhead
- Better for cache-sensitive processes

**Affinity Masks:**
- Bitmask of allowed CPUs
- Process can run on specified CPUs
- Can be set by process or system
- Affects load balancing

### Scheduling Policies

#### SCHED_NORMAL (CFS)

**Default Policy:**
- Used by most processes
- Fair time sharing
- CFS algorithm
- Nice value based

**Characteristics:**
- Fair CPU distribution
- Good responsiveness
- Suitable for most applications
- Default for Android apps

#### SCHED_FIFO

**First In, First Out:**
- Real-time policy
- No time slicing
- Runs until blocks or preempted
- Higher priority preempts

**Use Cases:**
- Real-time audio
- Critical system tasks
- Low-latency requirements
- Time-sensitive operations

#### SCHED_RR

**Round Robin:**
- Real-time policy
- Time-sliced
- Round-robin within same priority
- Higher priority preempts

**Use Cases:**
- Real-time with time sharing
- Multiple real-time processes
- Fair real-time scheduling
- Time-critical tasks

#### SCHED_DEADLINE

**Deadline-Based:**
- Earliest deadline first
- Guarantees deadlines
- Real-time policy
- Used for periodic tasks

**Use Cases:**
- Periodic real-time tasks
- Deadline guarantees
- Multimedia processing
- Time-critical applications

### Android-Specific Scheduling

#### Android Process Priorities

**Process Importance:**
- Foreground processes (highest)
- Visible processes
- Service processes
- Background processes
- Empty processes (lowest)

**Priority Mapping:**
- Android maps importance to nice values
- Foreground: Higher priority
- Background: Lower priority
- Affects CPU time allocation

#### Interactive Governor

**CPU Frequency Scaling:**
- Interactive governor for responsiveness
- Scales CPU frequency based on load
- Quick scale-up for responsiveness
- Gradual scale-down for efficiency

**Scheduling Interaction:**
- Scheduler affects CPU load
- CPU load affects frequency
- Frequency affects performance
- Performance affects scheduling

### Scheduler Tuning

#### Scheduler Parameters

**CFS Tunables:**
- `sched_latency_ns` - Target latency
- `sched_min_granularity_ns` - Minimum time slice
- `sched_wakeup_granularity_ns` - Wakeup granularity
- `sched_migration_cost_ns` - Migration cost

**Tuning:**
- Adjust for workload
- Balance responsiveness and fairness
- Consider system characteristics
- Test thoroughly

#### Performance Considerations

**Scheduler Overhead:**
- Context switch cost
- Runqueue operations
- Load balancing cost
- Lock contention

**Optimization:**
- Minimize context switches
- Reduce lock contention
- Optimize hot paths
- Cache-aware scheduling

### Debugging Scheduling

#### Scheduler Statistics

**/proc/schedstat:**
```bash
cat /proc/schedstat
```

**Information:**
- Context switch counts
- Load balancing statistics
- Migration statistics
- CPU utilization

**/proc/pid/sched:**
```bash
cat /proc/1234/sched
```

**Process Information:**
- Scheduler policy
- Priority (nice value)
- vruntime
- CPU time statistics

#### Common Issues

**High Context Switch Rate:**
- Too many processes
- Short time slices
- Excessive preemption
- Check with `vmstat` or `pidstat`

**CPU Imbalance:**
- Load not balanced
- Affinity issues
- Check load balancing
- Review process distribution

**Poor Responsiveness:**
- Low priority processes
- Too many processes
- Long time slices
- Check scheduler parameters

## Key Takeaways

1. **The kernel scheduler decides** which process runs on the CPU and manages CPU time distribution.

2. **CFS (Completely Fair Scheduler)** is Linux's default scheduler that uses virtual runtime to provide fair CPU time distribution.

3. **Process priorities** are managed through nice values (-20 to +19) and real-time priorities (1 to 99).

4. **Context switching** saves and restores process state when switching between processes, with overhead that must be minimized.

5. **Multi-CPU scheduling** uses per-CPU runqueues and load balancing to distribute processes across CPUs efficiently.

6. **Scheduling policies** include SCHED_NORMAL (CFS), SCHED_FIFO, SCHED_RR, and SCHED_DEADLINE for different use cases.

7. **Android-specific scheduling** maps process importance to priorities and interacts with CPU frequency scaling.

8. **Understanding scheduler internals** is essential for performance optimization, debugging scheduling issues, and AOSP development.

## Related Topics

- **Memory management internals:** How memory management interacts with scheduling
- **Power management:** How scheduling affects power consumption
- **Android Architecture - Complete Overview:** How scheduling fits into Android architecture
- **Process vs Threads Internals:** How threads are scheduled

