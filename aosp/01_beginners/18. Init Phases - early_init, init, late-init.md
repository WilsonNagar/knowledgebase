---
number: 18
title: 'Init Phases - early_init, init, late-init'
slug: init-phases-early-init-init-late-init
level: beginner
tags:
  - aosp
  - init
  - boot
  - initialization
  - phases
  - early-init
  - late-init
  - system-startup
prerequisites:
  - init-system-in-android
  - boot-process-overview
estimated_minutes: 90
contributors: []
diagrams: []
examples: []
canonical_id: aosp-beginner-18
---

# Init Phases - early_init, init, late-init

## Overview

The Android init process executes in distinct phases: `early-init`, `init`, and `late-init`. Each phase has a specific purpose and timing in the boot sequence, with actions and services starting at appropriate times. Understanding these phases is crucial for AOSP development, as it determines when system components initialize, when services can start, and how the boot sequence is organized.

Think of init phases like "stages of a construction project." Just as you must lay the foundation before building walls, and build walls before installing fixtures, init must complete early-init tasks before init tasks, and init tasks before late-init tasks. Each phase builds upon the previous one, creating a structured and reliable boot process.

## Deep Explanation

### What are Init Phases?

Init phases are distinct stages in the Android boot process where specific types of initialization occur. Each phase is triggered by a corresponding action trigger in init.rc files, and actions defined for each phase execute in order.

**Key Characteristics:**
- **Sequential execution:** Phases run in order: early-init → init → late-init
- **Trigger-based:** Each phase is triggered by a specific event
- **Declarative:** Actions defined in init.rc files
- **Dependency-aware:** Later phases depend on earlier phases
- **Extensible:** Device-specific scripts can add to each phase

**The Three Main Phases:**

1. **early-init:** Critical system setup, security initialization
2. **init:** Main initialization, partition mounting, property setup
3. **late-init:** Service startup, final system configuration

### Why Phases Matter

**1. Dependency Management:**
- Ensures prerequisites are ready
- Prevents race conditions
- Guarantees correct initialization order
- Makes boot process predictable

**2. System Stability:**
- Critical setup happens first
- Services start only when ready
- Reduces boot failures
- Enables proper error handling

**3. Development Clarity:**
- Clear separation of concerns
- Easy to understand boot sequence
- Simplifies debugging
- Makes customization easier

### Boot Sequence Overview

#### Complete Phase Sequence

```
Kernel Boot
   ↓
Init Process Starts (PID 1)
   ↓
early-init Phase
   ├── Create essential directories
   ├── Mount basic filesystems
   ├── Initialize SELinux
   └── Set up security
   ↓
init Phase
   ├── Mount system partitions
   ├── Create device nodes
   ├── Initialize property system
   └── Set up system structure
   ↓
late-init Phase
   ├── Trigger post-fs actions
   ├── Trigger post-fs-data actions
   ├── Start core services
   └── Start main services
   ↓
System Fully Operational
```

#### Phase Timing

**Relative Timing:**
- **early-init:** ~0-2 seconds after kernel boot
- **init:** ~2-5 seconds (after early-init)
- **late-init:** ~5-10 seconds (after init)
- **Total boot:** Varies by device (10-60 seconds)

**Critical Path:**
- early-init must complete before init
- init must complete before late-init
- Services start in late-init
- System ready after late-init

### Early-Init Phase

#### Purpose and Characteristics

**Purpose:**
- Critical system setup that everything else depends on
- Security initialization (SELinux)
- Essential filesystem setup
- Basic environment preparation

**Characteristics:**
- Executes first (after kernel boot)
- Minimal dependencies
- Critical for system operation
- Must complete successfully

#### Typical Early-Init Actions

**Directory Creation:**
```
on early-init
    # Create essential directories
    mkdir /dev 0755
    mkdir /proc 0755
    mkdir /sys 0755
    mkdir /system 0755
    mkdir /data 0755
    mkdir /vendor 0755
    mkdir /cache 0755
```

**Basic Filesystem Mounts:**
```
on early-init
    # Mount essential filesystems
    mount tmpfs tmpfs /dev mode=0755
    mount proc proc /proc
    mount sysfs sysfs /sys
    mount tmpfs tmpfs /tmp
```

**SELinux Initialization:**
```
on early-init
    # Setup SELinux
    mkdir /sys/fs/selinux 0755
    mount selinuxfs selinuxfs /sys/fs/selinux noatime
    
    # Load policy
    load_policy /sepolicy
    
    # Start permissive (will go enforcing later)
    setenforce 0
    
    # Label early filesystem
    restorecon /sys/fs/selinux
    restorecon /dev
```

**Security Setup:**
```
on early-init
    # Set up security
    write /proc/sys/kernel/core_pattern core
    write /proc/sys/kernel/core_uses_pid 1
```

#### Early-Init Best Practices

**Do:**
- Only critical setup
- Minimal operations
- Fast execution
- Essential mounts only

**Don't:**
- Start services
- Mount system partitions (usually)
- Complex operations
- Blocking operations

#### Common Early-Init Tasks

**1. Directory Structure:**
- Create mount points
- Set up basic directories
- Prepare filesystem structure

**2. Essential Mounts:**
- tmpfs for /dev
- proc filesystem
- sysfs filesystem
- Basic tmpfs mounts

**3. Security:**
- SELinux initialization
- Policy loading
- Security context setup
- Basic security hardening

**4. Logging:**
- Set up early logging
- Configure kernel logging
- Prepare log buffers

### Init Phase

#### Purpose and Characteristics

**Purpose:**
- Main system initialization
- Partition mounting
- Device node creation
- Property system setup
- System structure preparation

**Characteristics:**
- Executes after early-init
- More complex operations
- Sets up system partitions
- Prepares for service startup

#### Typical Init Actions

**Partition Mounting:**
```
on init
    # Wait for block device
    wait /dev/block/bootdevice
    
    # Mount system partitions
    mount ext4 /dev/block/bootdevice /system ro wait,avb=vbmeta_system
    mount ext4 /dev/block/bootdevice /vendor ro wait,avb=vbmeta_vendor
    mount ext4 /dev/block/bootdevice /product ro wait
    
    # Mount data partition
    mount ext4 /dev/block/bootdevice /data noatime,nosuid,nodev,noauto_da_alloc,barrier=1 wait,check,formattable,resize,quota
```

**Device Node Creation:**
```
on init
    # Create essential device nodes
    mknod /dev/null c 1 3 0666
    mknod /dev/zero c 1 5 0666
    mknod /dev/random c 1 8 0666
    mknod /dev/urandom c 1 9 0666
    mknod /dev/console c 5 1 0600
```

**Symlink Creation:**
```
on init
    # Create symlinks
    symlink /system/bin /bin
    symlink /system/etc /etc
    symlink /system/lib /lib
    symlink /system/lib64 /lib64
```

**Property System Initialization:**
```
on init
    # Initialize property system
    property_init
    
    # Load properties
    load_properties /system/build.prop
    load_properties /vendor/build.prop
    load_properties /default.prop
```

**SELinux Transition:**
```
on init
    # Label system partition
    restorecon_recursive /system
    
    # Transition to enforcing
    setenforce 1
```

#### Init Best Practices

**Do:**
- Mount all partitions
- Create device nodes
- Set up property system
- Label filesystem
- Prepare for services

**Don't:**
- Start services (usually)
- Complex service setup
- User-space operations
- Application-level setup

#### Common Init Tasks

**1. Partition Management:**
- Mount system partitions
- Mount vendor partitions
- Mount data partition
- Set up partition structure

**2. Device Nodes:**
- Create essential device nodes
- Set up device access
- Configure device permissions

**3. Property System:**
- Initialize property service
- Load build properties
- Set default properties
- Configure property access

**4. Filesystem Labeling:**
- Apply SELinux contexts
- Label system partition
- Label vendor partition
- Verify file contexts

**5. System Structure:**
- Create symlinks
- Set up directory structure
- Configure system paths
- Prepare environment

### Late-Init Phase

#### Purpose and Characteristics

**Purpose:**
- Service startup
- Final system configuration
- Post-mount actions
- System completion

**Characteristics:**
- Executes after init
- Starts services
- Triggers additional actions
- Completes boot process

#### Typical Late-Init Actions

**Trigger Post-Mount Actions:**
```
on late-init
    # Trigger post-fs (after filesystem mount)
    trigger post-fs
    
    # Trigger post-fs-data (after data mount)
    trigger post-fs-data
```

**Start Service Classes:**
```
on late-init
    # Start core services first
    class_start core
    
    # Start main services
    class_start main
    
    # Start late-start services (if any)
    class_start late_start
```

**Final Configuration:**
```
on late-init
    # Set boot complete property
    setprop sys.boot_completed 1
    
    # Trigger boot complete actions
    trigger boot
```

#### Late-Init Best Practices

**Do:**
- Start services
- Trigger post-mount actions
- Complete system setup
- Mark boot complete

**Don't:**
- Critical filesystem operations
- Security initialization
- Basic system setup
- Blocking operations

#### Common Late-Init Tasks

**1. Service Startup:**
- Start core services
- Start main services
- Start late-start services
- Monitor service health

**2. Post-Mount Actions:**
- Trigger post-fs
- Trigger post-fs-data
- Execute post-mount scripts
- Configure mounted partitions

**3. System Completion:**
- Set boot complete flag
- Trigger boot actions
- Final system configuration
- Enable user-space features

**4. Property Triggers:**
- Set properties that trigger actions
- Enable property-based services
- Configure runtime behavior
- Activate system features

### Phase Dependencies

#### Dependency Chain

**Early-Init Dependencies:**
- Depends on: Kernel boot, initramfs
- Provides: Basic filesystem, SELinux, directories

**Init Dependencies:**
- Depends on: Early-init completion
- Provides: Mounted partitions, properties, device nodes

**Late-Init Dependencies:**
- Depends on: Init completion
- Provides: Running services, complete system

#### Critical Dependencies

**SELinux → Everything:**
- Early-init: Load policy
- Init: Label filesystem, go enforcing
- Late-init: Services need contexts

**Partitions → Services:**
- Init: Mount partitions
- Late-init: Services access partitions

**Properties → Services:**
- Init: Initialize property system
- Late-init: Services read properties

### Action Triggers

#### Built-in Triggers

**Boot-Time Triggers:**
- `early-init` - Very early initialization
- `init` - Main initialization
- `late-init` - Late initialization
- `post-fs` - After filesystem mount
- `post-fs-data` - After data mount
- `boot` - After boot completes

**Property Triggers:**
- `on property:name=value` - When property changes
- `on property:name=*` - When property is set

**Service Triggers:**
- `on property:init.svc.name=running` - When service starts
- `on property:init.svc.name=stopped` - When service stops

#### Trigger Execution

**Sequential Execution:**
```
# Triggers execute in order
on early-init
    # Actions execute here

on init
    # Actions execute here

on late-init
    # Actions execute here
    trigger post-fs  # Triggers post-fs
```

**Nested Triggers:**
```
on late-init
    trigger post-fs
        # post-fs actions execute
    trigger post-fs-data
        # post-fs-data actions execute
```

### Real-World Examples

#### Example 1: Complete Phase Sequence

**Early-Init:**
```
on early-init
    # Essential setup
    mkdir /dev 0755
    mkdir /proc 0755
    mkdir /sys 0755
    mount tmpfs tmpfs /dev
    mount proc proc /proc
    mount sysfs sysfs /sys
    
    # SELinux
    mkdir /sys/fs/selinux 0755
    mount selinuxfs selinuxfs /sys/fs/selinux
    load_policy /sepolicy
    setenforce 0
```

**Init:**
```
on init
    # Mount partitions
    wait /dev/block/bootdevice
    mount ext4 /dev/block/bootdevice /system ro
    mount ext4 /dev/block/bootdevice /vendor ro
    mount ext4 /dev/block/bootdevice /data rw
    
    # Device nodes
    mknod /dev/null c 1 3 0666
    mknod /dev/zero c 1 5 0666
    
    # Properties
    property_init
    load_properties /system/build.prop
    
    # SELinux enforcing
    restorecon_recursive /system
    setenforce 1
```

**Late-Init:**
```
on late-init
    # Post-mount
    trigger post-fs
    trigger post-fs-data
    
    # Start services
    class_start core
    class_start main
    
    # Boot complete
    setprop sys.boot_completed 1
```

#### Example 2: Device-Specific Customization

**Adding to Early-Init:**
```
# In device/xxx/rootdir/init.xxx.rc
on early-init
    # Device-specific early setup
    write /proc/device/special_setting 1
    setprop ro.device.custom early
```

**Adding to Init:**
```
on init
    # Device-specific mounts
    mount ext4 /dev/block/custom /custom ro
    
    # Device-specific properties
    setprop ro.device.model "CustomDevice"
```

**Adding to Late-Init:**
```
on late-init
    # Start device-specific services
    start custom_service
    
    # Device-specific configuration
    setprop ro.device.ready 1
```

#### Example 3: Conditional Phase Actions

**Property-Based Init:**
```
on init
    # Conditional mount
    ifup lo
    
on property:ro.debuggable=1
    # Debug mode setup
    setprop service.adb.tcp.port 5555
    start adbd
```

**Service-Based Late-Init:**
```
on late-init
    # Start services conditionally
    class_start main

on property:sys.boot_completed=1
    # After boot complete
    start post_boot_service
```

### Debugging Init Phases

#### Viewing Phase Execution

**Init Logs:**
```bash
# View init logs
adb logcat -s init

# View specific phase
adb logcat -s init | grep "early-init"
adb logcat -s init | grep "late-init"
```

**Kernel Logs:**
```bash
# View kernel messages
adb shell dmesg | grep init

# View boot sequence
adb shell dmesg | grep -E "(early-init|init|late-init)"
```

#### Common Issues

**Issue 1: Early-Init Hangs**
- **Symptom:** Boot stops early, no services start
- **Cause:** Blocking operation, missing file, mount failure
- **Debug:** Check early-init logs, verify files exist

**Issue 2: Init Phase Fails**
- **Symptom:** Partitions not mounted, properties not set
- **Cause:** Wrong partition paths, filesystem errors
- **Debug:** Check init logs, verify partition paths

**Issue 3: Late-Init Services Don't Start**
- **Symptom:** Services not running, boot incomplete
- **Cause:** Service definition errors, missing dependencies
- **Debug:** Check service definitions, verify prerequisites

#### Debugging Techniques

**Enable Verbose Logging:**
```
on early-init
    # Enable verbose logging
    write /proc/sys/kernel/printk "7 4 1 7"
    log "Early-init starting"
```

**Add Debug Actions:**
```
on init
    # Debug output
    write /dev/kmsg "Init phase starting"
    setprop debug.init.phase init
```

**Check Phase Completion:**
```bash
# Check if phases completed
adb shell getprop | grep init

# Check service status
adb shell getprop | grep init.svc
```

### Edge Cases and Pitfalls

#### Common Mistakes

**1. Wrong Phase for Actions:**
```bash
# BAD: Service in early-init
on early-init
    start my_service  # Too early!

# GOOD: Service in late-init
on late-init
    class_start main  # Services start here
```

**2. Missing Dependencies:**
```bash
# BAD: Mount before device ready
on init
    mount ext4 /dev/block/system /system  # May fail!

# GOOD: Wait for device
on init
    wait /dev/block/bootdevice
    mount ext4 /dev/block/bootdevice /system ro wait
```

**3. Blocking Operations:**
```bash
# BAD: Blocking in init script
on init
    sleep 10  # Blocks init!

# GOOD: Use triggers or properties
on property:my.ready=1
    start my_service
```

**4. Circular Dependencies:**
```bash
# BAD: Circular dependency
on early-init
    trigger init  # Wrong!

# GOOD: Let init run naturally
# Phases run automatically in order
```

### Best Practices

#### For System Developers

**1. Phase Organization:**
- Use appropriate phases for actions
- Keep early-init minimal
- Do main setup in init
- Start services in late-init

**2. Dependencies:**
- Understand phase dependencies
- Don't assume earlier phase completion
- Use wait for devices
- Handle errors gracefully

**3. Performance:**
- Minimize early-init operations
- Avoid blocking operations
- Use triggers effectively
- Optimize boot time

**4. Debugging:**
- Add logging to phases
- Use properties for debugging
- Check phase completion
- Verify service startup

#### For Application Developers

**1. Understanding Phases:**
- Know when services start
- Understand boot sequence
- Be aware of timing
- Don't assume early availability

**2. Boot-Related Issues:**
- Check init logs for problems
- Understand phase dependencies
- Report issues with phase context
- Work with system team

## References and Further Reading

- [AOSP Init Process](https://source.android.com/docs/core/architecture/init)
- [Android Init Language](https://source.android.com/docs/core/architecture/init/init-language)
- [Init System in Android](./04.%20Init%20System%20in%20Android.md)
- [Boot Process Overview](./03.%20Boot%20Process%20Overview.md)

## Quiz

### Question 1
In what order do the init phases execute during Android boot?

**A)** init → early-init → late-init  
**B)** early-init → init → late-init  
**C)** late-init → init → early-init  
**D)** All phases execute simultaneously

**Answer: B** - The init phases execute in the order: early-init (critical setup and security), init (main initialization and partition mounting), and late-init (service startup and final configuration). This sequential order ensures dependencies are met before each phase begins.

### Question 2
Which init phase is responsible for starting system services?

**A)** early-init  
**B)** init  
**C)** late-init  
**D)** post-fs

**Answer: C** - The late-init phase is responsible for starting system services. This phase executes after the init phase has completed mounting partitions and setting up the system structure, ensuring that services have access to the resources they need.

### Question 3
What is the primary purpose of the early-init phase?

**A)** To start system services  
**B)** To mount system partitions  
**C)** To perform critical system setup, security initialization, and create essential directories  
**D)** To initialize the property system

**Answer: C** - The early-init phase performs critical system setup that everything else depends on, including creating essential directories, mounting basic filesystems (like tmpfs, proc, sys), initializing SELinux, and setting up security. It must complete before other phases can proceed.

### Question 4
Which phase typically handles mounting system partitions like /system and /vendor?

**A)** early-init  
**B)** init  
**C)** late-init  
**D)** post-fs

**Answer: B** - The init phase handles mounting system partitions. After early-init has set up the basic environment, init mounts the actual system partitions (system, vendor, data, etc.), creates device nodes, initializes the property system, and labels the filesystem with SELinux contexts.

### Question 5
What happens if a blocking operation is performed in an init phase?

**A)** It improves boot performance  
**B)** It blocks the entire init process, preventing subsequent phases from executing  
**C)** It runs in the background  
**D)** It is automatically skipped

**Answer: B** - Blocking operations in init phases will block the entire init process, preventing subsequent phases from executing. This can cause the boot process to hang. Init scripts should avoid blocking operations and instead use triggers, properties, or asynchronous mechanisms to handle operations that might take time.

## Related Topics

- [Init System in Android](./04.%20Init%20System%20in%20Android.md)
- [Boot Process Overview](./03.%20Boot%20Process%20Overview.md)
- [SELinux Policy Initialization](./17.%20SELinux%20Policy%20Initialization.md)
- [Initramfs in Android](./14.%20Initramfs%20in%20Android.md)

