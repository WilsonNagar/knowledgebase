---
number: 34
title: ART boot image & dex pre-optimization
slug: art-boot-image-dex-pre-optimization
level: beginner
tags:
  - aosp
  - art
  - boot-image
  - dex
  - optimization
  - runtime
  - pre-optimization
prerequisites:
  - build-system-structure
  - boot-process-overview
estimated_minutes: 85
contributors: []
diagrams: []
examples: []
canonical_id: aosp-beginner-34
---

# ART boot image & dex pre-optimization

## Overview

ART (Android Runtime) boot image and DEX pre-optimization are techniques that optimize Android applications and system code before they run on the device. The boot image contains pre-compiled system classes, and DEX pre-optimization converts DEX bytecode into optimized native code during build time. Understanding these optimization techniques is essential for AOSP development, as they significantly impact boot time, app launch speed, and overall system performance.

Think of ART boot image and DEX pre-optimization like pre-cooking meals: instead of cooking (compiling) every time you want to eat (run an app), you prepare and optimize the meals (code) in advance during meal prep (build time). When it's time to eat (app launch), the food is already ready and optimized, making it much faster to serve (launch apps).

## Deep Explanation

### What is ART Boot Image?

The ART boot image is a special file containing pre-compiled and pre-optimized system classes that are loaded into memory during boot. It's created during the build process and contains the most critical system classes needed for Android to function.

**Key Characteristics:**
- **Pre-compiled:** Classes compiled to native code
- **Pre-optimized:** Optimized during build
- **System Classes:** Critical framework classes
- **Fast Loading:** Loaded into memory at boot

**Why Boot Image?**
- **Boot Speed:** Faster system startup
- **Performance:** Optimized code ready to use
- **Efficiency:** Pre-compiled system classes
- **Optimization:** Build-time optimization

### Boot Image Contents

#### System Classes

**Framework Classes:**
- Core Android framework classes
- System service classes
- Critical system components
- Frequently used classes

**Examples:**
- `java.lang.*` classes
- `android.*` framework classes
- System service classes
- Core utilities

**Selection Criteria:**
- Frequently used
- Critical for boot
- System components
- Performance-sensitive

#### Pre-compiled Code

**Native Code:**
- Compiled to native instructions
- Architecture-specific
- Optimized for target CPU
- Ready to execute

**Optimization:**
- Inlining
- Dead code elimination
- Constant folding
- Register allocation

### Boot Image Creation

#### Build-Time Process

**Creation Steps:**
1. Identify system classes
2. Compile classes to native code
3. Optimize native code
4. Package into boot image
5. Include in system build

**Tools:**
- `dex2oat` - DEX to OAT compiler
- Build system integration
- Optimization passes
- Image packaging

#### Boot Image Format

**Image Structure:**
- Header with metadata
- Pre-compiled code sections
- Class metadata
- Optimization information

**File Location:**
- `system/framework/boot.art`
- `system/framework/boot-<arch>.art`
- Architecture-specific images
- Loaded at boot

### DEX Pre-optimization

#### What is DEX Pre-optimization?

DEX pre-optimization is the process of converting DEX (Dalvik Executable) bytecode into optimized native code (OAT - Optimized Android Type) during build time, rather than at runtime.

**Key Characteristics:**
- **Build-Time:** Happens during build
- **Native Code:** Converts to native instructions
- **Optimized:** Multiple optimization passes
- **Architecture-Specific:** CPU-specific code

**Why Pre-optimize?**
- **Performance:** Faster app execution
- **Boot Speed:** Faster system startup
- **Battery:** Less CPU usage at runtime
- **User Experience:** Faster app launches

### DEX to OAT Compilation

#### dex2oat Tool

**Purpose:**
Converts DEX bytecode to optimized native code.

**Usage:**
```bash
dex2oat --dex-file=app.dex --oat-file=app.oat
```

**Process:**
1. Parse DEX file
2. Analyze code
3. Optimize code
4. Generate native code
5. Create OAT file

**Optimization Passes:**
- Inlining
- Dead code elimination
- Constant propagation
- Register allocation
- Instruction selection

#### OAT File Format

**OAT Structure:**
- Header with metadata
- Native code sections
- DEX bytecode (optional)
- Class metadata
- Method information

**File Extensions:**
- `.oat` - Optimized Android Type
- `.odex` - Optimized DEX (legacy)
- `.vdex` - Verified DEX

### Pre-optimization Process

#### Build-Time Optimization

**When It Happens:**
- During AOSP build
- Before system image creation
- For all system apps
- For framework classes

**Process:**
1. Build system identifies DEX files
2. Calls dex2oat for each
3. Optimizes to native code
4. Packages optimized code
5. Includes in system image

#### Optimization Levels

**Compiler Filters:**
- `speed` - Maximum optimization
- `balanced` - Balanced optimization
- `space` - Size optimization
- `quicken` - Quick compilation

**Selection:**
- System apps: `speed`
- User apps: `balanced` or `quicken`
- Boot image: `speed`
- Performance vs. size trade-off

### Boot Image Benefits

#### Performance Benefits

**Boot Time:**
- Faster system startup
- Pre-compiled classes ready
- Less compilation at boot
- Reduced boot time

**App Launch:**
- Faster app startup
- Pre-optimized code
- Less JIT compilation
- Better user experience

**Runtime Performance:**
- Optimized native code
- Better CPU utilization
- Lower battery usage
- Improved responsiveness

#### Memory Benefits

**Memory Usage:**
- Shared boot image
- Multiple processes share
- Reduced memory footprint
- Efficient memory usage

**Code Sharing:**
- Boot image shared across processes
- Copy-on-write semantics
- Efficient memory management
- Reduced duplication

### DEX Pre-optimization Benefits

#### Build-Time vs Runtime

**Build-Time (Pre-optimization):**
- Optimize once during build
- No runtime overhead
- Better optimizations possible
- Consistent performance

**Runtime (JIT/AOT):**
- Optimize on device
- Runtime overhead
- Limited optimization time
- Variable performance

**Advantages of Pre-optimization:**
- No runtime cost
- Better optimizations
- Consistent performance
- Faster app launches

#### Performance Improvements

**App Launch:**
- 2-3x faster launch
- Less compilation needed
- Optimized code ready
- Better user experience

**Runtime:**
- Faster execution
- Better CPU efficiency
- Lower battery usage
- Improved performance

### Boot Image Configuration

#### Build Configuration

**Enable Boot Image:**
- Enabled by default
- Build system handles
- Automatic creation
- No manual configuration needed

**Configuration Options:**
- Class selection
- Optimization level
- Image size limits
- Architecture support

#### Customization

**Class Selection:**
- Configure which classes included
- Balance size vs. performance
- System-specific needs
- Custom requirements

**Optimization:**
- Choose optimization level
- Balance speed vs. size
- Performance requirements
- Device capabilities

### DEX Optimization Configuration

#### Compiler Filters

**Speed Filter:**
- Maximum optimization
- Best performance
- Larger code size
- Longer compilation

**Balanced Filter:**
- Balanced optimization
- Good performance
- Reasonable size
- Faster compilation

**Quicken Filter:**
- Quick compilation
- Basic optimization
- Smaller size
- Fastest compilation

#### Filter Selection

**System Apps:**
- Use `speed` filter
- Maximum performance
- Boot time critical
- System stability

**User Apps:**
- Use `balanced` or `quicken`
- Balance performance and size
- User experience
- Storage considerations

### Build System Integration

#### Automatic Optimization

**Build Process:**
1. Build system identifies DEX files
2. Automatically calls dex2oat
3. Optimizes during build
4. Packages optimized code
5. Includes in system image

**Transparency:**
- Automatic process
- No manual steps
- Build system handles
- Developer transparent

#### Build Targets

**Boot Image Target:**
```bash
m bootimage  # Build boot image
```

**System Image:**
- Includes optimized apps
- Pre-optimized DEX files
- Boot image included
- Complete optimized system

### Optimization Trade-offs

#### Performance vs Size

**Performance:**
- Better optimization = better performance
- But larger code size
- More compilation time
- Better user experience

**Size:**
- Smaller code = less storage
- But less optimization
- Faster compilation
- Storage constraints

**Balance:**
- Choose based on device
- Storage vs. performance
- User experience priority
- Device capabilities

#### Compilation Time

**Build Time:**
- Pre-optimization adds build time
- But saves runtime
- One-time cost
- Better overall experience

**Trade-off:**
- Longer builds
- But faster runtime
- Better user experience
- Worth the cost

### Best Practices

#### Optimization Strategy

**System Components:**
- Maximum optimization
- Performance critical
- Boot time important
- System stability

**User Apps:**
- Balanced optimization
- User experience
- Storage considerations
- Performance needs

#### Monitoring

**Performance:**
- Monitor boot time
- Track app launch times
- Measure optimization impact
- Verify improvements

**Size:**
- Monitor image sizes
- Balance size vs. performance
- Storage constraints
- Optimization levels

## Key Takeaways

1. **ART boot image** contains pre-compiled and pre-optimized system classes loaded at boot for faster system startup.

2. **DEX pre-optimization** converts DEX bytecode to optimized native code during build time, improving runtime performance.

3. **Boot image benefits** include faster boot time, faster app launches, and better runtime performance through pre-compiled code.

4. **DEX pre-optimization benefits** include faster app execution, reduced runtime compilation overhead, and better battery efficiency.

5. **dex2oat tool** performs the DEX to OAT conversion with multiple optimization passes for best performance.

6. **Compiler filters** (speed, balanced, quicken) allow balancing optimization level with code size and compilation time.

7. **Build system automatically** handles boot image creation and DEX pre-optimization during the AOSP build process.

8. **Understanding ART boot image and DEX pre-optimization** is essential for optimizing Android system performance and build processes.

## Related Topics

- **Build System Structure:** How boot image and DEX optimization integrate with the build system
- **Boot Process Overview:** How boot image is loaded during system startup
- **Android Runtime (ART):** The runtime that uses boot image and optimized code
- **ccache & build acceleration:** Other build-time optimization techniques

