---
number: 41
title: Kernel modules
slug: kernel-modules
level: beginner
tags:
  - aosp
  - kernel
  - modules
  - drivers
  - loadable
  - compilation
  - development
prerequisites:
  - differences-android-kernel-linux-kernel
  - build-system-structure
estimated_minutes: 80
contributors: []
diagrams: []
examples: []
canonical_id: aosp-beginner-41
---

# Kernel modules

## Overview

Kernel modules are loadable pieces of kernel code that can be inserted into and removed from the running kernel without rebooting. Understanding kernel modules is essential for AOSP development, as they allow adding functionality to the kernel dynamically, developing device drivers, and extending kernel capabilities without recompiling the entire kernel. This guide provides a comprehensive overview of kernel modules, how they work, how to create them, and how they're used in Android.

Think of kernel modules like plug-in extensions: just as you can add plugins to software to extend functionality without reinstalling the entire program, kernel modules allow you to add drivers and features to the kernel without recompiling and rebooting. They're like "hot-swappable" components that can be loaded when needed and unloaded when not needed, making the kernel more flexible and modular.

## Deep Explanation

### What are Kernel Modules?

Kernel modules are pieces of kernel code that can be dynamically loaded into and unloaded from a running kernel. They extend kernel functionality without requiring a kernel recompilation or system reboot.

**Key Characteristics:**
- **Loadable:** Can be loaded at runtime
- **Unloadable:** Can be removed when not needed
- **Dynamic:** No reboot required
- **Modular:** Extend kernel functionality

**Why Kernel Modules?**
- **Flexibility:** Add features without reboot
- **Modularity:** Keep kernel small
- **Development:** Easier driver development
- **Maintenance:** Update drivers independently

### Kernel Module Types

#### Device Drivers

**Purpose:**
Hardware device drivers.

**Examples:**
- USB drivers
- Network drivers
- Storage drivers
- Input drivers

**Characteristics:**
- Hardware-specific
- Device communication
- I/O operations
- Hardware control

#### File System Drivers

**Purpose:**
File system implementations.

**Examples:**
- ext4, ext3
- FAT32, NTFS
- Network file systems
- Special file systems

**Characteristics:**
- File system support
- Storage access
- Data organization
- File operations

#### Network Protocols

**Purpose:**
Network protocol implementations.

**Examples:**
- TCP/IP stack components
- Network protocols
- Firewall modules
- VPN modules

**Characteristics:**
- Network functionality
- Protocol support
- Network operations
- Communication

#### System Features

**Purpose:**
System-level features and extensions.

**Examples:**
- Security modules
- Monitoring tools
- Debugging modules
- Custom features

**Characteristics:**
- System extensions
- Additional functionality
- Custom features
- System integration

### Kernel Module Structure

#### Basic Module

**Minimal Module:**
```c
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/init.h>

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Your Name");
MODULE_DESCRIPTION("A simple kernel module");

static int __init mymodule_init(void)
{
    printk(KERN_INFO "My module loaded\n");
    return 0;
}

static void __exit mymodule_exit(void)
{
    printk(KERN_INFO "My module unloaded\n");
}

module_init(mymodule_init);
module_exit(mymodule_exit);
```

**Key Components:**
- Module metadata (LICENSE, AUTHOR, etc.)
- Init function (`__init`)
- Exit function (`__exit`)
- Registration macros

#### Module Functions

**Init Function:**
- Called when module loads
- Initialize module
- Register resources
- Return 0 on success

**Exit Function:**
- Called when module unloads
- Cleanup resources
- Unregister resources
- Free memory

### Building Kernel Modules

#### Makefile for Module

**Basic Makefile:**
```makefile
obj-m += mymodule.o

KDIR := /path/to/kernel

all:
    make -C $(KDIR) M=$(PWD) modules

clean:
    make -C $(KDIR) M=$(PWD) clean
```

**Key Elements:**
- `obj-m` - Module object
- `KDIR` - Kernel source directory
- Build command
- Clean target

#### Building Process

**Steps:**
1. Write module source
2. Create Makefile
3. Build module
4. Load module

**Build Command:**
```bash
make -C /path/to/kernel M=$(pwd) modules
```

**Output:**
- `.ko` file (kernel object)
- Loadable module
- Architecture-specific
- Ready to load

### Loading and Unloading Modules

#### Loading Modules

**insmod Command:**
```bash
insmod mymodule.ko
```

**modprobe Command:**
```bash
modprobe mymodule
```

**Differences:**
- `insmod` - Simple load
- `modprobe` - Loads dependencies
- `modprobe` - Better for production
- `insmod` - Direct loading

#### Unloading Modules

**rmmod Command:**
```bash
rmmod mymodule
```

**modprobe -r:**
```bash
modprobe -r mymodule
```

**Requirements:**
- Module must support unloading
- No active users
- Resources freed
- Safe to remove

#### Module Information

**lsmod:**
```bash
lsmod
```

**Shows:**
- Loaded modules
- Module sizes
- Reference counts
- Dependencies

**modinfo:**
```bash
modinfo mymodule.ko
```

**Shows:**
- Module information
- License
- Author
- Description
- Parameters

### Module Dependencies

#### Dependency Management

**Module Dependencies:**
- Modules can depend on others
- Loaded automatically
- Dependency resolution
- Order matters

**modprobe:**
- Handles dependencies
- Loads in order
- Automatic resolution
- Better than insmod

#### Dependency Example

**Module A depends on Module B:**
```bash
# modprobe loads B first, then A
modprobe module_a
# Automatically loads module_b first
```

**Manual Loading:**
```bash
# Must load in order
insmod module_b.ko
insmod module_a.ko
```

### Module Parameters

#### Defining Parameters

**Module with Parameters:**
```c
static int my_param = 10;
module_param(my_param, int, 0644);
MODULE_PARM_DESC(my_param, "My parameter description");
```

**Parameter Types:**
- `int` - Integer
- `long` - Long integer
- `charp` - Character pointer (string)
- `bool` - Boolean

**Permissions:**
- `0644` - Read/write permissions
- `0444` - Read-only
- Controls `/sys/module/` access

#### Using Parameters

**At Load Time:**
```bash
insmod mymodule.ko my_param=20
```

**At Runtime:**
```bash
echo 30 > /sys/module/mymodule/parameters/my_param
```

**Reading:**
```bash
cat /sys/module/mymodule/parameters/my_param
```

### Kernel Module APIs

#### Common APIs

**Memory Management:**
```c
kmalloc()    // Kernel memory allocation
kfree()      // Free kernel memory
vmalloc()    // Virtual memory allocation
vfree()      // Free virtual memory
```

**Printing:**
```c
printk()     // Kernel logging
pr_info()    // Info level
pr_err()     // Error level
pr_debug()   // Debug level
```

**Device Registration:**
```c
register_chrdev()  // Character device
register_blkdev()  // Block device
platform_driver_register()  // Platform driver
```

### Module Lifecycle

#### Loading Sequence

**1. Module Load Request:**
- User or system requests load
- Kernel checks module
- Validates module

**2. Dependency Resolution:**
- Checks dependencies
- Loads dependencies first
- Resolves all dependencies

**3. Module Initialization:**
- Calls module init function
- Module sets up
- Registers resources
- Returns success/failure

**4. Module Active:**
- Module is loaded
- Functionality available
- Can be used
- Active in kernel

#### Unloading Sequence

**1. Unload Request:**
- User or system requests unload
- Kernel checks usage
- Verifies safe to unload

**2. Module Cleanup:**
- Calls module exit function
- Unregisters resources
- Frees memory
- Cleans up

**3. Module Removed:**
- Module unloaded
- Functionality removed
- Memory freed
- No longer active

### Module Development

#### Development Workflow

**1. Write Module:**
- Create source file
- Implement functionality
- Add init/exit functions

**2. Create Makefile:**
- Define module
- Set kernel path
- Build configuration

**3. Build Module:**
- Compile module
- Generate .ko file
- Check for errors

**4. Test Module:**
- Load module
- Test functionality
- Check logs
- Verify operation

**5. Debug:**
- Check kernel logs
- Use debugging tools
- Fix issues
- Iterate

#### Debugging Modules

**Kernel Logs:**
```bash
dmesg | tail
# Or
cat /proc/kmsg
```

**Common Issues:**
- Compilation errors
- Loading failures
- Runtime errors
- Resource leaks

**Tools:**
- `dmesg` - Kernel messages
- `lsmod` - Module status
- `modinfo` - Module info
- `strace` - System calls

### Module Best Practices

#### Code Quality

**Best Practices:**
- Follow kernel coding style
- Proper error handling
- Resource cleanup
- Documentation

**Error Handling:**
- Check return values
- Handle errors properly
- Cleanup on failure
- Informative messages

#### Resource Management

**Allocation:**
- Allocate in init
- Check for success
- Handle failures
- Track resources

**Cleanup:**
- Free in exit
- Release all resources
- Unregister everything
- Prevent leaks

### Module Security

#### Security Considerations

**Permissions:**
- Module loading permissions
- Root access required
- Security implications
- Trust requirements

**Validation:**
- Module signature checking
- Secure boot integration
- Module verification
- Security policies

### Android-Specific Considerations

#### Android Kernel Modules

**Built-in vs Modules:**
- Many drivers built-in
- Some as modules
- Device-specific
- Configuration-dependent

**Module Loading:**
- Early boot modules
- Runtime modules
- Device-specific
- Vendor modules

#### Module Development for Android

**Android Kernel:**
- Android-specific APIs
- Android drivers
- Device-specific code
- Vendor modules

**Build Integration:**
- Android build system
- Module compilation
- Device integration
- Build configuration

## Key Takeaways

1. **Kernel modules are loadable kernel code** that can be inserted and removed from the running kernel without rebooting.

2. **Modules extend kernel functionality** by adding device drivers, file systems, network protocols, and system features dynamically.

3. **Modules have init and exit functions** that are called when the module is loaded and unloaded respectively.

4. **Modules are built using Makefiles** that reference the kernel source directory and compile to `.ko` (kernel object) files.

5. **Modules are loaded with `insmod` or `modprobe`** and unloaded with `rmmod`, with `modprobe` handling dependencies automatically.

6. **Modules can have parameters** that can be set at load time or runtime via `/sys/module/` interface.

7. **Module development requires** proper error handling, resource management, and cleanup to prevent kernel issues.

8. **Understanding kernel modules** is essential for driver development, kernel extension, and AOSP customization.

## Related Topics

- **Differences between Android kernel & Linux kernel:** How modules work in Android kernel
- **Kernel configuration (defconfig):** How to configure which modules are built
- **Building the kernel:** How modules are compiled as part of kernel build
- **Binder driver (low-level):** An example of an Android kernel module

