---
number: 4
title: "Init System in Android"
slug: "init-system-in-android"
level: "beginner"
tags: ["aosp", "init", "system-initialization", "init-rc", "services", "properties"]
prerequisites: ["boot-process-overview", "android-architecture-complete-overview"]
estimated_minutes: 90
contributors: []
diagrams: []
examples: []
canonical_id: "aosp-beginner-04"
---

# Init System in Android

## Overview

The init system is the first userspace process (PID 1) that starts when the Linux kernel finishes booting. It's the "parent of all processes" and is responsible for initializing the Android system, starting services, managing the system lifecycle, and setting up the environment for all other processes. Understanding the init system is crucial for AOSP development, as it controls how the system boots, which services start, and how the system behaves.

Think of init as the "conductor of an orchestra" - just as a conductor coordinates all musicians to play in harmony, init coordinates all system components to work together. It doesn't play any music itself (doesn't provide user functionality), but without it, nothing would work properly.

## Deep Explanation

### What is Init?

Init (short for "initialization") is a special process in Unix-like systems, including Android. It's always process ID 1 (PID 1), making it the first userspace process and the ancestor of all other processes.

**Key Characteristics:**
- **PID 1:** Always the first process (kernel creates it)
- **Cannot be killed:** Kernel prevents init from being terminated
- **Parent process:** All orphaned processes become children of init
- **System manager:** Starts, monitors, and manages all system services
- **Critical process:** System cannot function without init

**Why Init is Special:**

In Unix/Linux systems, PID 1 has special significance:
- **Orphan handling:** When a parent process dies, its children become orphans and are adopted by init
- **Zombie reaping:** Init reaps zombie processes (processes that have exited but haven't been cleaned up)
- **System stability:** If init dies, the kernel panics (system crash)
- **Signal handling:** Init handles certain signals specially (SIGCHLD for child process termination)

### Init's Role in Android Boot

Init is the bridge between the kernel and the Android system. Here's its position in the boot sequence:

```
1. Boot ROM → 2. Bootloader → 3. Kernel → 4. Init (PID 1) → 5. Zygote → 6. System Server → 7. Apps
```

**Init's Responsibilities During Boot:**

1. **Early Initialization:**
   - Mount essential filesystems
   - Set up directory structure
   - Initialize security (SELinux)
   - Create device nodes

2. **Service Startup:**
   - Parse init scripts (`.rc` files)
   - Start system services in correct order
   - Handle service dependencies
   - Monitor service health

3. **System Configuration:**
   - Initialize property system
   - Load system properties
   - Set up environment variables
   - Configure system behavior

4. **Ongoing Management:**
   - Monitor running services
   - Restart crashed services
   - Handle property changes
   - Manage system state transitions

### Init Process Lifecycle

#### Creation by Kernel

When the kernel finishes its initialization:

1. **Kernel creates init:**
   - Kernel calls `kernel_init()` function
   - Creates first userspace process
   - Sets PID to 1
   - Sets up process structure

2. **Init starts executing:**
   - Init binary is `/system/bin/init` or `/init` (in ramdisk)
   - Init starts in kernel space, then transitions to userspace
   - Begins executing init's main function

3. **Initial setup:**
   - Init sets up signal handlers
   - Initializes internal data structures
   - Prepares for service management

#### Execution Phases

Init executes in distinct phases:

**Phase 1: Early Init**
- Very early initialization
- Critical system setup
- Security initialization
- Essential mounts

**Phase 2: Init**
- Main initialization
- Service parsing
- Property system setup
- Most services start here

**Phase 3: Late Init**
- Non-critical services
- User-space daemons
- Final system setup
- Boot completion

**Phase 4: Running State**
- System is fully booted
- Services are running
- Monitoring and maintenance
- Handles runtime events

### Init Scripts (init.rc)

Init scripts are written in a special language that init understands. These scripts define what init should do during boot and runtime.

#### Script Locations

Init loads scripts from multiple locations:

**Primary Scripts:**
- `/init.rc` - Main init script (in ramdisk or root)
- `/system/etc/init/` - System init scripts
- `/vendor/etc/init/` - Vendor init scripts
- `/odm/etc/init/` - ODM (Original Design Manufacturer) scripts

**Loading Order:**
1. `/init.rc` (if in ramdisk)
2. `/system/etc/init/*.rc`
3. `/vendor/etc/init/*.rc`
4. `/odm/etc/init/*.rc`

Scripts are loaded in this order, with later scripts able to override earlier ones.

#### Init Language Syntax

The init language is declarative - you describe what you want, not how to do it.

**Basic Structure:**
```
# Comments start with #

# Actions
on <trigger>
    <command>
    <command>

# Services
service <name> <path> [arguments]
    <option>
    <option>

# Imports
import <path>
```

**Actions:**

Actions define what to do when certain events occur:

```
on early-init
    # Commands to run during early-init phase
    mkdir /dev
    mkdir /proc
    mkdir /sys

on init
    # Commands to run during init phase
    mount ext4 /dev/block/system /system ro
    mount ext4 /dev/block/vendor /vendor ro

on late-init
    # Commands to run during late-init phase
    trigger post-fs
    trigger post-fs-data
```

**Service Definitions:**

Services define long-running processes:

```
service zygote /system/bin/app_process64 -Xzygote /system/bin --zygote --start-system-server
    class main
    priority -20
    user root
    group root readproc
    socket zygote stream 660 root system
    onrestart write /sys/power/state on
    onrestart restart audioserver
    writepid /dev/cpuset/foreground/tasks
```

**Service Options Explained:**

- **class:** Service class (main, core, late_start, etc.)
- **priority:** Process priority (nice value, lower = higher priority)
- **user/group:** Run as specific user/group
- **socket:** Create a Unix domain socket
- **onrestart:** Commands to run when service restarts
- **writepid:** Write process ID to file
- **oneshot:** Service exits after starting (don't restart)
- **disabled:** Don't start automatically (start manually)

#### Action Triggers

Actions are triggered by events:

**Boot-time Triggers:**
- `early-init` - Very early, before most initialization
- `init` - Main initialization phase
- `late-init` - After main init, before services start
- `post-fs` - After filesystems mounted
- `post-fs-data` - After /data partition mounted
- `boot` - After boot completes

**Property Triggers:**
- `on property:name=value` - When property changes to value
- `on property:name=*` - When property is set to any value

**Example:**
```
on property:sys.boot_completed=1
    # System has finished booting
    start my_service
    setprop my.property value
```

**Service Triggers:**
- `on property:init.svc.<name>=stopped` - When service stops
- `on property:init.svc.<name>=running` - When service starts

#### Service Management

Init manages services throughout their lifecycle:

**Starting Services:**

Services can start automatically or manually:

**Automatic Start:**
```
service myservice /system/bin/myservice
    class main
    # Starts automatically when class "main" starts
```

**Manual Start:**
```
service myservice /system/bin/myservice
    class main
    disabled
    # Must be started manually: start myservice
```

**Starting a Service:**
```
# In init script or via property
start myservice
```

**Stopping a Service:**
```
stop myservice
```

**Restarting a Service:**
```
restart myservice
```

**Service States:**

Init tracks service states:
- **stopped** - Service is not running
- **starting** - Service is starting
- **running** - Service is running
- **restarting** - Service is restarting

**Monitoring Services:**

Init monitors services and can restart them:
- If service exits unexpectedly, init can restart it
- Restart behavior depends on service options
- `oneshot` services don't restart
- Services with `onrestart` run those commands when restarting

### Property System

The property system is Android's key-value store for system configuration. Init manages the property system.

#### Property Types

**Read-Only Properties (ro.*):**
- Set once during boot
- Cannot be changed at runtime
- Examples: `ro.build.version`, `ro.product.model`
- Used for device identification and build information

**Read-Write Properties:**
- Can be changed at runtime
- Examples: `sys.settings.global`, `persist.sys.timezone`
- Used for runtime configuration

**Control Properties (ctl.*):**
- Special properties that trigger actions
- Setting them causes init to perform actions
- Examples: `ctl.start`, `ctl.stop`, `ctl.restart`

**Persistent Properties (persist.*):**
- Survive reboots
- Stored in `/data/property/`
- Examples: `persist.sys.timezone`, `persist.vendor.audio`

#### Property Operations

**Setting Properties:**

In init scripts:
```
setprop property.name value
```

From command line:
```bash
adb shell setprop property.name value
```

From code:
```java
SystemProperties.set("property.name", "value");
```

**Getting Properties:**

From command line:
```bash
adb shell getprop property.name
adb shell getprop  # List all properties
```

From code:
```java
String value = SystemProperties.get("property.name", "default");
```

**Property Files:**

Properties are loaded from files:
- `/system/build.prop` - System build properties
- `/vendor/build.prop` - Vendor properties
- `/default.prop` - Default properties (in ramdisk)
- `/data/local.prop` - Local overrides (if exists)

**Property Service:**

Init starts the property service daemon:
- Listens on `/dev/socket/property_service`
- Handles property read/write requests
- Broadcasts property changes
- Manages property triggers

#### Property Triggers

Properties can trigger actions when they change:

```
on property:sys.boot_completed=1
    # Triggered when boot completes
    start my_service
    setprop my.ready 1

on property:ro.debuggable=1
    # Triggered if device is debuggable
    start adbd
    setprop service.adb.tcp.port 5555
```

**Common Property Triggers:**
- `sys.boot_completed=1` - System finished booting
- `dev.bootcomplete=1` - Device boot complete
- `init.svc.<name>=running` - Service started
- `init.svc.<name>=stopped` - Service stopped

### SELinux Integration

Init is responsible for initializing SELinux (Security-Enhanced Linux), Android's mandatory access control system.

#### SELinux Initialization

**Policy Loading:**

Init loads the SELinux policy:
1. Policy file location: `/sepolicy` or `/sys/fs/selinux/policy`
2. Policy is compiled binary format
3. Loaded into kernel's SELinux subsystem
4. Policy defines what processes can access what resources

**Context Setting:**

Init sets SELinux contexts:
- **Process contexts:** Each process gets a domain (e.g., `system_server`, `untrusted_app`)
- **File contexts:** Each file gets a type (e.g., `system_file`, `app_data_file`)
- **Contexts determine:** What processes can access what files/processes

**File Context Application:**

Init applies file contexts from `/file_contexts`:
- Sets SELinux labels on all files during boot
- Ensures proper security contexts
- Required for SELinux enforcement

**Mode Transition:**

Init transitions SELinux mode:
1. **Permissive mode:** Logs violations but doesn't block (during early boot)
2. **Enforcing mode:** Blocks violations (after policy loaded)
3. Transition happens after policy is loaded and file contexts applied

**Example:**
```
# In init.rc
on early-init
    # Load SELinux policy
    load_policy /sepolicy
    
    # Apply file contexts
    restorecon_recursive /system
    restorecon_recursive /vendor
    restorecon_recursive /data
    
    # Transition to enforcing
    setenforce 1
```

### Service Classes

Services are organized into classes that start together:

**Core Class:**
- Critical system services
- Start very early
- Examples: servicemanager, hwservicemanager, vndservicemanager

**Main Class:**
- Normal system services
- Start during main init phase
- Examples: zygote, surfaceflinger, audioserver

**Late Start Class:**
- Services that start after main services
- Non-critical services
- Examples: some vendor services

**Charger Class:**
- Services for charger mode (device charging while off)
- Only start when in charger mode
- Examples: charger service

**Starting Classes:**
```
class_start main    # Start all services in "main" class
class_stop main     # Stop all services in "main" class
class_reset main    # Stop and restart all services in "main" class
```

### Init Phases in Detail

#### Early Init Phase

**Timing:** Very early, before most initialization

**Purpose:** Critical system setup that everything else depends on

**Typical Actions:**
```
on early-init
    # Create essential directories
    mkdir /dev
    mkdir /proc
    mkdir /sys
    mkdir /system
    mkdir /data
    mkdir /vendor
    
    # Mount essential filesystems
    mount tmpfs tmpfs /dev
    mount proc proc /proc
    mount sysfs sysfs /sys
    
    # Initialize SELinux
    load_policy /sepolicy
    setenforce 0  # Start permissive
    
    # Set up security
    restorecon_recursive /system
```

**Why Early:**
- Other phases depend on these mounts
- Security must be initialized early
- Directory structure needed for everything else

#### Init Phase

**Timing:** Main initialization, after early-init

**Purpose:** Set up system, mount partitions, initialize subsystems

**Typical Actions:**
```
on init
    # Mount system partitions
    mount ext4 /dev/block/system /system ro
    mount ext4 /dev/block/vendor /vendor ro
    mount ext4 /dev/block/product /product ro
    
    # Create device nodes
    mknod /dev/null c 1 3
    mknod /dev/zero c 1 5
    mknod /dev/random c 1 8
    mknod /dev/urandom c 1 9
    
    # Set up symlinks
    symlink /system/bin /bin
    symlink /system/etc /etc
    
    # Initialize property system
    property_init
    load_properties /system/build.prop
    load_properties /vendor/build.prop
```

**Key Activities:**
- Mount all partitions
- Create device nodes
- Set up directory structure
- Initialize property system
- Load system properties

#### Late Init Phase

**Timing:** After main init, before services start

**Purpose:** Final setup before services start

**Typical Actions:**
```
on late-init
    # Trigger post-fs actions
    trigger post-fs
    
    # Trigger post-fs-data actions
    trigger post-fs-data
    
    # Start core services
    class_start core
    
    # Start main services
    class_start main
```

**Key Activities:**
- Trigger post-mount actions
- Start service classes
- Final system configuration
- Prepare for service startup

### Real-World Examples

#### Example 1: Starting Zygote

Here's how Zygote service is typically defined:

```
service zygote /system/bin/app_process64 -Xzygote /system/bin --zygote --start-system-server
    class main
    priority -20
    user root
    group root readproc
    socket zygote stream 660 root system
    socket usap_pool_primary stream 660 root system
    onrestart write /sys/power/state on
    onrestart restart audioserver
    onrestart restart cameraserver
    onrestart restart media
    onrestart restart netd
    onrestart restart wificond
    writepid /dev/cpuset/foreground/tasks /dev/stune/foreground/tasks
```

**Breaking it down:**
- **service zygote:** Service name
- **/system/bin/app_process64:** Executable path
- **-Xzygote /system/bin --zygote --start-system-server:** Arguments
- **class main:** Starts with "main" class
- **priority -20:** High priority (nice value)
- **user root:** Run as root user
- **socket zygote:** Create socket for app process creation
- **onrestart:** Commands when Zygote restarts
- **writepid:** Write process ID to cpuset files

#### Example 2: Property-Based Service Start

```
# Service definition
service adbd /system/bin/adbd
    class core
    socket adbd stream 660 system system
    disabled
    seclabel u:r:adbd:s0

# Start when device is debuggable
on property:ro.debuggable=1
    write /sys/class/android_usb/android0/enable 1
    start adbd

# Start when USB debugging enabled
on property:sys.usb.config=adb && property:sys.usb.ffs.ready=1
    start adbd
```

This shows:
- Service starts conditionally (not always)
- Multiple triggers can start the same service
- Properties control service behavior

#### Example 3: Mounting Partitions

```
on init
    # Wait for block device
    wait /dev/block/bootdevice
    
    # Mount system partition
    mount ext4 /dev/block/bootdevice /system ro wait,avb=vbmeta_system
    mount ext4 /dev/block/bootdevice /vendor ro wait,avb=vbmeta_vendor
    
    # Mount data partition
    mount ext4 /dev/block/bootdevice /data noatime,nosuid,nodev,noauto_da_alloc,barrier=1 wait,check,formattable,resize,quota
```

**Mount options explained:**
- **ro:** Read-only
- **wait:** Wait for device to be ready
- **avb=:** Android Verified Boot metadata
- **noatime:** Don't update access times (performance)
- **check:** Check filesystem on mount
- **formattable:** Can be formatted if corrupted

### Debugging Init

#### Viewing Init Logs

Init logs to kernel log and Android log:

**Kernel log:**
```bash
adb shell dmesg | grep init
```

**Android log:**
```bash
adb logcat -s init
adb logcat -s init:*  # All init-related logs
```

#### Checking Service Status

**List all services:**
```bash
adb shell getprop | grep init.svc
```

**Check specific service:**
```bash
adb shell getprop init.svc.zygote
# Returns: running, stopped, restarting, etc.
```

#### Viewing Properties

**All properties:**
```bash
adb shell getprop
```

**Specific property:**
```bash
adb shell getprop ro.build.version.release
```

#### Common Issues

**Service Not Starting:**
- Check service definition in init scripts
- Verify executable path exists
- Check permissions
- Review init logs for errors

**Property Not Setting:**
- Verify property name spelling
- Check if property is read-only (ro.*)
- Ensure property service is running
- Review property triggers

**SELinux Denials:**
- Check SELinux context
- Review policy
- Check file contexts
- Use `dmesg | grep avc` for denials

### Best Practices

#### For Init Scripts

**1. Use Appropriate Phases:**
- Early-init: Only critical setup
- Init: Main initialization
- Late-init: Service startup

**2. Handle Dependencies:**
- Start services in dependency order
- Use triggers appropriately
- Don't start services before prerequisites ready

**3. Error Handling:**
- Use `wait` for block devices
- Check if files/directories exist
- Handle mount failures gracefully

**4. Security:**
- Set appropriate SELinux contexts
- Use least privilege (don't run as root if not needed)
- Follow SELinux policies

#### For Service Definitions

**1. Clear Naming:**
- Use descriptive service names
- Follow naming conventions
- Document service purpose

**2. Proper Options:**
- Set appropriate user/group
- Use correct service class
- Set priority appropriately

**3. Restart Behavior:**
- Use `oneshot` for services that shouldn't restart
- Define `onrestart` actions carefully
- Consider restart impact

**4. Resource Management:**
- Set CPU/memory limits if needed
- Use cpusets appropriately
- Monitor resource usage

## Edge Cases and Pitfalls

### Common Mistakes

**1. Circular Dependencies:**
```
# BAD: Service A depends on B, B depends on A
service A /system/bin/A
    class main
    # Waits for B

service B /system/bin/B
    class main
    # Waits for A
```

**Solution:** Restructure dependencies or use lazy initialization

**2. Blocking Operations:**
```
# BAD: Blocking operation in init script
on init
    sleep 10  # Blocks init!
    start service
```

**Solution:** Use triggers or property-based starts

**3. Missing Wait:**
```
# BAD: Mount before device ready
on init
    mount ext4 /dev/block/system /system
```

**Solution:** Use `wait` option:
```
mount ext4 /dev/block/system /system wait
```

**4. Wrong Service Class:**
```
# BAD: Critical service in wrong class
service critical_service /system/bin/critical
    class late_start  # Starts too late!
```

**Solution:** Use appropriate class (core or main)

### Best Practices

- Keep init scripts simple and declarative
- Use appropriate phases for actions
- Handle dependencies correctly
- Test init changes thoroughly
- Document service purposes
- Follow security best practices
- Monitor service health
- Use property triggers effectively

## References and Further Reading

- [AOSP Init Source Code](https://cs.android.com/android/platform/superproject/+/master:system/core/init/)
- [Init Language Documentation](https://source.android.com/docs/core/architecture/init)
- [Property System Documentation](https://source.android.com/docs/core/architecture/init#property_system)
- [SELinux in Android](https://source.android.com/docs/security/features/selinux)

## Quiz

### Question 1
What is the process ID (PID) of the init process?

**A)** 0  
**B)** 1  
**C)** 1000  
**D)** Varies by device

**Answer: B** - Init is always PID 1, as it's the first userspace process created by the kernel.

### Question 2
What happens if the init process is killed?

**A)** Nothing, it restarts automatically  
**B)** The system continues running normally  
**C)** The kernel panics and the system crashes  
**D)** Only init's children are affected

**Answer: C** - If init (PID 1) is killed, the kernel panics because init is critical for system operation. The kernel prevents init from being killed under normal circumstances.

### Question 3
What is the purpose of service classes in init?

**A)** To organize services by functionality  
**B)** To start groups of services together  
**C)** To set service priorities  
**D)** To define service permissions

**Answer: B** - Service classes allow init to start groups of related services together using `class_start <classname>`, making service management more organized.

### Question 4
Which property type survives reboots?

**A)** ro.* (read-only properties)  
**B)** sys.* (system properties)  
**C)** persist.* (persistent properties)  
**D)** ctl.* (control properties)

**Answer: C** - Persistent properties (persist.*) are stored in `/data/property/` and survive reboots, making them suitable for user settings and configuration that should persist.

### Question 5
In what order are init phases executed?

**A)** init → early-init → late-init  
**B)** early-init → init → late-init  
**C)** late-init → init → early-init  
**D)** All phases execute simultaneously

**Answer: B** - Init phases execute in order: early-init (critical setup), init (main initialization), late-init (service startup and final setup).

## Related Topics

- [Android Architecture - Complete Overview](./01.%20Android%20Architecture%20-%20Complete%20Overview.md)
- [Boot Process Overview](./03.%20Boot%20Process%20Overview.md)
- [System Properties](./05.%20System%20Properties.md)
- [SELinux Overview](./07.%20SELinux%20Overview.md)

