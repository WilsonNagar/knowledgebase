---
number: 5
title: System Properties
slug: system-properties
level: beginner
tags:
  - aosp
  - properties
  - system-configuration
  - init
  - build-props
prerequisites:
  - init-system-in-android
  - android-architecture-complete-overview
estimated_minutes: 75
contributors: []
diagrams: []
examples: []
canonical_id: aosp-beginner-05
---

# System Properties

## Overview

System properties are Android's key-value configuration system that provides a way to store and retrieve system-wide configuration values. They're used throughout the Android system for device identification, build information, runtime configuration, and feature flags. Understanding system properties is essential for AOSP development, as they control many aspects of system behavior and are used extensively by the framework, services, and applications.

Think of system properties as a "global settings database" - they're like environment variables in traditional operating systems, but with additional features like persistence, triggers, and security controls. Properties allow different parts of the system to share configuration without tight coupling.

## Deep Explanation

### What are System Properties?

System properties are string key-value pairs that can be read and (sometimes) written by processes throughout the Android system. They provide a simple but powerful mechanism for:

- **Device Identification:** Model, manufacturer, hardware info
- **Build Information:** Android version, build ID, security patch level
- **Runtime Configuration:** Feature flags, debug settings, user preferences
- **System State:** Boot status, service states, device state
- **Configuration:** System behavior, resource limits, feature toggles

**Key Characteristics:**
- **Global Access:** Any process can read properties (with some restrictions)
- **Fast Access:** Optimized for frequent reads
- **Persistent:** Some properties survive reboots
- **Trigger Support:** Property changes can trigger actions
- **Security:** Write access is restricted

### Property System Architecture

#### Property Service

The property system is managed by the **property service**, a daemon started by init:

**Location:**
- Property service runs in init process
- Listens on Unix domain socket: `/dev/socket/property_service`
- Handles property read/write requests

**How It Works:**

```
┌─────────────┐         ┌──────────────────┐         ┌─────────────┐
│   Process   │────────▶│ Property Service  │────────▶│  Properties │
│  (App/      │  Binder │   (in init)       │         │   Storage   │
│  Service)   │  Call   │                   │         │             │
└─────────────┘         └──────────────────┘         └─────────────┘
```

**Request Flow:**
1. Process wants to read/write property
2. Makes system call or uses libc function
3. Request goes to property service via socket
4. Property service processes request
5. Returns result to caller

**Performance:**
- Properties are cached in each process's memory
- Direct memory access for reads (very fast)
- Writes go through property service (slightly slower)
- Cache invalidation on property changes

### Property Types

#### Read-Only Properties (ro.*)

Read-only properties are set once during boot and cannot be changed at runtime.

**Naming Convention:**
- All start with `ro.` prefix
- Examples: `ro.build.version.release`, `ro.product.model`

**When Set:**
- During boot from property files
- From init scripts
- From build system

**Characteristics:**
- Set early in boot process
- Never change during runtime
- Used for device identification
- Safe to read from any process

**Common Read-Only Properties:**

**Build Properties:**
```
ro.build.version.release=13
ro.build.version.sdk=33
ro.build.id=TP1A.220624.014
ro.build.type=user
ro.build.tags=release-keys
ro.build.fingerprint=google/pixel_7/panther:13/TP1A.220624.014/8819327:user/release-keys
```

**Product Properties:**
```
ro.product.model=Pixel 7
ro.product.manufacturer=Google
ro.product.brand=google
ro.product.name=panther
ro.product.device=panther
ro.product.board=panther
```

**Hardware Properties:**
```
ro.hardware=slider
ro.arch=arm64-v8a
ro.chipname=Google Tensor G2
```

**Why Read-Only?**
- Prevents accidental modification
- Ensures consistency
- Security (can't spoof device identity)
- Performance (no need to check permissions)

#### Read-Write Properties

Read-write properties can be changed at runtime.

**Naming Convention:**
- No special prefix (or `sys.*`, `persist.*`, etc.)
- Examples: `sys.boot_completed`, `debug.sf.showupdates`

**When Set:**
- During boot (initial values)
- At runtime by services/apps
- By user actions
- By system events

**Characteristics:**
- Can change during runtime
- May require permissions to write
- Used for runtime configuration
- Can trigger actions when changed

**Common Read-Write Properties:**

**System State:**
```
sys.boot_completed=1
sys.usb.config=mtp,adb
sys.usb.state=mtp,adb
dev.bootcomplete=1
```

**Debug Properties:**
```
debug.sf.showupdates=0
debug.egl.trace=0
debug.layout=false
```

**Service States:**
```
init.svc.zygote=running
init.svc.surfaceflinger=running
init.svc.adbd=stopped
```

#### Persistent Properties (persist.*)

Persistent properties survive reboots by being stored on disk.

**Naming Convention:**
- All start with `persist.` prefix
- Examples: `persist.sys.timezone`, `persist.vendor.audio`

**Storage:**
- Stored in `/data/property/` directory
- One file per property
- File name is property name
- File content is property value

**Characteristics:**
- Survive reboots
- Stored on /data partition
- Can be cleared by factory reset
- Used for user preferences

**Common Persistent Properties:**
```
persist.sys.timezone=America/New_York
persist.sys.locale=en-US
persist.vendor.audio.fluence.voicecall=true
persist.vendor.audio.fluence.speaker=true
persist.sys.dalvik.vm.lib.2=libart.so
```

**How Persistence Works:**

1. **Setting Property:**
   ```bash
   setprop persist.sys.timezone America/Los_Angeles
   ```

2. **Property Service:**
   - Receives setprop request
   - Updates in-memory property
   - Writes to `/data/property/persist.sys.timezone`
   - File contains: `America/Los_Angeles`

3. **On Next Boot:**
   - Init reads `/data/property/persist.sys.timezone`
   - Sets property: `persist.sys.timezone=America/Los_Angeles`
   - Property is available to all processes

**Important Notes:**
- `/data` partition must be mounted before persistent properties load
- Properties load during `post-fs-data` phase
- If `/data` is wiped, persistent properties are lost
- Factory reset clears all persistent properties

#### Control Properties (ctl.*)

Control properties are special - setting them triggers actions rather than storing values.

**Naming Convention:**
- All start with `ctl.` prefix
- Examples: `ctl.start`, `ctl.stop`, `ctl.restart`

**How They Work:**
- Setting a control property doesn't store a value
- Instead, it triggers an action in init
- Property value is the target (service name, etc.)

**Common Control Properties:**

**Service Control:**
```bash
# Start a service
setprop ctl.start myservice

# Stop a service
setprop ctl.stop myservice

# Restart a service
setprop ctl.restart myservice
```

**Init interprets these as:**
```
on property:ctl.start=myservice
    start myservice

on property:ctl.stop=myservice
    stop myservice

on property:ctl.restart=myservice
    restart myservice
```

**Security:**
- Only processes with appropriate permissions can set control properties
- Prevents unauthorized service control
- System services can control other services

### Property Files

Properties are loaded from multiple files during boot, in a specific order:

#### Property File Locations

**1. /default.prop (Ramdisk)**
- Earliest properties
- In initramfs/ramdisk
- Set before /system is mounted
- Examples: `ro.debuggable`, `ro.secure`

**2. /system/build.prop**
- System build properties
- Set by build system
- Contains device info, build version
- Read-only after boot

**3. /vendor/build.prop**
- Vendor-specific properties
- Set by vendor/OEM
- Hardware-specific settings
- Read-only after boot

**4. /product/build.prop**
- Product-specific properties
- Product line configuration
- Read-only after boot

**5. /odm/build.prop**
- ODM (Original Design Manufacturer) properties
- Device-specific customizations
- Read-only after boot

**6. /system_ext/build.prop**
- System extension properties
- Additional system configuration
- Read-only after boot

**7. /data/local.prop**
- Local overrides (if exists)
- Development/debugging
- Can override other properties
- Not present on production devices

**8. /data/property/persist.* (Persistent Properties)**
- User preferences
- Runtime settings
- Loaded after /data mounts

#### Loading Order

Properties load in this order (later files override earlier ones):

```
1. /default.prop (ramdisk)
2. /system/build.prop
3. /vendor/build.prop
4. /product/build.prop
5. /odm/build.prop
6. /system_ext/build.prop
7. /data/local.prop (if exists)
8. /data/property/persist.* (after /data mounts)
```

**Override Behavior:**
- Later files can override properties from earlier files
- `ro.*` properties can only be overridden by files loaded earlier (security)
- `persist.*` properties always load last

#### Property File Format

Property files use simple key-value format:

```
# Comments start with #
# Empty lines are ignored

# Format: key=value
ro.build.version.release=13
ro.product.model=Pixel 7

# Multi-line values (rare)
ro.build.description=panther-user 13 TP1A.220624.014 8819327 release-keys

# Boolean values as strings
ro.debuggable=0
ro.secure=1
```

**Parsing Rules:**
- One property per line
- Format: `key=value` (no spaces around `=`)
- Values can contain spaces
- No quotes needed (unless value contains special characters)
- Comments: lines starting with `#`

### Property Operations

#### Reading Properties

**From Command Line:**

```bash
# Get specific property
adb shell getprop ro.build.version.release
# Output: 13

# Get all properties
adb shell getprop

# Get properties matching pattern
adb shell getprop | grep ro.product

# Get property with default value
adb shell getprop ro.custom.property "default_value"
```

**From Code (Java/Kotlin):**

```java
import android.os.SystemProperties;

// Get property (returns empty string if not set)
String version = SystemProperties.get("ro.build.version.release");

// Get property with default
String model = SystemProperties.get("ro.product.model", "Unknown");

// Get boolean property
boolean debuggable = SystemProperties.getBoolean("ro.debuggable", false);

// Get integer property
int sdk = SystemProperties.getInt("ro.build.version.sdk", 0);

// Get long property
long uptime = SystemProperties.getLong("sys.boot_completed", 0);
```

**From Native Code (C/C++):**

```c
#include <cutils/properties.h>

char value[PROPERTY_VALUE_MAX];
char default_value[] = "default";

// Get property
property_get("ro.build.version.release", value, default_value);

// Get boolean
int is_debuggable = property_get_bool("ro.debuggable", 0);

// Get integer
int sdk = property_get_int32("ro.build.version.sdk", 0);
```

**From Shell Script:**

```bash
#!/system/bin/sh

# Get property
VERSION=$(getprop ro.build.version.release)
echo "Android version: $VERSION"

# Check if property exists
if [ -n "$(getprop ro.custom.property)" ]; then
    echo "Custom property is set"
fi
```

#### Writing Properties

**From Command Line:**

```bash
# Set property (requires root or appropriate permissions)
adb shell setprop sys.custom.property "value"

# Set property as root
adb root
adb shell setprop sys.custom.property "value"

# Set persistent property
adb shell setprop persist.sys.timezone "America/New_York"
```

**From Code (Java/Kotlin):**

```java
import android.os.SystemProperties;

// Set property (requires system permissions)
SystemProperties.set("sys.custom.property", "value");

// Set property (with namespace, requires system permissions)
SystemProperties.set("vendor.custom.property", "value");
```

**Important:** Writing properties requires:
- System-level permissions (system app or root)
- Appropriate SELinux context
- Property name must not be read-only (`ro.*`)

**From Native Code (C/C++):**

```c
#include <cutils/properties.h>

// Set property
property_set("sys.custom.property", "value");

// Returns 0 on success, -1 on error
```

**Security Restrictions:**
- Only system processes can write most properties
- `ro.*` properties cannot be written (enforced by property service)
- SELinux policies restrict property writes
- Control properties (`ctl.*`) have additional restrictions

### Property Triggers

Properties can trigger actions when they change, using init's trigger system.

#### How Property Triggers Work

When a property changes, init checks for matching triggers:

```
Property Change → Init Checks Triggers → Execute Matching Actions
```

**Trigger Syntax:**
```
on property:name=value
    # Actions to execute
    start service
    setprop other.property value
```

#### Common Property Triggers

**Boot Completion:**
```
on property:sys.boot_completed=1
    # System has finished booting
    start my_service
    setprop my.ready 1
```

**Debuggable Device:**
```
on property:ro.debuggable=1
    # Device is debuggable
    start adbd
    setprop service.adb.tcp.port 5555
```

**Service State:**
```
on property:init.svc.zygote=running
    # Zygote has started
    setprop sys.zygote.ready 1
```

**USB Configuration:**
```
on property:sys.usb.config=adb && property:sys.usb.ffs.ready=1
    # USB debugging enabled
    start adbd
```

#### Property Trigger Patterns

**Exact Match:**
```
on property:name=value
    # Triggers only when property equals exactly "value"
```

**Wildcard Match:**
```
on property:name=*
    # Triggers when property is set to any value
```

**Multiple Conditions:**
```
on property:prop1=value1 && property:prop2=value2
    # Triggers when both conditions are true
```

**OR Conditions:**
```
on property:prop1=value1 || property:prop2=value2
    # Triggers when either condition is true
```

### Property Namespaces

Properties are organized into namespaces for organization and security:

#### Standard Namespaces

**ro.* (Read-Only):**
- Build and device information
- Set during boot
- Never change

**sys.* (System):**
- System-wide runtime configuration
- Can be changed by system processes
- Examples: `sys.boot_completed`, `sys.usb.config`

**persist.* (Persistent):**
- User preferences and settings
- Survive reboots
- Stored in `/data/property/`

**vendor.* (Vendor):**
- Vendor-specific properties
- Hardware-specific settings
- Set by vendor/OEM

**persist.vendor.*:**
- Persistent vendor properties
- Vendor settings that survive reboots

**debug.* (Debug):**
- Debug and development settings
- Usually only on eng/userdebug builds
- Examples: `debug.sf.showupdates`

**init.svc.* (Service State):**
- Service status properties
- Managed by init
- Values: `stopped`, `running`, `restarting`

**ctl.* (Control):**
- Control properties (trigger actions)
- Don't store values
- Examples: `ctl.start`, `ctl.stop`

### Property Security

#### Access Control

**Read Access:**
- Most properties can be read by any process
- Some sensitive properties may be restricted
- SELinux policies can restrict reads

**Write Access:**
- Restricted to system processes
- Requires appropriate permissions
- SELinux context must allow writes
- `ro.*` properties cannot be written

#### SELinux Integration

Properties are subject to SELinux policies:

**Property Read:**
```
# SELinux policy example
allow untrusted_app system_prop:property_service get_prop ro.build.version.release;
```

**Property Write:**
```
# Only system processes can write
allow system_server system_prop:property_service set_prop sys.custom.property;
```

**Property Service:**
- Property service runs in init context
- Has access to all properties
- Enforces security policies

### Real-World Examples

#### Example 1: Device Identification

Properties are used extensively for device identification:

```bash
# Get device information
adb shell getprop | grep ro.product

ro.product.model=Pixel 7
ro.product.manufacturer=Google
ro.product.brand=google
ro.product.name=panther
ro.product.device=panther
ro.product.board=panther
```

**Usage in Apps:**
```java
String model = SystemProperties.get("ro.product.model", "Unknown");
String manufacturer = SystemProperties.get("ro.product.manufacturer", "Unknown");

// Display device info
textView.setText("Device: " + manufacturer + " " + model);
```

#### Example 2: Feature Flags

Properties can control feature availability:

```bash
# Check if feature is enabled
adb shell getprop ro.feature.custom_feature
# Returns: 1 (enabled) or 0 (disabled)
```

**In Code:**
```java
boolean featureEnabled = SystemProperties.getBoolean(
    "ro.feature.custom_feature", 
    false
);

if (featureEnabled) {
    // Enable feature
    enableCustomFeature();
}
```

#### Example 3: Debug Settings

Properties control debug behavior:

```bash
# Enable layout bounds (shows view boundaries)
adb shell setprop debug.layout true

# Show surface updates
adb shell setprop debug.sf.showupdates 1

# Enable GPU overdraw visualization
adb shell setprop debug.hwui.overdraw show
```

#### Example 4: Service Control

Using control properties to manage services:

```bash
# Restart a service
adb shell setprop ctl.restart zygote

# Start ADB daemon
adb shell setprop ctl.start adbd

# Stop a service
adb shell setprop ctl.stop myservice
```

### Property Best Practices

#### For System Developers

**1. Naming Conventions:**
- Use appropriate namespace (`ro.*`, `sys.*`, `persist.*`, etc.)
- Use descriptive names
- Follow existing patterns
- Document property purpose

**2. Property Types:**
- Use `ro.*` for immutable device/build info
- Use `sys.*` for runtime system configuration
- Use `persist.*` for user preferences
- Use `vendor.*` for vendor-specific settings

**3. Security:**
- Restrict write access appropriately
- Use SELinux policies
- Don't expose sensitive data
- Validate property values

**4. Performance:**
- Properties are cached - very fast reads
- Minimize property writes (they're slower)
- Use properties for configuration, not frequent state

#### For Application Developers

**1. Reading Properties:**
- Use `SystemProperties.get()` with defaults
- Handle missing properties gracefully
- Don't assume properties exist
- Cache property values if read frequently

**2. Writing Properties:**
- Usually not possible from apps (requires system permissions)
- Use Settings API for user preferences instead
- Don't try to modify `ro.*` properties

**3. Property Usage:**
- Use for device detection
- Use for feature flags
- Use for debug settings
- Don't use for app-specific data (use SharedPreferences)

### Common Issues and Debugging

#### Property Not Found

**Symptom:**
```java
String value = SystemProperties.get("ro.custom.property");
// Returns empty string
```

**Causes:**
- Property not set in build.prop files
- Property name misspelled
- Property not loaded yet (timing issue)

**Solutions:**
- Check property files
- Verify property name
- Use default value in code
- Check if property loads after app starts

#### Property Not Persisting

**Symptom:**
```bash
setprop persist.sys.custom "value"
# After reboot, property is gone
```

**Causes:**
- `/data` partition not mounted when property set
- Property service not running
- Insufficient permissions
- `/data/property/` directory issues

**Solutions:**
- Ensure `/data` is mounted
- Check property service status
- Verify permissions
- Check `/data/property/` directory

#### Property Write Denied

**Symptom:**
```bash
setprop ro.build.version.release "14"
# Error: property_set failed
```

**Causes:**
- `ro.*` properties are read-only
- Insufficient permissions
- SELinux denial

**Solutions:**
- Use appropriate property type (not `ro.*`)
- Ensure root/system permissions
- Check SELinux policies

### Edge Cases and Pitfalls

#### Common Mistakes

**1. Assuming Property Exists:**
```java
// BAD: No default value
String version = SystemProperties.get("ro.custom.property");

// GOOD: Provide default
String version = SystemProperties.get("ro.custom.property", "unknown");
```

**2. Wrong Property Type:**
```bash
# BAD: Trying to make read-only property persistent
setprop ro.build.version.release "14"  # Fails!

# GOOD: Use appropriate type
setprop sys.custom.property "value"
```

**3. Timing Issues:**
```java
// BAD: Reading property too early
// Property might not be loaded yet during early boot

// GOOD: Check if property exists or wait for boot complete
if (SystemProperties.getInt("sys.boot_completed", 0) == 1) {
    // Safe to read properties
}
```

**4. Security Issues:**
```java
// BAD: Exposing sensitive data in properties
setprop sys.password "secret123"  // Don't do this!

// GOOD: Use secure storage for sensitive data
```

### Best Practices

- Use appropriate property types for your use case
- Follow naming conventions
- Document property purpose and usage
- Handle missing properties gracefully
- Use defaults when reading properties
- Respect property security restrictions
- Test property changes thoroughly
- Use property triggers appropriately
- Monitor property usage for performance

## References and Further Reading

- [AOSP Property System Source](https://cs.android.com/android/platform/superproject/+/master:system/core/init/property_service.cpp)
- [System Properties Documentation](https://source.android.com/docs/core/architecture/init#property_system)
- [Property Service Implementation](https://cs.android.com/android/platform/superproject/+/master:system/core/init/)

## Quiz

### Question 1
What is the prefix for read-only properties that cannot be changed at runtime?

**A)** `sys.*`  
**B)** `ro.*`  
**C)** `persist.*`  
**D)** `ctl.*`

**Answer: B** - Properties starting with `ro.*` are read-only and set during boot. They cannot be modified at runtime, ensuring device identification and build information remain consistent.

### Question 2
Where are persistent properties stored so they survive reboots?

**A)** `/system/build.prop`  
**B)** `/data/property/`  
**C)** `/vendor/build.prop`  
**D)** `/default.prop`

**Answer: B** - Persistent properties (those starting with `persist.*`) are stored in `/data/property/` directory, with one file per property. This allows them to survive reboots.

### Question 3
What happens when you set a control property like `ctl.start`?

**A)** A value is stored in the property system  
**B)** An action is triggered in init (like starting a service)  
**C)** The property becomes read-only  
**D)** Nothing, control properties are ignored

**Answer: B** - Control properties (`ctl.*`) don't store values. Instead, setting them triggers actions in init, such as starting, stopping, or restarting services.

### Question 4
In what order are property files loaded during boot?

**A)** All files load simultaneously  
**B)** /data/property/ first, then build.prop files  
**C)** /default.prop first, then build.prop files, then /data/property/  
**D)** Random order

**Answer: C** - Properties load in order: /default.prop (ramdisk) → build.prop files (system, vendor, etc.) → /data/property/ (persistent properties). Later files can override earlier ones.

### Question 5
Which property type should you use for user preferences that should survive reboots?

**A)** `ro.*` (read-only)  
**B)** `sys.*` (system)  
**C)** `persist.*` (persistent)  
**D)** `ctl.*` (control)

**Answer: C** - Persistent properties (`persist.*`) are stored on disk and survive reboots, making them ideal for user preferences and settings that should persist across device restarts.

## Related Topics

- [Init System in Android](./04.%20Init%20System%20in%20Android.md)
- [Android Architecture - Complete Overview](./01.%20Android%20Architecture%20-%20Complete%20Overview.md)
- [Binder IPC Basics](./06.%20Binder%20IPC%20Basics.md)

