---
number: 20
title: System Server Launch
slug: system-server-launch
level: beginner
tags:
  - aosp
  - system-server
  - boot
  - startup
  - services
  - framework
  - binder
prerequisites:
  - boot-process-overview
  - system-server-overview
  - zygote-startup-flow
estimated_minutes: 90
contributors: []
diagrams: []
examples: []
canonical_id: aosp-beginner-20
---

# System Server Launch

## Overview

System Server is the central process that hosts all core Android system services. Its launch is a critical phase in the Android boot sequence, occurring right after Zygote starts and before user-facing applications can run. Understanding System Server launch is essential for comprehending how Android's core functionality becomes available, how services are initialized, and how the system transitions from basic initialization to a fully functional Android environment.

Think of System Server launch like opening a large office building: first, you unlock the main entrance (fork from Zygote), then you turn on the power and utilities (initialize runtime), then each department opens its doors and starts operations (start services), and finally the building is ready for business (boot complete). Each step must happen in the right order, and the building isn't functional until all departments are operational.

## Deep Explanation

### What is System Server Launch?

System Server launch is the process by which the System Server process is created, initialized, and started. It begins when Zygote forks a new process for System Server and ends when System Server has started all core services and is ready to handle system operations. This launch sequence is critical because System Server hosts approximately 80+ services that provide essential Android functionality.

**Key Characteristics:**
- **Forked from Zygote:** System Server is a child process of Zygote
- **Single Process:** All services run in one `system_server` process
- **Sequential Startup:** Services start in a specific order due to dependencies
- **Critical Path:** Boot cannot complete without System Server
- **Java Process:** Runs on Android Runtime (ART)

**Launch Timeline:**
- Typically starts 500-600ms after boot begins
- Takes 2-5 seconds to fully initialize all services
- One of the longest phases in boot process
- Critical for overall boot time

### System Server Launch Sequence

The launch sequence is a carefully orchestrated process with multiple stages. Let's trace through each stage:

#### Stage 1: Fork from Zygote

**Trigger:**
System Server launch is triggered during Zygote initialization when the `--start-system-server` flag is present:

```java
// In ZygoteInit.main()
if (startSystemServer) {
    Runnable r = forkSystemServer(abiList, zygoteSocketName, zygoteServer);
    if (r != null) {
        r.run();
        return;  // Child process (System Server) returns here
    }
    // Parent (Zygote) continues to server loop
}
```

**Fork Process:**
1. Zygote calls `fork()` system call
2. Creates copy of Zygote process
3. Child process becomes System Server
4. Parent (Zygote) continues to server loop
5. Child inherits all preloaded classes

**Process Inheritance:**
- **Memory:** Inherits all preloaded classes (via copy-on-write)
- **Libraries:** Inherits all loaded native libraries
- **Resources:** Inherits all preloaded resources
- **Environment:** Inherits Zygote's environment

**Initial Process State:**
- **PID:** New process ID
- **PPID:** Zygote's PID
- **UID:** Root (0) initially
- **GID:** Root (0) initially
- **State:** Just forked, no Java code running yet

**Security Transition:**
After fork, System Server transitions from root to system user:
- **Target UID:** 1000 (system)
- **Target GID:** 1000 (system)
- **SELinux Context:** `u:r:system_server:s0`
- **Capabilities:** System-level permissions

#### Stage 2: Native Code Entry Point

**ZygoteInit.handleSystemServerProcess():**
The forked process executes in ZygoteInit's handleSystemServerProcess method:

```java
private static Runnable handleSystemServerProcess(ZygoteArguments parsedArgs) {
    // Set up system server process
    // Transition to system user
    // Return SystemServer main method
    return ZygoteInit.zygoteInit(parsedArgs.targetSdkVersion,
        parsedArgs.remainingArgs, null);
}
```

**Process Setup:**
1. Parse remaining arguments
2. Set process name to "system_server"
3. Configure process limits
4. Set up signal handlers
5. Prepare for Java execution

**UID/GID Transition:**
```java
// Transition from root to system user
if (parsedArgs.uidSpecified) {
    Process.setUid(parsedArgs.uid);
}
if (parsedArgs.gidSpecified) {
    Process.setGid(parsedArgs.gid);
}
```

**Process Name:**
```java
Process.setArgV0("system_server");
```

**Capability Setup:**
- Drop unnecessary capabilities
- Retain system-level capabilities
- Set up process limits
- Configure security context

#### Stage 3: Runtime Initialization

**ZygoteInit.zygoteInit():**
The process calls zygoteInit to set up the runtime:

```java
public static final Runnable zygoteInit(int targetSdkVersion, 
    String[] argv, ClassLoader classLoader) {
    // Initialize runtime
    RuntimeInit.commonInit();
    ZygoteInit.nativeZygoteInit();
    return RuntimeInit.applicationInit(targetSdkVersion, argv, classLoader);
}
```

**RuntimeInit.commonInit():**
- Set up default uncaught exception handler
- Set timezone
- Initialize logging
- Configure process limits
- Set up signal handlers

**nativeZygoteInit():**
- Initialize native libraries
- Set up Binder IPC
- Initialize native services
- Prepare native callbacks

**applicationInit():**
- Create application class loader
- Find main class (SystemServer)
- Return main method Runnable

#### Stage 4: SystemServer.main() Entry

**Entry Point:**
System Server execution begins in `SystemServer.main()`:

```java
public static void main(String[] args) {
    new SystemServer().run();
}
```

**SystemServer Constructor:**
- Initialize SystemServer instance
- Set up service managers
- Prepare service startup infrastructure
- Configure system properties

**run() Method:**
The main execution happens in `run()` method, which orchestrates the entire startup sequence.

#### Stage 5: Early System Initialization

**Before Service Startup:**
System Server performs critical initialization before starting services:

**1. VM Tuning:**
```java
// Optimize VM for system server
VMRuntime.getRuntime().clearGrowthLimit();
VMRuntime.getRuntime().setTargetHeapUtilization(0.8f);
```

**2. Binder Initialization:**
```java
// Initialize Binder for IPC
BinderInternal.init();
```

**3. Native Services:**
- Initialize native services
- Set up native callbacks
- Prepare native libraries

**4. System Properties:**
- Set critical system properties
- Configure system state
- Initialize property service

**5. Looper Setup:**
```java
// Create main looper for handlers
Looper.prepareMainLooper();
```

**Why This Matters:**
These early initializations are prerequisites for services. Binder must be ready for service registration, the looper must exist for handlers, and VM tuning optimizes performance.

#### Stage 6: Service Startup Phases

System Server starts services in phases to manage dependencies:

**Phase 1: Bootstrap Services**
Services needed by other services:

**1. ActivityManagerService (AMS):**
```java
mActivityManagerService = mSystemServiceManager.startService(
    ActivityManagerService.Lifecycle.class).getService();
```
- Manages app lifecycle
- Needed by many other services
- Critical for system operation

**2. PowerManagerService:**
```java
mPowerManagerService = mSystemServiceManager.startService(
    PowerManagerService.class);
```
- Manages power state
- Needed for device operation
- Controls sleep/wake

**3. DisplayManagerService:**
```java
mDisplayManagerService = mSystemServiceManager.startService(
    DisplayManagerService.class);
```
- Manages displays
- Needed for UI
- Controls screen state

**4. PackageManagerService:**
```java
mPackageManagerService = PackageManagerService.main(mSystemContext,
    mInstaller, mFactoryTestMode != FactoryTest.FACTORY_TEST_OFF,
    mOnlyCore);
```
- Manages installed packages
- Needed for app information
- Critical for app launching

**Phase 2: Core Services**
Core system functionality:

**5. BatteryService:**
- Monitors battery state
- Reports battery level
- Manages power events

**6. UsageStatsService:**
- Tracks app usage
- Provides usage statistics
- Used for optimization

**7. WebViewUpdateService:**
- Manages WebView updates
- Provides web rendering
- Used by apps

**Phase 3: Other Services**
Additional system services:

**8. WindowManagerService:**
- Manages windows
- Handles input
- Controls display

**9. InputManagerService:**
- Manages input devices
- Handles touch/keyboard
- Routes input events

**10. ConnectivityService:**
- Manages network connections
- Handles Wi-Fi/cellular
- Provides network access

**And 70+ more services...**

**Service Startup Order:**
Services start in dependency order:
1. Services with no dependencies first
2. Services depending on earlier services next
3. Complex dependencies resolved carefully
4. Some services start in parallel (where safe)

**Service Manager:**
`SystemServiceManager` coordinates service startup:
- Tracks service lifecycle
- Manages dependencies
- Handles service callbacks
- Provides service context

#### Stage 7: Service Lifecycle Callbacks

**Lifecycle Phases:**
Services go through lifecycle phases:

**1. onStart():**
- Service starts
- Initial setup
- Register with system

**2. onBootPhase():**
Services receive boot phase callbacks:

**PHASE_SYSTEM_SERVICES_READY:**
- Core services ready
- System can function
- Some services can start

**PHASE_ACTIVITY_MANAGER_READY:**
- ActivityManager ready
- Apps can launch
- User interaction possible

**PHASE_THIRD_PARTY_APPS_CAN_START:**
- Third-party apps can start
- User apps available
- Full system ready

**3. onUserStarting():**
- User switching
- User-specific initialization
- User data available

**Why Phases Matter:**
- Ensures correct startup order
- Prevents race conditions
- Allows services to coordinate
- Makes boot process predictable

#### Stage 8: Boot Animation Management

**Boot Animation Control:**
System Server controls boot animation:

**Start Animation:**
- Animation starts early (kernel/init)
- Shows during boot
- Provides user feedback

**Stop Animation:**
```java
// Stop boot animation when ready
Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER, "StopBootAnimation");
SurfaceControl.bootFinished();
Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
```

**When to Stop:**
- After critical services start
- Before Launcher starts
- When system is functional
- User experience optimization

**Boot Animation Timing:**
- Starts: ~100ms after boot
- Stops: ~3-5 seconds (device-dependent)
- Provides visual feedback
- Hides boot complexity

#### Stage 9: Launcher Startup

**Launcher Process:**
System Server starts the Launcher (home screen):

**Process Creation:**
```java
// Start home app (Launcher)
mActivityManagerService.startHomeActivity(currentUserId, "systemReady");
```

**Launcher Startup:**
1. ActivityManager starts Launcher activity
2. Launcher process forked from Zygote
3. Launcher Activity starts
4. Home screen appears
5. User can interact

**Why Launcher Last:**
- Needs all services ready
- Depends on PackageManager
- Requires ActivityManager
- Needs display ready

#### Stage 10: Boot Complete Broadcast

**BOOT_COMPLETED Broadcast:**
When System Server is fully ready:

```java
// Send boot completed broadcast
mActivityManagerService.systemReady(() -> {
    // System is ready
    // Send BOOT_COMPLETED
    mSystemServiceManager.startBootPhase(
        SystemService.PHASE_BOOT_COMPLETED);
}, BOOT_TIMINGS_TRACE_FILE);
```

**What This Means:**
- All core services started
- System is functional
- Apps can receive boot events
- User can interact

**Boot Complete Actions:**
- Send `BOOT_COMPLETED` broadcast
- Start background services
- Initialize user apps
- Complete boot sequence

### System Server Startup Timeline

**Detailed Timeline:**
- **0ms:** Zygote forks System Server
- **10ms:** Native code initialization
- **50ms:** Java runtime setup
- **100ms:** SystemServer.main() starts
- **200ms:** Early initialization complete
- **500ms:** Bootstrap services starting
- **1000ms:** Core services starting
- **2000ms:** Other services starting
- **3000ms:** Services mostly ready
- **4000ms:** Launcher starting
- **5000ms:** Boot complete broadcast

**Factors Affecting Time:**
- Device performance
- Number of services
- Service dependencies
- Storage speed
- System load

### Service Dependency Management

**Dependency Graph:**
Services have complex dependencies:

**Example Dependencies:**
- ActivityManager → PackageManager
- WindowManager → ActivityManager
- InputManager → WindowManager
- Most services → ActivityManager

**Dependency Resolution:**
- SystemServiceManager tracks dependencies
- Services start in topological order
- Circular dependencies prevented
- Parallel startup where possible

**Service Registration:**
Services register with ServiceManager:
```java
ServiceManager.addService("activity", mActivityManagerService);
```

**Service Discovery:**
Other processes can find services:
```java
IBinder binder = ServiceManager.getService("activity");
IActivityManager am = IActivityManager.Stub.asInterface(binder);
```

### Binder IPC Setup

**Binder Initialization:**
System Server sets up Binder for IPC:

**1. Binder Driver:**
- Initialize Binder driver
- Set up Binder thread pool
- Configure Binder limits

**2. Service Registration:**
- Register services with ServiceManager
- Make services discoverable
- Set up service interfaces

**3. IPC Ready:**
- Services can communicate
- Apps can access services
- System is interconnected

**Why Binder Matters:**
- All service communication uses Binder
- Apps access services via Binder
- Critical for system operation
- Performance-sensitive

### System Server Process Characteristics

**Process Identity:**
- **Name:** `system_server`
- **UID:** 1000 (system)
- **GID:** 1000 (system)
- **PID:** Varies (process ID)
- **PPID:** Zygote's PID

**Process Limits:**
- **Memory:** High limit (system process)
- **CPU:** Normal priority
- **File Descriptors:** High limit
- **Threads:** Many threads (per service)

**Process State:**
- **State:** Running
- **Priority:** Normal (not real-time)
- **Scheduling:** Standard Linux scheduler
- **Isolation:** Isolated from apps

### System Server Restart

**When System Server Crashes:**
- Init detects crash
- Init may restart Zygote (which restarts System Server)
- Or System Server may restart independently
- Services reinitialize
- Boot sequence repeats (partial)

**Restart Impact:**
- All services restart
- Apps may be affected
- User experience disrupted
- System state reset

**Crash Handling:**
- Logs crash information
- Generates crash report
- May trigger device reset
- Critical for stability

### Debugging System Server Launch

**Logging:**
System Server logs extensively:
- Tag: `SystemServer`
- Filter: `adb logcat -s SystemServer`

**Key Log Points:**
- Service startup
- Service failures
- Boot phases
- Timing information

**Debugging Tools:**
- `adb logcat` - View logs
- `adb shell dumpsys` - Service state
- `adb shell ps | grep system_server` - Process info
- Boot timing traces

**Common Issues:**
- Service startup failures
- Dependency problems
- Timeout issues
- Memory problems

### Optimization Strategies

**Startup Time Optimization:**
- Parallel service startup
- Lazy service initialization
- Reduce service dependencies
- Optimize service code

**Memory Optimization:**
- Efficient service design
- Shared resources
- Memory pool usage
- Garbage collection tuning

**Performance Optimization:**
- Fast service startup
- Efficient IPC
- Optimized service code
- Device-specific tuning

## Key Takeaways

1. **System Server is forked from Zygote** early in boot, inheriting all preloaded classes for fast startup.

2. **Launch sequence is multi-stage** from fork through runtime initialization to service startup and boot completion.

3. **Services start in phases** to manage dependencies, with bootstrap services first, then core services, then others.

4. **Service lifecycle callbacks** ensure services start in the correct order and can coordinate with each other.

5. **System Server controls boot animation** and stops it when the system is ready, providing user feedback.

6. **Launcher starts last** after all services are ready, as it depends on many services for functionality.

7. **BOOT_COMPLETED broadcast** signals that the system is fully ready and apps can receive boot events.

8. **Understanding System Server launch** is essential for optimizing boot time, debugging service issues, and developing AOSP features.

## Related Topics

- **Zygote Startup Flow:** The process that forks System Server and provides the runtime environment
- **System Server Overview:** General overview of System Server and its services
- **Boot Process Overview:** The complete boot sequence that includes System Server launch
- **Binder IPC Basics:** The IPC mechanism that System Server uses for service communication

