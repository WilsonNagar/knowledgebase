---
number: 62
title: AIDL NDK
slug: aidl-ndk
level: intermediate
tags:
  - aosp
  - aidl
  - ndk
  - native
  - c++
  - binder
  - ipc
  - jni
prerequisites:
  - aidl
  - binder-architecture
  - binder-driver-internals
estimated_minutes: 90
contributors: []
diagrams: []
examples: []
canonical_id: aosp-intermediate-62
---

# AIDL NDK

## Overview

AIDL NDK (Native Development Kit) enables using AIDL interfaces from native C++ code, allowing native services and clients to use the same AIDL interface definitions as Java/Kotlin code. Understanding AIDL NDK is essential for AOSP development, as it enables native services, allows C++ code to use AIDL interfaces, provides type-safe native IPC, and bridges Java and native code. This guide provides a comprehensive overview of AIDL NDK, how to use AIDL from C++, generated native code, NDK-specific features, and best practices.

Think of AIDL NDK like a translator: just as a translator allows people speaking different languages to communicate, AIDL NDK allows Java/Kotlin and C++ code to use the same AIDL interface definitions, enabling seamless communication between Java framework code and native services or libraries. The build system generates both Java and C++ code from the same AIDL files, ensuring both sides use the same interface contract.

## Deep Explanation

### What is AIDL NDK?

AIDL NDK is the native (C++) support for AIDL interfaces, allowing C++ code to use AIDL-defined interfaces for Binder IPC. It generates C++ code from AIDL files, similar to how Java code is generated.

**Key Characteristics:**
- **Native Support:** C++ code can use AIDL interfaces
- **Code Generation:** Build system generates C++ code
- **Type Safety:** Compile-time type checking in C++
- **Same Interface:** Uses same AIDL files as Java

**Why AIDL NDK?**
- **Native Services:** Write services in C++
- **Performance:** Native code performance benefits
- **Code Reuse:** Same interface for Java and C++
- **Type Safety:** Compile-time checking in C++

### AIDL NDK vs Java AIDL

#### Similarities

**Same AIDL Files:**
- Both use same `.aidl` files
- Same syntax and structure
- Same interface definitions
- Build system generates both

**Same Interface Contract:**
- Same method signatures
- Same data types
- Same behavior
- Compatible implementations

#### Differences

**Generated Code:**
- Java: Generates Java classes
- NDK: Generates C++ classes
- Different language bindings
- Same functionality

**Language Features:**
- Java: Uses Java types and idioms
- NDK: Uses C++ types and idioms
- Different memory management
- Different error handling

### AIDL NDK File Structure

#### AIDL File (Same as Java)

**Basic AIDL File:**
```aidl
// IMyService.aidl
package com.example;

interface IMyService {
    int add(int a, int b);
    String processData(String input);
}
```

**With Parcelable:**
```aidl
// IMyService.aidl
package com.example;

import com.example.MyData;

interface IMyService {
    MyData processData(MyData input);
}
```

**Note:** Same AIDL files work for both Java and NDK.

### Generated C++ Code

#### Header File Structure

**Generated Header:**
```cpp
// Generated: com/example/IMyService.h
#ifndef AIDL_GENERATED_com_example_IMyService_H_
#define AIDL_GENERATED_com_example_IMyService_H_

#include <aidl/com/example/IMyService.h>
#include <android/binder_interface.h>
#include <android/binder_parcel.h>
#include <cstdint>

namespace aidl {
namespace com {
namespace example {

class IMyService : public ::ndk::ICInterface {
public:
    static const char* descriptor;
    static constexpr uint32_t TRANSACTION_add = (FIRST_CALL_TRANSACTION + 0);
    static constexpr uint32_t TRANSACTION_processData = (FIRST_CALL_TRANSACTION + 1);
    
    virtual ::ndk::ScopedAStatus add(int32_t a, int32_t b, int32_t* _aidl_return) = 0;
    virtual ::ndk::ScopedAStatus processData(const std::string& input, std::string* _aidl_return) = 0;
    
    // ... more methods
};

}  // namespace example
}  // namespace com
}  // namespace aidl

#endif  // AIDL_GENERATED_com_example_IMyService_H_
```

#### Implementation Structure

**Stub (Server Side):**
```cpp
// Generated: com/example/BnMyService.h (Binder Native)
namespace aidl {
namespace com {
namespace example {

class BnMyService : public ::ndk::BnCInterface<IMyService> {
public:
    ::ndk::ScopedAStatus onTransact(
        uint32_t code,
        const ::ndk::ScopedAParcel& data,
        ::ndk::ScopedAParcel* reply) override;
};

}  // namespace example
}  // namespace com
}  // namespace aidl
```

**Proxy (Client Side):**
```cpp
// Generated: com/example/BpMyService.h (Binder Proxy)
namespace aidl {
namespace com {
namespace example {

class BpMyService : public ::ndk::BpCInterface<IMyService> {
public:
    explicit BpMyService(const ::ndk::SpAIBinder& binder);
    ::ndk::ScopedAStatus add(int32_t a, int32_t b, int32_t* _aidl_return) override;
    ::ndk::ScopedAStatus processData(const std::string& input, std::string* _aidl_return) override;
};

}  // namespace example
}  // namespace com
}  // namespace aidl
```

### Using AIDL NDK

#### Creating a Native Service

**Service Implementation:**
```cpp
#include <aidl/com/example/IMyService.h>
#include <aidl/com/example/BnMyService.h>

using namespace aidl::com::example;

class MyService : public BnMyService {
public:
    ::ndk::ScopedAStatus add(int32_t a, int32_t b, int32_t* _aidl_return) override {
        *_aidl_return = a + b;
        return ::ndk::ScopedAStatus::ok();
    }
    
    ::ndk::ScopedAStatus processData(const std::string& input, std::string* _aidl_return) override {
        // Process input
        *_aidl_return = "Processed: " + input;
        return ::ndk::ScopedAStatus::ok();
    }
};
```

**Service Registration:**
```cpp
#include <binder/IServiceManager.h>
#include <binder/IPCThreadState.h>
#include <binder/ProcessState.h>

int main() {
    // Create service
    android::sp<MyService> service = new MyService();
    
    // Get default service manager
    android::sp<android::IServiceManager> sm = android::defaultServiceManager();
    
    // Register service
    sm->addService(android::String16("my_service"), service);
    
    // Start thread pool
    android::ProcessState::self()->startThreadPool();
    android::IPCThreadState::self()->joinThreadPool();
    
    return 0;
}
```

#### Creating a Native Client

**Client Usage:**
```cpp
#include <aidl/com/example/IMyService.h>
#include <aidl/com/example/BpMyService.h>
#include <binder/IServiceManager.h>

using namespace aidl::com::example;

int main() {
    // Get service manager
    android::sp<android::IServiceManager> sm = android::defaultServiceManager();
    
    // Get service binder
    android::sp<android::IBinder> binder = sm->getService(android::String16("my_service"));
    
    // Get interface
    android::sp<IMyService> service = IMyService::asInterface(binder);
    
    // Call service
    int32_t result;
    ::ndk::ScopedAStatus status = service->add(5, 3, &result);
    
    if (status.isOk()) {
        // Use result
        printf("Result: %d\n", result);
    }
    
    return 0;
}
```

### AIDL NDK Data Types

#### Primitive Types

**Supported Primitives:**
- `int` → `int32_t`
- `long` → `int64_t`
- `float` → `float`
- `double` → `double`
- `boolean` → `bool`
- `byte` → `int8_t`
- `char` → `char16_t`

**Usage:**
```aidl
interface IMyService {
    int calculate(int a, int b);
    boolean isValid(String input);
}
```

```cpp
::ndk::ScopedAStatus calculate(int32_t a, int32_t b, int32_t* _aidl_return);
::ndk::ScopedAStatus isValid(const std::string& input, bool* _aidl_return);
```

#### String Types

**String Mapping:**
- `String` → `std::string`
- `CharSequence` → `std::string`

**Usage:**
```aidl
interface IMyService {
    String processText(String input);
}
```

```cpp
::ndk::ScopedAStatus processText(const std::string& input, std::string* _aidl_return);
```

#### Collections

**List:**
- `List<Type>` → `std::vector<Type>`

**Map:**
- `Map<KeyType, ValueType>` → `std::map<KeyType, ValueType>` or `std::vector<std::pair<KeyType, ValueType>>`

**Usage:**
```aidl
interface IMyService {
    List<String> getItems();
    Map<String, int> getMap();
}
```

```cpp
::ndk::ScopedAStatus getItems(std::vector<std::string>* _aidl_return);
::ndk::ScopedAStatus getMap(std::vector<std::pair<std::string, int32_t>>* _aidl_return);
```

### NDK-Specific Features

#### ScopedAStatus

**What It Is:**
- Return type for AIDL NDK methods
- Represents transaction status
- Can indicate success or error
- Automatic resource management

**Usage:**
```cpp
::ndk::ScopedAStatus add(int32_t a, int32_t b, int32_t* _aidl_return) override {
    *_aidl_return = a + b;
    return ::ndk::ScopedAStatus::ok();
}

::ndk::ScopedAStatus divide(int32_t a, int32_t b, int32_t* _aidl_return) override {
    if (b == 0) {
        return ::ndk::ScopedAStatus::fromExceptionCode(EX_ILLEGAL_ARGUMENT);
    }
    *_aidl_return = a / b;
    return ::ndk::ScopedAStatus::ok();
}
```

**Status Types:**
- `::ndk::ScopedAStatus::ok()` - Success
- `::ndk::ScopedAStatus::fromExceptionCode()` - Exception
- `::ndk::ScopedAStatus::fromStatus()` - Status code

#### Binder Interface

**ICInterface:**
- Base interface for AIDL interfaces
- Provides binder operations
- Interface token management
- Transaction handling

**BnCInterface:**
- Base for server implementation
- Handles transaction routing
- Provides onTransact() implementation
- Server-side base class

**BpCInterface:**
- Base for client proxy
- Handles transaction sending
- Marshals parameters
- Client-side proxy base

### Error Handling

#### Exception Handling

**Exception Codes:**
```cpp
// Return exception
return ::ndk::ScopedAStatus::fromExceptionCode(EX_ILLEGAL_ARGUMENT);

// Return with message
return ::ndk::ScopedAStatus::fromExceptionCodeWithMessage(
    EX_ILLEGAL_ARGUMENT, "Invalid argument");
```

**Common Exception Codes:**
- `EX_NULL_POINTER` - Null pointer
- `EX_ILLEGAL_ARGUMENT` - Invalid argument
- `EX_UNSUPPORTED_OPERATION` - Unsupported operation
- `EX_SECURITY` - Security exception

#### Status Checking

**Check Status:**
```cpp
::ndk::ScopedAStatus status = service->add(5, 3, &result);

if (status.isOk()) {
    // Success
    printf("Result: %d\n", result);
} else {
    // Error
    printf("Error: %s\n", status.getDescription().c_str());
}
```

### Building AIDL NDK

#### Android.bp Configuration

**AIDL Interface:**
```bp
aidl_interface {
    name: "com.example.IMyService",
    srcs: ["IMyService.aidl"],
    backend: {
        java: {
            enabled: true,
        },
        ndk: {
            enabled: true,
        },
    },
}
```

**Native Service:**
```bp
cc_library_shared {
    name: "libmyservice",
    srcs: ["MyService.cpp"],
    shared_libs: [
        "libbinder_ndk",
        "com.example.IMyService-ndk",
    ],
}
```

**Native Client:**
```bp
cc_binary {
    name: "myclient",
    srcs: ["client.cpp"],
    shared_libs: [
        "libbinder_ndk",
        "com.example.IMyService-ndk",
    ],
}
```

### AIDL NDK Best Practices

#### Memory Management

**Use Smart Pointers:**
```cpp
// GOOD: Use sp<> for reference counting
android::sp<IMyService> service = IMyService::asInterface(binder);

// BAD: Raw pointers (no reference counting)
IMyService* service = ...;  // Don't do this
```

**ScopedAStatus:**
- Automatic resource management
- No manual cleanup needed
- Exception-safe
- RAII pattern

#### Error Handling

**Always Check Status:**
```cpp
::ndk::ScopedAStatus status = service->add(5, 3, &result);
if (!status.isOk()) {
    // Handle error
    return;
}
```

**Return Appropriate Errors:**
```cpp
if (input.empty()) {
    return ::ndk::ScopedAStatus::fromExceptionCode(EX_ILLEGAL_ARGUMENT);
}
```

#### Performance

**Minimize Transactions:**
- Batch operations when possible
- Avoid many small transactions
- Use oneway for notifications
- Keep transactions short

**Efficient Data Types:**
- Use appropriate types
- Avoid unnecessary copying
- Use const references
- Optimize for size

### Interoperability

#### Java to Native

**Java Service, Native Client:**
- Java service implements AIDL
- Native client uses NDK interface
- Same AIDL file
- Compatible

**Native Service, Java Client:**
- Native service implements AIDL NDK
- Java client uses Java interface
- Same AIDL file
- Compatible

#### Version Compatibility

**Interface Versioning:**
- Add new methods (backward compatible)
- Don't remove methods (breaking)
- Use version numbers if needed
- Document changes

### Debugging AIDL NDK

#### Common Issues

**Build Errors:**
- Check AIDL file syntax
- Verify NDK backend enabled
- Check dependencies
- Review Android.bp

**Runtime Errors:**
- Check service registration
- Verify binder connection
- Review status codes
- Check exception handling

**Type Mismatches:**
- Verify C++ types match AIDL
- Check parameter directions
- Review return types
- Ensure proper marshaling

#### Debugging Tools

**Binder State:**
```bash
# View Binder state
adb shell dumpsys binder
```

**Logging:**
```cpp
#include <android-base/logging.h>

LOG(INFO) << "Service called with: " << input;
```

## Key Takeaways

1. **AIDL NDK enables native C++ code to use AIDL interfaces**, allowing the same AIDL files to be used by both Java and C++ code.

2. **The build system generates C++ code from AIDL files**, creating header files with C++ classes that implement the interface.

3. **AIDL NDK uses ScopedAStatus for return values**, providing exception handling and status reporting in C++.

4. **Native services extend BnCInterface**, while clients use BpCInterface proxies, similar to Java's Stub and Proxy pattern.

5. **AIDL NDK data types map to C++ types** (e.g., `int` → `int32_t`, `String` → `std::string`, `List` → `std::vector`).

6. **AIDL NDK services and clients are interoperable with Java**, allowing Java services to be called from native code and vice versa.

7. **Error handling uses ScopedAStatus**, with exception codes and status checking for robust error handling.

8. **Understanding AIDL NDK** is essential for native service development, enabling type-safe IPC between Java and C++ code in AOSP.

## Related Topics

- **AIDL:** The base AIDL language and Java usage
- **Binder architecture:** How AIDL NDK fits into Binder architecture
- **Binder driver internals:** How native code interacts with the Binder driver
- **Native development:** General native development in Android

