---
number: 56
title: Parcelables
slug: parcelables
level: intermediate
tags:
  - aosp
  - parcelable
  - binder
  - ipc
  - serialization
  - aidl
  - data-transfer
prerequisites:
  - aidl
  - binder-ipc-basics
  - binder-architecture
estimated_minutes: 80
contributors: []
diagrams: []
examples: []
canonical_id: aosp-intermediate-56
---

# Parcelables

## Overview

Parcelable is Android's mechanism for serializing objects to pass them through Binder IPC. Unlike Java's Serializable, Parcelable is designed specifically for Android IPC and provides better performance through manual, efficient serialization. Understanding Parcelable is essential for AOSP development, as it's required for passing custom objects through Binder, used extensively in AIDL interfaces, and is the standard way to transfer complex data structures in Android IPC. This guide provides a comprehensive overview of Parcelable, how to implement it, best practices, and how it's used in Binder IPC.

Think of Parcelable like a custom packing system for shipping: just as you need to carefully pack items for shipping (writing data in a specific format), Parcelable requires you to manually pack your object's data into a Parcel (writeToParcel). When the package arrives, you need to unpack it in the same order (createFromParcel). This manual process is more work than automatic packing (Serializable), but it's faster and more efficient, which is critical for IPC performance.

## Deep Explanation

### What is Parcelable?

Parcelable is an Android interface that allows objects to be serialized and deserialized for IPC. It's the standard mechanism for passing custom objects through Binder.

**Key Characteristics:**
- **Manual Implementation:** Must implement serialization manually
- **Efficient:** Optimized for Android IPC
- **Type-Safe:** Compile-time type checking
- **Required for AIDL:** Custom objects in AIDL must be Parcelable

**Why Parcelable?**
- **Performance:** Faster than Serializable
- **IPC-Optimized:** Designed for Binder IPC
- **Explicit Control:** Manual implementation gives control
- **Android Standard:** Standard way to pass objects in Android

### Parcelable vs Serializable

#### Performance Comparison

**Parcelable:**
- **Faster:** Manual, optimized serialization
- **Less Overhead:** No reflection
- **Efficient:** Direct memory operations
- **Android-Specific:** Designed for Android

**Serializable:**
- **Slower:** Reflection-based serialization
- **More Overhead:** Reflection and object creation
- **Generic:** Java standard, not Android-optimized
- **Automatic:** Less code, but slower

**Performance Difference:**
- Parcelable: ~10x faster than Serializable
- Critical for IPC performance
- Better for frequent IPC calls
- Recommended for Android

#### When to Use Each

**Use Parcelable when:**
- Passing objects through Binder
- Using AIDL interfaces
- Performance is critical
- Android IPC

**Use Serializable when:**
- Storing to disk (Parcelable not persistent)
- Network serialization (though Parcelable can work)
- Java-only code (no Android dependency)
- Simple, infrequent serialization

### Implementing Parcelable

#### Basic Implementation

**Required Methods:**
1. `writeToParcel()` - Serialize object to Parcel
2. `describeContents()` - Describe special objects
3. `CREATOR` - Static field for deserialization

**Basic Example:**
```java
public class MyData implements Parcelable {
    private String name;
    private int value;
    
    // Constructor
    public MyData(String name, int value) {
        this.name = name;
        this.value = value;
    }
    
    // Parcelable implementation
    @Override
    public void writeToParcel(Parcel dest, int flags) {
        dest.writeString(name);
        dest.writeInt(value);
    }
    
    @Override
    public int describeContents() {
        return 0;  // No special objects
    }
    
    // Creator for deserialization
    public static final Creator<MyData> CREATOR = new Creator<MyData>() {
        @Override
        public MyData createFromParcel(Parcel in) {
            return new MyData(in.readString(), in.readInt());
        }
        
        @Override
        public MyData[] newArray(int size) {
            return new MyData[size];
        }
    };
}
```

#### Implementation Details

**writeToParcel():**
- Serializes object data to Parcel
- Must write in specific order
- Order must match read order
- Uses Parcel write methods

**describeContents():**
- Describes special objects (FileDescriptor, etc.)
- Returns 0 for most objects
- Used for flags in writeToParcel
- Rarely needed

**CREATOR:**
- Static field for deserialization
- Implements Creator interface
- `createFromParcel()` - Creates object from Parcel
- `newArray()` - Creates array of objects

#### Parcelable Constructor

**Parcel Constructor:**
```java
protected MyData(Parcel in) {
    name = in.readString();
    value = in.readInt();
}
```

**Usage in CREATOR:**
```java
public static final Creator<MyData> CREATOR = new Creator<MyData>() {
    @Override
    public MyData createFromParcel(Parcel in) {
        return new MyData(in);
    }
    
    @Override
    public MyData[] newArray(int size) {
        return new MyData[size];
    }
};
```

### Parcelable Data Types

#### Supported Types

**Primitives:**
- `writeInt()` / `readInt()`
- `writeLong()` / `readLong()`
- `writeFloat()` / `readFloat()`
- `writeDouble()` / `readDouble()`
- `writeByte()` / `readByte()`
- `writeBoolean()` / `readBoolean()`

**Strings:**
- `writeString()` / `readString()`
- UTF-8 encoded
- Null-safe

**Arrays:**
- `writeIntArray()` / `readIntArray()`
- `writeStringArray()` / `readStringArray()`
- `writeTypedArray()` / `readTypedArray()` (for Parcelable arrays)
- `writeParcelableArray()` / `readParcelableArray()`

**Collections:**
- `writeList()` / `readList()`
- `writeTypedList()` / `readTypedList()` (for Parcelable lists)
- `writeStringList()` / `readStringList()`
- `writeMap()` / `readMap()`

**Objects:**
- `writeParcelable()` / `readParcelable()`
- `writeSerializable()` / `readSerializable()`
- `writeBundle()` / `readBundle()`
- `writeSparseArray()` / `readSparseArray()`

**Special Types:**
- `writeByteArray()` / `readByteArray()`
- `writeBinder()` / `readStrongBinder()`
- `writeFileDescriptor()` / `readFileDescriptor()`

### Complex Parcelable Objects

#### Nested Objects

**Nested Parcelable:**
```java
public class Container implements Parcelable {
    private MyData data;
    private List<MyData> dataList;
    
    @Override
    public void writeToParcel(Parcel dest, int flags) {
        dest.writeParcelable(data, flags);
        dest.writeTypedList(dataList);
    }
    
    protected Container(Parcel in) {
        data = in.readParcelable(MyData.class.getClassLoader());
        dataList = in.createTypedArrayList(MyData.CREATOR);
    }
}
```

#### Collections

**List of Parcelables:**
```java
private List<MyData> dataList;

@Override
public void writeToParcel(Parcel dest, int flags) {
    dest.writeTypedList(dataList);
}

protected MyContainer(Parcel in) {
    dataList = in.createTypedArrayList(MyData.CREATOR);
}
```

**Map:**
```java
private Map<String, MyData> dataMap;

@Override
public void writeToParcel(Parcel dest, int flags) {
    dest.writeInt(dataMap.size());
    for (Map.Entry<String, MyData> entry : dataMap.entrySet()) {
        dest.writeString(entry.getKey());
        dest.writeParcelable(entry.getValue(), flags);
    }
}

protected MyContainer(Parcel in) {
    int size = in.readInt();
    dataMap = new HashMap<>();
    for (int i = 0; i < size; i++) {
        String key = in.readString();
        MyData value = in.readParcelable(MyData.class.getClassLoader());
        dataMap.put(key, value);
    }
}
```

### Parcelable Best Practices

#### Order Matters

**Critical Rule:**
- Read in same order as write
- Mismatched order causes data corruption
- Must be exact match

**Example:**
```java
// Write order
dest.writeString(name);
dest.writeInt(value);
dest.writeBoolean(active);

// Read order (MUST match)
name = in.readString();
value = in.readInt();
active = in.readBoolean();
```

#### Versioning

**Version Field:**
```java
private static final int VERSION = 1;
private int version;

@Override
public void writeToParcel(Parcel dest, int flags) {
    dest.writeInt(VERSION);
    dest.writeString(name);
    dest.writeInt(value);
}

protected MyData(Parcel in) {
    version = in.readInt();
    if (version >= 1) {
        name = in.readString();
        value = in.readInt();
    }
    // Handle older versions
}
```

#### Null Handling

**Null Safety:**
```java
@Override
public void writeToParcel(Parcel dest, int flags) {
    dest.writeInt(name != null ? 1 : 0);
    if (name != null) {
        dest.writeString(name);
    }
}

protected MyData(Parcel in) {
    if (in.readInt() == 1) {
        name = in.readString();
    } else {
        name = null;
    }
}
```

#### Performance Optimization

**Keep Objects Small:**
- Large objects are slow to serialize
- Consider splitting large objects
- Use references when possible
- Minimize nested structures

**Avoid Deep Hierarchies:**
- Deep object graphs are slow
- Flatten when possible
- Consider data transfer objects
- Optimize for IPC

### Using Parcelable in AIDL

#### AIDL Declaration

**Parcelable AIDL File:**
```aidl
// MyData.aidl
package com.example;

parcelable MyData;
```

**Interface Usage:**
```aidl
// IMyService.aidl
package com.example;

import com.example.MyData;

interface IMyService {
    MyData processData(MyData input);
    List<MyData> getDataList();
}
```

#### Java Implementation

**Service Implementation:**
```java
public class MyService extends IMyService.Stub {
    @Override
    public MyData processData(MyData input) throws RemoteException {
        // Process data
        return new MyData(input.getName(), input.getValue() * 2);
    }
    
    @Override
    public List<MyData> getDataList() throws RemoteException {
        List<MyData> list = new ArrayList<>();
        // Populate list
        return list;
    }
}
```

**Client Usage:**
```java
IMyService service = IMyService.Stub.asInterface(binder);
MyData input = new MyData("test", 42);
MyData result = service.processData(input);
```

### Parcelable Flags

#### describeContents() Flags

**PARCELABLE_WRITE_RETURN_VALUE:**
- Object being written as return value
- Can optimize serialization
- Rarely used

**CONTENTS_FILE_DESCRIPTOR:**
- Object contains FileDescriptor
- Special handling needed
- Used for file descriptors

**Usage:**
```java
@Override
public int describeContents() {
    return CONTENTS_FILE_DESCRIPTOR;  // If contains FileDescriptor
}
```

#### writeToParcel Flags

**PARCELABLE_WRITE_RETURN_VALUE:**
- Passed to writeToParcel
- Indicates return value
- Can optimize serialization

**Usage:**
```java
@Override
public void writeToParcel(Parcel dest, int flags) {
    if ((flags & PARCELABLE_WRITE_RETURN_VALUE) != 0) {
        // Optimize for return value
    }
    // Normal serialization
}
```

### Common Patterns

#### Builder Pattern

**Parcelable with Builder:**
```java
public class MyData implements Parcelable {
    private final String name;
    private final int value;
    
    private MyData(Builder builder) {
        this.name = builder.name;
        this.value = builder.value;
    }
    
    public static class Builder {
        private String name;
        private int value;
        
        public Builder setName(String name) {
            this.name = name;
            return this;
        }
        
        public Builder setValue(int value) {
            this.value = value;
            return this;
        }
        
        public MyData build() {
            return new MyData(this);
        }
    }
    
    // Parcelable implementation...
}
```

#### Immutable Objects

**Immutable Parcelable:**
```java
public final class MyData implements Parcelable {
    private final String name;
    private final int value;
    
    public MyData(String name, int value) {
        this.name = name;
        this.value = value;
    }
    
    // Getters only, no setters
    public String getName() { return name; }
    public int getValue() { return value; }
    
    // Parcelable implementation...
}
```

### Debugging Parcelable

#### Common Issues

**Order Mismatch:**
- Symptoms: Wrong data, crashes
- Cause: Read/write order mismatch
- Fix: Ensure exact order match

**Null Pointer:**
- Symptoms: NullPointerException
- Cause: Not handling nulls
- Fix: Check for null before read

**Version Mismatch:**
- Symptoms: Data corruption
- Cause: Version incompatibility
- Fix: Add versioning, handle old versions

#### Testing Parcelable

**Round-Trip Test:**
```java
@Test
public void testParcelable() {
    MyData original = new MyData("test", 42);
    
    Parcel parcel = Parcel.obtain();
    original.writeToParcel(parcel, 0);
    parcel.setDataPosition(0);
    
    MyData recreated = MyData.CREATOR.createFromParcel(parcel);
    
    assertEquals(original.getName(), recreated.getName());
    assertEquals(original.getValue(), recreated.getValue());
    
    parcel.recycle();
}
```

### Parcelable Tools

#### Auto-Generation

**Parcelize Plugin (Kotlin):**
```kotlin
@Parcelize
data class MyData(
    val name: String,
    val value: Int
) : Parcelable
```

**Auto-generates:**
- writeToParcel()
- describeContents()
- CREATOR

**Benefits:**
- Less boilerplate
- Less error-prone
- Compiler-generated
- Kotlin-specific

#### Manual vs Auto-Generated

**Manual:**
- Full control
- Can optimize
- More code
- More error-prone

**Auto-Generated:**
- Less code
- Less error-prone
- Less control
- Kotlin-specific

## Key Takeaways

1. **Parcelable is Android's serialization mechanism** for passing objects through Binder IPC, providing better performance than Serializable.

2. **Parcelable requires manual implementation** of writeToParcel(), describeContents(), and a CREATOR field for deserialization.

3. **Order matters critically** - data must be read in the exact same order as it was written, or data corruption will occur.

4. **Parcelable supports primitives, Strings, arrays, collections, and nested Parcelables** through various Parcel read/write methods.

5. **Parcelable is required for custom objects in AIDL** interfaces, defined in a separate .aidl file and imported into interface files.

6. **Best practices include** versioning for compatibility, null handling, keeping objects small, and avoiding deep hierarchies.

7. **Parcelable is significantly faster than Serializable** (approximately 10x) due to manual, optimized serialization without reflection.

8. **Understanding Parcelable is essential** for AOSP development, AIDL interfaces, and efficient IPC data transfer in Android.

## Related Topics

- **AIDL:** How Parcelable is used in AIDL interfaces
- **Binder IPC Basics:** How Parcelable objects are passed through Binder
- **Binder architecture:** How Parcelable fits into Binder's data transfer mechanism
- **Parcel:** The container used for Parcelable serialization

