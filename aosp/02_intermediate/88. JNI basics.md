---
number: 88
title: JNI basics
slug: jni-basics
level: intermediate
tags:
  - aosp
  - jni
  - native
  - java-native-interface
  - c++
  - native-code
  - interop
prerequisites:
  - dalvik-vs-art
  - android-architecture-complete-overview
estimated_minutes: 90
contributors: []
diagrams: []
examples: []
canonical_id: aosp-intermediate-88
---

# JNI basics

## Overview

JNI (Java Native Interface) is the bridge between Java/Kotlin code and native C/C++ code in Android. Understanding JNI basics is essential for AOSP development, as it explains how Java and native code interact, how to call native functions from Java, how to call Java methods from native code, how to pass data between Java and native code, and how native libraries are integrated into Android applications. This guide provides a comprehensive overview of JNI basics, JNI functions, data types, method signatures, memory management, and best practices.

Think of JNI like a translator between two languages: just as a translator allows people speaking different languages to communicate, JNI allows Java code and native C/C++ code to communicate. Java code can call native functions, and native code can call Java methods, with JNI handling the translation of data types, method calls, and memory management between the two worlds.

## Deep Explanation

### What is JNI?

JNI (Java Native Interface) is a programming framework that enables Java code running in a Java Virtual Machine (JVM) to call and be called by native applications and libraries written in C, C++, or assembly.

**Key Characteristics:**
- **Bridge:** Connects Java and native code
- **Bidirectional:** Java calls native, native calls Java
- **Type Mapping:** Maps Java types to native types
- **Memory Management:** Manages memory between Java and native

**Why JNI?**
- **Performance:** Native code performance benefits
- **Legacy Code:** Reuse existing C/C++ libraries
- **System Access:** Access system-level functionality
- **Hardware:** Direct hardware access

### JNI Architecture

#### Java to Native Call

**Call Flow:**
```
Java Code
    │
    │ native method call
    │
    ▼
JNI Layer
    │
    │ type conversion
    │
    ▼
Native Code (C/C++)
    │
    │ execution
    │
    ▼
Return (with type conversion)
```

**Process:**
1. Java code calls native method
2. JNI handles call
3. Convert Java types to native types
4. Call native function
5. Convert return value
6. Return to Java

#### Native to Java Call

**Call Flow:**
```
Native Code (C/C++)
    │
    │ JNI function call
    │
    ▼
JNI Layer
    │
    │ type conversion
    │
    ▼
Java Code
    │
    │ method execution
    │
    ▼
Return (with type conversion)
```

**Process:**
1. Native code calls JNI function
2. JNI handles call
3. Convert native types to Java types
4. Call Java method
5. Convert return value
6. Return to native

### JNI Method Declaration

#### Java Side

**Native Method Declaration:**
```java
public class MyClass {
    // Declare native method
    public native int nativeMethod(int param);
    
    // Static native method
    public static native String staticNativeMethod();
    
    // Native method with object parameter
    public native void processObject(MyObject obj);
}
```

**Key Points:**
- `native` keyword
- No method body
- Can have parameters
- Can return values

#### Native Side

**Native Function Implementation:**
```c
#include <jni.h>

// Function signature: Java_<Package>_<Class>_<Method>
JNIEXPORT jint JNICALL
Java_com_example_MyClass_nativeMethod(JNIEnv *env, jobject thiz, jint param) {
    // Native implementation
    return param * 2;
}
```

**Function Naming:**
- `Java_` prefix
- Package name (dots replaced with underscores)
- Class name
- Method name
- Signature encoding

### JNI Data Types

#### Primitive Types

**Java to JNI Mapping:**
```java
// Java Type → JNI Type
boolean → jboolean
byte    → jbyte
char    → jchar
short   → jshort
int     → jint
long    → jlong
float   → jfloat
double  → jdouble
void    → void
```

**Usage:**
```c
JNIEXPORT jint JNICALL
Java_MyClass_add(JNIEnv *env, jobject thiz, jint a, jint b) {
    return a + b;  // jint is C int
}
```

#### Reference Types

**Java to JNI Mapping:**
```java
// Java Type → JNI Type
Object      → jobject
String      → jstring
Class       → jclass
Object[]    → jobjectArray
int[]       → jintArray
```

**Usage:**
```c
JNIEXPORT jstring JNICALL
Java_MyClass_getString(JNIEnv *env, jobject thiz) {
    // Create Java string
    return (*env)->NewStringUTF(env, "Hello from native");
}
```

### JNI Environment

#### JNIEnv Pointer

**JNIEnv:**
- Pointer to JNI function table
- Provides JNI functions
- Thread-local
- Per-thread instance

**Usage:**
```c
// C style
(*env)->NewStringUTF(env, "string");

// C++ style
env->NewStringUTF("string");
```

**Functions:**
- String operations
- Array operations
- Object operations
- Exception handling

#### Common JNI Functions

**String Operations:**
```c
// Create Java string from C string
jstring jstr = (*env)->NewStringUTF(env, "Hello");

// Get C string from Java string
const char *cstr = (*env)->GetStringUTFChars(env, jstr, NULL);
(*env)->ReleaseStringUTFChars(env, jstr, cstr);
```

**Array Operations:**
```c
// Get array length
jsize len = (*env)->GetArrayLength(env, array);

// Get array elements
jint *elements = (*env)->GetIntArrayElements(env, array, NULL);
(*env)->ReleaseIntArrayElements(env, array, elements, 0);
```

**Object Operations:**
```c
// Get object class
jclass clazz = (*env)->GetObjectClass(env, obj);

// Get field ID
jfieldID fieldId = (*env)->GetFieldID(env, clazz, "fieldName", "I");

// Get field value
jint value = (*env)->GetIntField(env, obj, fieldId);
```

### Method Signatures

#### Signature Format

**Signature Syntax:**
```
(ParameterTypes)ReturnType
```

**Type Codes:**
- `Z` - boolean
- `B` - byte
- `C` - char
- `S` - short
- `I` - int
- `J` - long
- `F` - float
- `D` - double
- `V` - void
- `L<class>;` - Object (e.g., `Ljava/lang/String;`)
- `[` - Array (e.g., `[I` for int[])

**Examples:**
```java
// int method(int, int)
"(II)I"

// String method(String)
"(Ljava/lang/String;)Ljava/lang/String;"

// void method(int[], String)
"([ILjava/lang/String;)V"
```

#### Getting Method IDs

**Get Method ID:**
```c
jclass clazz = (*env)->GetObjectClass(env, obj);
jmethodID methodId = (*env)->GetMethodID(env, clazz, "methodName", "(I)I");
```

**Call Method:**
```c
jint result = (*env)->CallIntMethod(env, obj, methodId, arg);
```

### Memory Management

#### Local References

**Local References:**
- Created by JNI functions
- Valid until function returns
- Automatically freed
- Can be explicitly deleted

**Example:**
```c
jstring localStr = (*env)->NewStringUTF(env, "local");
// Use localStr
(*env)->DeleteLocalRef(env, localStr);  // Optional, auto-freed
```

#### Global References

**Global References:**
- Valid across JNI calls
- Must be explicitly deleted
- Survive function returns
- Use when needed across calls

**Example:**
```c
jstring localStr = (*env)->NewStringUTF(env, "string");
jstring globalStr = (*env)->NewGlobalRef(env, localStr);
// Use globalStr across calls
(*env)->DeleteGlobalRef(env, globalStr);  // Must delete
```

#### Weak Global References

**Weak Global References:**
- Don't prevent GC
- Can become NULL
- Check before use
- Use for caching

**Example:**
```c
jobject weakRef = (*env)->NewWeakGlobalRef(env, obj);
// Check if still valid
if ((*env)->IsSameObject(env, weakRef, NULL)) {
    // Object was GC'd
}
(*env)->DeleteWeakGlobalRef(env, weakRef);
```

### Exception Handling

#### Checking Exceptions

**Exception Check:**
```c
jstring result = (*env)->CallObjectMethod(env, obj, methodId);
if ((*env)->ExceptionCheck(env)) {
    (*env)->ExceptionDescribe(env);
    (*env)->ExceptionClear(env);
    return NULL;
}
```

#### Throwing Exceptions

**Throw Exception:**
```c
jclass exceptionClass = (*env)->FindClass(env, "java/lang/IllegalArgumentException");
(*env)->ThrowNew(env, exceptionClass, "Invalid argument");
```

### Loading Native Libraries

#### System.loadLibrary()

**Loading Library:**
```java
public class MyClass {
    static {
        // Load native library
        System.loadLibrary("mylib");
    }
    
    public native int nativeMethod();
}
```

**Library Name:**
- `System.loadLibrary("mylib")` loads `libmylib.so`
- Searches system library paths
- Architecture-specific

#### System.load()

**Loading by Path:**
```java
System.load("/path/to/libmylib.so");
```

**Use Cases:**
- Full path specified
- Custom library location
- Testing/debugging

### JNI Best Practices

#### Performance

**Minimize JNI Calls:**
- Batch operations
- Pass data efficiently
- Cache method/field IDs
- Avoid frequent crossings

**Example:**
```c
// BAD: Multiple JNI calls
for (int i = 0; i < 1000; i++) {
    (*env)->CallIntMethod(env, obj, methodId, i);
}

// GOOD: Single native call
processBatch(env, obj, methodId, 1000);
```

#### Error Handling

**Always Check:**
- Check return values
- Handle exceptions
- Validate parameters
- Clean up resources

**Example:**
```c
jstring jstr = (*env)->NewStringUTF(env, str);
if (jstr == NULL) {
    // Handle error
    return;
}
// Use jstr
```

#### Memory Management

**Manage References:**
- Delete global references
- Release native resources
- Avoid memory leaks
- Use local references when possible

**Example:**
```c
jobject globalRef = (*env)->NewGlobalRef(env, obj);
// Use globalRef
// ... later ...
(*env)->DeleteGlobalRef(env, globalRef);  // Must delete
```

### Common JNI Patterns

#### Calling Java from Native

**Pattern:**
```c
// Get class
jclass clazz = (*env)->FindClass(env, "com/example/MyClass");

// Get method ID
jmethodID methodId = (*env)->GetStaticMethodID(env, clazz, "method", "(I)I");

// Call method
jint result = (*env)->CallStaticIntMethod(env, clazz, methodId, arg);
```

#### Passing Arrays

**Pattern:**
```c
// Get array elements
jint *elements = (*env)->GetIntArrayElements(env, array, NULL);
jsize len = (*env)->GetArrayLength(env, array);

// Process elements
for (int i = 0; i < len; i++) {
    elements[i] *= 2;
}

// Release elements
(*env)->ReleaseIntArrayElements(env, array, elements, 0);
```

## Key Takeaways

1. **JNI (Java Native Interface)** is the bridge between Java/Kotlin code and native C/C++ code, enabling bidirectional communication and type conversion.

2. **JNI method declaration** uses the `native` keyword in Java and follows a specific naming convention in native code: `Java_<Package>_<Class>_<Method>`.

3. **JNI data types** map Java types to native types (e.g., `int` → `jint`, `String` → `jstring`), with primitive types and reference types handled differently.

4. **JNIEnv pointer** provides access to JNI functions for string operations, array operations, object operations, and exception handling.

5. **Method signatures** use a specific format `(ParameterTypes)ReturnType` with type codes (e.g., `I` for int, `Ljava/lang/String;` for String).

6. **Memory management** includes local references (auto-freed), global references (must be deleted), and weak global references (don't prevent GC).

7. **Exception handling** requires checking for exceptions after JNI calls and can throw exceptions from native code using JNI functions.

8. **Understanding JNI basics** is essential for AOSP development, explaining how Java and native code interact, how to implement native methods, and how to manage memory and exceptions in JNI code.

## Related Topics

- **Native shared libraries:** How native libraries are structured and loaded
- **AIDL NDK:** Native AIDL interfaces using similar concepts
- **Dalvik vs ART:** Runtime environment that supports JNI
- **Android Architecture - Complete Overview:** How JNI fits into overall architecture

