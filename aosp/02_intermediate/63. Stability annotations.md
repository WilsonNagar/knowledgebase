---
number: 63
title: Stability annotations
slug: stability-annotations
level: intermediate
tags:
  - aosp
  - aidl
  - stability
  - annotations
  - versioning
  - api-stability
  - binder
prerequisites:
  - aidl
  - binder-architecture
  - aidl-ndk
estimated_minutes: 75
contributors: []
diagrams: []
examples: []
canonical_id: aosp-intermediate-63
---

# Stability annotations

## Overview

Stability annotations in AIDL specify the stability guarantees of an interface, indicating whether the interface can be used across different Android versions, vendor implementations, and system partitions. Understanding stability annotations is essential for AOSP development, as they determine interface compatibility, affect system updates, control vendor customization, and ensure API stability across Android versions. This guide provides a comprehensive overview of stability annotations, their types, usage, implications, and best practices.

Think of stability annotations like version numbers on software: just as version numbers indicate compatibility and change policies (e.g., major version changes may break compatibility, minor versions add features, patch versions fix bugs), stability annotations indicate how an AIDL interface can change and whether it's compatible across different Android versions and vendor implementations.

## Deep Explanation

### What are Stability Annotations?

Stability annotations in AIDL specify the stability level of an interface, determining how the interface can evolve and whether it can be used across system boundaries (e.g., framework to vendor, system to app).

**Key Characteristics:**
- **Versioning Guarantees:** Define how interface can change
- **Compatibility:** Indicate cross-version compatibility
- **Partition Boundaries:** Control usage across partitions
- **Vendor Customization:** Allow or restrict vendor changes

**Why Stability Annotations?**
- **API Stability:** Ensure interfaces remain stable
- **System Updates:** Enable safe system updates
- **Vendor Customization:** Control vendor modifications
- **Compatibility:** Maintain compatibility across versions

### Stability Levels

#### @VintfStability

**What It Is:**
- Vendor Interface Object (VINTF) stability
- Highest stability level
- Guaranteed stable across Android versions
- Can be used across partitions

**Characteristics:**
- **Stable:** Interface cannot change incompatibly
- **Cross-Partition:** Can be used across partitions
- **Version-Independent:** Works across Android versions
- **Vendor-Safe:** Safe for vendor implementations

**Usage:**
```aidl
@VintfStability
interface IMyService {
    int add(int a, int b);
    String processData(String input);
}
```

**When to Use:**
- Interfaces used by vendors
- HAL interfaces
- System-vendor boundaries
- Long-term stable APIs

#### @UnsupportedAppUsage

**What It Is:**
- Marks interface as unsupported for apps
- Framework-internal use
- May change without notice
- Not for public API

**Characteristics:**
- **Internal:** Framework internal use
- **Unstable:** May change
- **Not Public:** Not for app developers
- **Flexible:** Can evolve freely

**Usage:**
```aidl
@UnsupportedAppUsage
interface IInternalService {
    void internalMethod();
}
```

**When to Use:**
- Framework-internal interfaces
- Not for public consumption
- May change frequently
- Implementation details

#### No Annotation (Default)

**What It Is:**
- No explicit stability annotation
- Framework-internal default
- May change
- Not guaranteed stable

**Characteristics:**
- **Flexible:** Can change
- **Internal:** Framework use
- **No Guarantees:** No stability promises
- **Default:** Standard for internal interfaces

**Usage:**
```aidl
// No annotation
interface IInternalService {
    void method();
}
```

**When to Use:**
- Internal framework interfaces
- Not exposed to vendors
- Can change freely
- Implementation details

### Stability Implications

#### Interface Evolution

**@VintfStability:**
- Cannot remove methods
- Cannot change method signatures
- Can add new methods (backward compatible)
- Must maintain compatibility

**@UnsupportedAppUsage:**
- Can change freely
- No compatibility guarantees
- May break existing code
- Framework-internal only

**No Annotation:**
- Can change freely
- No guarantees
- Internal use only
- May break compatibility

#### Cross-Partition Usage

**@VintfStability:**
- Can be used across partitions
- Framework ↔ Vendor
- System ↔ Vendor
- Safe for vendor implementations

**@UnsupportedAppUsage:**
- Framework-internal only
- Not for cross-partition use
- Not for vendor use
- Framework boundaries only

**No Annotation:**
- Framework-internal only
- Not for cross-partition use
- Not for vendor use
- Framework boundaries only

### Stability and Versioning

#### Android Version Compatibility

**@VintfStability:**
- Must work across Android versions
- Backward compatible changes only
- Interface must remain compatible
- New methods can be added

**Example:**
```aidl
@VintfStability
interface IMyService {
    // Android 11
    int add(int a, int b);
    
    // Android 12: Can add new method
    int multiply(int a, int b);  // OK: backward compatible
    
    // Cannot remove add() - breaks compatibility
}
```

#### Vendor Implementation

**@VintfStability:**
- Vendors can implement
- Must follow interface exactly
- Cannot change interface
- Must maintain compatibility

**Vendor Usage:**
```aidl
@VintfStability
interface IMyHal {
    int getValue();
    void setValue(int value);
}

// Vendor implements exactly as defined
// Cannot modify interface
// Must support all methods
```

### Stability Best Practices

#### When to Use @VintfStability

**Use For:**
- HAL interfaces
- Vendor-facing APIs
- Long-term stable interfaces
- Cross-partition interfaces
- Public vendor APIs

**Example:**
```aidl
@VintfStability
interface IAudioHal {
    int openStream(StreamConfig config);
    void closeStream(int streamId);
    int write(int streamId, byte[] data);
}
```

#### When to Use @UnsupportedAppUsage

**Use For:**
- Framework-internal interfaces
- Implementation details
- Not for public use
- May change frequently

**Example:**
```aidl
@UnsupportedAppUsage
interface IInternalManager {
    void internalConfigure();
    void internalUpdate();
}
```

#### When to Use No Annotation

**Use For:**
- Pure framework-internal interfaces
- Implementation details
- Not exposed externally
- Can change freely

**Example:**
```aidl
// No annotation - internal only
interface IInternalHelper {
    void helperMethod();
}
```

### Stability and Project Treble

#### Treble Context

**Project Treble:**
- Separates framework and vendor
- Requires stable interfaces
- Enables independent updates
- Uses VINTF for stability

**@VintfStability Role:**
- Enables Treble compatibility
- Allows framework updates
- Maintains vendor compatibility
- Critical for Treble

**Example:**
```aidl
@VintfStability
interface IGraphicsHal {
    // Stable interface for Treble
    // Framework can update independently
    // Vendor remains compatible
}
```

### Interface Evolution Rules

#### Adding Methods

**@VintfStability:**
```aidl
@VintfStability
interface IMyService {
    // Original
    int add(int a, int b);
    
    // Can add (backward compatible)
    int multiply(int a, int b);
}
```

**Rules:**
- Can add new methods
- Must be backward compatible
- Existing code still works
- New functionality added

#### Removing Methods

**@VintfStability:**
```aidl
@VintfStability
interface IMyService {
    // Cannot remove - breaks compatibility
    // int add(int a, int b);  // ERROR: Cannot remove
}
```

**Rules:**
- Cannot remove methods
- Breaks compatibility
- Violates stability contract
- Not allowed

#### Changing Signatures

**@VintfStability:**
```aidl
@VintfStability
interface IMyService {
    // Cannot change signature
    // int add(int a, int b, int c);  // ERROR: Changed signature
}
```

**Rules:**
- Cannot change method signatures
- Breaks compatibility
- Violates stability contract
- Not allowed

### Stability Checking

#### Build-Time Checks

**AIDL Compiler:**
- Validates stability annotations
- Checks interface compatibility
- Enforces stability rules
- Reports violations

**Errors:**
```
ERROR: Cannot remove method 'add' from @VintfStability interface
ERROR: Cannot change signature of 'processData' in @VintfStability interface
```

#### Runtime Checks

**VINTF:**
- Validates interface stability
- Checks vendor implementations
- Ensures compatibility
- Reports mismatches

### Stability Documentation

#### Documenting Stability

**Interface Documentation:**
```aidl
/**
 * MyService interface
 * 
 * @VintfStability: This interface is stable and can be used
 * across Android versions and vendor implementations.
 * 
 * Methods cannot be removed or have signatures changed.
 * New methods can be added in a backward-compatible manner.
 */
@VintfStability
interface IMyService {
    int add(int a, int b);
}
```

#### Version History

**Documenting Changes:**
```aidl
@VintfStability
interface IMyService {
    // Android 11: Initial version
    int add(int a, int b);
    
    // Android 12: Added multiply
    int multiply(int a, int b);
    
    // Android 13: Added divide
    int divide(int a, int b);
}
```

### Common Patterns

#### HAL Interfaces

**Standard Pattern:**
```aidl
@VintfStability
interface IMyHal {
    // Stable HAL interface
    int open();
    void close();
    int process(byte[] data);
}
```

**Characteristics:**
- Always @VintfStability
- Vendor-implemented
- Long-term stable
- Cross-partition

#### Framework Services

**Internal Services:**
```aidl
@UnsupportedAppUsage
interface IInternalService {
    // Framework-internal
    void internalMethod();
}
```

**Characteristics:**
- @UnsupportedAppUsage or no annotation
- Framework-internal
- Can change
- Not for vendors

### Stability Migration

#### Migrating to Stability

**Before:**
```aidl
// No annotation - unstable
interface IMyService {
    int add(int a, int b);
}
```

**After:**
```aidl
@VintfStability
interface IMyService {
    int add(int a, int b);
}
```

**Considerations:**
- Ensure interface is stable
- Review all methods
- Document stability guarantees
- Test compatibility

#### Breaking Changes

**Avoiding Breaking Changes:**
- Plan interface evolution
- Add methods, don't remove
- Maintain compatibility
- Version if needed

**If Breaking Change Needed:**
- Create new interface version
- Deprecate old interface
- Migrate gradually
- Document migration path

## Key Takeaways

1. **Stability annotations specify interface stability guarantees**, determining how interfaces can evolve and be used across system boundaries.

2. **@VintfStability** marks interfaces as stable across Android versions, allowing cross-partition use and vendor implementations.

3. **@UnsupportedAppUsage** marks interfaces as framework-internal, allowing changes without compatibility guarantees.

4. **No annotation** means framework-internal interfaces that can change freely, with no stability guarantees.

5. **@VintfStability interfaces cannot have methods removed or signatures changed**, but can have new methods added in a backward-compatible manner.

6. **Stability annotations are critical for Project Treble**, enabling framework and vendor updates to proceed independently.

7. **Build-time and runtime checks enforce stability rules**, preventing incompatible changes to stable interfaces.

8. **Understanding stability annotations** is essential for AOSP development, ensuring API stability and enabling safe system updates.

## Related Topics

- **AIDL:** Base AIDL language and interface definition
- **AIDL NDK:** Native AIDL usage and stability
- **Binder architecture:** How stability fits into Binder architecture
- **Project Treble:** How stability enables Treble compatibility

