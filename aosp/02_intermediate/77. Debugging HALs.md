---
number: 77
title: Debugging HALs
slug: debugging-hals
level: intermediate
tags:
  - aosp
  - hal
  - debugging
  - hal-debugging
  - troubleshooting
  - hal-testing
prerequisites:
  - creating-your-own-hal
  - vts-vendor-test-suite
  - aidl-based-hals
estimated_minutes: 85
contributors: []
diagrams: []
examples: []
canonical_id: aosp-intermediate-77
---

# Debugging HALs

## Overview

Debugging HALs involves identifying and resolving issues in Hardware Abstraction Layer implementations, including service registration problems, interface mismatches, hardware access failures, and runtime errors. Understanding HAL debugging is essential for AOSP development, as it enables efficient troubleshooting, validates HAL implementations, ensures compatibility, and helps maintain reliable hardware interfaces. This guide provides a comprehensive overview of HAL debugging techniques, common issues, debugging tools, and best practices for troubleshooting HAL problems.

Think of debugging HALs like diagnosing a car problem: just as a mechanic uses diagnostic tools (OBD scanner, multimeter, test drives) to identify issues, HAL debugging uses various tools (logs, dumpsys, lshal, VTS) to identify problems. The mechanic checks different systems (engine, electrical, transmission) just as HAL debugging checks different aspects (service registration, interface compliance, hardware access, runtime behavior).

## Deep Explanation

### What is HAL Debugging?

HAL debugging is the process of identifying, diagnosing, and resolving issues in Hardware Abstraction Layer implementations, including service registration, interface compliance, hardware access, and runtime behavior.

**Key Characteristics:**
- **Problem Identification:** Find the root cause
- **Systematic Approach:** Methodical troubleshooting
- **Tool Usage:** Leverage debugging tools
- **Validation:** Verify fixes

**Why HAL Debugging?**
- **Issue Resolution:** Fix HAL problems
- **Quality Assurance:** Ensure reliability
- **Compatibility:** Validate compliance
- **Development:** Improve implementations

### Common HAL Issues

#### Service Registration Issues

**Symptoms:**
- Service not found
- Framework can't access HAL
- Service crashes on start

**Common Causes:**
- Service not registered
- Wrong service name
- Init script missing
- Permissions issues

**Debugging:**
```bash
# Check if service is registered
adb shell lshal | grep <hal_name>

# Check service status
adb shell dumpsys | grep <hal_name>

# Check init script
adb shell cat /vendor/etc/init/<service>.rc
```

#### Interface Mismatches

**Symptoms:**
- Method not found
- Wrong parameter types
- Version incompatibility

**Common Causes:**
- Interface version mismatch
- Missing methods
- Type mismatches
- Stability annotation issues

**Debugging:**
```bash
# Check interface version
adb shell lshal -l | grep <hal_name>

# Check manifest
adb shell cat /vendor/manifest.xml | grep <hal_name>

# VTS validation
vts-tradefed run commandAndExit vts -m VtsHal<Name>Target
```

#### Hardware Access Failures

**Symptoms:**
- Hardware not responding
- Device node errors
- Permission denied

**Common Causes:**
- Device node not found
- Permission issues
- Hardware not initialized
- Driver problems

**Debugging:**
```bash
# Check device nodes
adb shell ls -l /dev/ | grep <device>

# Check permissions
adb shell getenforce
adb shell ls -Z /dev/<device>

# Check hardware state
adb shell dmesg | grep <device>
```

#### Runtime Errors

**Symptoms:**
- Service crashes
- Method failures
- Unexpected behavior

**Common Causes:**
- Null pointer dereference
- Resource leaks
- Thread safety issues
- Invalid parameters

**Debugging:**
```bash
# Check crash logs
adb logcat | grep -i crash

# Check service logs
adb logcat | grep <service_name>

# Check system logs
adb shell dmesg | tail -100
```

### Debugging Tools

#### lshal (List HAL)

**Purpose:**
- List all HAL services
- Show service information
- Check service registration

**Usage:**
```bash
# List all HALs
adb shell lshal

# List specific HAL
adb shell lshal | grep <hal_name>

# Detailed information
adb shell lshal -l

# Check service instance
adb shell lshal | grep <instance_name>
```

**Output:**
```
android.hardware.example@1.0::IExample/default
  Interface: android.hardware.example@1.0::IExample
  Instance: default
  PID: 1234
  Transport: hwbinder
```

#### dumpsys

**Purpose:**
- Dump system service state
- Check service status
- View service information

**Usage:**
```bash
# Dump all services
adb shell dumpsys

# Dump specific service
adb shell dumpsys <service_name>

# Check HAL-related services
adb shell dumpsys | grep -i hal
```

#### logcat

**Purpose:**
- View system logs
- Check HAL logs
- Monitor runtime behavior

**Usage:**
```bash
# View all logs
adb logcat

# Filter by tag
adb logcat -s HAL:* ServiceManager:*

# Filter by service
adb logcat | grep <service_name>

# Clear and monitor
adb logcat -c && adb logcat
```

#### VTS (Vendor Test Suite)

**Purpose:**
- Automated HAL testing
- Compatibility validation
- Issue detection

**Usage:**
```bash
# Run all VTS tests
vts-tradefed run commandAndExit vts

# Run specific HAL test
vts-tradefed run commandAndExit vts -m VtsHalExampleV1_0Target

# Run with options
vts-tradefed run commandAndExit vts -m <module> --logcat-on-failure
```

### Debugging Workflow

#### Step 1: Identify the Problem

**Symptoms:**
- What is not working?
- When does it fail?
- Error messages?
- User impact?

**Information Gathering:**
- Collect logs
- Check service status
- Review error messages
- Understand context

#### Step 2: Check Service Registration

**Verification:**
```bash
# Check service exists
adb shell lshal | grep <hal_name>

# Check service is running
adb shell ps | grep <service_name>

# Check init script
adb shell cat /vendor/etc/init/<service>.rc
```

**Common Issues:**
- Service not registered
- Init script missing
- Service not starting
- Permission problems

#### Step 3: Verify Interface Compliance

**Verification:**
```bash
# Check manifest
adb shell cat /vendor/manifest.xml | grep <hal_name>

# Check interface version
adb shell lshal -l | grep <hal_name>

# Run VTS tests
vts-tradefed run commandAndExit vts -m VtsHal<Name>Target
```

**Common Issues:**
- Version mismatch
- Missing methods
- Interface not declared
- Stability issues

#### Step 4: Check Hardware Access

**Verification:**
```bash
# Check device nodes
adb shell ls -l /dev/ | grep <device>

# Check permissions
adb shell ls -Z /dev/<device>

# Check hardware state
adb shell dmesg | grep <device>
```

**Common Issues:**
- Device node missing
- Permission denied
- Hardware not initialized
- Driver problems

#### Step 5: Analyze Runtime Behavior

**Verification:**
```bash
# Check service logs
adb logcat | grep <service_name>

# Check for crashes
adb logcat | grep -i crash

# Monitor service
adb shell dumpsys <service_name>
```

**Common Issues:**
- Service crashes
- Method failures
- Resource leaks
- Thread issues

### Debugging Techniques

#### Logging

**Effective Logging:**
```cpp
#include <android-base/logging.h>

// Info logging
LOG(INFO) << "HAL method called: " << methodName;

// Debug logging
LOG(DEBUG) << "Parameter value: " << value;

// Error logging
LOG(ERROR) << "Operation failed: " << error;

// Conditional logging
if (verbose) {
    LOG(VERBOSE) << "Detailed information";
}
```

**Log Levels:**
- VERBOSE: Detailed debugging
- DEBUG: Debug information
- INFO: General information
- WARN: Warnings
- ERROR: Errors
- FATAL: Fatal errors

#### Breakpoint Debugging

**GDB Usage:**
```bash
# Attach to HAL service
adb shell gdb -p <pid>

# Set breakpoint
(gdb) break function_name

# Continue execution
(gdb) continue

# Inspect variables
(gdb) print variable_name

# Backtrace
(gdb) bt
```

**Remote Debugging:**
```bash
# Start gdbserver on device
adb shell gdbserver :1234 --attach <pid>

# Connect from host
gdb
(gdb) target remote <device_ip>:1234
```

#### Tracing

**Function Tracing:**
```bash
# Enable function tracing
adb shell echo function > /sys/kernel/debug/tracing/current_tracer

# Set trace filter
adb shell echo <function_name> > /sys/kernel/debug/tracing/set_ftrace_filter

# Start tracing
adb shell echo 1 > /sys/kernel/debug/tracing/tracing_on

# View trace
adb shell cat /sys/kernel/debug/tracing/trace
```

#### Memory Debugging

**Valgrind:**
```bash
# Run with Valgrind
valgrind --leak-check=full <hal_service>

# Check for memory leaks
valgrind --tool=memcheck <hal_service>
```

**AddressSanitizer:**
```cpp
// Enable in Android.bp
sanitize: {
    address: true,
}
```

### Common Debugging Scenarios

#### Scenario 1: Service Not Found

**Problem:**
- Framework can't find HAL service
- Service not in lshal output

**Debugging Steps:**
1. Check service registration
2. Verify init script
3. Check service name
4. Review logs

**Solution:**
```cpp
// Verify service registration
std::string serviceName = "android.hardware.example.IExample/default";
AServiceManager_addService(hal->asBinder().get(), serviceName.c_str());

// Check init script
service example-hal /vendor/bin/hw/android.hardware.example@1.0-service
    class hal
```

#### Scenario 2: Interface Mismatch

**Problem:**
- Method calls fail
- Version incompatibility

**Debugging Steps:**
1. Check interface version
2. Verify method signatures
3. Check manifest
4. Run VTS tests

**Solution:**
```aidl
// Ensure version matches
package android.hardware.example@1.0;

// Verify @VintfStability
@VintfStability
interface IExample {
    // Methods
}
```

#### Scenario 3: Hardware Access Failure

**Problem:**
- Can't access hardware
- Permission denied

**Debugging Steps:**
1. Check device node
2. Verify permissions
3. Check SELinux
4. Review hardware state

**Solution:**
```bash
# Fix permissions
adb shell chmod 666 /dev/<device>

# Check SELinux
adb shell getenforce
adb shell ls -Z /dev/<device>
```

#### Scenario 4: Service Crash

**Problem:**
- Service crashes on start
- Unexpected termination

**Debugging Steps:**
1. Check crash logs
2. Review backtrace
3. Check for null pointers
4. Verify resource allocation

**Solution:**
```cpp
// Add null checks
if (parameter == nullptr) {
    LOG(ERROR) << "Null parameter";
    return ::ndk::ScopedAStatus::fromExceptionCode(EX_NULL_POINTER);
}

// Check resource allocation
if (mResource == nullptr) {
    LOG(ERROR) << "Resource allocation failed";
    return ::ndk::ScopedAStatus::fromExceptionCode(EX_ILLEGAL_STATE);
}
```

### Debugging Best Practices

#### Systematic Approach

**Methodical Debugging:**
1. Reproduce the issue
2. Gather information
3. Identify root cause
4. Implement fix
5. Verify solution

**Documentation:**
- Document the issue
- Record debugging steps
- Note solutions
- Share knowledge

#### Effective Logging

**Logging Strategy:**
- Use appropriate log levels
- Include context information
- Log entry and exit points
- Log error conditions

**Log Format:**
```cpp
LOG(INFO) << "[" << __FUNCTION__ << "] "
          << "Method called with param=" << param;
```

#### Test-Driven Debugging

**Testing Approach:**
- Write test cases
- Reproduce issues in tests
- Verify fixes with tests
- Use VTS for validation

### Debugging Tools Summary

#### Command-Line Tools

**lshal:**
- List HAL services
- Check registration
- View service info

**dumpsys:**
- Dump service state
- Check service status
- View service data

**logcat:**
- View system logs
- Filter by tag
- Monitor runtime

**dmesg:**
- Kernel messages
- Hardware events
- Driver information

#### Testing Tools

**VTS:**
- Automated testing
- Compatibility validation
- Issue detection

**Manual Testing:**
- Direct HAL calls
- Test clients
- Framework integration

#### Development Tools

**GDB:**
- Breakpoint debugging
- Variable inspection
- Backtrace analysis

**Tracing:**
- Function tracing
- Performance analysis
- Call flow

**Memory Tools:**
- Valgrind
- AddressSanitizer
- Memory leak detection

## Key Takeaways

1. **HAL debugging** involves systematic troubleshooting of service registration, interface compliance, hardware access, and runtime behavior issues.

2. **Common HAL issues** include service not found, interface mismatches, hardware access failures, and runtime errors, each with specific symptoms and causes.

3. **Debugging tools** include lshal (list HALs), dumpsys (service state), logcat (system logs), VTS (automated testing), and GDB (breakpoint debugging).

4. **Debugging workflow** follows a systematic approach: identify problem, check service registration, verify interface compliance, check hardware access, and analyze runtime behavior.

5. **Effective logging** uses appropriate log levels, includes context information, and logs entry/exit points and error conditions for better debugging.

6. **Common debugging scenarios** include service not found, interface mismatch, hardware access failure, and service crashes, each with specific debugging steps and solutions.

7. **Debugging best practices** include systematic approach, effective logging, test-driven debugging, and proper documentation of issues and solutions.

8. **Understanding HAL debugging** is essential for troubleshooting HAL implementations, ensuring compatibility, validating functionality, and maintaining reliable hardware interfaces in AOSP.

## Related Topics

- **Creating your own HAL:** HAL development workflow
- **VTS (Vendor Test Suite):** Automated HAL testing
- **AIDL-based HALs:** Modern HAL implementation
- **Common HAL implementations:** Lights, GPS, Bluetooth HALs

