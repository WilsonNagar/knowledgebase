---
number: 58
title: BpBinder & BBinder
slug: bpbinder-bbinder
level: intermediate
tags:
  - aosp
  - binder
  - bpbinder
  - bbinder
  - proxy
  - native
  - ipc
  - libbinder
prerequisites:
  - binder-architecture
  - binder-driver-internals
  - binder-ipc-basics
estimated_minutes: 85
contributors: []
diagrams: []
examples: []
canonical_id: aosp-intermediate-58
---

# BpBinder & BBinder

## Overview

BpBinder (Binder Proxy) and BBinder (Binder Base) are the core native C++ classes in Android's Binder IPC system. BpBinder represents a remote Binder object on the client side, while BBinder is the base class for local Binder objects on the server side. Understanding BpBinder and BBinder is essential for AOSP development, as they form the foundation of all Binder IPC, handle transaction marshaling and unmarshaling, and bridge the gap between application code and the Binder driver. This guide provides a comprehensive overview of BpBinder, BBinder, their roles, implementation, and how they work together to enable IPC.

Think of BpBinder and BBinder like a phone system: BpBinder is like the phone on your desk (the client side) - when you dial a number, it connects you to the remote phone. BBinder is like the phone at the destination (the server side) - it receives your call and connects you to the person you want to talk to. Together, they enable communication between two parties (processes) that can't directly see each other.

## Deep Explanation

### What are BpBinder and BBinder?

**BpBinder (Binder Proxy):**
- Client-side representation of remote Binder object
- Proxy pattern implementation
- Marshals transactions and sends to driver
- Unmarshals replies from driver
- C++ class in libbinder

**BBinder (Binder Base):**
- Base class for server-side Binder objects
- Receives transactions from driver
- Unmarshals parameters
- Calls implementation methods
- Marshals replies
- C++ class in libbinder

**Relationship:**
- BpBinder represents BBinder in remote process
- They communicate through Binder driver
- Client uses BpBinder, server uses BBinder
- Together enable transparent IPC

### BpBinder (Binder Proxy)

#### What is BpBinder?

BpBinder is a proxy object that represents a remote Binder object in the client process. It makes remote calls look like local method calls.

**Key Characteristics:**
- **Proxy Pattern:** Represents remote object locally
- **Client Side:** Used by clients
- **Handle-Based:**** Identified by Binder handle
- **Transaction Sender:** Sends transactions to driver

**Why BpBinder?**
- **Transparency:** Remote calls look local
- **Abstraction:** Hides IPC complexity
- **Efficiency:** Optimized transaction handling
- **Type Safety:** Works with AIDL interfaces

#### BpBinder Implementation

**Class Structure:**
```cpp
class BpBinder : public IBinder {
public:
    BpBinder(int32_t handle, bool isRemote);
    virtual ~BpBinder();
    
    virtual status_t transact(
        uint32_t code,
        const Parcel& data,
        Parcel* reply,
        uint32_t flags);
    
    int32_t handle() const { return mHandle; }
    
private:
    const int32_t mHandle;  // Binder handle
    mutable Mutex mLock;
    // ... more fields
};
```

**Key Members:**
- `mHandle` - Binder handle (descriptor)
- Transaction methods
- Reference counting
- Lifecycle management

#### BpBinder Usage

**Creating BpBinder:**
```cpp
// From Binder handle
sp<IBinder> binder = new BpBinder(handle);

// From service lookup
sp<IServiceManager> sm = defaultServiceManager();
sp<IBinder> binder = sm->getService(String16("service_name"));
sp<IMyService> service = interface_cast<IMyService>(binder);
```

**Transaction Flow:**
```
1. Client calls method on BpBinder
   ↓
2. BpBinder.transact() called
   ↓
3. Marshals parameters to Parcel
   ↓
4. Sends transaction to Binder driver
   ↓
5. Waits for reply
   ↓
6. Unmarshals reply from Parcel
   ↓
7. Returns result to caller
```

#### BpBinder transact() Method

**transact() Implementation:**
```cpp
status_t BpBinder::transact(
    uint32_t code,
    const Parcel& data,
    Parcel* reply,
    uint32_t flags) {
    
    // Get IPC thread state
    IPCThreadState* ipc = IPCThreadState::self();
    
    // Send transaction
    status_t status = ipc->transact(mHandle, code, data, reply, flags);
    
    return status;
}
```

**Parameters:**
- `code` - Transaction code (method identifier)
- `data` - Input Parcel (marshaled parameters)
- `reply` - Output Parcel (marshaled return value)
- `flags` - Transaction flags (e.g., FLAG_ONEWAY)

**Return Value:**
- `NO_ERROR` - Success
- Error codes on failure

### BBinder (Binder Base)

#### What is BBinder?

BBinder is the base class for server-side Binder objects. It receives transactions from the Binder driver and routes them to the appropriate handler.

**Key Characteristics:**
- **Base Class:** Extended by service implementations
- **Server Side:** Used by servers
- **Transaction Receiver:** Receives transactions from driver
- **onTransact() Handler:** Processes transactions

**Why BBinder?**
- **Base Implementation:** Common transaction handling
- **Lifecycle Management:** Handles object lifecycle
- **Transaction Routing:** Routes to onTransact()
- **Standard Interface:** Consistent API

#### BBinder Implementation

**Class Structure:**
```cpp
class BBinder : public IBinder {
public:
    BBinder();
    virtual ~BBinder();
    
    virtual status_t transact(
        uint32_t code,
        const Parcel& data,
        Parcel* reply,
        uint32_t flags);
    
protected:
    virtual status_t onTransact(
        uint32_t code,
        const Parcel& data,
        Parcel* reply,
        uint32_t flags) = 0;
    
    // ... more methods
};
```

**Key Methods:**
- `transact()` - Receives transaction from driver
- `onTransact()` - Abstract method, implemented by subclasses
- Lifecycle methods
- Reference counting

#### BBinder Usage

**Extending BBinder:**
```cpp
class MyService : public BBinder {
protected:
    virtual status_t onTransact(
        uint32_t code,
        const Parcel& data,
        Parcel* reply,
        uint32_t flags) override {
        
        switch (code) {
            case TRANSACTION_doSomething: {
                data.enforceInterface(DESCRIPTOR);
                // Unmarshal parameters
                String16 param = data.readString16();
                // Call implementation
                String16 result = doSomething(param);
                // Marshal reply
                reply->writeString16(result);
                return NO_ERROR;
            }
            default:
                return BBinder::onTransact(code, data, reply, flags);
        }
    }
    
private:
    String16 doSomething(const String16& param) {
        // Implementation
        return String16("Result");
    }
};
```

**Transaction Flow:**
```
1. Binder driver delivers transaction
   ↓
2. BBinder.transact() called
   ↓
3. Calls onTransact() with transaction code
   ↓
4. onTransact() unmarshals parameters
   ↓
5. Calls implementation method
   ↓
6. Marshals return value to reply
   ↓
7. Returns to driver
```

### BpBinder vs BBinder

#### Key Differences

**BpBinder (Client):**
- Represents remote object
- Sends transactions
- Marshals before send
- Unmarshals after receive
- Handle-based

**BBinder (Server):**
- Represents local object
- Receives transactions
- Unmarshals before process
- Marshals after process
- Object-based

#### Communication Flow

**Complete Flow:**
```
Client Process              Server Process
     │                           │
     │  BpBinder                 │  BBinder
     │                           │
     │  transact()                │
     │      │                     │
     │      │───Transaction───────▶│
     │      │   (via driver)       │  transact()
     │      │                     │      │
     │      │                     │      ▼
     │      │                     │  onTransact()
     │      │                     │      │
     │      │                     │      ▼
     │      │                     │  Implementation
     │      │                     │      │
     │      │◀────Reply──────────│
     │      │   (via driver)      │
     │      │                     │
     ▼      ▼                     ▼
```

### Interface Casting

#### interface_cast

**What It Is:**
- Template function for casting IBinder to interface
- Creates appropriate proxy or returns local object
- Type-safe interface conversion
- Used extensively in Binder code

**Usage:**
```cpp
// Get Binder from ServiceManager
sp<IBinder> binder = sm->getService(String16("my_service"));

// Cast to interface
sp<IMyService> service = interface_cast<IMyService>(binder);
if (service != nullptr) {
    // Use service
    service->doSomething();
}
```

**Implementation:**
```cpp
template<typename INTERFACE>
inline sp<INTERFACE> interface_cast(const sp<IBinder>& obj) {
    return INTERFACE::asInterface(obj);
}
```

#### asInterface() Pattern

**AIDL Generated Code:**
```cpp
// Generated in AIDL interface
static sp<IMyService> asInterface(const sp<IBinder>& obj) {
    if (obj == nullptr) {
        return nullptr;
    }
    
    // Check if local
    sp<IInterface> iin = obj->queryLocalInterface(DESCRIPTOR);
    if (iin != nullptr) {
        return static_cast<IMyService*>(iin.get());
    }
    
    // Remote - create proxy
    return new BpMyService(obj);
}
```

**Logic:**
1. Check if null
2. Query for local interface
3. If local, cast and return
4. If remote, create BpBinder proxy

### Reference Counting

#### Lifecycle Management

**BpBinder Reference Counting:**
- Strong references keep object alive
- Weak references don't keep alive
- Automatic cleanup on last reference
- Handles process death

**BBinder Reference Counting:**
- Similar reference counting
- Tracks references from clients
- Cleans up when no references
- Handles object lifecycle

#### Reference Operations

**Strong References:**
```cpp
sp<IBinder> binder = new BpBinder(handle);  // Strong ref
// Binder kept alive
binder = nullptr;  // Release ref, may be destroyed
```

**Weak References:**
```cpp
wp<IBinder> weakBinder = binder;  // Weak ref
sp<IBinder> strongBinder = weakBinder.promote();  // Promote to strong
```

### Transaction Marshaling

#### BpBinder Marshaling

**Client Side:**
```cpp
// Marshaling in BpBinder
Parcel data;
data.writeInterfaceToken(DESCRIPTOR);
data.writeString16(param);
data.writeInt32(value);

Parcel reply;
status_t status = transact(TRANSACTION_doSomething, data, &reply, 0);

if (status == NO_ERROR) {
    String16 result = reply.readString16();
}
```

**Process:**
1. Create Parcel
2. Write interface token
3. Write parameters
4. Call transact()
5. Read reply

#### BBinder Unmarshaling

**Server Side:**
```cpp
// Unmarshaling in BBinder
status_t onTransact(uint32_t code, const Parcel& data, Parcel* reply, uint32_t flags) {
    data.enforceInterface(DESCRIPTOR);
    String16 param = data.readString16();
    int32_t value = data.readInt32();
    
    // Call implementation
    String16 result = doSomething(param, value);
    
    // Marshal reply
    reply->writeString16(result);
    return NO_ERROR;
}
```

**Process:**
1. Enforce interface token
2. Read parameters
3. Call implementation
4. Write reply
5. Return status

### Error Handling

#### Transaction Errors

**Common Errors:**
- `DEAD_OBJECT` - Remote process died
- `BAD_TYPE` - Invalid transaction type
- `FAILED_TRANSACTION` - Transaction failed
- `TIMEOUT` - Transaction timeout

**Error Handling:**
```cpp
status_t status = binder->transact(code, data, &reply, flags);
if (status != NO_ERROR) {
    // Handle error
    if (status == DEAD_OBJECT) {
        // Process died, handle gracefully
    }
}
```

#### Process Death Handling

**Death Recipients:**
```cpp
class DeathRecipient : public IBinder::DeathRecipient {
    virtual void binderDied(const wp<IBinder>& who) {
        // Handle death
    }
};

sp<DeathRecipient> recipient = new DeathRecipient();
binder->linkToDeath(recipient, nullptr, 0);
```

**Death Notification:**
- Kernel detects process death
- Notifies death recipients
- Clients can handle gracefully
- Clean up resources

### Performance Considerations

#### Transaction Optimization

**Minimize Transactions:**
- Batch operations when possible
- Use oneway for notifications
- Cache service references
- Avoid frequent small calls

**Efficient Marshaling:**
- Use appropriate Parcel methods
- Minimize data size
- Reuse Parcel objects
- Optimize serialization

#### Memory Management

**Parcel Reuse:**
```cpp
// Reuse Parcel
Parcel data;
Parcel reply;

// Multiple transactions
for (int i = 0; i < 10; i++) {
    data.setDataPosition(0);
    data.writeInt32(i);
    binder->transact(CODE, data, &reply, 0);
}
```

**Buffer Management:**
- Parcel manages buffers
- Automatic allocation
- Efficient memory use
- Reuse when possible

### Integration with AIDL

#### AIDL Proxy Generation

**Generated BpBinder Usage:**
```cpp
// AIDL generates BpMyService
class BpMyService : public BpInterface<IMyService> {
public:
    BpMyService(const sp<IBinder>& impl)
        : BpInterface<IMyService>(impl) {}
    
    virtual String16 doSomething(const String16& param) {
        Parcel data, reply;
        data.writeInterfaceToken(IMyService::getInterfaceDescriptor());
        data.writeString16(param);
        remote()->transact(TRANSACTION_doSomething, data, &reply, 0);
        return reply.readString16();
    }
};
```

#### AIDL Stub Generation

**Generated BBinder Usage:**
```cpp
// AIDL generates BnMyService
class BnMyService : public BnInterface<IMyService> {
public:
    virtual status_t onTransact(
        uint32_t code,
        const Parcel& data,
        Parcel* reply,
        uint32_t flags) {
        
        switch (code) {
            case TRANSACTION_doSomething: {
                data.enforceInterface(getInterfaceDescriptor());
                String16 param = data.readString16();
                String16 result = doSomething(param);
                reply->writeString16(result);
                return NO_ERROR;
            }
        }
        return BBinder::onTransact(code, data, reply, flags);
    }
};
```

### Debugging BpBinder & BBinder

#### Common Issues

**Null Binder:**
- Service not found
- Process died
- Check service registration
- Verify service availability

**Transaction Failures:**
- Check error codes
- Verify marshaling
- Review transaction data
- Check permissions

**Reference Leaks:**
- Objects not released
- Circular references
- Check reference counts
- Use weak references

#### Debugging Tools

**Binder State:**
```bash
# View Binder state
adb shell dumpsys binder
```

**Transaction Tracing:**
- Enable Binder tracing
- Log transactions
- Analyze transaction flow
- Identify bottlenecks

## Key Takeaways

1. **BpBinder is the client-side proxy** that represents remote Binder objects and sends transactions to the Binder driver.

2. **BBinder is the server-side base class** that receives transactions from the Binder driver and routes them to implementation methods via onTransact().

3. **BpBinder and BBinder work together** through the Binder driver to enable transparent IPC, making remote calls look like local method calls.

4. **interface_cast() provides type-safe conversion** from IBinder to specific interfaces, creating BpBinder proxies for remote objects.

5. **Transaction marshaling happens in BpBinder** (client side) and unmarshaling happens in BBinder (server side) using Parcel objects.

6. **Reference counting manages object lifecycle** for both BpBinder and BBinder, with automatic cleanup when references are released.

7. **AIDL generates code that uses BpBinder and BBinder** - proxies extend BpBinder functionality, stubs extend BBinder functionality.

8. **Understanding BpBinder and BBinder** is essential for AOSP development, debugging IPC issues, and understanding how Binder IPC works at the native level.

## Related Topics

- **Binder architecture:** How BpBinder and BBinder fit into overall architecture
- **Binder driver internals:** How transactions flow through the driver
- **transact(), onTransact():** The transaction methods used by BpBinder and BBinder
- **AIDL:** How AIDL generates code that uses BpBinder and BBinder

