---
number: 81
title: AOT & JIT compilation
slug: aot-jit-compilation
level: intermediate
tags:
  - aosp
  - art
  - aot
  - jit
  - compilation
  - optimization
  - runtime
prerequisites:
  - dalvik-vs-art
  - dex2oat
estimated_minutes: 90
contributors: []
diagrams: []
examples: []
canonical_id: aosp-intermediate-81
---

# AOT & JIT compilation

## Overview

AOT (Ahead-Of-Time) and JIT (Just-In-Time) compilation are two compilation strategies used by ART (Android Runtime) to convert DEX bytecode into native code. Understanding AOT and JIT compilation is essential for AOSP development, as it explains how Android applications are compiled, when compilation occurs, the trade-offs between compilation strategies, and how ART uses a hybrid approach to balance installation time and runtime performance. This guide provides a comprehensive overview of AOT and JIT compilation, their characteristics, use cases, the hybrid approach, and profile-guided optimization.

Think of AOT vs JIT like preparing food: AOT is like meal prep where you cook everything in advance (compile at install time) - it takes time upfront but food is ready instantly when needed. JIT is like cooking on demand - you start with raw ingredients (DEX bytecode) and cook (compile) only what's needed when it's needed, which is faster to start but takes time during execution. ART uses a hybrid approach - prepare the most common meals (hot methods) in advance, and cook others on demand.

## Deep Explanation

### What are AOT and JIT Compilation?

AOT (Ahead-Of-Time) and JIT (Just-In-Time) are two compilation strategies for converting DEX bytecode into native machine code, differing in when compilation occurs.

**Key Characteristics:**
- **AOT:** Compiles before execution (install time)
- **JIT:** Compiles during execution (runtime)
- **Both:** Convert DEX to native code
- **Purpose:** Improve performance

**Why Two Strategies?**
- **Trade-offs:** Different benefits and costs
- **Flexibility:** Adapt to different scenarios
- **Optimization:** Balance installation vs runtime
- **Performance:** Optimize for different use cases

### AOT (Ahead-Of-Time) Compilation

#### What is AOT?

AOT compilation compiles DEX bytecode to native code before the app runs, typically during installation or first launch.

**Key Characteristics:**
- **Pre-compilation:** Compiles before execution
- **Full Compilation:** Compiles entire app
- **Native Code:** Creates OAT files
- **Install Time:** Compilation during installation

**When AOT Happens:**
- During app installation
- During first app launch
- During system build (system apps)
- Background compilation (Android 7.0+)

#### AOT Process

**Compilation Flow:**
```
App Installation
     │
     ▼
DEX Extraction
     │
     ▼
dex2oat Execution
     │
     ▼
DEX → Native Code
     │
     ▼
OAT File Creation
     │
     ▼
App Ready
```

**Process Steps:**
1. APK installed
2. DEX files extracted
3. dex2oat compiler runs
4. DEX bytecode compiled to native code
5. OAT file created
6. App ready to run

#### AOT Benefits

**Performance:**
- Native code execution
- No interpretation overhead
- Consistent performance
- Fast execution

**Startup:**
- Pre-compiled code ready
- Fast app startup
- No compilation delay
- Immediate performance

**Battery:**
- Less CPU usage
- No runtime compilation
- Efficient execution
- Better battery life

#### AOT Drawbacks

**Installation Time:**
- Longer installation
- Compilation overhead
- User waits longer
- Storage space needed

**Storage:**
- Larger OAT files
- Native code larger than DEX
- More storage required
- ~2-3x DEX size

**Flexibility:**
- Can't optimize based on runtime
- Static optimization only
- Less adaptive
- Fixed at install time

### JIT (Just-In-Time) Compilation

#### What is JIT?

JIT compilation compiles DEX bytecode to native code during app execution, compiling only methods that are frequently executed (hot methods).

**Key Characteristics:**
- **Runtime Compilation:** Compiles during execution
- **Selective Compilation:** Compiles hot methods only
- **Adaptive:** Optimizes based on usage
- **On-Demand:** Compiles when needed

**When JIT Happens:**
- During app execution
- When method becomes hot
- Based on execution profile
- Continuous optimization

#### JIT Process

**Compilation Flow:**
```
App Execution
     │
     ▼
DEX Interpretation
     │
     ▼
Method Execution Count
     │
     ▼
Hot Method Detection
     │
     ▼
JIT Compilation
     │
     ▼
Native Code (cached)
     │
     ▼
Future Calls Use Native Code
```

**Process Steps:**
1. App starts (interpreted)
2. Methods executed (interpreted)
3. Execution count tracked
4. Hot methods identified
5. Hot methods compiled
6. Compiled code cached
7. Future calls use native code

#### JIT Benefits

**Installation:**
- Fast installation
- No compilation during install
- Quick app availability
- Better user experience

**Adaptive:**
- Optimizes based on actual usage
- Compiles only hot code
- Profile-guided optimization
- Better optimization

**Storage:**
- Smaller storage footprint
- Only compiles hot methods
- DEX remains primary
- Efficient storage

#### JIT Drawbacks

**Runtime Overhead:**
- Compilation during execution
- CPU usage for compilation
- Performance impact
- Battery usage

**Warm-up Time:**
- Performance improves over time
- Initial execution slower
- Compilation delay
- Gradual optimization

**Inconsistent Performance:**
- Variable performance
- Depends on execution pattern
- May not compile all code
- Less predictable

### Hybrid Approach (Android 7.0+)

#### What is Hybrid Compilation?

Hybrid compilation combines AOT and JIT, using JIT initially and then performing AOT compilation of hot methods based on execution profiles.

**Key Characteristics:**
- **JIT Initially:** Fast installation
- **Profile Collection:** Track hot methods
- **Background AOT:** Compile hot methods
- **Best of Both:** Combines benefits

**Why Hybrid?**
- **Fast Installation:** No AOT during install
- **Optimized Hot Code:** AOT for frequently used methods
- **Adaptive:** Profile-guided optimization
- **Balanced:** Good performance and installation time

#### Hybrid Process

**Complete Flow:**
```
App Installation (Fast)
     │
     ▼
App Runs (JIT)
     │
     ▼
Profile Collection
     │
     ▼
Hot Methods Identified
     │
     ▼
Background AOT Compilation
     │
     ▼
Next Launch Uses Compiled Code
```

**Process Steps:**
1. App installed (no AOT, fast)
2. App runs (interpreted initially)
3. JIT compiles hot methods
4. Profile collected (method usage)
5. Background AOT compilation
6. Hot methods compiled to OAT
7. Next launch uses compiled code

#### Profile-Guided Optimization

**What is PGO?**
- Profile execution patterns
- Identify hot methods
- Optimize based on profile
- Better optimization

**Profile Data:**
- Method call counts
- Execution frequency
- Hot method list
- Usage patterns

**Optimization:**
- Compile hot methods with AOT
- Aggressive optimization for hot code
- Less optimization for cold code
- Better overall performance

### Comparison

#### Installation Time

**AOT:**
- Longer installation
- Compilation during install
- User waits
- Slower availability

**JIT:**
- Fast installation
- No compilation during install
- Quick availability
- Better user experience

**Hybrid:**
- Fast installation
- No AOT during install
- Quick availability
- Best installation time

#### Runtime Performance

**AOT:**
- Consistent performance
- Native code ready
- Fast execution
- Predictable

**JIT:**
- Improves over time
- Variable performance
- Warm-up period
- Adaptive

**Hybrid:**
- Good performance
- Hot code optimized
- Fast execution
- Balanced performance

#### Storage Usage

**AOT:**
- Larger storage
- Full app compiled
- OAT files large
- More storage needed

**JIT:**
- Smaller storage
- Only hot methods compiled
- DEX primary format
- Efficient storage

**Hybrid:**
- Moderate storage
- Hot methods compiled
- Efficient storage
- Balanced storage

#### Battery Life

**AOT:**
- Better battery life
- No runtime compilation
- Efficient execution
- Less CPU usage

**JIT:**
- More battery usage
- Runtime compilation overhead
- CPU usage for compilation
- More power consumption

**Hybrid:**
- Good battery life
- Background compilation
- Efficient execution
- Balanced battery usage

### Compilation Strategies by Android Version

#### Android 5.0-6.0 (Lollipop-Marshmallow)

**Pure AOT:**
- AOT compilation only
- Full app compilation
- Long installation
- Best performance

**Characteristics:**
- Compile entire app
- Create OAT files
- No JIT
- Maximum optimization

#### Android 7.0+ (Nougat and later)

**Hybrid AOT+JIT:**
- JIT initially
- Profile collection
- Background AOT
- Best of both

**Characteristics:**
- Fast installation
- JIT for hot methods
- Profile-guided optimization
- Background compilation

### Compiler Filters and Strategies

#### AOT Compiler Filters

**speed:**
- Maximum optimization
- Best performance
- Longer compilation
- Used for: System apps

**balanced:**
- Balanced optimization
- Good performance
- Moderate compilation
- Used for: User apps

**quicken:**
- Quick compilation
- Minimal optimization
- Fast compilation
- Used for: Fast installation

#### JIT Compilation Thresholds

**Hot Method Detection:**
- Method call count
- Execution frequency
- Threshold-based
- Adaptive thresholds

**Compilation Triggers:**
- Call count threshold
- Loop execution count
- Method complexity
- Profile data

### Best Practices

#### For Developers

**Code Optimization:**
- Write efficient code
- Optimize hot paths
- Profile and optimize
- Minimize allocations

**Performance:**
- Consider compilation impact
- Profile app execution
- Optimize critical paths
- Monitor performance

#### For System Builders

**System Apps:**
- Use AOT with speed filter
- Pre-compile during build
- Optimize for performance
- Include in boot image

**User Apps:**
- Use hybrid approach
- Fast installation
- Profile-guided optimization
- Balance performance

## Key Takeaways

1. **AOT (Ahead-Of-Time) compilation** compiles DEX bytecode to native code before execution (install time), providing consistent performance but longer installation time.

2. **JIT (Just-In-Time) compilation** compiles DEX bytecode to native code during execution (runtime), providing fast installation but requiring warm-up time and runtime compilation overhead.

3. **Hybrid approach (Android 7.0+)** combines AOT and JIT: fast installation with JIT initially, profile collection to identify hot methods, and background AOT compilation of hot methods.

4. **AOT benefits** include native code execution, fast startup, consistent performance, and better battery life, but with longer installation time and larger storage requirements.

5. **JIT benefits** include fast installation, adaptive optimization, smaller storage, and profile-guided optimization, but with runtime compilation overhead and warm-up time.

6. **Profile-guided optimization** uses execution profiles to identify hot methods and optimize them with AOT, providing better overall performance than pure AOT or JIT.

7. **Android evolution** moved from pure AOT (Android 5.0-6.0) to hybrid AOT+JIT (Android 7.0+) for better balance between installation time and runtime performance.

8. **Understanding AOT and JIT compilation** is essential for AOSP development, explaining how Android applications are compiled, when compilation occurs, and the trade-offs between different compilation strategies.

## Related Topics

- **dex2oat:** ART's AOT compiler implementation
- **OAT & VDEX files:** Compilation output formats
- **Dalvik vs ART:** Runtime evolution and compilation models
- **Garbage collectors:** Runtime memory management

