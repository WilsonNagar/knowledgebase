---
number: 95
title: 'AddressSanitizer, HWASan in Android'
slug: addresssanitizer-hwasan-in-android
level: intermediate
tags:
  - aosp
  - native
  - sanitizers
  - addresssanitizer
  - hwasan
  - memory-safety
  - debugging
prerequisites:
  - building-native-system-components
  - debugging-native-crashes-tombstones
estimated_minutes: 90
contributors: []
diagrams: []
examples: []
canonical_id: aosp-intermediate-95
---

# AddressSanitizer, HWASan in Android

## Overview

AddressSanitizer (ASan) and HWAddressSanitizer (HWASan) are memory error detection tools that help identify memory bugs in native C/C++ code at runtime. Understanding AddressSanitizer and HWASan in Android is essential for AOSP development, as it explains how to detect memory errors, how to enable sanitizers in Android builds, how sanitizers work, what types of errors they detect, and how to use them for debugging and testing. This guide provides a comprehensive overview of AddressSanitizer and HWASan, their usage in Android, build configuration, error detection, and best practices.

Think of AddressSanitizer and HWASan like security cameras for memory: just as security cameras monitor and detect unauthorized access, sanitizers monitor memory access and detect unauthorized or invalid memory operations (buffer overflows, use-after-free, etc.). They catch memory bugs that might otherwise go undetected until they cause crashes or security vulnerabilities.

## Deep Explanation

### What are AddressSanitizer and HWASan?

AddressSanitizer (ASan) and HWAddressSanitizer (HWASan) are compile-time instrumentation tools that detect memory errors in native C/C++ code at runtime, helping identify bugs like buffer overflows, use-after-free, and memory leaks.

**Key Characteristics:**
- **Runtime Detection:** Detects errors during execution
- **Instrumentation:** Code instrumentation at compile time
- **Memory Safety:** Detects memory safety violations
- **Debugging Tool:** Development and testing tool

**Why Sanitizers?**
- **Bug Detection:** Find memory bugs early
- **Security:** Prevent security vulnerabilities
- **Quality:** Improve code quality
- **Debugging:** Easier debugging

### AddressSanitizer (ASan)

#### What is AddressSanitizer?

AddressSanitizer is a fast memory error detector that uses compile-time instrumentation and a runtime library to detect memory errors like buffer overflows, use-after-free, and use of uninitialized memory.

**Key Characteristics:**
- **Fast:** ~2x slowdown
- **Comprehensive:** Detects many error types
- **Precise:** Pinpoints error location
- **Widely Used:** Industry standard

**Detected Errors:**
- Buffer overflow (heap, stack, global)
- Use-after-free
- Use of uninitialized memory
- Double-free
- Memory leaks (with LeakSanitizer)

#### How AddressSanitizer Works

**Instrumentation:**
```
Original Code:
  *ptr = 10;

Instrumented Code:
  if (is_poisoned(ptr)) {
    report_error();
  }
  *ptr = 10;
```

**Shadow Memory:**
- Maps each byte to shadow byte
- Tracks memory state
- Detects invalid access
- Fast lookup

**Memory Layout:**
```
Application Memory
  ↓
Shadow Memory (1/8 of app memory)
  ↓
Error Detection
```

#### ASan Overhead

**Performance Impact:**
- ~2x slowdown
- ~2-3x memory overhead
- Acceptable for debugging
- Not for production

**Memory Overhead:**
- Shadow memory: 1/8 of application memory
- Red zones: Extra memory around allocations
- Quarantine: Delayed free for use-after-free detection

### HWAddressSanitizer (HWASan)

#### What is HWAddressSanitizer?

HWAddressSanitizer is a hardware-assisted memory error detector that uses ARM's Memory Tagging Extension (MTE) to detect memory errors with lower overhead than AddressSanitizer.

**Key Characteristics:**
- **Hardware-Assisted:** Uses MTE
- **Lower Overhead:** ~1.5x slowdown
- **Tag-Based:** Memory tagging
- **ARM64 Only:** Requires MTE support

**Detected Errors:**
- Buffer overflow
- Use-after-free
- Similar to ASan
- Hardware-accelerated

#### How HWASan Works

**Memory Tagging:**
- Each memory location has tag
- Pointer stores tag
- Tag mismatch = error
- Hardware-accelerated

**Tag Management:**
```
Allocation: Memory tagged with unique tag
Pointer: Stores tag in top byte
Access: Hardware checks tag match
Mismatch: Hardware trap → error report
```

**Hardware Support:**
- ARM Memory Tagging Extension (MTE)
- ARM64 architecture
- Hardware-accelerated checks
- Lower overhead

### Enabling Sanitizers in Android

#### Build Configuration

**Android.bp Configuration:**
```blueprint
cc_library_shared {
    name: "libmymodule",
    srcs: ["src/file.cpp"],
    
    // Enable AddressSanitizer
    sanitize: {
        address: true,
    },
}
```

**Sanitizer Options:**
- `address: true` - AddressSanitizer
- `hwaddress: true` - HWAddressSanitizer
- `thread: true` - ThreadSanitizer
- `undefined: true` - UndefinedBehaviorSanitizer

#### Build Commands

**Building with Sanitizers:**
```bash
# Build with ASan
SANITIZE_TARGET=address m libmymodule

# Build with HWASan
SANITIZE_TARGET=hwaddress m libmymodule

# Build with multiple sanitizers
SANITIZE_TARGET="address,undefined" m libmymodule
```

**Global Build:**
```bash
# Enable for all modules
export SANITIZE_TARGET=address
m
```

### Error Detection

#### Buffer Overflow Detection

**Heap Buffer Overflow:**
```c
char* buffer = malloc(10);
buffer[15] = 'x';  // ASan detects: heap-buffer-overflow
```

**ASan Report:**
```
==12345==ERROR: AddressSanitizer: heap-buffer-overflow
WRITE of size 1 at 0x...
    #0 0x... in function_name file.cpp:123
    #1 0x... in caller_function file.cpp:456
```

**Stack Buffer Overflow:**
```c
char buffer[10];
buffer[15] = 'x';  // ASan detects: stack-buffer-overflow
```

#### Use-After-Free Detection

**Use-After-Free:**
```c
void* ptr = malloc(100);
free(ptr);
*ptr = 10;  // ASan detects: use-after-free
```

**ASan Report:**
```
==12345==ERROR: AddressSanitizer: use-after-free
WRITE of size 4 at 0x...
    #0 0x... in function_name file.cpp:123
    #1 0x... in caller_function file.cpp:456
```

#### Null Pointer Dereference

**Null Pointer:**
```c
void* ptr = NULL;
*ptr = 10;  // ASan detects: null-pointer-dereference
```

**ASan Report:**
```
==12345==ERROR: AddressSanitizer: null-pointer-dereference
WRITE of size 4 at 0x...
    #0 0x... in function_name file.cpp:123
```

### Sanitizer Reports

#### Report Format

**ASan Report Structure:**
```
==PID==ERROR: AddressSanitizer: error-type
operation of size N at address 0x...
    #0 0x... in function_name file.cpp:line
    #1 0x... in caller_function file.cpp:line
    ...
SUMMARY: AddressSanitizer: error-type
```

**Report Components:**
- Error type
- Operation (READ/WRITE)
- Address
- Stack trace
- Summary

#### Report Analysis

**Reading Reports:**
1. Identify error type
2. Locate error address
3. Analyze stack trace
4. Find source location
5. Understand context

**Example Analysis:**
```
ERROR: AddressSanitizer: heap-buffer-overflow
WRITE of size 1 at 0x7fe1234567
    #0 0x12345 in process_data file.cpp:123
      buffer[i] = value;  // Line 123
    #1 0x67890 in main file.cpp:456
      process_data(data, size);  // Line 456
```

### Sanitizer Configuration

#### Runtime Options

**Environment Variables:**
```bash
# Enable ASan
export ASAN_OPTIONS=detect_leaks=1:abort_on_error=1

# ASan options
ASAN_OPTIONS=help=1  # Show options
ASAN_OPTIONS=verbosity=1  # Verbose output
ASAN_OPTIONS=log_path=/sdcard/asan  # Log file
```

**Common Options:**
- `detect_leaks=1` - Enable leak detection
- `abort_on_error=1` - Abort on error
- `verbosity=1` - Verbose output
- `log_path=...` - Log file path

#### Leak Detection

**LeakSanitizer:**
```bash
# Enable leak detection
export ASAN_OPTIONS=detect_leaks=1

# Run application
./myapp
```

**Leak Report:**
```
==12345==ERROR: LeakSanitizer: detected memory leaks
Direct leak of 100 bytes in 1 object
    #0 0x... in malloc
    #1 0x... in function_name file.cpp:123
```

### HWASan in Android

#### MTE Requirements

**Hardware Requirements:**
- ARM64 architecture
- Memory Tagging Extension (MTE)
- Android 11+ (for HWASan support)
- MTE-enabled kernel

**Software Requirements:**
- MTE-enabled kernel
- HWASan runtime
- HWASan-instrumented code
- Compatible toolchain

#### HWASan Configuration

**Build Configuration:**
```blueprint
cc_library_shared {
    name: "libmymodule",
    srcs: ["src/file.cpp"],
    
    // Enable HWASan
    sanitize: {
        hwaddress: true,
    },
}
```

**Build Command:**
```bash
SANITIZE_TARGET=hwaddress m libmymodule
```

### Comparison

#### ASan vs HWASan

**Performance:**
- ASan: ~2x slowdown
- HWASan: ~1.5x slowdown
- HWASan faster

**Memory:**
- ASan: ~2-3x memory overhead
- HWASan: Lower memory overhead
- HWASan more efficient

**Hardware:**
- ASan: Works on all architectures
- HWASan: ARM64 with MTE only
- ASan more portable

**Detection:**
- Both detect similar errors
- Both provide stack traces
- Both precise error location

### Best Practices

#### When to Use

**Development:**
- Use during development
- Enable in debug builds
- Test with sanitizers
- Fix detected issues

**Testing:**
- Run test suites with sanitizers
- Continuous testing
- Regression testing
- Quality assurance

**Production:**
- Not recommended (overhead)
- May use in special cases
- Performance impact
- Memory overhead

#### Integration

**CI/CD Integration:**
- Run tests with sanitizers
- Automated error detection
- Early bug detection
- Quality gates

**Build Configuration:**
- Enable for debug builds
- Disable for release builds
- Conditional compilation
- Build variants

### Limitations

#### Performance Impact

**Overhead:**
- Slower execution
- Higher memory usage
- Not for production
- Development/testing only

#### False Positives

**Potential Issues:**
- May report false positives
- Requires investigation
- Tool limitations
- Edge cases

#### Coverage

**Limitations:**
- May not catch all bugs
- Some patterns missed
- Tool limitations
- Requires code execution

## Key Takeaways

1. **AddressSanitizer (ASan)** is a fast memory error detector using compile-time instrumentation and shadow memory to detect buffer overflows, use-after-free, and other memory errors with ~2x slowdown.

2. **HWAddressSanitizer (HWASan)** is a hardware-assisted memory error detector using ARM's Memory Tagging Extension (MTE) with lower overhead (~1.5x) but requires ARM64 with MTE support.

3. **Enabling sanitizers** in Android uses `sanitize: { address: true }` or `sanitize: { hwaddress: true }` in Android.bp, or `SANITIZE_TARGET=address` build environment variable.

4. **Error detection** includes buffer overflow (heap, stack, global), use-after-free, null pointer dereference, double-free, and memory leaks (with LeakSanitizer).

5. **Sanitizer reports** provide error type, operation (READ/WRITE), address, detailed stack traces, and summaries, enabling precise bug location and analysis.

6. **Sanitizer configuration** uses environment variables (ASAN_OPTIONS) for runtime options like leak detection, verbosity, and log paths.

7. **Comparison** shows ASan works on all architectures with higher overhead, while HWASan requires ARM64+MTE but has lower overhead and better performance.

8. **Understanding AddressSanitizer and HWASan** is essential for AOSP development, enabling early detection of memory bugs, improved code quality, and easier debugging of memory-related issues in native code.

## Related Topics

- **Debugging native crashes (tombstones):** How to analyze crashes that sanitizers help prevent
- **Building native system components:** How to build code with sanitizers enabled
- **Logging in native layers:** How to add logging for sanitizer-assisted debugging
- **Memory management internals:** How memory works and why sanitizers are needed

