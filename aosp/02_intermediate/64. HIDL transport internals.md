---
number: 64
title: HIDL transport internals
slug: hidl-transport-internals
level: intermediate
tags:
  - aosp
  - hidl
  - transport
  - binder
  - passthrough
  - ipc
  - hal
prerequisites:
  - hidl-deprecated-but-still-used
  - binder-driver-internals
  - binder-architecture
estimated_minutes: 90
contributors: []
diagrams: []
examples: []
canonical_id: aosp-intermediate-64
---

# HIDL transport internals

## Overview

HIDL transport internals cover how HIDL interfaces communicate between framework and vendor HAL implementations, including Binder transport (separate processes) and passthrough transport (same process). Understanding HIDL transport internals is essential for AOSP development, as it affects HAL performance, determines process isolation, impacts system architecture, and influences how framework and vendor code interact. This guide provides a comprehensive overview of HIDL transport mechanisms, Binder transport internals, passthrough transport internals, transport selection, and performance implications.

Think of HIDL transport like different communication methods: just as you can communicate with someone in the same room (passthrough - direct, fast) or through a phone call (Binder - indirect, but works across distances), HIDL transport provides two ways for framework and HAL to communicate - passthrough for same-process communication (fast but less isolated) and Binder for cross-process communication (slower but better isolation).

## Deep Explanation

### What is HIDL Transport?

HIDL transport is the mechanism by which HIDL interface calls are delivered from the framework (client) to the HAL implementation (server). It determines how the communication happens - whether in the same process or across process boundaries.

**Key Characteristics:**
- **Transport Modes:** Binder (IPC) or passthrough (same process)
- **Process Isolation:** Determines isolation level
- **Performance:** Affects call overhead
- **Architecture:** Influences system design

**Why Transport Matters:**
- **Performance:** Different overheads
- **Isolation:** Process boundaries
- **Security:** Separation of concerns
- **Flexibility:** Different use cases

### Transport Modes

#### Binder Transport

**What It Is:**
- HAL runs in separate process
- Uses Binder IPC for communication
- Process isolation
- Standard IPC mechanism

**Characteristics:**
- **Process Isolation:** Framework and HAL in different processes
- **IPC Overhead:** Binder transaction overhead
- **Security:** Better security
- **Stability:** Process crashes don't affect each other

**Architecture:**
```
Framework Process          HAL Process
     │                          │
     │───Binder IPC────────────▶│
     │                          │
     │                          │
  Client                    Server
```

#### Passthrough Transport

**What It Is:**
- HAL runs in same process as framework
- Direct function calls
- No IPC overhead
- Legacy compatibility

**Characteristics:**
- **Same Process:** Framework and HAL in same process
- **Direct Calls:** No IPC overhead
- **Performance:** Lower latency
- **Isolation:** Less isolation

**Architecture:**
```
Framework Process
     │
     │───Direct Call───▶
     │                  │
  Client            HAL Library
```

### Binder Transport Internals

#### Binder Transport Architecture

**Process Structure:**
```
Framework Process              HAL Process
┌─────────────────┐          ┌─────────────────┐
│  HIDL Client    │          │  HIDL Server    │
│  (Generated)    │          │  (Generated)    │
└────────┬────────┘          └────────┬────────┘
         │                              │
         │  Binder IPC                  │
         │─────────────────────────────▶│
         │                              │
         │                              │
    Binder Driver (Kernel)
```

**Components:**
- **HIDL Client:** Generated client code in framework
- **HIDL Server:** Generated server code in HAL process
- **Binder Driver:** Kernel IPC mechanism
- **Transport Layer:** HIDL-specific transport code

#### Binder Transport Implementation

**Client Side:**
```cpp
// Generated HIDL client code
sp<IMyHal> hal = IMyHal::getService();
if (hal != nullptr) {
    Return<int32_t> result = hal->method(param);
    // Result received via Binder
}
```

**Server Side:**
```cpp
// Generated HIDL server code
class MyHal : public IMyHal {
public:
    Return<int32_t> method(int32_t param) override {
        // Implementation
        return param * 2;
    }
};

// Register service
sp<IMyHal> hal = new MyHal();
registerAsService(hal);
```

**Transport Layer:**
- Marshals HIDL types to Binder transactions
- Handles Return<> types
- Manages Binder objects
- Processes transactions

#### Binder Transaction Flow

**Call Flow:**
```
1. Client calls HIDL method
   ↓
2. HIDL client marshals parameters
   ↓
3. Creates Binder transaction
   ↓
4. Sends to Binder driver
   ↓
5. Driver routes to HAL process
   ↓
6. HAL process receives transaction
   ↓
7. HIDL server unmarshals parameters
   ↓
8. Calls HAL implementation
   ↓
9. Marshals return value
   ↓
10. Sends reply via Binder
   ↓
11. Client receives and unmarshals
```

**Marshaling:**
- HIDL types → Binder Parcel
- Primitives, structs, arrays
- Handles, interfaces
- Error handling

**Unmarshaling:**
- Binder Parcel → HIDL types
- Type validation
- Error checking
- Return value construction

### Passthrough Transport Internals

#### Passthrough Architecture

**Process Structure:**
```
Framework Process
┌─────────────────────────────┐
│  HIDL Client (Generated)    │
│         │                    │
│         │ Direct Call        │
│         ▼                    │
│  HIDL Passthrough Wrapper    │
│         │                    │
│         │ Function Call      │
│         ▼                    │
│  HAL Implementation         │
│  (Legacy .so library)        │
└─────────────────────────────┘
```

**Components:**
- **HIDL Client:** Generated client code
- **Passthrough Wrapper:** Converts HIDL calls to legacy HAL calls
- **Legacy HAL:** Traditional HAL implementation
- **Same Process:** All in framework process

#### Passthrough Implementation

**Client Code:**
```cpp
// Get passthrough service
sp<IMyHal> hal = IMyHal::getService("passthrough");
if (hal != nullptr) {
    Return<int32_t> result = hal->method(param);
    // Direct call, no IPC
}
```

**Passthrough Wrapper:**
```cpp
// Passthrough wrapper converts HIDL to legacy HAL
class PassthroughWrapper : public IMyHal {
private:
    hw_module_t* mModule;
    hw_device_t* mDevice;
    
public:
    Return<int32_t> method(int32_t param) override {
        // Convert HIDL call to legacy HAL call
        return mDevice->ops->legacy_method(mDevice, param);
    }
};
```

**Legacy HAL:**
```c
// Traditional HAL implementation
static int legacy_method(struct hw_device_t* device, int param) {
    // Implementation
    return param * 2;
}
```

#### Passthrough Call Flow

**Direct Call Flow:**
```
1. Client calls HIDL method
   ↓
2. HIDL client calls passthrough wrapper
   ↓
3. Passthrough wrapper converts to legacy call
   ↓
4. Direct function call to HAL
   ↓
5. HAL implementation executes
   ↓
6. Return value converted back
   ↓
7. Returned to client
```

**No IPC:**
- No Binder transactions
- No process boundaries
- Direct function calls
- Lower overhead

### Transport Selection

#### How Transport is Selected

**Service Name:**
```cpp
// Binder transport (default)
sp<IMyHal> hal = IMyHal::getService();

// Passthrough transport
sp<IMyHal> hal = IMyHal::getService("passthrough");
```

**Service Registration:**
```cpp
// Binder: Register as service
registerAsService(hal);

// Passthrough: Load legacy HAL
loadPassthroughHal("myhal");
```

#### Transport Configuration

**HAL Implementation:**
- HAL can support both transports
- Framework chooses which to use
- Can switch between transports
- Configuration-dependent

**Default Behavior:**
- Binder transport preferred
- Passthrough for legacy compatibility
- Can be configured per HAL
- System property control

### Transport Performance

#### Binder Transport Performance

**Overhead:**
- Binder transaction overhead
- Process context switch
- Memory copying
- Marshaling/unmarshaling

**Latency:**
- Higher latency than passthrough
- IPC overhead
- Process boundaries
- Acceptable for most use cases

**Throughput:**
- Good for moderate call rates
- Binder thread pool handles concurrency
- Suitable for most HALs

#### Passthrough Transport Performance

**Overhead:**
- Minimal overhead
- Direct function calls
- No process switch
- No marshaling for simple types

**Latency:**
- Lower latency
- Direct calls
- No IPC overhead
- Better for high-frequency calls

**Throughput:**
- Higher throughput
- No IPC bottleneck
- Better for performance-critical HALs
- Limited by single process

### Transport Trade-offs

#### Binder Transport

**Advantages:**
- Process isolation
- Better security
- Crash isolation
- Standard IPC

**Disadvantages:**
- IPC overhead
- Higher latency
- More complex
- Process management

#### Passthrough Transport

**Advantages:**
- Lower latency
- Higher throughput
- Simpler (no IPC)
- Legacy compatibility

**Disadvantages:**
- Less isolation
- Shared process space
- Crash affects framework
- Legacy HAL only

### Transport Internals Deep Dive

#### Binder Transport Marshaling

**HIDL Types to Parcel:**
```cpp
// Marshaling HIDL types
void writeToParcel(const MyStruct& value, Parcel* parcel) {
    parcel->writeInt32(value.field1);
    parcel->writeString16(value.field2);
    // ... more fields
}
```

**Parcel to HIDL Types:**
```cpp
// Unmarshaling from Parcel
MyStruct readFromParcel(const Parcel& parcel) {
    MyStruct value;
    value.field1 = parcel.readInt32();
    value.field2 = parcel.readString16();
    // ... more fields
    return value;
}
```

#### Passthrough Transport Conversion

**HIDL to Legacy:**
```cpp
// Convert HIDL call to legacy
Return<int32_t> method(int32_t param) override {
    // Convert HIDL types to legacy types
    int result = legacy_hal_method(mLegacyDevice, param);
    
    // Convert legacy return to HIDL Return<>
    if (result < 0) {
        return Status::fromStatusT(result);
    }
    return result;
}
```

**Legacy to HIDL:**
```cpp
// Convert legacy callback to HIDL
void legacy_callback(void* context, int event) {
    // Convert to HIDL callback
    IMyHalCallback* callback = static_cast<IMyHalCallback*>(context);
    callback->onEvent(event);
}
```

### Transport Error Handling

#### Binder Transport Errors

**Transaction Errors:**
- Binder transaction failures
- Process death
- Timeout errors
- Permission errors

**Error Handling:**
```cpp
Return<int32_t> result = hal->method(param);
if (!result.isOk()) {
    // Handle error
    Status status = result;
    // Error handling
}
```

#### Passthrough Transport Errors

**Direct Call Errors:**
- Function call failures
- Invalid parameters
- HAL errors
- No process boundary errors

**Error Handling:**
```cpp
Return<int32_t> result = hal->method(param);
if (!result.isOk()) {
    // Handle error
    // Same as Binder transport
}
```

### Transport Debugging

#### Binder Transport Debugging

**Tools:**
```bash
# View Binder transactions
adb shell dumpsys binder

# HIDL-specific debugging
adb shell lshal
```

**Common Issues:**
- Service not found
- Transaction failures
- Process death
- Permission issues

#### Passthrough Transport Debugging

**Tools:**
```bash
# View loaded HALs
adb shell lshal

# Check HAL library loading
adb logcat | grep -i hal
```

**Common Issues:**
- Library loading failures
- Symbol resolution
- Version mismatches
- Initialization errors

### Transport Best Practices

#### When to Use Binder Transport

**Use For:**
- New HAL implementations
- Better isolation needed
- Security-critical HALs
- Standard IPC preferred

**Example:**
```cpp
// Binder transport (default)
sp<IMyHal> hal = IMyHal::getService();
```

#### When to Use Passthrough Transport

**Use For:**
- Legacy HAL compatibility
- Performance-critical paths
- Low-latency requirements
- Migration from legacy HAL

**Example:**
```cpp
// Passthrough transport
sp<IMyHal> hal = IMyHal::getService("passthrough");
```

### Transport Migration

#### Migrating from Passthrough to Binder

**Steps:**
1. Implement HIDL interface
2. Register as Binder service
3. Update framework to use Binder
4. Remove passthrough support

**Benefits:**
- Better isolation
- Standard IPC
- Improved security
- Modern architecture

#### Keeping Passthrough Support

**Reasons:**
- Legacy compatibility
- Performance requirements
- Gradual migration
- Dual support

## Key Takeaways

1. **HIDL transport determines how framework and HAL communicate**, with two modes: Binder (IPC) and passthrough (same process).

2. **Binder transport provides process isolation** but has IPC overhead, while passthrough transport has lower latency but less isolation.

3. **Binder transport uses standard Binder IPC** with marshaling/unmarshaling, while passthrough uses direct function calls with conversion wrappers.

4. **Transport selection** is based on service name and configuration, with Binder being the default for new HALs.

5. **Binder transport is preferred for new HALs** due to better isolation and security, while passthrough is used for legacy compatibility.

6. **Transport performance** differs significantly: passthrough has lower latency and higher throughput, while Binder provides better isolation.

7. **Error handling** is similar for both transports using HIDL's Return<> type, but error sources differ (IPC vs direct calls).

8. **Understanding HIDL transport internals** is essential for AOSP development, HAL implementation, and system architecture decisions.

## Related Topics

- **HIDL (deprecated but still used):** Base HIDL language and concepts
- **Binder driver internals:** How Binder IPC works at kernel level
- **Binder architecture:** Overall Binder IPC architecture
- **HAL modules (hw/ directory):** Legacy HAL implementation

