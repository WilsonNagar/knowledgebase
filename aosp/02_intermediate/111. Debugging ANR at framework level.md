---
number: 111
title: Debugging ANR at framework level
slug: debugging-anr-at-framework-level
level: intermediate
tags:
  - aosp
  - framework
  - anr
  - debugging
  - system-server
  - performance
prerequisites:
  - system-server-overview
  - activitymanagerservice-ams-internals
  - handler-looper-deep-dive
estimated_minutes: 95
contributors: []
diagrams: []
examples: []
canonical_id: aosp-intermediate-111
---

# Debugging ANR at framework level

## Overview

Debugging ANR (Application Not Responding) at the framework level involves analyzing ANR occurrences from the system server perspective, understanding how ANRs are detected, how ANR information is collected, how to analyze ANR traces, and how to identify and fix framework-level causes of ANRs. Understanding ANR debugging at the framework level is essential for AOSP development, as it explains how ANRs are detected by ActivityManagerService, how ANR diagnostics are collected, how to read and analyze ANR traces, how to identify framework bottlenecks, and how to debug system server ANRs. This guide provides a comprehensive overview of debugging ANR at the framework level, ANR detection, diagnostics collection, trace analysis, and debugging techniques.

Think of debugging ANR at the framework level like investigating a traffic jam from the traffic control center: just as a traffic control center monitors traffic flow (ANR detection), collects data about the jam (ANR diagnostics), analyzes the cause (trace analysis), and identifies solutions (debugging), debugging ANR at the framework level involves monitoring ANR detection, collecting ANR information, analyzing ANR traces, and identifying framework-level causes and solutions.

## Deep Explanation

### What is ANR Debugging at Framework Level?

ANR debugging at the framework level involves analyzing ANR occurrences from the system server perspective, understanding how ActivityManagerService detects ANRs, how ANR information is collected, and how to identify and fix framework-level causes of ANRs.

**Key Characteristics:**
- **System Server Perspective:** Framework-level analysis
- **ANR Detection:** How AMS detects ANRs
- **Diagnostics Collection:** ANR information gathering
- **Trace Analysis:** Analyzing ANR traces
- **Framework Debugging:** Identifying framework causes

**Why Debug ANR at Framework Level?**
- **Root Cause Analysis:** Identify framework causes
- **System Optimization:** Optimize framework performance
- **ANR Prevention:** Prevent framework-caused ANRs
- **Performance Improvement:** Improve system responsiveness

### ANR Detection at Framework Level

#### ANR Detection Mechanism

**ANR Detection Process:**
```
1. App receives input event or operation request
2. AMS starts timeout timer
3. AMS monitors app response
4. If timeout expires:
   - AMS detects ANR
   - AMS collects diagnostics
   - AMS shows ANR dialog
   - AMS logs ANR information
```

**Detection Types:**
- **Input ANR:** 5-second timeout for input events
- **Service ANR:** 20-second timeout for service operations
- **Broadcast ANR:** 10-second timeout for broadcast receivers

#### ANR Timeout Configuration

**Timeout Values:**
- Input ANR: 5 seconds (configurable)
- Service ANR: 20 seconds (configurable)
- Broadcast ANR: 10 seconds (configurable)

**Configuration:**
```java
// In ActivityManagerService
private static final int INPUT_ANR_TIMEOUT = 5000; // 5 seconds
private static final int SERVICE_ANR_TIMEOUT = 20000; // 20 seconds
private static final int BROADCAST_ANR_TIMEOUT = 10000; // 10 seconds
```

### ANR Diagnostics Collection

#### ANR Information Collection

**ANR Diagnostics:**
- **Stack Traces:** All thread stack traces
- **Process State:** Current process state
- **CPU Usage:** CPU usage information
- **Memory State:** Memory information
- **Binder State:** Binder transaction state
- **Logs:** Relevant log entries

**Collection Process:**
```
1. ANR detected
2. AMS requests stack traces
3. AMS collects process information
4. AMR collects CPU/memory state
5. AMS collects binder state
6. AMS collects relevant logs
7. ANR information stored
```

#### Stack Trace Collection

**Stack Trace Collection:**
- Collect all thread stack traces
- Include native stack traces
- Include Java stack traces
- Timestamp information

**Collection Method:**
```java
// In ActivityManagerService
private void collectAnrTraces(ProcessRecord app) {
    // Request stack traces
    app.dumpDebugInfo(new PrintWriter(...));
    
    // Collect native traces
    Debug.dumpNativeBacktraceToFile(app.pid, traceFile);
    
    // Collect Java traces
    Debug.dumpHprofData(traceFile);
}
```

### ANR Trace Analysis

#### ANR Trace Location

**Trace Files:**
- `/data/anr/traces.txt` - Latest ANR traces
- `/data/anr/traces_*.txt` - Historical traces
- `/data/tombstones/` - Native crash traces (if applicable)

**Accessing Traces:**
```bash
# Pull ANR traces
adb pull /data/anr/traces.txt

# View traces
adb shell cat /data/anr/traces.txt

# List all traces
adb shell ls -l /data/anr/
```

#### Reading ANR Traces

**Trace Format:**
```
----- pid 12345 at 2024-01-15 10:30:45 -----
Cmd line: com.example.app
...
"main" prio=5 tid=1 Blocked
  | group="main" sCount=1 dsCount=0 flags=1 obj=0x...
  | sysTid=12345 nice=0 cgrp=default sched=0/0 handle=0x...
  | state=S schedstat=( ... ) utm=... stm=... core=0 HZ=100
  | stack=0x...-0x...
  | held mutexes=
  at java.lang.Object.wait(Native method)
  - waiting on <0x...> (a java.lang.Object)
  at com.example.app.MainActivity.onCreate(MainActivity.java:123)
  ...
```

**Trace Components:**
- Process information (PID, package name)
- Thread information (thread name, state, priority)
- Stack traces (method calls, line numbers)
- Lock information (held mutexes, waiting on)

#### Analyzing ANR Traces

**Analysis Steps:**
1. Identify ANR thread (usually "main")
2. Check thread state (Blocked, Waiting, etc.)
3. Analyze stack trace
4. Identify blocking operations
5. Find root cause

**Common ANR Causes:**
- Main thread blocked
- Waiting on lock
- Synchronous I/O
- Long-running operation
- Deadlock

### Framework-Level ANR Causes

#### System Server ANR

**System Server ANR:**
- System server main thread blocked
- Service deadlock
- Excessive Binder calls
- Long-running operation

**Symptoms:**
- System becomes unresponsive
- Apps can't start
- System-wide slowdown

#### Service Blocking

**Service Blocking:**
- Service operation blocks main thread
- Synchronous I/O in service
- Long computation in service
- Deadlock between services

**Example:**
```java
// BAD: Blocking operation
public void serviceMethod() {
    // Blocks main thread
    File file = new File("/large/file");
    byte[] data = Files.readAllBytes(file.toPath()); // Blocks!
}

// GOOD: Async operation
public void serviceMethod() {
    executor.execute(() -> {
        File file = new File("/large/file");
        byte[] data = Files.readAllBytes(file.toPath());
        // Process data
    });
}
```

#### Binder Deadlock

**Binder Deadlock:**
- Circular Binder calls
- Service A calls Service B
- Service B calls Service A
- Deadlock occurs

**Deadlock Prevention:**
- Avoid circular dependencies
- Use async calls
- Use one-way Binder calls
- Timeout on calls

### ANR Debugging Tools

#### dumpsys activity

**ANR Information:**
```bash
# Dump ANR information
adb shell dumpsys activity | grep -A 50 "ANR"

# Dump specific app ANR
adb shell dumpsys activity | grep -A 50 "com.example.app"
```

**ANR Output:**
- ANR history
- ANR details
- Process information
- Stack traces

#### ANR Traces

**Trace Analysis:**
```bash
# Get ANR traces
adb shell cat /data/anr/traces.txt

# Filter for specific app
adb shell cat /data/anr/traces.txt | grep -A 100 "com.example.app"

# Get latest trace
adb shell cat /data/anr/traces.txt | head -500
```

#### Logcat Analysis

**ANR Logs:**
```bash
# Filter ANR logs
adb logcat | grep -i anr

# Filter ActivityManager ANR logs
adb logcat | grep ActivityManager | grep -i anr

# Filter with timestamps
adb logcat -v time | grep -i anr
```

### ANR Prevention

#### Framework Optimization

**Optimization Strategies:**
- Avoid blocking operations
- Use async operations
- Minimize Binder calls
- Optimize service operations

**Best Practices:**
- Keep service operations fast
- Use background threads
- Avoid synchronous I/O
- Minimize lock contention

#### Service Design

**Service Design Principles:**
- Fast service methods
- Async operations
- Minimal blocking
- Efficient data structures

**Design Example:**
```java
// GOOD: Fast, non-blocking
public void serviceMethod() {
    // Quick operation
    updateState();
    // Notify asynchronously
    handler.post(() -> notifyListeners());
}
```

### ANR Monitoring

#### ANR Monitoring

**Monitoring ANRs:**
- Track ANR frequency
- Monitor ANR patterns
- Identify problematic apps
- System-wide ANR tracking

**Monitoring Implementation:**
```java
// In ActivityManagerService
private void logAnr(ProcessRecord app, String reason) {
    // Log ANR
    Slog.w(TAG, "ANR in " + app.processName);
    
    // Track ANR
    mAnrTracker.recordAnr(app, reason);
    
    // Collect diagnostics
    collectAnrDiagnostics(app);
}
```

### Common ANR Scenarios

#### Input ANR

**Input ANR Scenario:**
- User touches screen
- Input event sent to app
- App doesn't respond in 5 seconds
- ANR detected

**Framework Analysis:**
- Check if input delivery is slow
- Check if framework is blocking
- Check system server state

#### Service ANR

**Service ANR Scenario:**
- Service started
- Service.onStart() doesn't complete in 20 seconds
- ANR detected

**Framework Analysis:**
- Check service implementation
- Check if framework is blocking service
- Check system server state

### Debugging Workflow

#### ANR Debugging Steps

**Debugging Process:**
1. Reproduce ANR
2. Collect ANR traces
3. Analyze stack traces
4. Identify blocking operation
5. Find root cause
6. Fix issue
7. Verify fix

**Step-by-Step:**
```bash
# Step 1: Reproduce
# Trigger ANR condition

# Step 2: Collect traces
adb pull /data/anr/traces.txt

# Step 3: Analyze
# Read traces.txt, find blocking thread

# Step 4: Identify cause
# Check stack trace for blocking operations

# Step 5: Fix
# Modify code to avoid blocking

# Step 6: Verify
# Test fix, ensure no ANR
```

### Framework ANR Analysis

#### System Server Analysis

**System Server ANR:**
- Check system server main thread
- Analyze service operations
- Check for deadlocks
- Review Binder calls

**Analysis Tools:**
```bash
# Check system server state
adb shell dumpsys activity | grep -A 20 "system_server"

# Check system server threads
adb shell cat /data/anr/traces.txt | grep -A 50 "system_server"
```

#### Service Analysis

**Service ANR Analysis:**
- Check service implementation
- Analyze service operations
- Check for blocking calls
- Review service logs

**Service Debugging:**
```bash
# Dump service state
adb shell dumpsys activity services

# Check service logs
adb logcat | grep ServiceName
```

### Best Practices

#### ANR Prevention

**Prevention Guidelines:**
- Keep operations fast
- Use async operations
- Avoid blocking I/O
- Minimize lock contention

**Code Guidelines:**
- No blocking operations on main thread
- Use background threads for I/O
- Use async APIs
- Minimize Binder calls

#### ANR Debugging

**Debugging Guidelines:**
- Collect traces immediately
- Analyze stack traces carefully
- Check system server state
- Review service logs
- Test fixes thoroughly

## Key Takeaways

1. **Debugging ANR at framework level** involves analyzing ANR occurrences from the system server perspective, understanding ANR detection, diagnostics collection, and identifying framework-level causes.

2. **ANR detection at framework level** includes detection mechanism (AMS monitors app response), timeout configuration (5s input, 20s service, 10s broadcast), and detection types.

3. **ANR diagnostics collection** includes collecting stack traces (all threads), process state, CPU/memory state, Binder state, and relevant logs for analysis.

4. **ANR trace analysis** includes trace location (/data/anr/traces.txt), reading traces (process info, thread info, stack traces), and analyzing traces to identify blocking operations.

5. **Framework-level ANR causes** include system server ANR (main thread blocked), service blocking (blocking operations), Binder deadlock (circular calls), and framework bottlenecks.

6. **ANR debugging tools** include dumpsys activity (ANR information), ANR traces (trace files), logcat analysis (ANR logs), and system state inspection.

7. **ANR prevention** includes framework optimization (avoid blocking, use async), service design (fast operations, minimal blocking), and best practices for preventing ANRs.

8. **ANR monitoring** includes tracking ANR frequency, monitoring patterns, identifying problematic apps, and system-wide ANR tracking.

9. **Common ANR scenarios** include input ANR (5-second timeout), service ANR (20-second timeout), and framework analysis for each scenario.

10. **Debugging workflow** includes reproducing ANR, collecting traces, analyzing stack traces, identifying blocking operations, finding root cause, fixing issue, and verifying fix.

11. **Understanding debugging ANR at framework level** is essential for AOSP development, enabling identification of framework causes, system optimization, ANR prevention, and performance improvement.

## Related Topics

- **System Server Overview:** How system server works
- **ActivityManagerService (AMS) internals:** How AMS detects ANRs
- **Handler/Looper deep dive:** How threading affects ANRs
- **Debugging native crashes (tombstones):** Related debugging techniques

