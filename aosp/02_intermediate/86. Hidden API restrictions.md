---
number: 86
title: Hidden API restrictions
slug: hidden-api-restrictions
level: intermediate
tags:
  - aosp
  - art
  - hidden-api
  - restrictions
  - greylist
  - blacklist
  - api-access
prerequisites:
  - dalvik-vs-art
  - class-preloading
estimated_minutes: 85
contributors: []
diagrams: []
examples: []
canonical_id: aosp-intermediate-86
---

# Hidden API restrictions

## Overview

Hidden API restrictions are security and stability mechanisms in Android that prevent applications from accessing internal, non-public APIs that are not part of the public Android SDK. Understanding hidden API restrictions is essential for AOSP development, as it explains how Android protects internal APIs, how the restriction system works, the different API lists (whitelist, greylist, blacklist), and how to properly use or access APIs. This guide provides a comprehensive overview of hidden API restrictions, the restriction mechanisms, API classification, enforcement, and best practices.

Think of hidden API restrictions like a restricted area in a building: just as a building has public areas (public APIs) that anyone can access and restricted areas (hidden APIs) that require special access, Android has public APIs (SDK) that apps can use and hidden APIs (internal) that are restricted. The restriction system ensures apps only use stable, supported APIs while protecting internal implementation details.

## Deep Explanation

### What are Hidden API Restrictions?

Hidden API restrictions are runtime mechanisms that prevent applications from accessing internal Android framework APIs that are not part of the public Android SDK, protecting system stability and enabling framework evolution.

**Key Characteristics:**
- **Runtime Enforcement:** Enforced by ART runtime
- **API Protection:** Prevents access to internal APIs
- **Stability:** Protects framework stability
- **Evolution:** Enables framework changes

**Why Hidden API Restrictions?**
- **Stability:** Prevent apps from using unstable APIs
- **Security:** Protect internal implementation
- **Evolution:** Allow framework changes
- **Compatibility:** Maintain API compatibility

### API Classification

#### Public APIs

**Public APIs:**
- Part of Android SDK
- Documented and stable
- Guaranteed compatibility
- Safe to use

**Characteristics:**
- Publicly documented
- Stable across versions
- Backward compatible
- Supported by Google

**Examples:**
- `android.app.Activity`
- `android.content.Context`
- `android.view.View`
- Standard SDK classes

#### Hidden APIs

**Hidden APIs:**
- Not part of public SDK
- Marked with `@hide` annotation
- Internal implementation
- Subject to change

**Characteristics:**
- Not documented publicly
- May change without notice
- Internal use only
- Unstable

**Examples:**
- Internal framework classes
- System service internals
- Implementation details
- Private APIs

### Restriction Lists

#### Whitelist

**Whitelist:**
- APIs explicitly allowed
- Safe to access
- No restrictions
- Public APIs

**Purpose:**
- Allow public API access
- Permit approved APIs
- Enable legitimate use
- Maintain compatibility

#### Greylist

**Greylist:**
- APIs with warnings
- Access allowed but discouraged
- May be restricted in future
- Transitional state

**Characteristics:**
- Access generates warning
- Not recommended
- May become blacklisted
- Deprecated APIs

**Enforcement:**
- Warning logged
- Access allowed
- Future restriction possible
- Developer notification

#### Blacklist

**Blacklist:**
- APIs strictly forbidden
- Access blocked
- Security/stability risk
- Enforced restriction

**Characteristics:**
- Access denied
- Exception thrown
- Strictly enforced
- Security critical

**Enforcement:**
- Access blocked at runtime
- Exception: `NoSuchMethodError` or `NoSuchFieldError`
- Logged as violation
- Prevented access

### Restriction Mechanism

#### Runtime Enforcement

**Enforcement Process:**
```
1. App attempts to access API
2. ART checks API classification
3. Determine if access allowed
4. Enforce restriction if needed
5. Allow or block access
```

**Enforcement Points:**
- Method invocation
- Field access
- Class loading
- Reflection access

#### API Lookup

**Lookup Process:**
1. Check whitelist (allowed)
2. Check greylist (warning)
3. Check blacklist (blocked)
4. Default behavior

**Lookup Tables:**
- Whitelist table
- Greylist table
- Blacklist table
- Efficient lookup

### Annotation System

#### @hide Annotation

**@hide Annotation:**
- Marks APIs as hidden
- Not part of public SDK
- Internal use only
- Documentation marker

**Usage:**
```java
/**
 * Internal method for framework use.
 * @hide
 */
public void internalMethod() {
    // Implementation
}
```

**Effect:**
- Excluded from SDK
- Not in public documentation
- Marked as hidden
- Subject to restrictions

#### @UnsupportedAppUsage

**@UnsupportedAppUsage:**
- Marks APIs used by apps
- Legacy app compatibility
- May be greylisted
- Transitional annotation

**Usage:**
```java
/**
 * Legacy API for app compatibility.
 * @hide
 * @UnsupportedAppUsage
 */
public void legacyMethod() {
    // Implementation
}
```

**Effect:**
- May be in greylist
- Legacy app access
- Transitional support
- May be restricted later

### Restriction Enforcement

#### Android 9.0 (Pie)

**Initial Enforcement:**
- Hidden API restrictions introduced
- Greylist and blacklist
- Runtime enforcement
- Reflection restrictions

**Enforcement:**
- Reflection access blocked
- Direct access warnings
- Greylist warnings
- Blacklist blocking

#### Android 10.0+ (Q and later)

**Enhanced Enforcement:**
- Stricter restrictions
- Expanded blacklist
- Better enforcement
- Improved security

**Changes:**
- More APIs blacklisted
- Stricter reflection rules
- Enhanced enforcement
- Better protection

### Bypassing Restrictions

#### System Apps

**System App Access:**
- System apps can access hidden APIs
- Higher privileges
- Framework access
- System partition apps

**Characteristics:**
- System signature
- System partition
- Framework access
- Privileged access

#### Reflection Bypass (Historical)

**Historical Bypass:**
- Reflection could bypass restrictions
- Android 9.0+ restrictions
- Limited effectiveness
- Security risk

**Current State:**
- Reflection also restricted
- Stricter enforcement
- Limited bypass options
- Security improved

#### Developer Options

**Developer Bypass:**
- Developer options
- Debug builds
- Testing purposes
- Not for production

**Usage:**
```bash
# Enable hidden API access (development only)
adb shell settings put global hidden_api_policy 1
```

**Warning:**
- Development only
- Not for production
- Security risk
- Unsupported

### Best Practices

#### For App Developers

**Use Public APIs:**
- Only use public SDK APIs
- Avoid hidden APIs
- Check API documentation
- Use supported APIs

**Migration:**
- Migrate from hidden APIs
- Use public alternatives
- Update dependencies
- Follow guidelines

#### For Framework Developers

**API Design:**
- Design public APIs carefully
- Mark internal APIs with @hide
- Document public APIs
- Maintain compatibility

**API Evolution:**
- Use greylist for transitions
- Provide migration paths
- Deprecate gradually
- Maintain stability

### Debugging Restrictions

#### Access Violations

**Common Errors:**
- `NoSuchMethodError`
- `NoSuchFieldError`
- `ClassNotFoundException`
- Access denied errors

**Debugging:**
```bash
# Check hidden API policy
adb shell settings get global hidden_api_policy

# View restriction logs
adb logcat | grep -i "hidden.*api"
```

#### Restriction Logs

**Logging:**
- Access attempts logged
- Violation warnings
- Greylist warnings
- Blacklist blocks

**View Logs:**
```bash
# View hidden API logs
adb logcat | grep -i "Accessing.*hidden"

# Check greylist warnings
adb logcat | grep -i "greylist"
```

## Key Takeaways

1. **Hidden API restrictions** are runtime mechanisms that prevent applications from accessing internal Android framework APIs not part of the public SDK, protecting system stability and enabling framework evolution.

2. **API classification** includes public APIs (SDK, stable), hidden APIs (internal, @hide), with restriction lists: whitelist (allowed), greylist (warnings), and blacklist (blocked).

3. **Restriction mechanism** is enforced at runtime by ART, checking API classification during method invocation, field access, class loading, and reflection access.

4. **Annotation system** uses @hide to mark hidden APIs and @UnsupportedAppUsage for legacy app compatibility, with APIs potentially in greylist or blacklist.

5. **Enforcement evolution** started in Android 9.0 with initial restrictions, enhanced in Android 10.0+ with stricter enforcement, expanded blacklist, and better security.

6. **Bypassing restrictions** is possible for system apps (higher privileges), was historically possible via reflection (now restricted), and can be enabled in developer options (development only, not for production).

7. **Best practices** include using only public APIs for app developers, careful API design and evolution for framework developers, and proper migration from hidden APIs.

8. **Understanding hidden API restrictions** is essential for AOSP development, explaining how Android protects internal APIs, maintains stability, and enables framework evolution while preventing apps from using unstable internal APIs.

## Related Topics

- **Dalvik vs ART:** Runtime environment that enforces restrictions
- **Class preloading:** How classes are loaded and restricted
- **Stability annotations:** API stability and versioning
- **Android Architecture - Complete Overview:** How restrictions fit into overall architecture

