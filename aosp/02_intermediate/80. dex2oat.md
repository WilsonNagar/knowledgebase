---
number: 80
title: dex2oat
slug: dex2oat
level: intermediate
tags:
  - aosp
  - art
  - dex2oat
  - compilation
  - oat
  - dex
  - aot
  - optimization
prerequisites:
  - dalvik-vs-art
  - art-boot-image-dex-pre-optimization
estimated_minutes: 85
contributors: []
diagrams: []
examples: []
canonical_id: aosp-intermediate-80
---

# dex2oat

## Overview

dex2oat is ART's (Android Runtime) compiler that converts DEX (Dalvik Executable) bytecode into optimized native code stored in OAT (Optimized Android Type) files. Understanding dex2oat is essential for AOSP development, as it explains how Android applications are compiled, how optimization is performed, how OAT files are created, and how the compilation process impacts app installation and performance. This guide provides a comprehensive overview of dex2oat, its architecture, compilation process, optimization passes, compiler filters, and usage.

Think of dex2oat like a translator that converts a high-level language (DEX bytecode) into machine language (native code): just as a translator converts text from one language to another, dex2oat converts DEX bytecode (portable, interpreted code) into native machine code (fast, CPU-specific code) that can run directly on the device's processor.

## Deep Explanation

### What is dex2oat?

dex2oat is ART's Ahead-Of-Time (AOT) compiler that converts DEX bytecode into optimized native machine code, creating OAT files that contain compiled code ready for execution.

**Key Characteristics:**
- **AOT Compiler:** Compiles before execution
- **Native Code Generation:** Creates machine code
- **Optimization:** Multiple optimization passes
- **OAT File Creation:** Generates OAT files

**Why dex2oat?**
- **Performance:** Native code execution
- **Optimization:** Build-time optimization
- **Startup Speed:** Pre-compiled code ready
- **Battery Life:** Less CPU usage at runtime

### dex2oat Architecture

#### Compiler Components

**Main Components:**
```
dex2oat
├── DEX Parser
│   └── Parse DEX files
├── Compiler Backend
│   ├── Instruction Selection
│   ├── Register Allocation
│   └── Code Generation
├── Optimizer
│   ├── Inlining
│   ├── Dead Code Elimination
│   └── Constant Propagation
└── OAT Writer
    └── Write OAT file
```

**Compilation Pipeline:**
```
DEX Bytecode
     │
     ▼
DEX Parser
     │
     ▼
Optimizer
     │
     ▼
Compiler Backend
     │
     ▼
Native Code
     │
     ▼
OAT File
```

### Compilation Process

#### Step 1: DEX Parsing

**Parse DEX File:**
- Read DEX file structure
- Parse class definitions
- Extract method bytecode
- Build internal representation

**DEX Structure:**
```
DEX File
├── Header
├── String Table
├── Type Table
├── Method Table
├── Class Definitions
└── Code (bytecode)
```

**Parsing:**
```cpp
// Simplified parsing
DexFile* dex_file = DexFile::Open(dex_file_path);
for (const DexFile::ClassDef& class_def : dex_file->GetClassDefs()) {
    // Process class
    for (const DexFile::CodeItem& code_item : class_def.GetCodeItems()) {
        // Process method bytecode
    }
}
```

#### Step 2: Optimization

**Optimization Passes:**
- **Inlining:** Inline small methods
- **Dead Code Elimination:** Remove unused code
- **Constant Propagation:** Replace variables with constants
- **Loop Optimization:** Optimize loops
- **Register Allocation:** Efficient register usage

**Inlining Example:**
```java
// Before optimization
int add(int a, int b) {
    return a + b;
}
void main() {
    int result = add(5, 3);  // Method call
}

// After inlining
void main() {
    int result = 5 + 3;  // Direct calculation
}
```

**Dead Code Elimination:**
```java
// Before optimization
if (false) {
    expensiveOperation();  // Never executed
}

// After optimization
// Code removed
```

#### Step 3: Code Generation

**Native Code Generation:**
- Convert bytecode to native instructions
- Architecture-specific code
- Register allocation
- Instruction selection

**Code Generation:**
```cpp
// Simplified code generation
for (const Instruction& inst : method_bytecode) {
    switch (inst.opcode) {
        case OP_ADD_INT:
            // Generate ADD instruction
            emit_add(inst.reg1, inst.reg2, inst.reg3);
            break;
        case OP_INVOKE_VIRTUAL:
            // Generate method call
            emit_method_call(inst.method);
            break;
        // ... other opcodes
    }
}
```

#### Step 4: OAT File Creation

**OAT File Structure:**
```
OAT File
├── OAT Header
│   ├── Magic Number
│   ├── Version
│   └── Architecture
├── DEX File (optional)
├── Native Code Sections
│   ├── Method Code
│   └── Metadata
└── OAT Classes
    └── Class Information
```

**OAT File Format:**
- ELF (Executable and Linkable Format)
- Contains native code
- Includes metadata
- Architecture-specific

### Compiler Filters

#### What are Compiler Filters?

Compiler filters control the level of optimization and compilation performed by dex2oat, balancing compilation time, code size, and runtime performance.

**Filter Options:**
- `speed` - Maximum optimization
- `balanced` - Balanced optimization
- `space` - Size optimization
- `quicken` - Quick compilation
- `verify` - Verification only
- `extract` - Extract DEX only

#### Filter Details

**speed:**
- Maximum optimization
- Best runtime performance
- Longer compilation time
- Larger OAT files
- Used for: System apps, boot image

**balanced:**
- Balanced optimization
- Good performance
- Moderate compilation time
- Moderate OAT size
- Used for: User apps (default)

**space:**
- Size optimization
- Smaller OAT files
- Moderate performance
- Faster compilation
- Used for: Storage-constrained devices

**quicken:**
- Quick compilation
- Minimal optimization
- Fast compilation
- Smaller OAT files
- Used for: Fast installation

**verify:**
- Verification only
- No compilation
- Fast processing
- No OAT file
- Used for: Verification only

**extract:**
- Extract DEX only
- No compilation
- No optimization
- Extract DEX from APK
- Used for: DEX extraction

### dex2oat Usage

#### Command-Line Interface

**Basic Usage:**
```bash
dex2oat --dex-file=app.dex --oat-file=app.oat
```

**Common Options:**
```bash
dex2oat \
    --dex-file=app.dex \
    --oat-file=app.oat \
    --compiler-filter=speed \
    --instruction-set=arm64 \
    --android-root=/system \
    --boot-image=/system/framework/boot.art
```

**Key Options:**
- `--dex-file`: Input DEX file
- `--oat-file`: Output OAT file
- `--compiler-filter`: Optimization level
- `--instruction-set`: Target architecture
- `--android-root`: Android root directory
- `--boot-image`: Boot image path

#### Installation-Time Compilation

**Automatic Compilation:**
- Package manager triggers dex2oat
- Runs during app installation
- Creates OAT file
- Stores in app directory

**Process:**
```
1. APK installed
2. DEX extracted
3. dex2oat invoked
4. Compilation performed
5. OAT file created
6. App ready
```

**Location:**
- `/data/app/<package>/oat/<arch>/base.odex`
- Architecture-specific directory
- Per-app OAT files

#### Build-Time Compilation

**System Build:**
- dex2oat runs during AOSP build
- Compiles system apps
- Creates boot image
- Pre-optimizes framework

**Build Integration:**
```makefile
# Android.bp example
dex_preopt {
    name: "framework",
    dex_location: "framework.jar",
    profile: "framework.prof",
    compiler_filter: "speed",
}
```

### Optimization Techniques

#### Method Inlining

**Purpose:**
- Eliminate method call overhead
- Enable further optimizations
- Improve performance

**Process:**
- Identify small methods
- Check call sites
- Inline method body
- Optimize inlined code

**Example:**
```java
// Before
int add(int a, int b) { return a + b; }
int result = add(x, y);

// After
int result = x + y;
```

#### Dead Code Elimination

**Purpose:**
- Remove unused code
- Reduce code size
- Improve performance

**Process:**
- Identify unreachable code
- Remove dead branches
- Eliminate unused methods
- Clean up code

**Example:**
```java
// Before
if (false) {
    expensiveOperation();
}

// After
// Code removed
```

#### Constant Propagation

**Purpose:**
- Replace variables with constants
- Enable further optimizations
- Improve performance

**Process:**
- Track constant values
- Propagate constants
- Replace variables
- Optimize expressions

**Example:**
```java
// Before
final int x = 5;
int result = x + 3;

// After
int result = 8;
```

#### Register Allocation

**Purpose:**
- Efficient register usage
- Minimize memory access
- Improve performance

**Process:**
- Analyze variable usage
- Allocate registers
- Spill to memory if needed
- Optimize allocation

### Performance Considerations

#### Compilation Time

**Factors:**
- Compiler filter
- DEX file size
- Number of methods
- Optimization level
- Device performance

**Trade-offs:**
- More optimization = longer compilation
- Faster compilation = less optimization
- Balance needed

#### OAT File Size

**Size Factors:**
- Native code size
- Optimization level
- Metadata size
- DEX inclusion

**Size Comparison:**
- DEX: 5MB
- OAT (speed): ~15MB
- OAT (balanced): ~10MB
- OAT (quicken): ~6MB

#### Runtime Performance

**Performance Factors:**
- Optimization level
- Code quality
- Native code efficiency
- CPU architecture

**Performance Gains:**
- speed: ~3x faster than interpreted
- balanced: ~2x faster than interpreted
- quicken: ~1.5x faster than interpreted

### Debugging dex2oat

#### Common Issues

**Compilation Failures:**
- DEX file corruption
- Out of memory
- Invalid bytecode
- Architecture mismatch

**Debugging:**
```bash
# Verbose output
dex2oat --dex-file=app.dex --oat-file=app.oat --verbose

# Check DEX file
dexdump app.dex

# Check OAT file
oatdump --oat-file=app.oat
```

#### Compilation Logs

**Logging:**
```bash
# Enable logging
dex2oat --dex-file=app.dex --oat-file=app.oat \
    --runtime-arg -Xlog:compiler

# Check logs
adb logcat | grep dex2oat
```

### dex2oat Evolution

#### Android 5.0 (Lollipop)

**Initial Implementation:**
- Pure AOT compilation
- Full app compilation
- Long installation time
- Best performance

#### Android 7.0 (Nougat)

**Hybrid Compilation:**
- JIT + AOT
- Profile-guided optimization
- Faster installation
- Better optimization

#### Android 8.0+ (Oreo)

**Improvements:**
- VDEX support
- Better optimization
- Faster compilation
- Improved performance

## Key Takeaways

1. **dex2oat is ART's AOT compiler** that converts DEX bytecode into optimized native code, creating OAT files for fast execution.

2. **Compilation process** involves DEX parsing, optimization (inlining, dead code elimination), code generation, and OAT file creation.

3. **Compiler filters** control optimization level: `speed` (maximum), `balanced` (default), `space` (size), `quicken` (fast), `verify` (verification only), `extract` (extract only).

4. **Optimization techniques** include method inlining, dead code elimination, constant propagation, and register allocation for better performance.

5. **dex2oat runs** during app installation (automatic) and during AOSP build (system apps, boot image) to pre-compile code.

6. **Performance considerations** include compilation time, OAT file size, and runtime performance, with trade-offs between optimization level and compilation speed.

7. **OAT files** are ELF-format files containing native code, metadata, and optional DEX, stored per-app in architecture-specific directories.

8. **Understanding dex2oat** is essential for AOSP development, explaining how Android apps are compiled, optimized, and executed for optimal performance.

## Related Topics

- **AOT & JIT compilation:** Compilation strategies in ART
- **OAT & VDEX files:** Output file formats
- **Dalvik vs ART:** Runtime evolution
- **ART boot image & dex pre-optimization:** Build-time optimization

