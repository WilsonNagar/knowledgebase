---
number: 72
title: Creating your own HAL
slug: creating-your-own-hal
level: intermediate
tags:
  - aosp
  - hal
  - custom-hal
  - hal-development
  - aidl-hal
  - hal-implementation
prerequisites:
  - aidl-based-hals
  - aidl
  - stability-annotations
  - vintf
estimated_minutes: 95
contributors: []
diagrams: []
examples: []
canonical_id: aosp-intermediate-72
---

# Creating your own HAL

## Overview

Creating your own HAL (Hardware Abstraction Layer) involves defining a stable interface, implementing the HAL service, configuring the build system, updating manifests, and testing the implementation. Understanding how to create a custom HAL is essential for AOSP development, as it enables hardware-specific functionality, supports Project Treble, allows vendor customization, and provides a standardized way to expose hardware capabilities to the framework. This guide provides a comprehensive overview of the complete workflow for creating a custom HAL, from interface definition to deployment and testing.

Think of creating a HAL like building a bridge: you need to design the bridge (define the interface), build the foundation and structure (implement the HAL), get permits and approvals (update manifests and build configuration), test it (run VTS), and finally open it for traffic (deploy and use). Each step is critical for a successful HAL implementation.

## Deep Explanation

### HAL Development Workflow

#### Complete Workflow

**Steps:**
1. Define AIDL interface
2. Implement HAL service
3. Configure build system
4. Update device manifest
5. Create service process
6. Test implementation
7. Deploy and verify

**Why This Order?**
- Interface first (contract)
- Implementation follows
- Build system integration
- Manifest for discovery
- Service for runtime
- Testing for validation

### Step 1: Define AIDL Interface

#### Create AIDL File

**File Location:**
```
hardware/interfaces/example/1.0/IExample.aidl
```

**AIDL Content:**
```aidl
package android.hardware.example@1.0;

@VintfStability
interface IExample {
    int32_t getValue();
    void setValue(int32_t value);
    void registerCallback(IExampleCallback callback);
    void unregisterCallback(IExampleCallback callback);
}

@VintfStability
interface IExampleCallback {
    oneway void onValueChanged(int32_t newValue);
}
```

**Key Elements:**
- `@VintfStability`: Required for HAL interfaces
- Package with version: `@1.0`
- Interface methods
- Callback interface (optional)

#### Configure AIDL Interface Build

**Android.bp:**
```bp
aidl_interface {
    name: "android.hardware.example",
    srcs: ["*.aidl"],
    stability: "vintf",
    backend: {
        java: {
            enabled: true,
        },
        ndk: {
            enabled: true,
        },
    },
}
```

**Key Settings:**
- `stability: "vintf"`: VINTF stability
- `backend`: Java and NDK support
- `srcs`: AIDL source files

### Step 2: Implement HAL Service

#### C++ Implementation

**Service Header:**
```cpp
// ExampleHal.h
#include <aidl/android/hardware/example/BnExample.h>
#include <aidl/android/hardware/example/IExampleCallback.h>

using aidl::android::hardware::example::BnExample;
using aidl::android::hardware::example::IExampleCallback;

class ExampleHal : public BnExample {
public:
    ::ndk::ScopedAStatus getValue(int32_t* _aidl_return) override;
    ::ndk::ScopedAStatus setValue(int32_t value) override;
    ::ndk::ScopedAStatus registerCallback(
            const std::shared_ptr<IExampleCallback>& callback) override;
    ::ndk::ScopedAStatus unregisterCallback(
            const std::shared_ptr<IExampleCallback>& callback) override;

private:
    int32_t mValue = 0;
    std::shared_ptr<IExampleCallback> mCallback;
    std::mutex mMutex;
};
```

**Service Implementation:**
```cpp
// ExampleHal.cpp
#include "ExampleHal.h"

::ndk::ScopedAStatus ExampleHal::getValue(int32_t* _aidl_return) {
    std::lock_guard<std::mutex> lock(mMutex);
    *_aidl_return = mValue;
    return ::ndk::ScopedAStatus::ok();
}

::ndk::ScopedAStatus ExampleHal::setValue(int32_t value) {
    std::lock_guard<std::mutex> lock(mMutex);
    mValue = value;
    
    // Notify callback
    if (mCallback != nullptr) {
        mCallback->onValueChanged(value);
    }
    
    return ::ndk::ScopedAStatus::ok();
}

::ndk::ScopedAStatus ExampleHal::registerCallback(
        const std::shared_ptr<IExampleCallback>& callback) {
    std::lock_guard<std::mutex> lock(mMutex);
    mCallback = callback;
    return ::ndk::ScopedAStatus::ok();
}

::ndk::ScopedAStatus ExampleHal::unregisterCallback(
        const std::shared_ptr<IExampleCallback>& callback) {
    std::lock_guard<std::mutex> lock(mMutex);
    if (mCallback == callback) {
        mCallback = nullptr;
    }
    return ::ndk::ScopedAStatus::ok();
}
```

### Step 3: Create Service Process

#### Service Main Function

**main.cpp:**
```cpp
#include <android/binder_manager.h>
#include <android/binder_process.h>
#include <android-base/logging.h>
#include "ExampleHal.h"

using aidl::android::hardware::example::ExampleHal;

int main() {
    // Create HAL instance
    std::shared_ptr<ExampleHal> hal = ndk::SharedRefBase::make<ExampleHal>();
    
    // Register service
    std::string instanceName = "default";
    std::string serviceName = std::string() + 
        "android.hardware.example.IExample" + "/" + instanceName;
    
    ALOG(INFO) << "Registering service: " << serviceName;
    
    binder_status_t status = AServiceManager_addService(
        hal->asBinder().get(), serviceName.c_str());
    
    if (status != STATUS_OK) {
        ALOGE("Failed to register service: %d", status);
        return 1;
    }
    
    ALOG(INFO) << "Service registered successfully";
    
    // Start thread pool
    ABinderProcess_startThreadPool();
    
    // Join thread pool (blocks)
    ABinderProcess_joinThreadPool();
    
    return 0;
}
```

### Step 4: Configure Build System

#### HAL Service Library

**Android.bp:**
```bp
cc_library_shared {
    name: "android.hardware.example-service",
    srcs: [
        "ExampleHal.cpp",
    ],
    shared_libs: [
        "android.hardware.example-V1-ndk",
        "libbinder_ndk",
        "libbase",
        "liblog",
    ],
    header_libs: [
        "android.hardware.example-V1-ndk",
    ],
}
```

#### HAL Service Binary

**Android.bp:**
```bp
cc_binary {
    name: "android.hardware.example@1.0-service",
    srcs: ["main.cpp"],
    shared_libs: [
        "android.hardware.example-service",
        "libbinder_ndk",
        "libbase",
        "liblog",
    ],
    init_rc: ["android.hardware.example@1.0-service.rc"],
    vendor: true,
}
```

#### Init Script

**android.hardware.example@1.0-service.rc:**
```rc
service example-hal-1-0 /vendor/bin/hw/android.hardware.example@1.0-service
    class hal
    user system
    group system
    setenv LD_LIBRARY_PATH /vendor/lib64
```

### Step 5: Update Device Manifest

#### Add HAL to Manifest

**vendor/manifest.xml:**
```xml
<manifest version="1.0" type="device">
    <!-- Other HALs -->
    
    <hal format="aidl">
        <name>android.hardware.example</name>
        <version>1</version>
        <fqname>IExample/default</fqname>
    </hal>
</manifest>
```

**Key Elements:**
- `format="aidl"`: AIDL HAL
- `name`: HAL package name
- `version`: HAL version
- `fqname`: Interface/instance

### Step 6: Build and Deploy

#### Build HAL

**Build Command:**
```bash
# Build HAL service
m android.hardware.example@1.0-service

# Or build everything
m
```

**Output:**
- Service binary: `out/target/product/<device>/vendor/bin/hw/android.hardware.example@1.0-service`
- Libraries: `out/target/product/<device>/vendor/lib64/`

#### Deploy to Device

**Flash or Push:**
```bash
# Flash entire build
fastboot flash vendor vendor.img

# Or push specific files
adb push android.hardware.example@1.0-service /vendor/bin/hw/
adb push libexample-service.so /vendor/lib64/
adb push manifest.xml /vendor/
```

### Step 7: Test Implementation

#### Manual Testing

**Check Service:**
```bash
# Check if service is running
adb shell lshal | grep example

# Check service registration
adb shell dumpsys | grep example
```

**Test HAL:**
```bash
# Use test client or framework
# Framework should be able to get service
```

#### VTS Testing

**Run VTS:**
```bash
# Run VTS tests for HAL
vts-tradefed run commandAndExit vts -m VtsHalExampleV1_0Target
```

**Validate:**
- All tests pass
- No errors
- Compatibility verified

### HAL Development Best Practices

#### Interface Design

**Stability:**
- Always use @VintfStability
- Plan for versioning
- Avoid breaking changes
- Document interface

**Method Design:**
- Keep methods focused
- Use appropriate types
- Handle errors properly
- Document behavior

#### Implementation

**Error Handling:**
- Return ScopedAStatus appropriately
- Use exception codes
- Provide error messages
- Handle all cases

**Thread Safety:**
- Protect shared data
- Use mutexes/locks
- Avoid race conditions
- Document thread safety

**Performance:**
- Keep transactions short
- Avoid blocking operations
- Use oneway for notifications
- Optimize data transfer

#### Build Configuration

**Proper Dependencies:**
- Include required libraries
- Link correctly
- Set vendor flag
- Configure init script

**Manifest Updates:**
- Accurate HAL declarations
- Correct versions
- Complete interface info
- Valid format

### Common Issues and Solutions

#### Service Not Found

**Problem:**
- Service not registered
- Manifest missing
- Service not started

**Solution:**
- Check service registration
- Verify manifest
- Check init script
- Review logs

#### Build Errors

**Problem:**
- Missing dependencies
- Link errors
- AIDL generation issues

**Solution:**
- Check Android.bp
- Verify dependencies
- Review AIDL files
- Check build logs

#### Runtime Errors

**Problem:**
- Service crashes
- Method failures
- Callback issues

**Solution:**
- Check logs
- Review implementation
- Validate parameters
- Test error handling

### HAL Versioning

#### Version Management

**Version Format:**
- `@1.0`: Initial version
- `@1.1`: Minor update (backward compatible)
- `@2.0`: Major update (breaking changes)

**Version Rules:**
- Minor: Add methods, extend types
- Major: Breaking changes
- Maintain compatibility
- Document changes

#### Interface Evolution

**Adding Methods:**
```aidl
// Version 1.0
package android.hardware.example@1.0;
interface IExample {
    int32_t getValue();
}

// Version 1.1 (backward compatible)
package android.hardware.example@1.1;
interface IExample {
    int32_t getValue();
    int32_t getValue2();  // New method
}
```

**Breaking Changes:**
```aidl
// Version 2.0 (breaking)
package android.hardware.example@2.0;
interface IExample {
    int64_t getValue();  // Changed return type
}
```

### HAL Testing

#### Unit Testing

**Test Structure:**
- Test individual methods
- Test error cases
- Test edge cases
- Mock dependencies

#### Integration Testing

**Test Framework Integration:**
- Test with framework
- Validate behavior
- Check compatibility
- Verify performance

#### VTS Testing

**Automated Testing:**
- Run VTS tests
- Validate compliance
- Check compatibility
- Ensure certification

## Key Takeaways

1. **Creating a HAL involves multiple steps**: Define AIDL interface, implement HAL service, configure build system, update device manifest, create service process, and test.

2. **AIDL interface definition** requires @VintfStability annotation, proper versioning, and clear method signatures.

3. **HAL service implementation** must handle errors properly, be thread-safe, and follow best practices for performance.

4. **Build configuration** includes Android.bp files for the service library, service binary, and init script configuration.

5. **Device manifest** must declare the HAL with correct format, name, version, and fully qualified name (fqname).

6. **Service process** registers the HAL with ServiceManager and runs in a separate process for isolation.

7. **Testing** includes manual testing, VTS testing, and integration testing to ensure correctness and compatibility.

8. **Understanding the complete HAL development workflow** is essential for creating custom HALs, supporting hardware-specific functionality, and ensuring Treble compatibility in AOSP.

## Related Topics

- **AIDL-based HALs:** Modern HAL implementation approach
- **Stability annotations:** @VintfStability for HAL interfaces
- **VINTF:** Vendor Interface Object Tree framework
- **VTS (Vendor Test Suite):** Testing HAL implementations

