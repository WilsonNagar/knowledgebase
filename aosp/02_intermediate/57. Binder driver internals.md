---
number: 57
title: Binder driver internals
slug: binder-driver-internals
level: intermediate
tags:
  - aosp
  - binder
  - driver
  - internals
  - kernel
  - transactions
  - memory-management
prerequisites:
  - binder-driver-low-level
  - binder-architecture
  - memory-management-internals
estimated_minutes: 90
contributors: []
diagrams: []
examples: []
canonical_id: aosp-intermediate-57
---

# Binder driver internals

## Overview

Binder driver internals covers the deep internal mechanisms of the Binder driver, including data structures, transaction processing algorithms, memory management, reference counting, and how the driver orchestrates IPC at the kernel level. While "Binder driver (low-level)" covers the driver's role and basic operations, this topic dives into the internal implementation details, algorithms, and data structures that make Binder work. Understanding Binder driver internals is essential for AOSP development, debugging complex IPC issues, performance optimization, and understanding how transactions flow through the system.

Think of Binder driver internals like the detailed engineering blueprints of a complex machine: while you might understand what the machine does (low-level overview), the internals show you exactly how each gear, lever, and mechanism works together - the data structures that store state, the algorithms that process transactions, the memory management that ensures efficiency, and the reference counting that prevents leaks. Understanding these internals lets you debug issues, optimize performance, and truly understand how Binder works.

## Deep Explanation

### Binder Driver Internal Architecture

The Binder driver's internal architecture consists of data structures, algorithms, and mechanisms that work together to provide efficient IPC.

**Key Internal Components:**
- **Data Structures:** binder_proc, binder_node, binder_ref, binder_transaction
- **Transaction Processing:** Queue management, thread selection, transaction routing
- **Memory Management:** Buffer allocation, shared memory, zero-copy optimization
- **Reference Counting:** Object lifecycle, process death handling
- **Thread Management:** Binder thread pool, thread selection

### Core Data Structures

#### binder_proc

**What It Is:**
- Represents a process using Binder
- Created when process opens `/dev/binder`
- Tracks process's Binder state
- Central data structure

**Key Fields:**
```c
struct binder_proc {
    struct hlist_node proc_node;      // Hash list node
    struct rb_root threads;            // Thread tree
    struct rb_root nodes;             // Binder nodes
    struct rb_root refs_by_desc;      // References by descriptor
    struct rb_root refs_by_node;      // References by node
    int pid;                          // Process ID
    struct task_struct *tsk;          // Task structure
    struct files_struct *files;       // File descriptors
    struct binder_alloc alloc;         // Memory allocator
    struct list_head todo;             // Work queue
    // ... more fields
};
```

**Responsibilities:**
- Track all Binder objects in process
- Manage process's Binder threads
- Handle process memory
- Queue pending transactions

#### binder_node

**What It Is:**
- Represents a Binder object (service)
- Created when service registered
- Identified by Binder token
- Lives in server process

**Key Fields:**
```c
struct binder_node {
    int debug_id;                     // Debug ID
    struct binder_work work;         // Work entry
    union {
        struct rb_node rb_node;       // Tree node
        struct hlist_node dead_node;  // Dead node list
    };
    struct binder_proc *proc;         // Owner process
    struct hlist_head refs;           // References to this node
    int internal_strong_refs;         // Internal strong refs
    int local_weak_refs;              // Local weak refs
    int local_strong_refs;            // Local strong refs
    // ... more fields
};
```

**Responsibilities:**
- Represent Binder service object
- Track references to object
- Handle object lifecycle
- Manage reference counting

#### binder_ref

**What It Is:**
- Reference to a binder_node from another process
- Created when client gets Binder token
- Maps descriptor to node
- Lives in client process

**Key Fields:**
```c
struct binder_ref {
    int debug_id;                     // Debug ID
    struct rb_node rb_node_desc;     // Tree by descriptor
    struct rb_node rb_node_node;      // Tree by node
    struct hlist_node node_entry;     // Node's ref list
    struct binder_proc *proc;         // Owner process
    struct binder_node *node;        // Referenced node
    uint32_t desc;                    // Descriptor (handle)
    int strong;                       // Strong reference count
    int weak;                         // Weak reference count
    // ... more fields
};
```

**Responsibilities:**
- Reference remote Binder object
- Map descriptor to node
- Track reference counts
- Handle reference lifecycle

#### binder_transaction

**What It Is:**
- Represents a Binder transaction
- Created when transaction sent
- Queued for processing
- Contains transaction data

**Key Fields:**
```c
struct binder_transaction {
    int debug_id;                     // Debug ID
    struct binder_work work;          // Work entry
    struct binder_thread *from;       // Sending thread
    struct binder_transaction *from_parent;  // Parent transaction
    struct binder_proc *to_proc;      // Target process
    struct binder_thread *to_thread;  // Target thread
    struct binder_node *to_node;      // Target node
    unsigned int code;                // Transaction code
    unsigned int flags;               // Transaction flags
    struct binder_buffer *buffer;     // Transaction buffer
    // ... more fields
};
```

**Responsibilities:**
- Represent transaction
- Link sender and receiver
- Hold transaction data
- Track transaction state

### Transaction Processing

#### Transaction Flow Internals

**1. Transaction Creation:**
```
Client calls service method
  ↓
BpBinder.transact() called
  ↓
IPCThreadState writes transaction data
  ↓
Binder driver receives ioctl(BINDER_WRITE_READ)
  ↓
binder_transaction() creates binder_transaction struct
```

**2. Transaction Routing:**
```
binder_transaction() called
  ↓
Find target binder_node
  ↓
Find target binder_proc
  ↓
Select target binder_thread
  ↓
Queue transaction to thread
```

**3. Transaction Delivery:**
```
Target thread wakes up
  ↓
Processes transaction queue
  ↓
Calls onTransact() on target node
  ↓
Server method executes
  ↓
Reply transaction created
```

**4. Reply Processing:**
```
Reply transaction created
  ↓
Routed back to original thread
  ↓
Client thread wakes up
  ↓
Returns result to caller
```

#### Transaction Queue Management

**Thread Todo Queue:**
- Each binder_thread has todo queue
- Transactions queued to thread
- Thread processes queue sequentially
- FIFO order (typically)

**Queue Operations:**
```c
// Add transaction to queue
list_add_tail(&transaction->work.entry, &thread->todo);

// Process queue
while (!list_empty(&thread->todo)) {
    // Process transaction
}
```

**Thread Selection:**
- Select available thread
- Prefer idle threads
- Create new thread if needed
- Balance load across threads

### Memory Management Internals

#### Binder Buffer Allocation

**Buffer Structure:**
```c
struct binder_buffer {
    struct list_head entry;           // Free/allocated list
    struct rb_node rb_node;           // Tree node
    unsigned free:1;                   // Free flag
    unsigned allow_user_free:1;        // User free allowed
    unsigned async_transaction:1;     // Async transaction
    struct binder_transaction *transaction;  // Associated transaction
    struct binder_node *target_node;  // Target node
    size_t data_size;                 // Data size
    size_t offsets_size;              // Offsets size
    uint8_t *data;                    // Data pointer
    // ... more fields
};
```

**Allocation Process:**
1. Check free buffers
2. Allocate from free list
3. Or allocate new buffer
4. Mark as allocated
5. Associate with transaction

#### Shared Memory Management

**Memory Mapping:**
- Process mmaps `/dev/binder`
- Driver allocates shared memory
- Both user-space and kernel can access
- Zero-copy for small transactions

**Buffer Lifecycle:**
```
Allocation:
  - Allocate buffer from pool
  - Mark as allocated
  - Associate with transaction

Usage:
  - Transaction data written
  - Buffer mapped to target
  - Target reads data

Free:
  - Transaction complete
  - Buffer returned to pool
  - Available for reuse
```

#### Zero-Copy Optimization

**Small Transactions:**
- Transactions < 1KB: zero-copy
- Data stays in kernel buffer
- No copying to userspace
- Very efficient

**Large Transactions:**
- Transactions > 1KB: one copy
- Data copied to target process
- Still efficient (one copy vs two)
- Better than sockets

**Implementation:**
- Buffer allocated in shared memory
- Both processes can access
- No copying needed
- Kernel manages access

### Reference Counting Internals

#### Reference Count Management

**Strong References:**
- Incremented when referenced
- Decremented when released
- Object alive while > 0
- Kernel manages counts

**Weak References:**
- Don't keep object alive
- Tracked separately
- Used for death notifications
- Can be upgraded to strong

**Reference Operations:**
```c
// Increment strong ref
binder_inc_ref(node, 1, 1);

// Decrement strong ref
binder_dec_ref(node, 1);

// Increment weak ref
binder_inc_ref(node, 0, 1);

// Decrement weak ref
binder_dec_ref(node, 0);
```

#### Process Death Handling

**Death Detection:**
- Kernel detects process death
- Cleans up binder_proc
- Releases all references
- Notifies clients

**Death Notification:**
- Clients registered for death
- Kernel sends death notification
- Client can handle gracefully
- Clean up resources

**Cleanup Process:**
```
Process dies
  ↓
Kernel detects (task_struct)
  ↓
binder_proc cleanup
  ↓
Release all binder_nodes
  ↓
Release all binder_refs
  ↓
Notify death recipients
  ↓
Free all buffers
```

### Thread Management Internals

#### Binder Thread Pool

**Thread Creation:**
- Process creates Binder threads
- Threads register with driver
- Driver tracks threads
- Threads process transactions

**Thread Structure:**
```c
struct binder_thread {
    struct binder_proc *proc;         // Owner process
    struct rb_node rb_node;           // Tree node
    int pid;                          // Thread ID
    struct list_head todo;            // Work queue
    struct binder_transaction *transaction_stack;  // Transaction stack
    struct binder_transaction *return_error;       // Return error
    // ... more fields
};
```

**Thread Selection:**
- Select available thread
- Prefer idle threads
- Create if needed
- Balance load

#### Thread State Management

**Thread States:**
- **Idle:** Waiting for work
- **Busy:** Processing transaction
- **Waiting:** Waiting for reply
- **Dead:** Thread terminated

**State Transitions:**
```
Idle → Busy (transaction received)
Busy → Waiting (waiting for reply)
Waiting → Busy (reply received)
Busy → Idle (transaction complete)
```

### Transaction Processing Algorithms

#### Transaction Routing Algorithm

**Step 1: Find Target Node**
```
Get Binder handle from transaction
  ↓
Look up binder_ref by handle
  ↓
Get binder_node from ref
  ↓
Verify node is valid
```

**Step 2: Find Target Process**
```
Get binder_proc from binder_node
  ↓
Verify process is alive
  ↓
Check process permissions
```

**Step 3: Select Target Thread**
```
Check for available threads
  ↓
Prefer idle threads
  ↓
Create thread if needed
  ↓
Select thread
```

**Step 4: Queue Transaction**
```
Create binder_transaction
  ↓
Link to target thread
  ↓
Add to thread's todo queue
  ↓
Wake up thread
```

#### Synchronous Transaction Processing

**Client Side:**
```
1. Send transaction
2. Wait for reply
3. Block until reply received
4. Return result
```

**Server Side:**
```
1. Receive transaction
2. Process transaction
3. Create reply transaction
4. Send reply
5. Continue processing
```

#### Asynchronous Transaction Processing

**One-Way Transactions:**
```
1. Send transaction
2. Don't wait for reply
3. Continue immediately
4. No reply expected
```

**Implementation:**
- FLAG_ONEWAY set
- No reply transaction
- Client doesn't block
- Fire-and-forget

### Security Internals

#### Permission Checking

**Caller Identity:**
- Kernel tracks caller UID/PID
- Available to server
- Server can check permissions
- SELinux context tracked

**Permission Validation:**
```
Transaction received
  ↓
Get caller identity
  ↓
Check SELinux policy
  ↓
Server checks permissions
  ↓
Allow or deny
```

#### SELinux Integration

**Context Tracking:**
- Each process has SELinux context
- Context passed with transaction
- Server can check context
- Policy enforcement

**Policy Checking:**
- Kernel checks SELinux policy
- Allows or denies transaction
- Based on process contexts
- Enforced at kernel level

### Performance Optimizations

#### Transaction Batching

**Batching:**
- Multiple transactions in one ioctl
- Reduces system calls
- Better performance
- Lower overhead

**Implementation:**
- Buffer multiple transactions
- Send in single ioctl
- Process all at once
- Efficient

#### Buffer Reuse

**Buffer Pool:**
- Maintain pool of free buffers
- Reuse when possible
- Reduce allocations
- Better performance

**Allocation Strategy:**
- Check free list first
- Allocate new if needed
- Return to pool when done
- Efficient management

### Debugging Internals

#### Internal State Inspection

**Debug IDs:**
- Each object has debug_id
- Unique identifier
- Used for debugging
- Track object lifecycle

**Debugging Tools:**
- `/proc/binder/` - Debug information
- Binder state dumps
- Transaction traces
- Reference tracking

#### Common Internal Issues

**Memory Leaks:**
- Buffers not freed
- References not released
- Check reference counts
- Verify cleanup

**Transaction Deadlocks:**
- Circular dependencies
- Blocking transactions
- Thread starvation
- Check transaction flow

**Performance Issues:**
- Too many transactions
- Large transaction size
- Thread contention
- Buffer allocation overhead

## Key Takeaways

1. **Binder driver internals** consist of core data structures (binder_proc, binder_node, binder_ref, binder_transaction) that manage IPC state.

2. **Transaction processing** involves routing algorithms that find target nodes, select threads, and queue transactions for delivery.

3. **Memory management** uses shared memory buffers with zero-copy optimization for small transactions and efficient allocation strategies.

4. **Reference counting** manages object lifecycle with strong and weak references, automatically cleaning up on process death.

5. **Thread management** maintains a pool of Binder threads per process, selecting available threads and creating new ones as needed.

6. **Security internals** track caller identity and enforce SELinux policies at the kernel level for transaction authorization.

7. **Performance optimizations** include transaction batching, buffer reuse, and zero-copy mechanisms for efficient IPC.

8. **Understanding Binder driver internals** is essential for debugging complex IPC issues, optimizing performance, and deep AOSP development.

## Related Topics

- **Binder driver (low-level):** Overview of the Binder driver's role and basic operations
- **Binder architecture:** How driver internals fit into overall Binder architecture
- **Memory management internals:** How Binder's memory management relates to kernel memory management
- **BpBinder & BBinder:** How these classes interact with driver internals

