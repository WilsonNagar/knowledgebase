---
number: 92
title: Working with frameworks/native/
slug: working-with-frameworks-native
level: intermediate
tags:
  - aosp
  - native
  - frameworks
  - native-framework
  - native-code
  - aosp-development
prerequisites:
  - building-native-system-components
  - jni-basics
  - android-architecture-complete-overview
estimated_minutes: 85
contributors: []
diagrams: []
examples: []
canonical_id: aosp-intermediate-92
---

# Working with frameworks/native/

## Overview

Working with `frameworks/native/` involves understanding and developing native framework code that provides the native layer of Android's framework, including graphics, input, sensors, and other system services. Understanding how to work with frameworks/native/ is essential for AOSP development, as it explains the native framework structure, common native framework components, how to add new native framework code, how native framework integrates with Java framework, and best practices for native framework development. This guide provides a comprehensive overview of working with frameworks/native/, directory structure, common components, development patterns, and integration.

Think of frameworks/native/ like the foundation and infrastructure of a building: just as a building's foundation (native framework) supports the visible structure (Java framework), frameworks/native/ provides the native infrastructure that supports the Java/Kotlin framework layer. The native framework handles performance-critical operations, system-level functionality, and hardware interactions that the Java framework relies on.

## Deep Explanation

### What is frameworks/native/?

`frameworks/native/` is the directory in AOSP that contains native (C/C++) framework code that provides the native layer of Android's framework, including graphics, input handling, sensors, and other system services.

**Key Characteristics:**
- **Native Code:** C/C++ implementation
- **Framework Layer:** Native framework components
- **System Services:** Native system services
- **Performance-Critical:** High-performance operations

**Why frameworks/native/?**
- **Performance:** Native code performance
- **System Access:** Direct system access
- **Hardware:** Hardware interaction
- **Foundation:** Supports Java framework

### Directory Structure

#### Top-Level Organization

**frameworks/native/ Structure:**
```
frameworks/native/
├── libs/
│   ├── binder/          - Binder IPC library
│   ├── ui/              - UI framework
│   ├── input/           - Input framework
│   ├── sensor/          - Sensor framework
│   └── ...              - Other libraries
├── services/
│   ├── surfaceflinger/  - SurfaceFlinger service
│   ├── inputflinger/    - InputFlinger service
│   └── ...              - Other services
├── opengl/              - OpenGL framework
├── vulkan/              - Vulkan framework
├── include/             - Public headers
└── tools/               - Native framework tools
```

**Key Directories:**
- `libs/` - Native framework libraries
- `services/` - Native system services
- `opengl/` - Graphics framework
- `include/` - Public API headers

#### Libraries Directory

**libs/ Subdirectories:**
- `binder/` - Binder IPC implementation
- `ui/` - UI framework (Surface, Display, etc.)
- `input/` - Input framework
- `sensor/` - Sensor framework
- `gui/` - Graphics UI framework
- `utils/` - Utility libraries

**Library Organization:**
- Each library in its own directory
- Android.bp in each directory
- Public headers in `include/`
- Implementation in `src/` or root

#### Services Directory

**services/ Subdirectories:**
- `surfaceflinger/` - Surface composition service
- `inputflinger/` - Input handling service
- `sensorservice/` - Sensor service
- Other native services

**Service Organization:**
- Each service in its own directory
- Service main in directory
- Android.bp for service
- Init scripts for service

### Common Native Framework Components

#### Graphics Framework

**Graphics Components:**
- Surface management
- Display management
- Window management
- Composition

**Key Libraries:**
- `libui` - UI framework
- `libgui` - Graphics UI
- `libEGL` - EGL interface
- `libGLESv2` - OpenGL ES

**Components:**
```cpp
// Surface management
class Surface;
class SurfaceControl;

// Display management
class Display;
class DisplayInfo;

// Composition
class CompositionEngine;
```

#### Input Framework

**Input Components:**
- Input event handling
- Touch input
- Keyboard input
- Input device management

**Key Libraries:**
- `libinput` - Input framework
- `libinputflinger` - Input service

**Components:**
```cpp
// Input events
class InputEvent;
class KeyEvent;
class MotionEvent;

// Input devices
class InputDevice;
class InputReader;
```

#### Sensor Framework

**Sensor Components:**
- Sensor data handling
- Sensor device management
- Sensor event processing

**Key Libraries:**
- `libsensor` - Sensor framework
- `libsensorservice` - Sensor service

**Components:**
```cpp
// Sensor events
class SensorEvent;
class Sensor;

// Sensor service
class SensorService;
```

### Development Patterns

#### Library Development

**Creating a Native Library:**
```blueprint
// frameworks/native/libs/mymodule/Android.bp
cc_library_shared {
    name: "libmymodule",
    srcs: [
        "src/file1.cpp",
        "src/file2.cpp",
    ],
    shared_libs: [
        "liblog",
        "libutils",
        "libbinder",
    ],
    export_include_dirs: ["include"],
    vendor: false,
}
```

**Directory Structure:**
```
frameworks/native/libs/mymodule/
├── Android.bp
├── include/
│   └── mymodule.h
└── src/
    ├── file1.cpp
    └── file2.cpp
```

#### Service Development

**Creating a Native Service:**
```blueprint
// frameworks/native/services/myservice/Android.bp
cc_binary {
    name: "myservice",
    srcs: ["main.cpp", "service.cpp"],
    shared_libs: [
        "liblog",
        "libbinder",
        "libutils",
    ],
    init_rc: ["myservice.rc"],
}
```

**Service Structure:**
```
frameworks/native/services/myservice/
├── Android.bp
├── myservice.rc
├── main.cpp
└── service.cpp
```

### Integration with Java Framework

#### JNI Integration

**JNI Bridge:**
- Java framework calls native code
- JNI functions bridge calls
- Native implementation in frameworks/native/
- Seamless integration

**Example:**
```java
// Java framework
public class Surface {
    private native long nativeCreate();
}

// Native implementation (frameworks/native/)
JNIEXPORT jlong JNICALL
Java_android_view_Surface_nativeCreate(JNIEnv *env, jobject thiz) {
    // Native implementation
    return (jlong)new Surface();
}
```

#### Binder Integration

**Binder Services:**
- Native services use Binder
- Java framework accesses via Binder
- AIDL interfaces
- IPC communication

**Example:**
```cpp
// Native service
class MyService : public BnMyService {
    // Binder implementation
};

// Java framework accesses via Binder
IMyService service = IMyService.Stub.asInterface(binder);
```

### Common Native Framework APIs

#### UI Framework APIs

**Surface APIs:**
```cpp
// Surface creation
sp<Surface> surface = new Surface();

// Surface operations
surface->lock(&buffer);
surface->unlockAndPost();
```

**Display APIs:**
```cpp
// Display management
DisplayManager& dm = DisplayManager::getInstance();
sp<Display> display = dm.getDisplay(0);
```

#### Input Framework APIs

**Input Event Handling:**
```cpp
// Input event processing
class InputListener {
    virtual void notifyInput(const NotifyInputArgs& args) = 0;
};

// Input device management
InputDevice* device = getInputDevice(deviceId);
```

### Build Integration

#### Building Native Framework

**Build Commands:**
```bash
# Build specific library
m libui

# Build all native framework
m native

# Build native service
m surfaceflinger
```

**Build Output:**
- Libraries in `/system/lib64/`
- Services in `/system/bin/`
- Headers available for inclusion

#### Module Dependencies

**Framework Dependencies:**
```blueprint
shared_libs: [
    "liblog",      // Logging
    "libutils",    // Utilities
    "libbinder",   // Binder IPC
    "libui",       // UI framework
    "libbase",     // Base library
],
```

**Common Dependencies:**
- `liblog` - Logging
- `libutils` - Utilities
- `libbinder` - Binder IPC
- `libbase` - Base library
- Framework-specific libraries

### Best Practices

#### Code Organization

**Organization Principles:**
- Clear module boundaries
- Separate headers and implementation
- Modular design
- Clear interfaces

**Structure:**
```
module/
├── Android.bp
├── include/
│   └── public_api.h
├── src/
│   └── implementation.cpp
└── tests/
    └── test.cpp
```

#### API Design

**API Design Principles:**
- Stable public APIs
- Clear interfaces
- Documented APIs
- Version management

**Public Headers:**
- In `include/` directory
- Exported via `export_include_dirs`
- Stable API surface
- Documented

#### Performance

**Performance Considerations:**
- Minimize JNI crossings
- Efficient memory usage
- Optimize hot paths
- Profile and optimize

**Optimization:**
- Use native code for performance
- Minimize allocations
- Cache frequently used data
- Optimize critical paths

### Common Components

#### SurfaceFlinger

**SurfaceFlinger Service:**
- Surface composition
- Display management
- Graphics composition
- Native graphics service

**Location:**
- `frameworks/native/services/surfaceflinger/`
- Core graphics service
- Performance-critical

#### InputFlinger

**InputFlinger Service:**
- Input event processing
- Input device management
- Input event distribution
- Native input service

**Location:**
- `frameworks/native/services/inputflinger/`
- Core input service
- Real-time processing

#### Binder Library

**Binder Framework:**
- Binder IPC implementation
- Native Binder support
- Binder services
- IPC infrastructure

**Location:**
- `frameworks/native/libs/binder/`
- Core IPC library
- System-wide usage

### Debugging Native Framework

#### Common Issues

**Development Issues:**
- Build errors
- Link errors
- Runtime crashes
- Integration issues

**Debugging:**
```bash
# Check build
m libmymodule

# Check logs
adb logcat | grep MyModule

# Check library
adb shell ls -l /system/lib64/libmymodule.so
```

#### Testing

**Testing Native Framework:**
- Unit tests
- Integration tests
- System tests
- Performance tests

**Test Structure:**
```
module/
└── tests/
    ├── Android.bp
    └── test.cpp
```

## Key Takeaways

1. **frameworks/native/** is the directory containing native (C/C++) framework code that provides the native layer of Android's framework, including graphics, input, sensors, and system services.

2. **Directory structure** includes `libs/` (native framework libraries), `services/` (native system services), `opengl/` (graphics framework), and `include/` (public headers).

3. **Common native framework components** include graphics framework (Surface, Display), input framework (InputEvent, InputDevice), and sensor framework (SensorEvent, SensorService).

4. **Development patterns** include library development (cc_library_shared modules) and service development (cc_binary modules with init scripts), following AOSP conventions.

5. **Integration with Java framework** uses JNI bridges (Java calls native) and Binder IPC (native services accessible from Java), enabling seamless framework integration.

6. **Common native framework APIs** include UI framework APIs (Surface, Display), input framework APIs (InputEvent, InputDevice), and system service APIs.

7. **Build integration** uses Soong/Android.bp with common dependencies (liblog, libutils, libbinder), building libraries and services that integrate into the system.

8. **Understanding working with frameworks/native/** is essential for AOSP development, explaining how native framework code is organized, developed, and integrated with the Java framework to provide complete Android framework functionality.

## Related Topics

- **Building native system components:** How to build native code in AOSP
- **JNI basics:** How Java and native code interact
- **Native shared libraries:** Output format of native framework builds
- **Android Architecture - Complete Overview:** How native framework fits into overall architecture

