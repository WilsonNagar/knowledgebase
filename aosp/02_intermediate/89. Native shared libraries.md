---
number: 89
title: Native shared libraries
slug: native-shared-libraries
level: intermediate
tags:
  - aosp
  - native
  - shared-libraries
  - so-files
  - dynamic-linking
  - native-libs
prerequisites:
  - jni-basics
  - android-architecture-complete-overview
estimated_minutes: 85
contributors: []
diagrams: []
examples: []
canonical_id: aosp-intermediate-89
---

# Native shared libraries

## Overview

Native shared libraries are compiled C/C++ code packaged as `.so` (shared object) files that can be loaded and used by Android applications and system components. Understanding native shared libraries is essential for AOSP development, as it explains how native code is packaged, how libraries are loaded, how symbols are resolved, how libraries are organized in Android, and how they integrate with the Java/Kotlin layer through JNI. This guide provides a comprehensive overview of native shared libraries, library structure, loading mechanisms, symbol resolution, and Android-specific considerations.

Think of native shared libraries like a toolbox: just as a toolbox contains tools that can be used by different projects, a shared library contains functions that can be used by different applications. Multiple applications can use the same library, sharing the code in memory, which is efficient and allows code reuse. The library is loaded when needed and can be shared across processes.

## Deep Explanation

### What are Native Shared Libraries?

Native shared libraries are compiled C/C++ code packaged as shared object (`.so`) files that contain functions, data, and symbols that can be dynamically loaded and linked at runtime by applications or other libraries.

**Key Characteristics:**
- **Shared:** Multiple processes can use same library
- **Dynamic:** Loaded at runtime
- **Reusable:** Code shared across applications
- **Efficient:** Memory-efficient code sharing

**Why Shared Libraries?**
- **Code Reuse:** Same code used by multiple apps
- **Memory Efficiency:** Shared memory pages
- **Modularity:** Separate compilation units
- **Updates:** Update library without recompiling apps

### Library File Format

#### ELF Format

**ELF (Executable and Linkable Format):**
- Standard format for shared libraries
- Contains code, data, symbols
- Architecture-specific
- Loadable by dynamic linker

**ELF Structure:**
```
┌─────────────────────────────────┐
│      ELF Header                 │
│  - Magic number                 │
│  - Architecture                 │
│  - Entry point                  │
├─────────────────────────────────┤
│      Program Headers            │
│  - Loadable segments            │
│  - Memory layout                │
├─────────────────────────────────┤
│      Sections                   │
│  - .text (code)                 │
│  - .data (initialized data)     │
│  - .bss (uninitialized data)    │
│  - .rodata (read-only data)     │
│  - .symtab (symbol table)       │
│  - .dynsym (dynamic symbols)    │
├─────────────────────────────────┤
│      String Table               │
│  - Symbol names                 │
│  - Section names                │
└─────────────────────────────────┘
```

#### Library Naming

**Naming Convention:**
- `lib<name>.so` - Shared library
- `lib<name>.so.<version>` - Versioned library
- Example: `libmylib.so`, `libmylib.so.1`

**Android Convention:**
- `lib<name>.so` - Standard name
- Loaded via `System.loadLibrary("name")`
- Searches for `libname.so`

### Library Loading

#### Dynamic Loading

**Load Process:**
```
1. Application requests library
2. Dynamic linker searches paths
3. Library file found
4. Library loaded into memory
5. Symbols resolved
6. Library ready to use
```

**Loading Methods:**
- `System.loadLibrary()` - Load by name
- `System.load()` - Load by path
- `dlopen()` - Native loading

#### System.loadLibrary()

**Java Loading:**
```java
public class MyClass {
    static {
        // Load native library
        System.loadLibrary("mylib");
        // Searches for libmylib.so
    }
}
```

**Search Paths:**
- App's native library directory
- System library directories
- Architecture-specific paths

#### Native Loading

**dlopen() Loading:**
```c
#include <dlfcn.h>

void *handle = dlopen("libmylib.so", RTLD_LAZY);
if (handle) {
    // Library loaded
    void (*func)() = dlsym(handle, "function_name");
    if (func) {
        func();
    }
    dlclose(handle);
}
```

### Library Paths

#### Application Libraries

**App Library Path:**
- `/data/app/<package>/lib/<arch>/`
- Per-app directory
- Architecture-specific
- APK native libraries

**Structure:**
```
/data/app/com.example.app-<hash>/lib/
├── arm64/
│   └── libmylib.so
└── armeabi-v7a/
    └── libmylib.so
```

#### System Libraries

**System Library Paths:**
- `/system/lib/` - 32-bit libraries
- `/system/lib64/` - 64-bit libraries
- `/vendor/lib/` - Vendor libraries
- `/vendor/lib64/` - Vendor 64-bit libraries

**System Libraries:**
- Framework libraries
- HAL libraries
- System services
- Core system components

### Symbol Resolution

#### Symbol Types

**Exported Symbols:**
- Functions callable from outside
- Data accessible externally
- Marked as exported
- In symbol table

**Internal Symbols:**
- Functions used internally
- Not exported
- Hidden from external access
- Static functions

#### Symbol Visibility

**Default Visibility:**
- Symbols exported by default
- Visible to other libraries
- Can be linked against

**Hidden Visibility:**
```c
// Hide symbol
__attribute__((visibility("hidden")))
void internal_function() {
    // Not exported
}
```

**Default Visibility:**
```c
// Export symbol (default)
void exported_function() {
    // Exported
}
```

### Library Dependencies

#### Dependency Resolution

**Dependencies:**
- Libraries can depend on other libraries
- Dynamic linker resolves dependencies
- Loads dependencies automatically
- Resolves symbols

**Dependency Chain:**
```
App
  └── libapp.so
      └── libdependency.so
          └── libsystem.so
```

#### DT_NEEDED

**Dependency Declaration:**
```c
// Library declares dependencies
// In ELF: DT_NEEDED entries
// libmylib.so needs libsystem.so
```

**Resolution:**
1. Load requested library
2. Check dependencies (DT_NEEDED)
3. Load dependencies recursively
4. Resolve all symbols
5. Complete loading

### Android-Specific Considerations

#### Architecture Support

**Multi-Architecture:**
- ARM (32-bit)
- ARM64 (64-bit)
- x86 (32-bit)
- x86_64 (64-bit)

**APK Structure:**
```
APK
├── lib/
│   ├── armeabi-v7a/
│   │   └── libmylib.so
│   ├── arm64-v8a/
│   │   └── libmylib.so
│   ├── x86/
│   │   └── libmylib.so
│   └── x86_64/
│       └── libmylib.so
```

#### NDK Libraries

**NDK Libraries:**
- Built with Android NDK
- Use Bionic libc
- Android-specific APIs
- Architecture-specific

**NDK Build:**
```makefile
# Android.mk
LOCAL_MODULE := mylib
LOCAL_SRC_FILES := mylib.c
include $(BUILD_SHARED_LIBRARY)
```

### Library Lifecycle

#### Loading Phase

**Load Time:**
- Library loaded into memory
- Segments mapped
- Initialization code runs
- Ready for use

**Initialization:**
```c
// Constructor (runs on load)
__attribute__((constructor))
void init_library() {
    // Initialization code
}
```

#### Runtime Phase

**Runtime:**
- Functions called
- Symbols resolved
- Memory accessed
- Active use

#### Unloading Phase

**Unload Time:**
- Library unloaded
- Destructor runs
- Memory freed
- Resources cleaned

**Destructor:**
```c
// Destructor (runs on unload)
__attribute__((destructor))
void cleanup_library() {
    // Cleanup code
}
```

### Library Best Practices

#### Naming

**Good Naming:**
- Descriptive names
- Consistent naming
- Version information
- Clear purpose

**Example:**
- `libcamera_client.so` - Clear purpose
- `libmedia.so` - Media library
- `libutils.so` - Utilities

#### Versioning

**Library Versioning:**
- Major version changes
- ABI compatibility
- Symbol versioning
- Backward compatibility

**Versioned Libraries:**
- `libmylib.so.1` - Version 1
- `libmylib.so.2` - Version 2
- Symbol versioning

#### Dependencies

**Minimize Dependencies:**
- Reduce library dependencies
- Avoid circular dependencies
- Clear dependency tree
- Efficient loading

### Debugging Libraries

#### Library Inspection

**Inspection Tools:**
```bash
# View library symbols
nm -D libmylib.so

# View library dependencies
readelf -d libmylib.so | grep NEEDED

# View library information
file libmylib.so
```

#### Loading Issues

**Common Issues:**
- Library not found
- Symbol not found
- Architecture mismatch
- Dependency missing

**Debugging:**
```bash
# Check library paths
adb shell ls -l /data/app/*/lib/*/

# Check loaded libraries
adb shell cat /proc/<pid>/maps | grep .so

# Check library dependencies
readelf -d libmylib.so
```

## Key Takeaways

1. **Native shared libraries** are compiled C/C++ code packaged as `.so` files that can be dynamically loaded and used by multiple applications, providing code reuse and memory efficiency.

2. **Library file format** uses ELF (Executable and Linkable Format) containing code, data, symbols, and metadata, with architecture-specific compilation.

3. **Library loading** happens dynamically at runtime using `System.loadLibrary()` in Java or `dlopen()` in native code, with the dynamic linker searching library paths and resolving dependencies.

4. **Library paths** include application-specific paths (`/data/app/<package>/lib/<arch>/`) and system paths (`/system/lib/`, `/vendor/lib/`), with architecture-specific directories.

5. **Symbol resolution** involves exported symbols (visible externally) and internal symbols (hidden), with the dynamic linker resolving symbols and dependencies automatically.

6. **Android-specific considerations** include multi-architecture support (ARM, ARM64, x86, x86_64), NDK libraries using Bionic libc, and architecture-specific library directories in APKs.

7. **Library lifecycle** includes loading phase (initialization), runtime phase (active use), and unloading phase (cleanup), with constructors and destructors for initialization and cleanup.

8. **Understanding native shared libraries** is essential for AOSP development, explaining how native code is packaged, loaded, and integrated with the Java/Kotlin layer through JNI, enabling performance-critical operations and system-level functionality.

## Related Topics

- **JNI basics:** How Java code interacts with native libraries
- **Loading libs from system partitions:** System library loading mechanisms
- **AIDL NDK:** Native AIDL interfaces using shared libraries
- **Android Architecture - Complete Overview:** How native libraries fit into overall architecture

