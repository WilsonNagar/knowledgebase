---
number: 60
title: Object reference counting
slug: object-reference-counting
level: intermediate
tags:
  - aosp
  - binder
  - reference-counting
  - lifecycle
  - memory-management
  - sp
  - wp
prerequisites:
  - bpbinder-bbinder
  - binder-driver-internals
  - binder-architecture
estimated_minutes: 80
contributors: []
diagrams: []
examples: []
canonical_id: aosp-intermediate-60
---

# Object reference counting

## Overview

Object reference counting is the mechanism by which Binder objects manage their lifecycle, tracking how many references exist to an object and automatically destroying the object when the last reference is released. Understanding reference counting is essential for AOSP development, as it's fundamental to Binder object lifecycle, prevents memory leaks, handles process death gracefully, and ensures objects are only destroyed when safe. This guide provides a comprehensive overview of Binder reference counting, strong and weak references, the sp<> and wp<> smart pointers, reference counting operations, and how it all works together.

Think of reference counting like a library book checkout system: just as a library book can't be discarded while someone has it checked out, a Binder object can't be destroyed while someone has a reference to it. Each time someone checks out the book (gets a reference), the count goes up. When they return it (release the reference), the count goes down. When the count reaches zero (no one has it checked out), the book can be discarded (object destroyed). This ensures the object exists as long as it's needed and is cleaned up when no longer needed.

## Deep Explanation

### What is Reference Counting?

Reference counting is a memory management technique where objects track how many references point to them. When the reference count reaches zero, the object is automatically destroyed.

**Key Characteristics:**
- **Automatic:** Objects manage their own lifecycle
- **Thread-Safe:** Reference counting is atomic
- **Efficient:** Low overhead
- **Safe:** Prevents use-after-free

**Why Reference Counting?**
- **Memory Safety:** Prevents premature destruction
- **Automatic Cleanup:** No manual memory management
- **Process Death:** Handles remote process death
- **Leak Prevention:** Automatic resource cleanup

### Reference Counting in Binder

#### How It Works

**Basic Mechanism:**
1. Object created with reference count = 1
2. Each new reference increments count
3. Each released reference decrements count
4. When count reaches 0, object destroyed

**Reference Types:**
- **Strong References:** Keep object alive
- **Weak References:** Don't keep object alive
- **Local References:** In same process
- **Remote References:** In different process

#### Strong References

**What They Are:**
- References that keep object alive
- Increment strong reference count
- Object destroyed when count = 0
- Standard reference type

**Characteristics:**
- Object alive while strong refs > 0
- Automatic cleanup on last release
- Thread-safe operations
- Kernel-managed for remote objects

**Usage:**
```cpp
// Create strong reference
sp<IBinder> binder = new BpBinder(handle);  // Count = 1

// Another strong reference
sp<IBinder> binder2 = binder;  // Count = 2

// Release reference
binder = nullptr;  // Count = 1

// Release last reference
binder2 = nullptr;  // Count = 0, object destroyed
```

#### Weak References

**What They Are:**
- References that don't keep object alive
- Increment weak reference count
- Don't prevent object destruction
- Used for death notifications

**Characteristics:**
- Object can be destroyed even with weak refs
- Can be promoted to strong reference
- Used for observing object lifecycle
- Don't prevent cleanup

**Usage:**
```cpp
// Create strong reference
sp<IBinder> binder = new BpBinder(handle);

// Create weak reference
wp<IBinder> weakBinder = binder;  // Weak count = 1, strong count = 1

// Release strong reference
binder = nullptr;  // Strong count = 0, object may be destroyed

// Try to promote weak to strong
sp<IBinder> strongBinder = weakBinder.promote();
if (strongBinder != nullptr) {
    // Object still alive, use it
} else {
    // Object destroyed
}
```

### Smart Pointers

#### sp<> (Strong Pointer)

**What It Is:**
- C++ smart pointer for strong references
- Automatic reference counting
- Thread-safe operations
- Automatic cleanup

**Usage:**
```cpp
// Create object with sp<>
sp<IBinder> binder = new BpBinder(handle);

// Copy increases reference count
sp<IBinder> binder2 = binder;  // Both point to same object

// Assignment
binder = binder2;  // Reference count managed automatically

// Automatic cleanup when out of scope
// Object destroyed when last sp<> released
```

**Operations:**
- `sp<T> ptr = new T()` - Create with count = 1
- `sp<T> ptr2 = ptr` - Copy, count++
- `ptr = nullptr` - Release, count--
- Automatic destruction when count = 0

#### wp<> (Weak Pointer)

**What It Is:**
- C++ smart pointer for weak references
- Doesn't keep object alive
- Can be promoted to strong
- Used for observation

**Usage:**
```cpp
// Create strong reference
sp<IBinder> binder = new BpBinder(handle);

// Create weak reference
wp<IBinder> weakBinder = binder;

// Promote to strong
sp<IBinder> strongBinder = weakBinder.promote();
if (strongBinder != nullptr) {
    // Object still alive
} else {
    // Object destroyed
}
```

**Operations:**
- `wp<T> weak = strong` - Create weak reference
- `sp<T> strong = weak.promote()` - Promote to strong
- `weak = nullptr` - Release weak reference
- Object can be destroyed even with weak refs

### Reference Counting Operations

#### Incrementing References

**Strong Reference:**
```cpp
// Automatic with sp<>
sp<IBinder> binder1 = new BpBinder(handle);  // Count = 1
sp<IBinder> binder2 = binder1;  // Count = 2

// Manual (rarely needed)
binder->incStrong(nullptr);  // Increment manually
```

**Weak Reference:**
```cpp
// Automatic with wp<>
wp<IBinder> weak = binder;  // Weak count = 1

// Manual (rarely needed)
binder->incWeak(nullptr);  // Increment weak manually
```

#### Decrementing References

**Strong Reference:**
```cpp
// Automatic with sp<>
sp<IBinder> binder = ...;
binder = nullptr;  // Decrements count, destroys if 0

// Manual (rarely needed)
binder->decStrong(nullptr);  // Decrement manually
```

**Weak Reference:**
```cpp
// Automatic with wp<>
wp<IBinder> weak = ...;
weak = nullptr;  // Decrements weak count

// Manual (rarely needed)
binder->decWeak(nullptr);  // Decrement weak manually
```

### Kernel-Level Reference Counting

#### Remote Object References

**How It Works:**
- Kernel tracks references to remote objects
- Each process has its own reference count
- Kernel manages cross-process references
- Automatic cleanup on process death

**Reference Structure:**
```c
struct binder_ref {
    int strong;    // Strong reference count
    int weak;      // Weak reference count
    // ... more fields
};
```

**Operations:**
- Client gets Binder handle → kernel increments ref
- Client releases handle → kernel decrements ref
- Process dies → kernel releases all refs
- Object destroyed when all refs released

#### Process Death Handling

**Death Detection:**
```
Process dies
  ↓
Kernel detects (task_struct)
  ↓
Cleanup binder_proc
  ↓
Release all binder_refs
  ↓
Decrement reference counts
  ↓
Destroy objects if count = 0
```

**Death Notification:**
- Clients can register death recipients
- Kernel notifies when process dies
- Clients can clean up references
- Automatic reference cleanup

### Reference Counting Patterns

#### Service Registration

**Service Side:**
```cpp
// Service creates object
sp<IMyService> service = new MyService();

// Register with ServiceManager
// ServiceManager holds reference
ServiceManager::addService("my_service", service);

// Service object kept alive by ServiceManager reference
// Destroyed when ServiceManager releases reference
```

**Client Side:**
```cpp
// Get service
sp<IBinder> binder = ServiceManager::getService("my_service");
sp<IMyService> service = interface_cast<IMyService>(binder);

// Client holds reference
// Service kept alive while client has reference
// Released when client releases
```

#### Callback Pattern

**Registering Callback:**
```cpp
// Client creates callback
sp<IMyCallback> callback = new MyCallback();

// Register with service
service->registerCallback(callback);

// Service holds reference to callback
// Callback kept alive by service
// Released when service releases or service dies
```

**Unregistering Callback:**
```cpp
// Unregister callback
service->unregisterCallback(callback);

// Service releases reference
// Callback may be destroyed if no other refs
```

### Reference Counting Best Practices

#### Avoiding Leaks

**Release References:**
```cpp
// GOOD: Automatic with sp<>
{
    sp<IBinder> binder = getBinder();
    // Use binder
}  // Automatically released

// BAD: Manual management (error-prone)
IBinder* binder = getBinder();
// Must remember to release
// Easy to forget, causes leaks
```

**Circular References:**
```cpp
// BAD: Circular reference
class A {
    sp<B> b;
};

class B {
    sp<A> a;  // Circular reference!
};

// Objects never destroyed
// Use weak references to break cycle
```

**Breaking Cycles:**
```cpp
// GOOD: Use weak reference
class A {
    sp<B> b;
};

class B {
    wp<A> a;  // Weak reference breaks cycle
};
```

#### Process Death Handling

**Death Recipients:**
```cpp
class MyDeathRecipient : public IBinder::DeathRecipient {
    virtual void binderDied(const wp<IBinder>& who) {
        // Handle death
        // Clean up references
        // Reconnect if needed
    }
};

sp<DeathRecipient> recipient = new MyDeathRecipient();
binder->linkToDeath(recipient, nullptr, 0);
```

**Automatic Cleanup:**
- Kernel automatically releases references
- Objects destroyed when appropriate
- Death recipients notified
- Clients can handle gracefully

### Reference Counting Internals

#### Object Lifecycle

**Creation:**
```
Object created
  ↓
Reference count = 1
  ↓
Object alive
```

**Reference:**
```
New reference created
  ↓
Reference count++
  ↓
Object still alive
```

**Release:**
```
Reference released
  ↓
Reference count--
  ↓
If count == 0: destroy object
Else: object still alive
```

#### Thread Safety

**Atomic Operations:**
- Reference counting uses atomic operations
- Thread-safe increment/decrement
- No race conditions
- Safe for concurrent access

**Implementation:**
```cpp
// Atomic increment
atomic_inc(&refCount);

// Atomic decrement
if (atomic_dec_and_test(&refCount)) {
    // Last reference, destroy object
    delete this;
}
```

### Common Patterns

#### Service Lifecycle

**Service Creation:**
```cpp
// Service created
sp<MyService> service = new MyService();  // Count = 1

// Registered with ServiceManager
ServiceManager::addService("service", service);  // ServiceManager holds ref

// Service kept alive by ServiceManager
// Clients get references
// Service destroyed when ServiceManager releases and no clients
```

**Client Usage:**
```cpp
// Client gets service
sp<IMyService> service = getService();  // Client holds ref

// Service kept alive while client has ref
// Released when client releases
// Service destroyed if no other refs
```

#### Object Sharing

**Sharing Between Components:**
```cpp
// Create object
sp<MyObject> obj = new MyObject();  // Count = 1

// Share with component A
componentA->setObject(obj);  // Count = 2

// Share with component B
componentB->setObject(obj);  // Count = 3

// Release from A
componentA->setObject(nullptr);  // Count = 2

// Release from B
componentB->setObject(nullptr);  // Count = 1

// Release original
obj = nullptr;  // Count = 0, destroyed
```

### Debugging Reference Counting

#### Common Issues

**Memory Leaks:**
- Objects not destroyed
- Reference count never reaches 0
- Check for circular references
- Verify references released

**Use-After-Free:**
- Object destroyed while still referenced
- Check reference counting
- Verify object lifecycle
- Use weak references appropriately

**Premature Destruction:**
- Object destroyed too early
- Check reference counts
- Verify references held
- Review object lifecycle

#### Debugging Tools

**Reference Count Inspection:**
```cpp
// Check reference count (if available)
int refCount = binder->getStrongCount();

// Debug output
ALOGD("Reference count: %d", refCount);
```

**Binder State:**
```bash
# View Binder state
adb shell dumpsys binder
```

## Key Takeaways

1. **Reference counting manages Binder object lifecycle** by tracking how many references exist and destroying objects when the count reaches zero.

2. **Strong references (sp<>)** keep objects alive, while **weak references (wp<>)** don't prevent destruction but can be promoted to strong.

3. **Reference counting is automatic** with smart pointers (sp<> and wp<>), handling increment/decrement and cleanup automatically.

4. **Kernel manages remote object references** across processes, automatically cleaning up when processes die.

5. **Death recipients** allow clients to be notified when remote objects die, enabling graceful cleanup and reconnection.

6. **Circular references can cause memory leaks** and should be broken using weak references.

7. **Reference counting is thread-safe** using atomic operations, allowing safe concurrent access.

8. **Understanding reference counting** is essential for AOSP development, preventing memory leaks, and managing Binder object lifecycles correctly.

## Related Topics

- **BpBinder & BBinder:** How reference counting is used in Binder objects
- **Binder driver internals:** How kernel manages reference counting
- **Binder architecture:** How reference counting fits into overall architecture
- **Memory management internals:** How reference counting relates to kernel memory management

