---
number: 82
title: 'Garbage collectors (CMS, G1, generational)'
slug: garbage-collectors-cms-g1-generational
level: intermediate
tags:
  - aosp
  - art
  - garbage-collection
  - gc
  - cms
  - g1
  - generational
  - memory-management
prerequisites:
  - dalvik-vs-art
  - aot-jit-compilation
estimated_minutes: 90
contributors: []
diagrams: []
examples: []
canonical_id: aosp-intermediate-82
---

# Garbage collectors (CMS, G1, generational)

## Overview

Garbage collectors in ART (Android Runtime) automatically manage memory by reclaiming unused objects. Understanding garbage collectors is essential for AOSP development, as it explains how Android manages memory, the different GC algorithms (CMS, G1, generational), their characteristics, trade-offs, and how they impact application performance. This guide provides a comprehensive overview of garbage collectors in ART, including CMS (Concurrent Mark-Sweep), G1 (Garbage-First), generational collection, and their evolution across Android versions.

Think of garbage collectors like automatic waste management: just as a waste management system automatically collects and disposes of garbage, garbage collectors automatically identify and free memory that's no longer in use. Different collection strategies (CMS, G1, generational) are like different waste collection methods - some are faster but less thorough, others are more thorough but take longer, and the best choice depends on the situation.

## Deep Explanation

### What is Garbage Collection?

Garbage collection is the automatic memory management system in ART that identifies and reclaims memory occupied by objects that are no longer reachable or in use.

**Key Characteristics:**
- **Automatic:** No manual memory management
- **Reclamation:** Frees unused memory
- **Pause Times:** Brief pauses during collection
- **Efficiency:** Optimized for mobile devices

**Why Garbage Collection?**
- **Memory Safety:** Prevents memory leaks
- **Developer Productivity:** No manual memory management
- **Reliability:** Automatic cleanup
- **Performance:** Optimized memory usage

### Garbage Collection Basics

#### Object Lifecycle

**Allocation:**
```java
// Object allocated on heap
MyObject obj = new MyObject();
```

**Usage:**
```java
// Object used
obj.doSomething();
```

**Reclamation:**
```java
// Object becomes unreachable
obj = null;  // GC can now collect
```

#### Reachability

**Root Set:**
- Static variables
- Stack variables (local variables)
- Thread-local variables
- JNI references

**Reachability:**
- Objects reachable from root set are alive
- Objects not reachable are garbage
- GC marks reachable objects
- GC reclaims unreachable objects

### Generational Garbage Collection

#### What is Generational GC?

Generational GC divides the heap into generations (young and old) based on object age, collecting young generation more frequently than old generation.

**Key Insight:**
- Most objects die young
- Long-lived objects are rare
- Young generation is small
- Old generation is large

**Why Generational?**
- **Efficiency:** Collect young generation frequently (fast)
- **Thoroughness:** Collect old generation less frequently (slower but thorough)
- **Performance:** Better overall performance
- **Pause Times:** Shorter average pause times

#### Heap Organization

**Generational Heap:**
```
┌─────────────────────────────────┐
│      Young Generation            │
│  ┌──────────┐  ┌──────────┐    │
│  │  Eden    │  │ Survivor │    │
│  │  Space   │  │  Space   │    │
│  └──────────┘  └──────────┘    │
├─────────────────────────────────┤
│      Old Generation              │
│  ┌──────────────────────────┐  │
│  │   Tenured Space           │  │
│  └──────────────────────────┘  │
└─────────────────────────────────┘
```

**Young Generation:**
- **Eden Space:** New objects allocated here
- **Survivor Space:** Objects that survive GC
- **Small:** Typically 10-20% of heap
- **Frequent Collection:** Collected often (fast)

**Old Generation:**
- **Tenured Space:** Long-lived objects
- **Large:** Typically 80-90% of heap
- **Infrequent Collection:** Collected less often (slower)

#### Generational Collection Process

**Young Generation GC:**
```
1. New objects allocated in Eden
2. Eden fills up
3. Young GC triggered
4. Mark reachable objects
5. Copy survivors to Survivor Space
6. Clear Eden
7. Repeat
```

**Promotion:**
```
1. Object survives multiple young GCs
2. Object promoted to Old Generation
3. Object lives in Old Generation
4. Collected by full GC
```

**Full GC:**
```
1. Old Generation fills up
2. Full GC triggered
3. Mark all reachable objects
4. Sweep unreachable objects
5. Compact heap (optional)
```

### CMS (Concurrent Mark-Sweep)

#### What is CMS?

CMS (Concurrent Mark-Sweep) is a garbage collection algorithm that performs most of its work concurrently with application execution, minimizing pause times.

**Key Characteristics:**
- **Concurrent:** Most work concurrent with app
- **Low Pause Times:** Minimal application pauses
- **Mark-Sweep:** Marks and sweeps garbage
- **No Compaction:** Doesn't compact heap

**Why CMS?**
- **Low Latency:** Short pause times
- **Interactive Apps:** Good for UI responsiveness
- **Concurrent:** Doesn't stop app for long
- **Predictable:** Predictable pause times

#### CMS Process

**CMS Phases:**
```
1. Initial Mark (STW - Stop The World)
   └── Mark root objects
   └── Brief pause

2. Concurrent Mark
   └── Mark reachable objects
   └── Concurrent with app

3. Remark (STW)
   └── Finalize marking
   └── Brief pause

4. Concurrent Sweep
   └── Reclaim garbage
   └── Concurrent with app
```

**Stop-The-World (STW) Phases:**
- **Initial Mark:** Brief pause to mark roots
- **Remark:** Brief pause to finalize marking
- **Total Pause:** Usually < 10ms

**Concurrent Phases:**
- **Concurrent Mark:** Marks objects while app runs
- **Concurrent Sweep:** Reclaims memory while app runs

#### CMS Characteristics

**Advantages:**
- Low pause times
- Concurrent operation
- Good for interactive apps
- Predictable pauses

**Disadvantages:**
- No compaction (fragmentation)
- CPU overhead (concurrent work)
- More complex
- May not collect all garbage

### G1 (Garbage-First) Garbage Collector

#### What is G1?

G1 (Garbage-First) is a garbage collector that divides the heap into regions and collects regions with the most garbage first, providing predictable pause times.

**Key Characteristics:**
- **Region-Based:** Heap divided into regions
- **Garbage-First:** Collects regions with most garbage
- **Predictable Pauses:** Target pause times
- **Compaction:** Compacts heap incrementally

**Why G1?**
- **Predictable:** Predictable pause times
- **Large Heaps:** Good for large heaps
- **Compaction:** Reduces fragmentation
- **Modern:** Default in Android 8.0+

#### G1 Heap Organization

**Region-Based Heap:**
```
┌─────────────────────────────────┐
│  Region 1  │  Region 2  │  ...  │
├─────────────────────────────────┤
│  Region 3  │  Region 4  │  ...  │
├─────────────────────────────────┤
│  Region 5  │  Region 6  │  ...  │
└─────────────────────────────────┘
```

**Region Types:**
- **Eden Regions:** New objects
- **Survivor Regions:** Surviving objects
- **Old Regions:** Long-lived objects
- **Humongous Regions:** Large objects

#### G1 Collection Process

**Young Collection:**
```
1. Identify Eden regions
2. Mark reachable objects
3. Copy survivors to Survivor regions
4. Clear Eden regions
5. Update remembered sets
```

**Mixed Collection:**
```
1. Collect young regions
2. Collect some old regions (garbage-first)
3. Evacuate survivors
4. Update remembered sets
```

**Full GC (if needed):**
```
1. All regions collected
2. Complete marking
3. Complete compaction
4. Rare occurrence
```

#### G1 Characteristics

**Advantages:**
- Predictable pause times
- Good for large heaps
- Incremental compaction
- Garbage-first approach

**Disadvantages:**
- More complex
- Overhead for remembered sets
- May have longer pauses initially
- Requires tuning

### GC Comparison

#### Pause Times

**CMS:**
- Initial Mark: < 5ms
- Remark: < 5ms
- Total: < 10ms typically
- Concurrent phases: No pause

**G1:**
- Young Collection: < 10ms
- Mixed Collection: < 20ms
- Target pause: Configurable
- Predictable pauses

**Generational:**
- Young GC: < 5ms
- Full GC: 50-200ms
- Variable pauses
- Depends on heap size

#### Throughput

**CMS:**
- Good throughput
- Concurrent operation
- CPU overhead
- Efficient for interactive apps

**G1:**
- Good throughput
- Predictable performance
- Region-based efficiency
- Good for large heaps

**Generational:**
- Excellent throughput
- Efficient young collection
- Full GC overhead
- Best overall throughput

#### Fragmentation

**CMS:**
- No compaction
- Can fragment heap
- May need full GC
- Fragmentation issues

**G1:**
- Incremental compaction
- Reduces fragmentation
- Better heap utilization
- Less fragmentation

**Generational:**
- Compaction in full GC
- Some fragmentation
- Better than CMS
- Acceptable fragmentation

### GC Evolution in Android

#### Android 5.0-6.0 (Lollipop-Marshmallow)

**ART GC:**
- Concurrent Mark-Sweep
- Generational collection
- Improved over Dalvik
- Better pause times

#### Android 7.0 (Nougat)

**Improvements:**
- Better concurrent marking
- Improved pause times
- Generational improvements
- Better performance

#### Android 8.0+ (Oreo and later)

**G1 Garbage Collector:**
- G1 becomes default
- Predictable pause times
- Better for large heaps
- Incremental compaction

### GC Tuning

#### Heap Size

**Configuration:**
```bash
# Set heap size
dalvik.vm.heapsize=256m
dalvik.vm.heapgrowthlimit=192m
```

**Considerations:**
- Larger heap = fewer GCs
- Larger heap = longer GC pauses
- Balance needed
- Device-specific

#### GC Frequency

**Factors:**
- Allocation rate
- Heap size
- Object lifetime
- Memory pressure

**Optimization:**
- Reduce allocations
- Reuse objects
- Object pooling
- Minimize temporary objects

### GC Monitoring

#### GC Logs

**Enable Logging:**
```bash
# Enable GC logging
adb shell setprop dalvik.vm.extra-opts -XX:DumpGCPerformanceOnShutdown
```

**View Logs:**
```bash
# View GC logs
adb logcat | grep -i gc
```

#### GC Metrics

**Key Metrics:**
- GC frequency
- Pause times
- Throughput
- Heap usage

**Monitoring:**
- Use profiling tools
- Monitor GC events
- Track pause times
- Analyze heap usage

## Key Takeaways

1. **Garbage collection** automatically manages memory by identifying and reclaiming unreachable objects, preventing memory leaks and simplifying memory management.

2. **Generational GC** divides the heap into young and old generations, collecting young generation frequently (fast) and old generation less frequently (thorough), based on the insight that most objects die young.

3. **CMS (Concurrent Mark-Sweep)** performs most work concurrently with application execution, providing low pause times but no compaction, which can lead to fragmentation.

4. **G1 (Garbage-First)** divides the heap into regions and collects regions with the most garbage first, providing predictable pause times and incremental compaction, making it the default in Android 8.0+.

5. **GC comparison** shows trade-offs: CMS has low pauses but fragmentation, G1 has predictable pauses and compaction, generational has excellent throughput but variable pauses.

6. **GC evolution** in Android moved from basic mark-sweep (Dalvik) to concurrent mark-sweep (ART 5.0-7.0) to G1 garbage collector (Android 8.0+), improving pause times and heap management.

7. **GC tuning** involves configuring heap size, monitoring GC frequency and pause times, and optimizing allocation patterns to reduce GC overhead.

8. **Understanding garbage collectors** is essential for AOSP development, explaining how Android manages memory, the trade-offs between different GC algorithms, and how they impact application performance.

## Related Topics

- **Dalvik vs ART:** Runtime evolution and GC improvements
- **Memory management internals:** Kernel-level memory management
- **AOT & JIT compilation:** Compilation strategies and memory usage
- **Android Architecture - Complete Overview:** How GC fits into overall architecture

