---
number: 91
title: Building native system components
slug: building-native-system-components
level: intermediate
tags:
  - aosp
  - native
  - build-system
  - android-bp
  - soong
  - native-compilation
prerequisites:
  - understanding-android-bp-files
  - soong-build-system
  - native-shared-libraries
estimated_minutes: 90
contributors: []
diagrams: []
examples: []
canonical_id: aosp-intermediate-91
---

# Building native system components

## Overview

Building native system components involves compiling C/C++ code into libraries and executables that become part of the Android system using AOSP's build system (Soong/Android.bp). Understanding how to build native system components is essential for AOSP development, as it explains how native code is compiled, how libraries and binaries are created, how dependencies are managed, and how native components are integrated into the Android system. This guide provides a comprehensive overview of building native system components, Android.bp configuration, compilation process, and integration into the system.

Think of building native system components like constructing a building: just as constructing a building requires blueprints (Android.bp), materials (source code), tools (compilers), and a construction process (build system), building native components requires build descriptions (Android.bp), source files, toolchains, and the build system to compile and link everything together into the final system components.

## Deep Explanation

### What is Building Native System Components?

Building native system components is the process of compiling C/C++ source code into shared libraries, static libraries, and executables that become part of the Android system, using AOSP's build system (Soong) and build description files (Android.bp).

**Key Characteristics:**
- **Native Code:** C/C++ compilation
- **System Components:** Part of Android system
- **Build System:** Soong/Android.bp
- **Integration:** Integrated into system images

**Why Build Native Components?**
- **Performance:** Native code performance
- **System Services:** Native system services
- **Libraries:** System libraries
- **Tools:** System utilities

### Native Module Types

#### Shared Libraries

**cc_library_shared:**
- Builds shared library (`.so` file)
- Loadable at runtime
- Shared across processes
- Most common native module type

**Example:**
```blueprint
cc_library_shared {
    name: "libmymodule",
    srcs: ["src/file1.cpp", "src/file2.cpp"],
    shared_libs: ["liblog", "libutils"],
    export_include_dirs: ["include"],
}
```

#### Static Libraries

**cc_library_static:**
- Builds static library (`.a` file)
- Linked into other modules
- Not loadable separately
- Used for code reuse

**Example:**
```blueprint
cc_library_static {
    name: "libmystatic",
    srcs: ["src/utils.cpp"],
    export_include_dirs: ["include"],
}
```

#### Executables

**cc_binary:**
- Builds executable binary
- System tools and daemons
- Standalone programs
- System utilities

**Example:**
```blueprint
cc_binary {
    name: "mytool",
    srcs: ["main.cpp"],
    shared_libs: ["liblog", "libbase"],
}
```

### Android.bp Configuration

#### Basic Module Structure

**Module Definition:**
```blueprint
cc_library_shared {
    name: "libmymodule",
    // Module properties
}
```

**Key Properties:**
- `name` - Module name (required)
- `srcs` - Source files
- `shared_libs` - Shared library dependencies
- `static_libs` - Static library dependencies
- `cflags` - C compilation flags
- `cppflags` - C++ compilation flags

#### Source Files

**Source File Specification:**
```blueprint
srcs: [
    "file1.cpp",
    "file2.cpp",
    "src/file3.cpp",
    "src/**/*.cpp",  // Glob pattern
],
```

**File Patterns:**
- Direct file paths
- Glob patterns (`**/*.cpp`)
- Architecture-specific sources
- Generated sources

#### Include Directories

**Include Paths:**
```blueprint
include_dirs: [
    "include",
    "src",
],
export_include_dirs: [
    "include",  // Exported to dependents
],
```

**Include Types:**
- `include_dirs` - Internal includes
- `export_include_dirs` - Exported includes
- `local_include_dirs` - Local includes
- `system_include_dirs` - System includes

#### Dependencies

**Shared Libraries:**
```blueprint
shared_libs: [
    "liblog",
    "libutils",
    "libbinder",
],
```

**Static Libraries:**
```blueprint
static_libs: [
    "libmystatic",
    "libbase",
],
```

**Header Libraries:**
```blueprint
header_libs: [
    "libheaders",
],
```

### Compilation Process

#### Compilation Steps

**Build Process:**
```
1. Parse Android.bp
2. Resolve dependencies
3. Generate compilation commands
4. Compile source files (.cpp → .o)
5. Link object files (.o → .so/.a/binary)
6. Install to output directory
```

**Compilation:**
- Source files compiled to object files
- Object files linked into libraries/binaries
- Output installed to system directories

#### Compiler Flags

**C Flags:**
```blueprint
cflags: [
    "-Wall",
    "-Werror",
    "-Wextra",
    "-O2",
],
```

**C++ Flags:**
```blueprint
cppflags: [
    "-std=c++14",
    "-fno-rtti",
    "-fno-exceptions",
],
```

**Common Flags:**
- `-Wall` - Enable warnings
- `-Werror` - Treat warnings as errors
- `-O2` - Optimization level
- `-std=c++14` - C++ standard

### Module Organization

#### Directory Structure

**Typical Structure:**
```
frameworks/native/libs/mymodule/
├── Android.bp
├── include/
│   └── mymodule.h
├── src/
│   ├── file1.cpp
│   └── file2.cpp
└── tests/
    └── test.cpp
```

**Organization:**
- `Android.bp` - Build file
- `include/` - Header files
- `src/` - Source files
- `tests/` - Test files

#### Module Location

**System Components:**
- `frameworks/native/` - Framework native code
- `system/core/` - Core system components
- `system/libbase/` - Base libraries
- `hardware/` - HAL implementations

**Vendor Components:**
- `vendor/` - Vendor-specific code
- `device/` - Device-specific code
- Vendor partition placement

### Build System Integration

#### Soong Build System

**Soong Processing:**
1. Scans for Android.bp files
2. Parses module definitions
3. Resolves dependencies
4. Generates Ninja build files
5. Executes builds

**Build Execution:**
```bash
# Build specific module
m libmymodule

# Build all native modules
m native
```

#### Module Visibility

**Visibility Rules:**
```blueprint
visibility: [
    "//frameworks/native",
    "//system/core",
],
```

**Visibility Types:**
- Public (default)
- Package-local
- Specific packages
- Vendor visibility

### Advanced Configuration

#### Architecture-Specific

**Architecture Variants:**
```blueprint
target: {
    android: {
        srcs: ["android_specific.cpp"],
    },
    host: {
        srcs: ["host_specific.cpp"],
    },
},
```

**Architecture Support:**
- `arm` - 32-bit ARM
- `arm64` - 64-bit ARM
- `x86` - 32-bit x86
- `x86_64` - 64-bit x86

#### Vendor Modules

**Vendor Flag:**
```blueprint
vendor: true,
```

**Vendor Modules:**
- Built for vendor partition
- Vendor-specific code
- Different build rules
- Vendor visibility

#### Sanitizers

**AddressSanitizer:**
```blueprint
sanitize: {
    address: true,
},
```

**Sanitizer Types:**
- `address` - AddressSanitizer
- `thread` - ThreadSanitizer
- `undefined` - UndefinedBehaviorSanitizer
- `hwaddress` - HWAddressSanitizer

### Output and Installation

#### Output Locations

**System Libraries:**
- `/system/lib/` - 32-bit libraries
- `/system/lib64/` - 64-bit libraries
- `/system/bin/` - Executables

**Vendor Libraries:**
- `/vendor/lib/` - 32-bit vendor libraries
- `/vendor/lib64/` - 64-bit vendor libraries
- `/vendor/bin/` - Vendor executables

#### Installation Rules

**Installation:**
- Libraries installed to appropriate directories
- Architecture-specific placement
- Partition-specific placement
- Permissions set correctly

### Common Patterns

#### System Library Pattern

**Framework Library:**
```blueprint
cc_library_shared {
    name: "libframework",
    srcs: ["src/**/*.cpp"],
    shared_libs: [
        "liblog",
        "libutils",
        "libbinder",
    ],
    export_include_dirs: ["include"],
    vendor: false,
}
```

#### System Tool Pattern

**System Binary:**
```blueprint
cc_binary {
    name: "mytool",
    srcs: ["main.cpp"],
    shared_libs: [
        "liblog",
        "libbase",
    ],
    init_rc: ["mytool.rc"],
}
```

#### HAL Module Pattern

**HAL Implementation:**
```blueprint
cc_library_shared {
    name: "libhardware",
    srcs: ["hal_impl.cpp"],
    shared_libs: ["libhardware"],
    vendor: true,
}
```

### Best Practices

#### Module Design

**Design Principles:**
- Clear module boundaries
- Minimal dependencies
- Well-defined interfaces
- Proper encapsulation

#### Dependency Management

**Dependency Best Practices:**
- Minimize dependencies
- Use appropriate types (shared vs static)
- Avoid circular dependencies
- Document dependencies

#### Code Organization

**Organization:**
- Clear directory structure
- Separate headers and sources
- Modular design
- Test organization

### Debugging Build Issues

#### Common Issues

**Build Failures:**
- Missing dependencies
- Incorrect paths
- Compilation errors
- Link errors

**Debugging:**
```bash
# Check module definition
cat Android.bp

# Check dependencies
m libmymodule --show-commands

# Check compilation
m libmymodule -j1  # Single-threaded for debugging
```

#### Build Logs

**Log Analysis:**
- Compilation errors
- Link errors
- Dependency issues
- Path problems

## Key Takeaways

1. **Building native system components** involves compiling C/C++ code into libraries and executables using AOSP's Soong build system and Android.bp build description files.

2. **Native module types** include shared libraries (`cc_library_shared`), static libraries (`cc_library_static`), and executables (`cc_binary`), each with specific use cases.

3. **Android.bp configuration** defines module properties including source files, dependencies, include directories, compilation flags, and module visibility.

4. **Compilation process** involves parsing Android.bp, resolving dependencies, compiling source files to object files, linking into libraries/binaries, and installing to system directories.

5. **Module organization** follows directory structures with Android.bp, include directories, source directories, and proper placement in system or vendor locations.

6. **Build system integration** uses Soong to process Android.bp files, resolve dependencies, generate Ninja build files, and execute the build process.

7. **Advanced configuration** includes architecture-specific variants, vendor modules, sanitizers, and custom installation rules for specialized requirements.

8. **Understanding building native system components** is essential for AOSP development, explaining how native code is compiled, linked, and integrated into the Android system, enabling development of system libraries, services, and tools.

## Related Topics

- **Understanding Android.bp Files:** Build description file format
- **Soong Build System:** Modern build system that processes Android.bp
- **Native shared libraries:** Output format of native builds
- **Loading libs from system partitions:** How built libraries are loaded

