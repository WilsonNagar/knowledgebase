---
number: 67
title: AIDL-based HALs
slug: aidl-based-hals
level: intermediate
tags:
  - aosp
  - aidl
  - hal
  - hardware
  - treble
  - aidl-hal
  - vendor-interface
prerequisites:
  - aidl
  - stability-annotations
  - aidl-ndk
  - android-architecture-complete-overview
estimated_minutes: 90
contributors: []
diagrams: []
examples: []
canonical_id: aosp-intermediate-67
---

# AIDL-based HALs

## Overview

AIDL-based HALs are the modern approach to implementing Hardware Abstraction Layer interfaces in Android, using AIDL (Android Interface Definition Language) to define stable, versioned interfaces between the Android framework and vendor HAL implementations. Understanding AIDL-based HALs is essential for AOSP development, as they're the recommended approach for new HALs (Android 11+), provide better performance than HIDL, enable Project Treble compatibility, and support both Java and C++ implementations. This guide provides a comprehensive overview of AIDL-based HALs, their architecture, implementation, stability requirements, and how they enable independent framework and vendor updates.

Think of AIDL-based HALs like a modern, standardized contract system: just as modern legal contracts use standardized language and versioning to ensure compatibility across different parties and time, AIDL-based HALs use standardized interface definitions with versioning to ensure compatibility between the Android framework and vendor HAL implementations, even as both evolve independently.

## Deep Explanation

### What are AIDL-based HALs?

AIDL-based HALs are Hardware Abstraction Layer implementations that use AIDL to define the interface between the Android framework and vendor hardware implementations. They replace HIDL HALs as the recommended approach for new HAL development.

**Key Characteristics:**
- **AIDL Interfaces:** Use AIDL for interface definition
- **Stability Annotations:** Require @VintfStability
- **Versioned:** Support interface versioning
- **Process Isolation:** Can run in separate processes

**Why AIDL-based HALs?**
- **Modern Replacement:** Recommended over HIDL (Android 11+)
- **Better Performance:** Improved over HIDL
- **Better Tooling:** Superior development tools
- **Treble Compatible:** Enable independent updates

### AIDL HAL vs HIDL HAL

#### AIDL HAL (Android 11+)

**Characteristics:**
- Modern, recommended approach
- Better performance
- Better tooling support
- Java and C++ support
- Simpler than HIDL

**Advantages:**
- Unified with framework AIDL
- Better developer experience
- Improved performance
- Active development

#### HIDL HAL (Android 8.0-10)

**Characteristics:**
- Introduced with Treble
- C++ focused
- Deprecated in Android 11+
- Still used in legacy HALs

**Status:**
- Deprecated but still supported
- Legacy implementations
- Migration to AIDL recommended
- Coexists with AIDL HALs

### AIDL HAL Architecture

#### Architecture Overview

**Framework Side:**
```
Android Framework
     │
     │ Uses AIDL interface
     │
     ▼
AIDL Client (Generated)
     │
     │ Binder IPC
     │
     ▼
Binder Driver
```

**Vendor Side:**
```
Binder Driver
     │
     │ Binder IPC
     │
     ▼
AIDL Server (Generated)
     │
     │ Calls implementation
     │
     ▼
HAL Implementation (Vendor)
     │
     │ Hardware access
     │
     ▼
Hardware
```

#### Process Isolation

**Separate Process Model:**
- HAL runs in separate process
- Framework and HAL isolated
- Binder IPC communication
- Better security and stability

**Benefits:**
- Process crash isolation
- Independent updates
- Better security
- Standard IPC model

### AIDL HAL Interface Definition

#### Basic AIDL HAL Interface

**AIDL File:**
```aidl
// hardware/interfaces/example/1.0/IExample.aidl
package android.hardware.example@1.0;

@VintfStability
interface IExample {
    int32_t getValue();
    void setValue(int32_t value);
    void registerCallback(IExampleCallback callback);
}
```

**Key Elements:**
- `@VintfStability`: Required for HAL interfaces
- Package with version: `@1.0`
- Interface methods
- Callback support

#### Stability Requirements

**@VintfStability:**
- Required for all HAL interfaces
- Ensures interface stability
- Enables Treble compatibility
- Prevents breaking changes

**Interface Evolution:**
- Cannot remove methods
- Cannot change signatures
- Can add new methods (backward compatible)
- Version increment for breaking changes

### AIDL HAL Implementation

#### C++ Implementation

**Server Implementation:**
```cpp
#include <aidl/android/hardware/example/BnExample.h>
#include <aidl/android/hardware/example/IExampleCallback.h>

using aidl::android::hardware::example::BnExample;
using aidl::android::hardware::example::IExampleCallback;

class ExampleHal : public BnExample {
public:
    ::ndk::ScopedAStatus getValue(int32_t* _aidl_return) override {
        *_aidl_return = mValue;
        return ::ndk::ScopedAStatus::ok();
    }
    
    ::ndk::ScopedAStatus setValue(int32_t value) override {
        mValue = value;
        return ::ndk::ScopedAStatus::ok();
    }
    
    ::ndk::ScopedAStatus registerCallback(
            const std::shared_ptr<IExampleCallback>& callback) override {
        mCallback = callback;
        return ::ndk::ScopedAStatus::ok();
    }

private:
    int32_t mValue = 0;
    std::shared_ptr<IExampleCallback> mCallback;
};
```

**Service Registration:**
```cpp
#include <android/binder_manager.h>
#include <android/binder_process.h>

int main() {
    // Create HAL instance
    std::shared_ptr<ExampleHal> hal = ndk::SharedRefBase::make<ExampleHal>();
    
    // Register service
    std::string instanceName = "default";
    std::string serviceName = std::string() + IExample::descriptor + "/" + instanceName;
    AServiceManager_addService(hal->asBinder().get(), serviceName.c_str());
    
    // Start thread pool
    ABinderProcess_startThreadPool();
    ABinderProcess_joinThreadPool();
    
    return 0;
}
```

#### Java Implementation

**Server Implementation:**
```java
package android.hardware.example;

import android.hardware.example.IExample;
import android.hardware.example.IExampleCallback;

public class ExampleHal extends IExample.Stub {
    private int mValue = 0;
    private IExampleCallback mCallback;
    
    @Override
    public int getValue() throws RemoteException {
        return mValue;
    }
    
    @Override
    public void setValue(int value) throws RemoteException {
        mValue = value;
    }
    
    @Override
    public void registerCallback(IExampleCallback callback) throws RemoteException {
        mCallback = callback;
    }
}
```

**Service Registration:**
```java
public class ExampleHalService extends Service {
    @Override
    public void onCreate() {
        super.onCreate();
        
        ExampleHal hal = new ExampleHal();
        ServiceManager.addService("android.hardware.example.IExample/default", hal);
    }
}
```

### AIDL HAL Client Usage

#### Framework Client (C++)

**Getting Service:**
```cpp
#include <aidl/android/hardware/example/IExample.h>

using aidl::android::hardware::example::IExample;

std::shared_ptr<IExample> hal = IExample::fromBinder(
    AServiceManager_getService("android.hardware.example.IExample/default"));
    
if (hal != nullptr) {
    int32_t value;
    hal->getValue(&value);
}
```

#### Framework Client (Java)

**Getting Service:**
```java
import android.hardware.example.IExample;

IBinder binder = ServiceManager.getService("android.hardware.example.IExample/default");
IExample hal = IExample.Stub.asInterface(binder);

if (hal != null) {
    int value = hal.getValue();
}
```

### AIDL HAL Build Configuration

#### Android.bp for AIDL HAL

**AIDL Interface:**
```bp
aidl_interface {
    name: "android.hardware.example",
    srcs: ["*.aidl"],
    stability: "vintf",
    backend: {
        java: {
            enabled: true,
        },
        ndk: {
            enabled: true,
        },
    },
}
```

**HAL Implementation:**
```bp
cc_library_shared {
    name: "android.hardware.example-service",
    srcs: ["service.cpp"],
    shared_libs: [
        "android.hardware.example-V1-ndk",
        "libbinder_ndk",
        "libbase",
        "liblog",
    ],
}
```

**HAL Service Binary:**
```bp
cc_binary {
    name: "android.hardware.example@1.0-service",
    srcs: ["main.cpp"],
    shared_libs: [
        "android.hardware.example-service",
        "libbinder_ndk",
        "libbase",
        "liblog",
    ],
    init_rc: ["android.hardware.example@1.0-service.rc"],
}
```

### AIDL HAL Service Lifecycle

#### Service Startup

**init.rc Configuration:**
```rc
service example-hal-1-0 /vendor/bin/hw/android.hardware.example@1.0-service
    class hal
    user system
    group system
```

**Service Process:**
- Started by init
- Runs as system user
- Registers with ServiceManager
- Handles Binder transactions

#### Service Registration

**Service Name Format:**
```
<interface_descriptor>/<instance_name>
```

**Example:**
```
android.hardware.example.IExample/default
```

**Registration:**
- Service registers with ServiceManager
- Framework discovers via ServiceManager
- Multiple instances supported
- Instance names differentiate

### AIDL HAL Versioning

#### Interface Versioning

**Version Format:**
```aidl
package android.hardware.example@1.0;  // Version 1.0
package android.hardware.example@1.1;  // Minor update
package android.hardware.example@2.0;  // Major update
```

**Version Rules:**
- Minor versions: Backward compatible changes
- Major versions: Breaking changes
- Framework can use multiple versions
- Vendor implements specific version

#### Interface Evolution

**Adding Methods (Minor Version):**
```aidl
// Version 1.0
package android.hardware.example@1.0;
interface IExample {
    int32_t getValue();
}

// Version 1.1 (backward compatible)
package android.hardware.example@1.1;
interface IExample {
    int32_t getValue();
    int32_t getValue2();  // New method
}
```

**Breaking Changes (Major Version):**
```aidl
// Version 2.0 (breaking)
package android.hardware.example@2.0;
interface IExample {
    int64_t getValue();  // Changed return type
}
```

### AIDL HAL Best Practices

#### Interface Design

**Stability:**
- Always use @VintfStability
- Plan for versioning
- Avoid breaking changes
- Document interface evolution

**Method Design:**
- Keep methods focused
- Use appropriate types
- Handle errors properly
- Document behavior

#### Implementation

**Error Handling:**
- Return ScopedAStatus appropriately
- Use exception codes
- Provide error messages
- Handle all error cases

**Performance:**
- Keep transactions short
- Avoid blocking operations
- Use oneway for notifications
- Optimize data transfer

### AIDL HAL vs Legacy HAL

#### Legacy HAL (libhardware)

**Characteristics:**
- C-based interface
- Shared library loading
- Same-process execution
- Pre-Treble model

**Limitations:**
- No process isolation
- No versioning
- Tight coupling
- Difficult to update

#### AIDL HAL

**Characteristics:**
- Interface-based
- Process isolation
- Versioned interfaces
- Treble-compatible

**Advantages:**
- Independent updates
- Better isolation
- Version management
- Modern architecture

### AIDL HAL Migration

#### Migrating from HIDL

**Steps:**
1. Define AIDL interface
2. Implement HAL in AIDL
3. Update framework to use AIDL
4. Test and validate
5. Remove HIDL implementation

**Benefits:**
- Better performance
- Better tooling
- Unified IPC
- Modern architecture

#### Migrating from Legacy HAL

**Steps:**
1. Define AIDL interface
2. Implement HAL in AIDL
3. Create service process
4. Update framework
5. Remove legacy HAL

**Benefits:**
- Process isolation
- Versioning support
- Treble compatibility
- Modern architecture

### Debugging AIDL HALs

#### Common Issues

**Service Not Found:**
- Check service registration
- Verify service name
- Check init.rc configuration
- Review service logs

**Interface Mismatch:**
- Verify AIDL interface version
- Check stability annotations
- Review interface compatibility
- Validate generated code

#### Debugging Tools

**Service Discovery:**
```bash
# List HAL services
adb shell lshal

# Check specific service
adb shell dumpsys | grep example
```

**Logging:**
```cpp
#include <android-base/logging.h>

LOG(INFO) << "HAL method called";
LOG(ERROR) << "Error: " << error;
```

## Key Takeaways

1. **AIDL-based HALs are the modern approach** for HAL implementation, using AIDL interfaces with @VintfStability for Treble compatibility.

2. **AIDL HALs replace HIDL HALs** as the recommended approach (Android 11+), providing better performance and tooling.

3. **@VintfStability is required** for all HAL interfaces, ensuring interface stability and enabling independent framework/vendor updates.

4. **AIDL HALs support both C++ and Java** implementations, with C++ being common for vendor HALs and Java for framework services.

5. **Service registration** uses the format `<interface_descriptor>/<instance_name>`, allowing multiple instances of the same HAL.

6. **Interface versioning** supports minor (backward compatible) and major (breaking) version updates, enabling interface evolution.

7. **AIDL HALs provide process isolation** through Binder IPC, enabling better security, stability, and independent updates.

8. **Understanding AIDL-based HALs** is essential for modern HAL development, Treble compatibility, and creating maintainable hardware interfaces in AOSP.

## Related Topics

- **AIDL:** Base AIDL language and concepts
- **Stability annotations:** @VintfStability and interface stability
- **AIDL NDK:** Native AIDL usage
- **HIDL (deprecated but still used):** Legacy HAL interface definition
- **VINTF:** Vendor Interface Object for HAL compatibility

