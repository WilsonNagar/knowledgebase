---
number: 59
title: 'transact(), onTransact()'
slug: transact-ontransact
level: intermediate
tags:
  - aosp
  - binder
  - transact
  - ontransact
  - transactions
  - ipc
  - marshaling
prerequisites:
  - bpbinder-bbinder
  - binder-architecture
  - parcelables
estimated_minutes: 85
contributors: []
diagrams: []
examples: []
canonical_id: aosp-intermediate-59
---

# transact(), onTransact()

## Overview

transact() and onTransact() are the core methods that handle Binder transactions. transact() is called by clients (via BpBinder) to send transactions, while onTransact() is called by servers (via BBinder) to receive and process transactions. Understanding transact() and onTransact() is essential for AOSP development, as they're the fundamental mechanisms for all Binder IPC, handle parameter marshaling and unmarshaling, and are where the actual IPC communication happens. This guide provides a comprehensive overview of transact(), onTransact(), their parameters, transaction codes, marshaling patterns, and how they work together.

Think of transact() and onTransact() like a postal system's send and receive operations: transact() is like dropping off a package at the post office (sending a transaction with data), and onTransact() is like receiving and opening that package at the destination (receiving the transaction, unpacking the data, processing it, and sending a reply). The transaction code is like the address label that tells the receiver what to do with the package.

## Deep Explanation

### What are transact() and onTransact()?

**transact():**
- Method called by client to send transaction
- Implemented by BpBinder (client side)
- Marshals parameters and sends to driver
- Waits for reply and unmarshals result
- Core IPC sending mechanism

**onTransact():**
- Method called by server to receive transaction
- Implemented by BBinder subclasses (server side)
- Unmarshals parameters from transaction
- Calls implementation method
- Marshals reply and returns
- Core IPC receiving mechanism

**Relationship:**
- transact() sends, onTransact() receives
- They work together for complete transaction
- Transaction code links them
- Parcel is the data container

### transact() Method

#### transact() Signature

**IBinder Interface:**
```java
public boolean transact(int code, Parcel data, Parcel reply, int flags)
    throws RemoteException;
```

**Native (C++):**
```cpp
virtual status_t transact(
    uint32_t code,
    const Parcel& data,
    Parcel* reply,
    uint32_t flags);
```

**Parameters:**
- `code` - Transaction code (method identifier)
- `data` - Input Parcel (marshaled parameters)
- `reply` - Output Parcel (marshaled return value, can be null)
- `flags` - Transaction flags (e.g., FLAG_ONEWAY)

**Return Value:**
- Java: `boolean` - true on success
- C++: `status_t` - NO_ERROR on success

#### transact() Implementation

**BpBinder Implementation:**
```cpp
status_t BpBinder::transact(
    uint32_t code,
    const Parcel& data,
    Parcel* reply,
    uint32_t flags) {
    
    // Get IPC thread state
    IPCThreadState* ipc = IPCThreadState::self();
    
    // Send transaction through driver
    status_t status = ipc->transact(mHandle, code, data, reply, flags);
    
    return status;
}
```

**Process:**
1. Get IPC thread state
2. Call IPCThreadState::transact()
3. IPCThreadState sends to driver
4. Wait for reply (if not oneway)
5. Return status

#### Using transact()

**Client Side Usage:**
```java
// Java
Parcel data = Parcel.obtain();
Parcel reply = Parcel.obtain();

try {
    data.writeInterfaceToken(DESCRIPTOR);
    data.writeString("parameter");
    
    boolean success = binder.transact(TRANSACTION_doSomething, data, reply, 0);
    
    if (success) {
        String result = reply.readString();
    }
} finally {
    data.recycle();
    reply.recycle();
}
```

**Native Usage:**
```cpp
// C++
Parcel data;
Parcel reply;

data.writeInterfaceToken(String16(DESCRIPTOR));
data.writeString16(String16("parameter"));

status_t status = binder->transact(TRANSACTION_doSomething, data, &reply, 0);

if (status == NO_ERROR) {
    String16 result = reply.readString16();
}
```

### onTransact() Method

#### onTransact() Signature

**BBinder (C++):**
```cpp
virtual status_t onTransact(
    uint32_t code,
    const Parcel& data,
    Parcel* reply,
    uint32_t flags);
```

**Binder (Java):**
```java
protected boolean onTransact(int code, Parcel data, Parcel reply, int flags)
    throws RemoteException;
```

**Parameters:**
- `code` - Transaction code (method identifier)
- `data` - Input Parcel (marshaled parameters)
- `reply` - Output Parcel (for marshaling return value)
- `flags` - Transaction flags

**Return Value:**
- Java: `boolean` - true if handled
- C++: `status_t` - NO_ERROR if handled

#### onTransact() Implementation

**BBinder Implementation:**
```cpp
status_t BBinder::transact(
    uint32_t code,
    const Parcel& data,
    Parcel* reply,
    uint32_t flags) {
    
    // Route to onTransact()
    status_t err = onTransact(code, data, reply, flags);
    
    return err;
}
```

**Service Implementation:**
```cpp
status_t MyService::onTransact(
    uint32_t code,
    const Parcel& data,
    Parcel* reply,
    uint32_t flags) {
    
    switch (code) {
        case TRANSACTION_doSomething: {
            // Enforce interface
            CHECK_INTERFACE(IMyService, data, reply);
            
            // Unmarshal parameters
            String16 param = data.readString16();
            
            // Call implementation
            String16 result = doSomething(param);
            
            // Marshal reply
            reply->writeString16(result);
            
            return NO_ERROR;
        }
        default:
            return BBinder::onTransact(code, data, reply, flags);
    }
}
```

#### Using onTransact()

**Server Side Implementation:**
```java
// Java
@Override
protected boolean onTransact(int code, Parcel data, Parcel reply, int flags)
        throws RemoteException {
    
    switch (code) {
        case TRANSACTION_doSomething: {
            data.enforceInterface(DESCRIPTOR);
            String param = data.readString();
            
            String result = doSomething(param);
            
            reply.writeString(result);
            return true;
        }
        default:
            return super.onTransact(code, data, reply, flags);
    }
}
```

### Transaction Codes

#### What are Transaction Codes?

Transaction codes are numeric identifiers that map to specific methods. They're used to route transactions to the correct handler.

**Code Definition:**
```java
// Java
static final int TRANSACTION_doSomething = (IBinder.FIRST_CALL_TRANSACTION + 0);
static final int TRANSACTION_doAnother = (IBinder.FIRST_CALL_TRANSACTION + 1);
```

```cpp
// C++
enum {
    TRANSACTION_doSomething = IBinder::FIRST_CALL_TRANSACTION + 0,
    TRANSACTION_doAnother = IBinder::FIRST_CALL_TRANSACTION + 1,
};
```

**Code Ranges:**
- `FIRST_CALL_TRANSACTION` - Start of user-defined codes
- System codes below FIRST_CALL_TRANSACTION
- User codes start from FIRST_CALL_TRANSACTION
- Typically sequential

#### Code Usage

**Client Side:**
```java
binder.transact(TRANSACTION_doSomething, data, reply, 0);
```

**Server Side:**
```java
switch (code) {
    case TRANSACTION_doSomething:
        // Handle this method
        break;
    case TRANSACTION_doAnother:
        // Handle another method
        break;
}
```

### Transaction Flags

#### Common Flags

**FLAG_ONEWAY (0x01):**
- Asynchronous transaction
- Client doesn't wait for reply
- Fire-and-forget
- No reply expected

**Normal Transaction (0):**
- Synchronous transaction
- Client waits for reply
- Blocking call
- Reply expected

**Usage:**
```java
// Oneway (async)
binder.transact(CODE, data, null, FLAG_ONEWAY);

// Normal (sync)
binder.transact(CODE, data, reply, 0);
```

#### Flag Combinations

**Multiple Flags:**
- Flags can be combined with bitwise OR
- Most common: 0 (normal) or FLAG_ONEWAY
- Other flags exist but less common
- Check documentation for specific flags

### Marshaling Patterns

#### Client Side Marshaling (transact())

**Standard Pattern:**
```java
Parcel data = Parcel.obtain();
Parcel reply = Parcel.obtain();

try {
    // 1. Write interface token
    data.writeInterfaceToken(DESCRIPTOR);
    
    // 2. Write parameters (in order)
    data.writeString(param1);
    data.writeInt(param2);
    data.writeParcelable(param3, 0);
    
    // 3. Send transaction
    binder.transact(CODE, data, reply, 0);
    
    // 4. Read reply (if not oneway)
    if (reply != null) {
        reply.readException();
        String result = reply.readString();
    }
} finally {
    data.recycle();
    if (reply != null) {
        reply.recycle();
    }
}
```

**Key Steps:**
1. Write interface token (security check)
2. Write parameters in order
3. Call transact()
4. Read exception (if any)
5. Read return value

#### Server Side Unmarshaling (onTransact())

**Standard Pattern:**
```java
@Override
protected boolean onTransact(int code, Parcel data, Parcel reply, int flags)
        throws RemoteException {
    
    switch (code) {
        case TRANSACTION_doSomething: {
            // 1. Enforce interface token
            data.enforceInterface(DESCRIPTOR);
            
            // 2. Read parameters (same order as write)
            String param1 = data.readString();
            int param2 = data.readInt();
            MyData param3 = data.readParcelable(MyData.class.getClassLoader());
            
            // 3. Call implementation
            String result = doSomething(param1, param2, param3);
            
            // 4. Write reply
            reply.writeNoException();
            reply.writeString(result);
            
            return true;
        }
        default:
            return super.onTransact(code, data, reply, flags);
    }
}
```

**Key Steps:**
1. Enforce interface token
2. Read parameters in same order
3. Call implementation method
4. Write exception status (if any)
5. Write return value

### Interface Token

#### What is Interface Token?

Interface token is a security mechanism that ensures transactions are sent to the correct interface implementation.

**Purpose:**
- Verify correct interface
- Prevent interface confusion
- Security check
- Standard practice

**Writing Token:**
```java
data.writeInterfaceToken(DESCRIPTOR);
```

**Enforcing Token:**
```java
data.enforceInterface(DESCRIPTOR);
```

**DESCRIPTOR:**
- String identifying interface
- Usually interface class name
- Must match on both sides
- Generated by AIDL

### Exception Handling

#### Exception Marshaling

**Client Side:**
```java
try {
    binder.transact(CODE, data, reply, 0);
    reply.readException();  // Check for exceptions
    String result = reply.readString();
} catch (RemoteException e) {
    // Handle IPC error
}
```

**Server Side:**
```java
try {
    String result = doSomething(param);
    reply.writeNoException();
    reply.writeString(result);
} catch (Exception e) {
    reply.writeException(e);
}
```

#### Exception Types

**RemoteException:**
- IPC communication error
- Process death
- Transaction failure
- Caught on client side

**Application Exceptions:**
- Business logic exceptions
- Marshaled in reply
- Unmarshaled on client
- Can be custom exceptions

### Transaction Flow

#### Complete Flow

**1. Client Calls transact():**
```
Client code
  ↓
AIDL Proxy
  ↓
BpBinder.transact()
  ↓
IPCThreadState.transact()
  ↓
Binder driver
```

**2. Driver Routes Transaction:**
```
Binder driver
  ↓
Target process
  ↓
Target thread
  ↓
BBinder.transact()
  ↓
onTransact()
```

**3. Server Processes:**
```
onTransact()
  ↓
Unmarshal parameters
  ↓
Call implementation
  ↓
Marshal reply
  ↓
Return to driver
```

**4. Reply to Client:**
```
Binder driver
  ↓
Client thread wakes
  ↓
IPCThreadState receives
  ↓
BpBinder returns
  ↓
AIDL Proxy returns
  ↓
Client code
```

### Oneway Transactions

#### FLAG_ONEWAY Usage

**Client Side:**
```java
// Oneway - no reply
binder.transact(CODE, data, null, FLAG_ONEWAY);
// Continues immediately, doesn't wait
```

**Server Side:**
```java
// onTransact() still called
// But reply can be null or ignored
// Client doesn't wait
```

**Characteristics:**
- Client doesn't block
- No reply expected
- Fire-and-forget
- Used for notifications

### Best Practices

#### Transaction Design

**Keep Transactions Focused:**
- One logical operation per transaction
- Don't combine unrelated operations
- Clear transaction codes
- Well-documented

**Error Handling:**
- Always check return values
- Handle RemoteException
- Check for exceptions in reply
- Provide meaningful errors

#### Marshaling Best Practices

**Order Matters:**
- Write and read in same order
- Use consistent patterns
- Document parameter order
- Test thoroughly

**Efficiency:**
- Minimize transaction size
- Use appropriate types
- Avoid unnecessary data
- Optimize serialization

### Debugging transact() and onTransact()

#### Common Issues

**Order Mismatch:**
- Read/write order doesn't match
- Causes data corruption
- Fix: Ensure exact order match

**Interface Token Mismatch:**
- DESCRIPTOR doesn't match
- Causes enforceInterface() to fail
- Fix: Use same DESCRIPTOR

**Transaction Code Mismatch:**
- Code doesn't match method
- Transaction not handled
- Fix: Use correct transaction code

#### Debugging Techniques

**Logging:**
```java
// Log transaction codes
Log.d(TAG, "Received transaction: " + code);

// Log parameters
Log.d(TAG, "Parameter: " + param);

// Log results
Log.d(TAG, "Result: " + result);
```

**Transaction Tracing:**
- Enable Binder tracing
- Log all transactions
- Analyze transaction flow
- Identify issues

## Key Takeaways

1. **transact() is the client-side method** that sends transactions, marshals parameters, and waits for replies.

2. **onTransact() is the server-side method** that receives transactions, unmarshals parameters, calls implementations, and marshals replies.

3. **Transaction codes** are numeric identifiers that map transactions to specific methods, used for routing in onTransact().

4. **Transaction flags** control transaction behavior, with FLAG_ONEWAY enabling asynchronous fire-and-forget transactions.

5. **Marshaling order is critical** - parameters must be written and read in the exact same order, or data corruption occurs.

6. **Interface tokens** provide security by ensuring transactions are sent to the correct interface implementation.

7. **Exception handling** is built into the transaction mechanism, with exceptions marshaled in replies and unmarshaled on the client.

8. **Understanding transact() and onTransact()** is essential for AOSP development, debugging IPC issues, and implementing Binder services.

## Related Topics

- **BpBinder & BBinder:** The classes that implement transact() and onTransact()
- **Binder architecture:** How transact() and onTransact() fit into overall architecture
- **Parcelables:** How complex objects are marshaled in transactions
- **AIDL:** How AIDL generates code that uses transact() and onTransact()

