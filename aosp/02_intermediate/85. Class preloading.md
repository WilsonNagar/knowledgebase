---
number: 85
title: Class preloading
slug: class-preloading
level: intermediate
tags:
  - aosp
  - art
  - zygote
  - class-preloading
  - preload
  - runtime
  - boot
prerequisites:
  - zygote-startup-flow
  - zygote-fork-model
  - boot-image-creation
estimated_minutes: 85
contributors: []
diagrams: []
examples: []
canonical_id: aosp-intermediate-85
---

# Class preloading

## Overview

Class preloading is the process of loading commonly used Java classes into memory during Zygote startup, before any applications are launched. Understanding class preloading is essential for AOSP development, as it explains how Android optimizes app startup, which classes are preloaded, how the preloading process works, and how it enables fast app launches through the Zygote fork model. This guide provides a comprehensive overview of class preloading, the preloading process, class selection, memory sharing, and performance benefits.

Think of class preloading like pre-stocking a warehouse: just as a warehouse pre-stocks commonly needed items so they're ready when customers arrive, Zygote preloads commonly used classes so they're ready when apps need them. When a new app starts (customer arrives), it doesn't need to wait for items to be loaded (classes to be loaded) - they're already there and ready to use.

## Deep Explanation

### What is Class Preloading?

Class preloading is the process of loading commonly used Java classes into memory during Zygote initialization, making them available to all forked application processes without needing to load them individually.

**Key Characteristics:**
- **Zygote Phase:** Happens during Zygote startup
- **Common Classes:** Frequently used classes
- **Memory Sharing:** Shared across all apps
- **Fast Access:** Classes ready immediately

**Why Preload Classes?**
- **Fast App Startup:** Classes already loaded
- **Memory Efficiency:** Shared across processes
- **Performance:** No loading overhead
- **Consistency:** Same classes for all apps

### Preloading Process

#### When Preloading Happens

**Timing:**
- During Zygote startup
- After VM initialization
- Before System Server fork
- Before app processes start

**Sequence:**
```
1. Zygote starts
2. VM initialized
3. Preloading phase begins
4. Classes loaded
5. Resources preloaded
6. Zygote ready
```

#### Preloading Implementation

**ZygoteInit.main():**
```java
public static void main(String argv[]) {
    // ... initialization ...
    
    // Preload classes
    preloadClasses();
    
    // Preload resources
    preloadResources();
    
    // Preload OpenGL
    preloadOpenGL();
    
    // Preload shared libraries
    preloadSharedLibraries();
    
    // ... continue startup ...
}
```

**Preload Classes Method:**
```java
private static void preloadClasses() {
    final VMRuntime runtime = VMRuntime.getRuntime();
    
    InputStream is = new FileInputStream(PRELOADED_CLASSES);
    BufferedReader br = new BufferedReader(new InputStreamReader(is));
    
    int count = 0;
    String line;
    while ((line = br.readLine()) != null) {
        // Skip comments and empty lines
        line = line.trim();
        if (line.startsWith("#") || line.isEmpty()) {
            continue;
        }
        
        try {
            // Load class
            Class.forName(line);
            count++;
        } catch (ClassNotFoundException | NoClassDefFoundError e) {
            // Log error but continue
        }
    }
    
    Log.i(TAG, "Preloaded " + count + " classes");
}
```

### Preloaded Classes

#### Class Categories

**Core Java Classes:**
- `java.lang.*` classes
  - String, Object, Class, Integer, etc.
  - System, Runtime, Thread, etc.
  - Exception classes

**Java Collections:**
- `java.util.*` classes
  - ArrayList, HashMap, HashSet, etc.
  - Collections, Arrays, etc.
  - Date, Calendar, etc.

**Android Framework:**
- `android.*` framework classes
  - Activity, Service, BroadcastReceiver
  - Context, Intent, Bundle
  - View, ViewGroup, etc.

**System Classes:**
- System service classes
- Core utilities
- Framework components
- Common system classes

#### Preloaded Classes List

**Configuration File:**
- `/system/etc/preloaded-classes`
- Text file with class names
- One class per line
- Comments with `#`

**Example Classes:**
```
# Core Java classes
java.lang.String
java.lang.Object
java.lang.Class
java.lang.Integer
java.lang.Thread

# Collections
java.util.ArrayList
java.util.HashMap
java.util.HashSet

# Android Framework
android.app.Activity
android.app.Service
android.content.Context
android.content.Intent
android.os.Bundle
```

**Class Count:**
- Typically 1000-2000 classes
- Device-dependent
- Framework-dependent
- Optimized list

### Preloading Sequence

#### Step 1: Read Class List

**Read Configuration:**
```java
InputStream is = new FileInputStream(PRELOADED_CLASSES);
BufferedReader br = new BufferedReader(new InputStreamReader(is));
```

**File Location:**
- `/system/etc/preloaded-classes`
- Build-time generated
- System partition
- Read-only

#### Step 2: Load Each Class

**Class Loading:**
```java
for (String className : classNames) {
    try {
        Class.forName(className);
    } catch (ClassNotFoundException e) {
        // Log and continue
    }
}
```

**Loading Process:**
1. Parse class name
2. Locate class file
3. Load class definition
4. Link class
5. Initialize if needed

#### Step 3: Memory Allocation

**Memory Layout:**
```
Zygote Process Memory
┌─────────────────────────────────┐
│  Preloaded Classes              │
│  ├── java.lang.String          │
│  ├── java.util.ArrayList       │
│  ├── android.app.Activity      │
│  └── ... (1000+ classes)       │
└─────────────────────────────────┘
         │
         │ Copy-on-Write
         │
         ▼
App Process Memory (shared)
```

**Memory Characteristics:**
- Classes in heap memory
- Shared across processes
- Copy-on-write semantics
- Efficient memory usage

### Memory Sharing

#### Copy-on-Write (COW)

**Memory Sharing:**
- Preloaded classes shared
- Read-only pages
- Copy when modified
- Efficient sharing

**COW Mechanism:**
```
Zygote: [Preloaded Classes] (read-only)
         │
         │ fork()
         │
         ▼
App 1:   [Same Classes] (shared, read-only)
App 2:   [Same Classes] (shared, read-only)
App 3:   [Same Classes] (shared, read-only)
```

**When Copy Occurs:**
- App modifies class data
- App loads new classes
- App changes class state
- Write to shared page

#### Memory Efficiency

**Memory Savings:**
```
Without Preloading:
- 10 apps × 50MB = 500MB

With Preloading:
- 1 copy (50MB) + 10 apps × 5MB = 100MB
- 80% memory savings
```

**Benefits:**
- Significant memory savings
- Efficient resource usage
- Scalable to many apps
- Better memory utilization

### Preloading Performance

#### Preloading Time

**Time Statistics:**
- Typically 200-500ms
- Device-dependent
- Class count dependent
- Storage speed dependent

**Factors:**
- Number of classes
- Storage I/O speed
- CPU performance
- Memory speed

#### App Startup Benefit

**Startup Time:**
- Without preloading: 2-5 seconds
- With preloading: 100-500ms
- 10x faster startup
- Better user experience

**Performance Impact:**
- Faster app launch
- Reduced loading time
- Better responsiveness
- Improved UX

### Preloading Configuration

#### Class List Generation

**Build-Time Generation:**
- Analyze class usage
- Identify common classes
- Generate class list
- Include in system image

**Analysis Tools:**
- Class usage profiling
- Framework analysis
- App analysis
- Usage statistics

#### Customization

**Device-Specific:**
- Custom class lists
- Device optimization
- Performance tuning
- Memory constraints

**Configuration:**
```makefile
# Custom preloaded classes
PRODUCT_COPY_FILES += \
    device/company/product/preloaded-classes:system/etc/preloaded-classes
```

### Preloading Optimization

#### Class Selection

**Selection Criteria:**
- Frequently used classes
- Boot-critical classes
- Framework core classes
- Performance-sensitive classes

**Balance:**
- Include essential classes
- Avoid rarely used classes
- Balance memory vs. startup
- Optimize for common cases

#### Preloading Tuning

**Optimization:**
- Reduce class count
- Focus on hot classes
- Remove unused classes
- Optimize class list

**Performance:**
- Faster preloading
- Less memory usage
- Better startup time
- Improved performance

### Preloading Limitations

#### Memory Constraints

**Memory Usage:**
- Preloaded classes use memory
- Device memory limits
- Balance needed
- Memory pressure

**Constraints:**
- Limited device memory
- Class count limits
- Memory pressure
- Trade-offs

#### Startup Time

**Preloading Overhead:**
- Adds to boot time
- Zygote startup time
- Boot time impact
- Trade-off

**Balance:**
- Preloading time vs. app startup
- Boot time vs. app performance
- Memory vs. performance
- Optimization needed

### Debugging Preloading

#### Preloading Logs

**Logging:**
```bash
# View preloading logs
adb logcat | grep -i preload

# Check preloaded classes
adb logcat | grep "Preloaded"
```

**Log Information:**
- Class count
- Loading time
- Errors
- Warnings

#### Common Issues

**Class Not Found:**
- Missing class in classpath
- Class not available
- Framework issue
- Configuration error

**Loading Errors:**
- Class loading failures
- Linkage errors
- Initialization errors
- Memory issues

## Key Takeaways

1. **Class preloading** is the process of loading commonly used Java classes into memory during Zygote startup, making them available to all forked application processes.

2. **Preloading process** happens during Zygote initialization, reading a class list from `/system/etc/preloaded-classes` and loading each class using `Class.forName()`.

3. **Preloaded classes** include core Java classes (java.lang.*, java.util.*), Android framework classes (android.*), and system classes, typically 1000-2000 classes.

4. **Memory sharing** uses copy-on-write semantics, where preloaded classes are shared across all app processes until modified, providing significant memory savings.

5. **Performance benefits** include faster app startup (10x faster), reduced loading time, better responsiveness, and improved user experience.

6. **Preloading configuration** uses a build-time generated class list, with device-specific customization possible for optimization and memory constraints.

7. **Preloading optimization** involves careful class selection, balancing memory usage with startup performance, and tuning the class list for optimal results.

8. **Understanding class preloading** is essential for AOSP development, explaining how Android optimizes app startup, enables fast app launches, and efficiently manages memory through the Zygote fork model.

## Related Topics

- **Zygote Startup Flow:** How Zygote initializes and preloads classes
- **Zygote fork model:** How preloaded classes are shared with app processes
- **Boot image creation:** Build-time compilation of system classes
- **ART boot image & dex pre-optimization:** Related optimization techniques

