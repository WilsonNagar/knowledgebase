---
number: 79
title: Zygote fork model
slug: zygote-fork-model
level: intermediate
tags:
  - aosp
  - zygote
  - fork
  - process-creation
  - copy-on-write
  - app-launch
  - runtime
prerequisites:
  - zygote-startup-flow
  - dalvik-vs-art
  - android-architecture-complete-overview
estimated_minutes: 80
contributors: []
diagrams: []
examples: []
canonical_id: aosp-intermediate-79
---

# Zygote fork model

## Overview

The Zygote fork model is Android's mechanism for creating new application processes by forking (copying) the Zygote process, which has preloaded common classes and resources. Understanding the Zygote fork model is essential for AOSP development, as it explains how Android applications are launched, how memory is shared efficiently through copy-on-write, how the runtime environment is prepared, and why app startup is fast. This guide provides a comprehensive overview of the Zygote fork model, the fork mechanism, copy-on-write memory sharing, process specialization, and how this model enables fast app startup.

Think of the Zygote fork model like a photocopier with a master template: just as a photocopier can quickly make copies of a pre-printed template (much faster than printing each copy from scratch), Zygote can quickly fork new processes that already have all common classes and resources preloaded (much faster than starting each app from scratch). The "copies" share the original pages until they need to be modified, then they get their own copy - this is copy-on-write.

## Deep Explanation

### What is the Zygote Fork Model?

The Zygote fork model is Android's process creation mechanism where new application processes are created by forking (copying) the Zygote process, which already has common Java classes, resources, and the ART runtime preloaded.

**Key Characteristics:**
- **Fork-Based:** Uses Unix fork() system call
- **Preloaded State:** Zygote has classes/resources preloaded
- **Copy-on-Write:** Memory shared until modified
- **Fast Startup:** Apps start quickly

**Why Fork Model?**
- **Fast Startup:** Preloaded state enables fast launch
- **Memory Efficiency:** Shared memory via copy-on-write
- **Consistency:** All apps use same preloaded code
- **Resource Sharing:** Efficient resource usage

### Fork Mechanism

#### Unix Fork System Call

**What is Fork?**
- Creates copy of current process
- Child process is exact copy
- Both processes continue execution
- Child gets new PID

**Fork Behavior:**
```c
pid_t pid = fork();
if (pid == 0) {
    // Child process
    // New PID, copy of parent
} else {
    // Parent process
    // Original PID, continues
}
```

**Memory Inheritance:**
- Child inherits parent's memory
- Copy-on-write semantics
- Shared until modified
- Efficient memory usage

#### Zygote Fork Process

**Fork Sequence:**
```
1. ActivityManager requests fork
   ↓
2. Zygote receives request
   ↓
3. Zygote calls fork()
   ↓
4. Child process created
   ↓
5. Child inherits Zygote's state
   ↓
6. Child specializes for app
   ↓
7. App process ready
```

**Fork Implementation:**
```java
// Zygote fork implementation
int pid = Zygote.forkAndSpecialize(
    uid, gid, gids,
    runtimeFlags, rlimits,
    mountExternal, seInfo,
    niceName, fdsToClose,
    fdsToIgnore, startChildZygote,
    instructionSet, appDataDir
);
```

### Copy-on-Write Memory

#### What is Copy-on-Write?

Copy-on-Write (COW) is a memory management technique where memory pages are shared between processes until one process modifies them, at which point a private copy is created.

**Key Characteristics:**
- **Shared Initially:** Memory pages shared
- **Copy on Write:** Copy created when modified
- **Efficient:** Saves memory
- **Transparent:** Automatic behavior

**Why Copy-on-Write?**
- **Memory Savings:** Multiple processes share memory
- **Efficiency:** No copying until needed
- **Performance:** Fast fork operation
- **Scalability:** Works with many processes

#### COW in Zygote Fork

**Memory Sharing:**
```
Zygote Process
┌─────────────────────┐
│ Preloaded Classes   │ ← Shared memory
│ Preloaded Resources │ ← Shared memory
│ ART Runtime         │ ← Shared memory
│ Native Libraries    │ ← Shared memory
└─────────────────────┘
         │
         │ fork()
         │
         ▼
App Process
┌─────────────────────┐
│ Same Classes        │ ← Shared (COW)
│ Same Resources      │ ← Shared (COW)
│ Same Runtime        │ ← Shared (COW)
│ Same Libraries      │ ← Shared (COW)
└─────────────────────┘
```

**When Copy Occurs:**
- App modifies class data
- App loads new classes
- App modifies resources
- App changes runtime state

**Memory Efficiency:**
- 10 apps = 1 copy of common code
- Only app-specific data copied
- Significant memory savings
- Efficient resource usage

### Process Specialization

#### What is Specialization?

Process specialization is the process of configuring a forked Zygote child process to become a specific Android application process.

**Specialization Steps:**
1. Set process name
2. Set UID/GID
3. Configure SELinux context
4. Load app-specific classes
5. Initialize app environment
6. Start app main method

#### Specialization Process

**Step 1: Identity Setup**
```java
// Set process name
Process.setArgV0(appPackageName);

// Set UID/GID
setuid(uid);
setgid(gid);
```

**Step 2: Security Context**
```java
// Set SELinux context
selinux_android_setcontext(uid, isSystemServer, seInfo, appName);
```

**Step 3: App-Specific Initialization**
```java
// Load app classes
ClassLoader classLoader = createAppClassLoader(appDataDir);

// Initialize app
RuntimeInit.applicationInit(targetSdkVersion, argv, classLoader);
```

**Step 4: Start Application**
```java
// Invoke app main
Method mainMethod = clazz.getMethod("main", String[].class);
mainMethod.invoke(null, new Object[] { argv });
```

### Fork Request Flow

#### Request Process

**Complete Flow:**
```
Application Launch
     │
     ▼
ActivityManager
     │
     │ IPC Request
     │
     ▼
Zygote Socket
     │
     │ Fork Request
     │
     ▼
Zygote Process
     │
     │ fork()
     │
     ▼
Child Process
     │
     │ Specialize
     │
     ▼
App Process
```

#### Request Format

**Fork Request:**
```java
// Request parameters
String[] args = {
    "--setuid=" + uid,
    "--setgid=" + gid,
    "--runtime-args",
    "--target-sdk-version=" + targetSdkVersion,
    appPackageName,
    appMainClass,
    appMainMethod
};
```

**Request Handling:**
```java
// Zygote receives request
ZygoteConnection conn = socket.accept();
String[] args = conn.readArgumentList();

// Parse arguments
int uid = parseUid(args);
String packageName = parsePackage(args);

// Fork process
int pid = forkAndSpecialize(uid, ...);
```

### Memory Sharing Benefits

#### Memory Efficiency

**Shared Memory:**
- Preloaded classes shared
- Framework classes shared
- Resources shared
- Native libraries shared

**Memory Savings:**
```
Without COW:
- 10 apps × 50MB = 500MB

With COW:
- 1 copy (50MB) + 10 apps × 5MB = 100MB
- 80% memory savings
```

#### Performance Benefits

**Fast Fork:**
- Fork is fast (copy page tables)
- No memory copying initially
- Shared memory pages
- Minimal overhead

**Fast Startup:**
- Classes already loaded
- Resources preloaded
- Runtime initialized
- Minimal initialization

### Zygote Variants

#### 32-bit vs 64-bit Zygote

**32-bit Zygote:**
- For 32-bit apps
- 32-bit native libraries
- 32-bit ART runtime
- Separate process

**64-bit Zygote:**
- For 64-bit apps
- 64-bit native libraries
- 64-bit ART runtime
- Primary Zygote

**Selection:**
- Framework selects appropriate Zygote
- Based on app's native libraries
- Architecture matching
- Optimal performance

#### WebView Zygote

**Separate Zygote:**
- Isolated from app Zygotes
- Security isolation
- Resource isolation
- WebView-specific

**Purpose:**
- Isolate WebView
- Security boundaries
- Resource management
- Independent lifecycle

### Fork Model Benefits

#### Performance

**Fast App Launch:**
- Preloaded state
- Minimal initialization
- Fast fork operation
- Quick specialization

**Efficient Memory:**
- Shared memory
- Copy-on-write
- Minimal duplication
- Scalable

#### Consistency

**Shared Code:**
- All apps use same framework
- Consistent behavior
- Same runtime version
- Unified environment

**Reliability:**
- Preloaded code tested
- Framework validated
- Runtime verified
- Stable base

### Fork Model Limitations

#### Memory Pressure

**COW Overhead:**
- Copy when modified
- Memory pressure
- Page faults
- Performance impact

**Mitigation:**
- Minimize modifications
- Efficient memory use
- GC optimization
- Memory management

#### Fork Overhead

**Fork Cost:**
- Page table copying
- Process creation
- Context switching
- Initial overhead

**Optimization:**
- Efficient fork implementation
- Minimal page tables
- Optimized specialization
- Fast path optimization

### Debugging Fork Model

#### Common Issues

**Fork Failures:**
- Out of memory
- Resource limits
- Permission issues
- Process limits

**Debugging:**
```bash
# Check process limits
adb shell ulimit -a

# Check memory
adb shell dumpsys meminfo

# Check Zygote
adb shell ps | grep zygote
```

#### Fork Monitoring

**Monitoring Tools:**
```bash
# Monitor fork operations
adb shell strace -p <zygote_pid> -e fork

# Check process tree
adb shell pstree

# Monitor memory sharing
adb shell cat /proc/<pid>/smaps
```

## Key Takeaways

1. **Zygote fork model** creates new app processes by forking the Zygote process, which has preloaded common classes and resources.

2. **Fork mechanism** uses Unix fork() system call to create a copy of Zygote, with the child process inheriting Zygote's preloaded state.

3. **Copy-on-Write (COW)** enables efficient memory sharing where memory pages are shared until modified, providing significant memory savings.

4. **Process specialization** configures the forked child process to become a specific app by setting identity, security context, and loading app-specific classes.

5. **Fork request flow** involves ActivityManager requesting a fork via Zygote socket, Zygote forking a new process, and the child specializing for the app.

6. **Memory sharing benefits** include significant memory savings (shared preloaded code), fast fork operations, and efficient resource usage across multiple apps.

7. **Zygote variants** include 32-bit and 64-bit Zygotes for different app architectures, and WebView Zygote for isolated WebView execution.

8. **Understanding the Zygote fork model** is essential for AOSP development, explaining how apps are launched, how memory is managed efficiently, and why Android app startup is fast.

## Related Topics

- **Zygote Startup Flow:** How Zygote is initialized and started
- **Dalvik vs ART:** Runtime environments that Zygote preloads
- **Android Architecture - Complete Overview:** How Zygote fits into overall architecture
- **System Server Launch:** How System Server is forked from Zygote

