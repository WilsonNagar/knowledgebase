---
number: 66
title: libhardware
slug: libhardware
level: intermediate
tags:
  - aosp
  - libhardware
  - hal
  - hardware
  - module-loading
  - legacy-hal
prerequisites:
  - hal-modules-hw-directory
  - android-architecture-complete-overview
estimated_minutes: 80
contributors: []
diagrams: []
examples: []
canonical_id: aosp-intermediate-66
---

# libhardware

## Overview

libhardware is the core library that provides the framework for loading and interacting with HAL (Hardware Abstraction Layer) modules in Android. It defines the standard HAL interface structures, provides module loading functions, and manages the lifecycle of HAL modules. Understanding libhardware is essential for AOSP development, as it's the foundation of the legacy HAL model, provides the interface between framework and hardware, and is still used by many HAL implementations. This guide provides a comprehensive overview of libhardware, its API, module loading internals, interface definitions, and how it enables hardware abstraction.

Think of libhardware like a library management system: just as a library system provides a standard way to find, check out, and use books (modules), libhardware provides a standard way to find, load, and use HAL modules. It defines the "catalog system" (interface structures) and "checkout process" (loading functions) that allow the framework to discover and use hardware-specific implementations without knowing the details of each implementation.

## Deep Explanation

### What is libhardware?

libhardware is a C library that provides the framework for HAL modules in Android. It defines standard interfaces, provides module loading mechanisms, and manages the interaction between the Android framework and hardware-specific implementations.

**Key Characteristics:**
- **HAL Framework:** Core library for HAL modules
- **Module Loading:** Dynamic loading of HAL modules
- **Standard Interface:** Defines HAL interface structures
- **Legacy Model:** Foundation of pre-Treble HAL model

**Why libhardware?**
- **Standardization:** Consistent interface across HALs
- **Dynamic Loading:** Load modules at runtime
- **Abstraction:** Hide hardware details from framework
- **Flexibility:** Allow vendor-specific implementations

### libhardware Location and Structure

#### Source Location

**AOSP Path:**
```
hardware/libhardware/
├── include/
│   └── hardware/
│       ├── hardware.h          # Core HAL structures
│       ├── audio.h              # Audio HAL interface
│       ├── camera.h             # Camera HAL interface
│       ├── sensors.h            # Sensors HAL interface
│       └── ...                  # Other HAL interfaces
├── hardware.c                   # Module loading implementation
└── modules/
    └── ...                      # Example modules
```

**Installed Location:**
- Library: `/system/lib/libhardware.so` (or `/vendor/lib/libhardware.so`)
- Headers: Available to HAL implementations
- Modules: `/system/lib/hw/` or `/vendor/lib/hw/`

#### Library Components

**Core Components:**
- **hardware.h:** Core HAL structures and definitions
- **hardware.c:** Module loading implementation
- **HAL-specific headers:** Interface definitions for each HAL type
- **Module loading functions:** `hw_get_module()`, etc.

### Core API

#### hw_get_module()

**Function Signature:**
```c
int hw_get_module(const char *id, const struct hw_module_t **module);
```

**Purpose:**
- Load a HAL module by ID
- Search standard locations
- Return module structure
- Primary module loading function

**Parameters:**
- `id`: Module identifier (e.g., "audio", "camera")
- `module`: Output parameter for loaded module structure

**Returns:**
- `0` on success
- Negative error code on failure

**Usage:**
```c
const struct hw_module_t *module;
int err = hw_get_module(AUDIO_HARDWARE_MODULE_ID, &module);
if (err != 0) {
    ALOGE("Failed to load audio module: %d", err);
    return err;
}
// Use module
```

#### hw_get_module_by_class()

**Function Signature:**
```c
int hw_get_module_by_class(const char *class_id, const char *inst,
                          const struct hw_module_t **module);
```

**Purpose:**
- Load module by class and instance
- More specific module selection
- Allows multiple instances

**Parameters:**
- `class_id`: Class identifier (e.g., "audio")
- `inst`: Instance identifier (e.g., "primary", "a2dp")
- `module`: Output parameter

**Usage:**
```c
const struct hw_module_t *module;
int err = hw_get_module_by_class("audio", "primary", &module);
```

### Core Data Structures

#### hw_module_t

**Structure Definition:**
```c
typedef struct hw_module_t {
    uint32_t tag;                    // Must be HARDWARE_MODULE_TAG
    uint16_t module_api_version;   // Module API version
    uint16_t hal_api_version;     // HAL API version
    const char *id;                 // Module ID
    const char *name;               // Module name
    const char *author;             // Author
    struct hw_module_methods_t* methods;  // Module methods
    void* dso;                       // Shared library handle
    uint32_t reserved[32-7];        // Reserved fields
} hw_module_t;
```

**Key Fields:**
- **tag:** Must be `HARDWARE_MODULE_TAG` (0x14) for validation
- **id:** Unique module identifier
- **methods:** Function pointers, especially `open()`
- **dso:** Handle to loaded shared library
- **version fields:** API version information

**Purpose:**
- Represents a HAL module
- Contains module metadata
- Provides access to module methods
- Links to loaded library

#### hw_module_methods_t

**Structure Definition:**
```c
typedef struct hw_module_methods_t {
    int (*open)(const struct hw_module_t* module,
                const char* id,
                struct hw_device_t** device);
} hw_module_methods_t;
```

**Purpose:**
- Defines methods available on module
- Primary method is `open()` to get devices
- Extensible for module-specific methods

**open() Method:**
- Opens a device from the module
- Returns device structure
- Module-specific implementation

#### hw_device_t

**Structure Definition:**
```c
typedef struct hw_device_t {
    uint32_t tag;                   // Must be HARDWARE_DEVICE_TAG
    uint32_t version;                // Device API version
    struct hw_module_t* module;     // Module that owns device
    uint32_t reserved[12];          // Reserved fields
    void (*close)(struct hw_device_t* device);  // Close device
} hw_device_t;
```

**Key Fields:**
- **tag:** Must be `HARDWARE_DEVICE_TAG` (0x10) for validation
- **version:** Device API version
- **module:** Reference to owning module
- **close:** Function to close/cleanup device

**Purpose:**
- Represents a hardware device
- Base structure extended by HAL-specific types
- Managed by module
- Lifecycle tied to module

### Module Loading Internals

#### Loading Process

**Step 1: Search for Module**
```
1. Construct module path
2. Try /vendor/lib/hw/<module>.<variant>.so
3. Try /system/lib/hw/<module>.<variant>.so
4. Try platform-specific variant
5. Fall back to default variant
```

**Step 2: Load Shared Library**
```c
// Pseudo-code
void* handle = dlopen(path, RTLD_NOW);
if (handle == NULL) {
    // Error: library not found or cannot load
    return -ENOENT;
}
```

**Step 3: Find Module Symbol**
```c
// Look for HAL_MODULE_INFO_SYM
const struct hw_module_t* hmi = 
    (const struct hw_module_t*)dlsym(handle, HAL_MODULE_INFO_SYM);
if (hmi == NULL) {
    dlclose(handle);
    return -EINVAL;
}
```

**Step 4: Validate Module**
```c
// Check module tag
if (hmi->tag != HARDWARE_MODULE_TAG) {
    dlclose(handle);
    return -EINVAL;
}

// Check module ID matches
if (strcmp(hmi->id, requested_id) != 0) {
    dlclose(handle);
    return -EINVAL;
}
```

**Step 5: Return Module**
```c
// Store handle in module
hmi->dso = handle;
*module = hmi;
return 0;
```

#### Module Search Algorithm

**Path Construction:**
```c
// Try variant-specific first
snprintf(path, sizeof(path), "%s/%s.%s.so", base_path, id, variant);

// Then try default
snprintf(path, sizeof(path), "%s/%s.default.so", base_path, id);
```

**Search Order:**
1. `/vendor/lib/hw/<id>.<variant>.so`
2. `/system/lib/hw/<id>.<variant>.so`
3. `/vendor/lib/hw/<id>.default.so`
4. `/system/lib/hw/<id>.default.so`

**Variant Selection:**
- Platform-specific variant preferred
- Property-based selection
- Fallback to "default"
- Allows vendor overrides

### HAL Interface Definitions

#### Standard HAL Interfaces

**Audio HAL:**
```c
// hardware/audio.h
typedef struct audio_module {
    struct hw_module_t common;
} audio_module_t;

typedef struct audio_hw_device {
    struct hw_device_t common;
    // Audio-specific methods
    int (*set_parameters)(struct audio_hw_device *dev, const char *kv_pairs);
    // ... more methods
} audio_hw_device_t;
```

**Camera HAL:**
```c
// hardware/camera.h
typedef struct camera_module {
    struct hw_module_t common;
    // Camera-specific methods
} camera_module_t;

typedef struct camera_device {
    struct hw_device_t common;
    // Camera-specific methods
} camera_device_t;
```

**Sensors HAL:**
```c
// hardware/sensors.h
typedef struct sensors_module {
    struct hw_module_t common;
} sensors_module_t;

typedef struct sensors_poll_device {
    struct hw_device_t common;
    // Sensor polling methods
} sensors_poll_device_t;
```

### Module Lifecycle

#### Module Loading

**Initial Load:**
- Framework calls `hw_get_module()`
- libhardware searches and loads .so
- Module structure returned
- Module remains loaded

**Module Caching:**
- Loaded modules may be cached
- Subsequent calls return cached module
- Reduces loading overhead
- Module stays in memory

#### Device Lifecycle

**Device Opening:**
```c
struct hw_device_t *device;
int err = module->methods->open(module, "device_id", &device);
if (err != 0) {
    // Error handling
}
```

**Device Usage:**
- Device methods called
- Hardware operations performed
- Device-specific functionality

**Device Closing:**
```c
device->close(device);
// Device resources freed
// Device invalidated
```

### Error Handling

#### Error Codes

**Common Errors:**
- `-ENOENT`: Module not found
- `-EINVAL`: Invalid module or parameters
- `-ENOMEM`: Out of memory
- `-EIO`: I/O error

**Error Checking:**
```c
int err = hw_get_module(id, &module);
if (err != 0) {
    ALOGE("Failed to load module %s: %s", id, strerror(-err));
    return err;
}
```

### libhardware Implementation Details

#### Symbol Resolution

**HAL_MODULE_INFO_SYM:**
- Standard symbol name: `HAL_MODULE_INFO_SYM_AS_STR`
- Module must export this symbol
- Points to module structure
- Required for module loading

**Module Definition:**
```c
// In HAL module implementation
struct audio_module HAL_MODULE_INFO_SYM = {
    .common = {
        .tag = HARDWARE_MODULE_TAG,
        .module_api_version = AUDIO_MODULE_API_VERSION_0_1,
        .hal_api_version = HARDWARE_HAL_API_VERSION,
        .id = AUDIO_HARDWARE_MODULE_ID,
        .name = "Audio HAL",
        .author = "Vendor",
        .methods = &hal_module_methods,
    },
};
```

#### Library Handle Management

**Handle Storage:**
- Stored in `hw_module_t.dso`
- Used for cleanup
- Prevents library unloading
- Managed by libhardware

**Cleanup:**
- Module handle kept until process exit
- No explicit unloading
- System manages library lifecycle
- Handles freed on process termination

### libhardware vs Modern HAL

#### libhardware (Legacy)

**Characteristics:**
- C-based interface
- Shared library loading
- Same-process execution
- Pre-Treble model

**Limitations:**
- No process isolation
- No versioning
- Tight coupling
- Difficult to update

#### Modern HAL (HIDL/AIDL)

**Characteristics:**
- Interface-based
- Process isolation
- Versioned interfaces
- Treble-compatible

**Advantages:**
- Independent updates
- Better isolation
- Version management
- Modern architecture

### Using libhardware

#### Framework Usage

**Loading Module:**
```c
#include <hardware/hardware.h>
#include <hardware/audio.h>

const struct audio_module *module;
int err = hw_get_module(AUDIO_HARDWARE_MODULE_ID,
                       (const struct hw_module_t**)&module);
```

**Opening Device:**
```c
struct audio_hw_device *device;
err = module->common.methods->open(&module->common,
                                   "primary",
                                   (struct hw_device_t**)&device);
```

**Using Device:**
```c
// Call device methods
err = device->set_parameters(device, "key=value");
if (err != 0) {
    // Error handling
}
```

**Closing Device:**
```c
device->common.close(&device->common);
```

### Best Practices

#### Module Development

**Standard Interface:**
- Follow libhardware structures
- Implement required methods
- Use standard error codes
- Document module capabilities

**Symbol Export:**
- Export `HAL_MODULE_INFO_SYM`
- Use correct structure type
- Initialize all fields
- Validate in implementation

#### Error Handling

**Return Codes:**
- Use standard error codes
- Document error conditions
- Provide meaningful errors
- Handle all failure cases

**Resource Management:**
- Allocate in open()
- Free in close()
- Handle errors properly
- Clean up on failure

### Debugging libhardware

#### Common Issues

**Module Not Found:**
- Check module path
- Verify .so file exists
- Check file permissions
- Review search paths

**Symbol Not Found:**
- Verify `HAL_MODULE_INFO_SYM` export
- Check symbol visibility
- Review build configuration
- Inspect .so file

**Invalid Module:**
- Check module tag
- Verify module ID
- Review structure initialization
- Validate version fields

#### Debugging Tools

**Library Inspection:**
```bash
# Check exported symbols
nm -D /vendor/lib/hw/audio.primary.default.so | grep HAL_MODULE

# Check library dependencies
ldd /vendor/lib/hw/audio.primary.default.so

# View library information
readelf -d /vendor/lib/hw/audio.primary.default.so
```

**Runtime Debugging:**
```c
// Add logging
ALOGD("Loading module: %s", id);
ALOGD("Module path: %s", path);
ALOGD("Module loaded: tag=0x%x, id=%s", module->tag, module->id);
```

## Key Takeaways

1. **libhardware is the core library** that provides the framework for loading and interacting with HAL modules in Android.

2. **hw_get_module() is the primary function** for loading HAL modules, searching standard locations and returning module structures.

3. **Core structures (hw_module_t, hw_device_t)** define the standard HAL interface, with modules extending these for HAL-specific functionality.

4. **Module loading** searches `/vendor/lib/hw/` and `/system/lib/hw/`, trying platform-specific variants before falling back to default.

5. **HAL_MODULE_INFO_SYM** is the required symbol that modules must export, pointing to the module structure.

6. **libhardware is the legacy HAL model** before Project Treble, replaced by HIDL/AIDL HALs for better isolation and versioning.

7. **Module lifecycle** involves loading (hw_get_module), device opening (module->methods->open), usage, and closing (device->close).

8. **Understanding libhardware** is essential for maintaining legacy HALs, understanding HAL evolution, and debugging hardware interface issues in AOSP.

## Related Topics

- **HAL modules (hw/ directory):** How HAL modules are structured and used
- **Android Architecture - Complete Overview:** How HAL fits into overall architecture
- **HIDL:** Modern HAL interface definition (replacement for libhardware)
- **AIDL-based HALs:** Modern AIDL-based HAL implementations

