---
number: 110
title: Customizing framework services
slug: customizing-framework-services
level: intermediate
tags:
  - aosp
  - framework
  - framework-customization
  - service-customization
  - oem-customization
  - aosp-development
prerequisites:
  - system-server-overview
  - activitymanagerservice-ams-internals
  - adding-new-system-apis
estimated_minutes: 95
contributors: []
diagrams: []
examples: []
canonical_id: aosp-intermediate-110
---

# Customizing framework services

## Overview

Customizing framework services involves modifying or extending existing system services to add OEM-specific functionality, change default behavior, or adapt services for specific hardware or use cases. Understanding how to customize framework services is essential for AOSP development, as it explains how to modify service behavior, how to extend service functionality, how to add OEM-specific features, how to maintain compatibility, and how to test customizations. This guide provides a comprehensive overview of customizing framework services, customization approaches, service modification, extension patterns, compatibility considerations, and best practices.

Think of customizing framework services like customizing a car: just as you can modify a car's engine (service behavior), add new features (extend functionality), and adapt it for specific needs (OEM requirements), customizing framework services allows modifying service behavior, adding new features, and adapting services for specific hardware or OEM requirements.

## Deep Explanation

### What is Customizing Framework Services?

Customizing framework services is the process of modifying or extending existing system services to add OEM-specific functionality, change default behavior, or adapt services for specific hardware or use cases while maintaining compatibility with the Android framework.

**Key Characteristics:**
- **Service Modification:** Modify existing service behavior
- **Functionality Extension:** Add new features
- **OEM Customization:** OEM-specific adaptations
- **Compatibility:** Maintain framework compatibility
- **Integration:** Integrate with existing services

**Why Customize Framework Services?**
- **OEM Requirements:** Meet OEM-specific needs
- **Hardware Adaptation:** Adapt for specific hardware
- **Feature Addition:** Add new functionality
- **Behavior Modification:** Change default behavior
- **Market Differentiation:** Differentiate products

### Customization Approaches

#### Service Subclassing

**Service Subclassing:**
- Extend existing service class
- Override methods
- Add custom functionality
- Maintain compatibility

**Subclassing Example:**
```java
public class CustomActivityManagerService extends ActivityManagerService {
    public CustomActivityManagerService(Context context) {
        super(context);
        // Custom initialization
    }
    
    @Override
    public int startActivity(...) {
        // Custom pre-processing
        customPreStartActivity(...);
        
        // Call parent
        int result = super.startActivity(...);
        
        // Custom post-processing
        customPostStartActivity(...);
        
        return result;
    }
    
    private void customPreStartActivity(...) {
        // OEM-specific logic
    }
}
```

#### Service Wrapping

**Service Wrapping:**
- Wrap service with custom wrapper
- Delegate to original service
- Add custom logic
- Transparent to clients

**Wrapping Example:**
```java
public class CustomWindowManagerService {
    private WindowManagerService mOriginal;
    
    public CustomWindowManagerService(WindowManagerService original) {
        mOriginal = original;
    }
    
    public int addWindow(...) {
        // Custom validation
        if (customValidation(...)) {
            return WINDOW_ERROR;
        }
        
        // Call original
        return mOriginal.addWindow(...);
    }
}
```

#### Configuration-Based Customization

**Configuration Customization:**
- Use configuration files
- Modify behavior via config
- No code changes needed
- Easy to update

**Configuration Example:**
```java
// In service
if (SystemProperties.getBoolean("ro.custom.feature.enabled", false)) {
    // Custom behavior
} else {
    // Default behavior
}
```

### Service Modification

#### Behavior Modification

**Modifying Behavior:**
- Override service methods
- Change default logic
- Add custom checks
- Modify return values

**Modification Example:**
```java
@Override
public ProcessRecord startProcessLocked(...) {
    // Custom process creation logic
    if (shouldUseCustomProcess(...)) {
        return createCustomProcess(...);
    }
    
    // Default behavior
    return super.startProcessLocked(...);
}
```

#### Policy Customization

**Policy Customization:**
- Customize service policies
- Modify decision logic
- Add OEM-specific rules
- Maintain security

**Policy Example:**
```java
@Override
public boolean shouldKillProcess(ProcessRecord app) {
    // OEM-specific kill policy
    if (isOemProtectedApp(app)) {
        return false; // Don't kill
    }
    
    // Default policy
    return super.shouldKillProcess(app);
}
```

### Service Extension

#### Adding New Methods

**Method Addition:**
- Add new methods to service
- Expose via AIDL
- Maintain backward compatibility
- Document new methods

**Method Addition Example:**
```java
// In service
public void customMethod(String param) {
    // Custom implementation
}

// In AIDL
interface IMyService {
    void customMethod(String param);
}
```

#### Feature Addition

**Feature Addition:**
- Add new features to service
- Integrate with existing code
- Maintain compatibility
- Test thoroughly

**Feature Example:**
```java
public class CustomPowerManagerService extends PowerManagerService {
    private CustomFeature mCustomFeature;
    
    @Override
    public void systemReady() {
        super.systemReady();
        mCustomFeature = new CustomFeature();
        mCustomFeature.initialize();
    }
    
    public void customFeatureMethod() {
        mCustomFeature.doSomething();
    }
}
```

### OEM Customization

#### OEM-Specific Features

**OEM Features:**
- Add OEM-specific functionality
- Customize for OEM needs
- Maintain framework compatibility
- Document customizations

**OEM Feature Example:**
```java
public class OemActivityManagerService extends ActivityManagerService {
    private OemFeatureManager mOemFeatures;
    
    @Override
    public int startActivity(...) {
        // OEM-specific pre-processing
        if (mOemFeatures.shouldIntercept(...)) {
            return mOemFeatures.handleStartActivity(...);
        }
        
        // Default behavior
        return super.startActivity(...);
    }
}
```

#### Hardware Adaptation

**Hardware Adaptation:**
- Adapt services for specific hardware
- Handle hardware differences
- Optimize for hardware
- Maintain compatibility

**Hardware Adaptation Example:**
```java
@Override
public void updateDisplayConfiguration() {
    // Hardware-specific configuration
    if (isCustomDisplayHardware()) {
        applyCustomDisplayConfig();
    } else {
        super.updateDisplayConfiguration();
    }
}
```

### Compatibility Considerations

#### Backward Compatibility

**Compatibility Requirements:**
- Maintain existing APIs
- Don't break existing behavior
- Add new APIs carefully
- Test compatibility

**Compatibility Example:**
```java
// Maintain old API
@Deprecated
public void oldMethod() {
    newMethod(null); // Delegate to new
}

// New API
public void newMethod(String param) {
    // New implementation
    if (param == null) {
        // Backward compatible behavior
    } else {
        // New behavior
    }
}
```

#### Framework Compatibility

**Framework Compatibility:**
- Maintain framework contracts
- Follow framework patterns
- Use framework APIs
- Test with framework

### Customization Patterns

#### Strategy Pattern

**Strategy Pattern:**
- Define customization strategies
- Switch strategies via config
- Easy to change behavior
- Maintainable

**Strategy Example:**
```java
interface CustomizationStrategy {
    void customize(ServiceContext context);
}

class OemStrategy implements CustomizationStrategy {
    @Override
    public void customize(ServiceContext context) {
        // OEM-specific customization
    }
}

// In service
CustomizationStrategy strategy = getStrategy();
strategy.customize(this);
```

#### Factory Pattern

**Factory Pattern:**
- Create customized services
- Factory selects implementation
- Easy to switch implementations
- Maintainable

**Factory Example:**
```java
class ServiceFactory {
    public static ActivityManagerService create() {
        if (isOemBuild()) {
            return new OemActivityManagerService();
        }
        return new ActivityManagerService();
    }
}
```

### Service Integration

#### SystemServer Integration

**SystemServer Customization:**
```java
// In SystemServer
if (isOemBuild()) {
    mActivityManagerService = new OemActivityManagerService(...);
} else {
    mActivityManagerService = new ActivityManagerService(...);
}
```

#### Service Registration

**Custom Service Registration:**
```java
// Register custom service
ServiceManager.addService(Context.ACTIVITY_SERVICE, 
                         customActivityManagerService);
```

### Testing Customizations

#### Testing Strategy

**Testing Requirements:**
- Unit tests
- Integration tests
- Compatibility tests
- Regression tests

**Test Implementation:**
```java
@Test
public void testCustomBehavior() {
    CustomActivityManagerService service = new CustomActivityManagerService(...);
    int result = service.startActivity(...);
    assertEquals(EXPECTED_RESULT, result);
}
```

#### Compatibility Testing

**Compatibility Tests:**
- Test with standard apps
- Test framework compatibility
- Test API compatibility
- Test behavior

### Best Practices

#### Customization Guidelines

**Best Practices:**
- Minimize changes
- Maintain compatibility
- Document customizations
- Test thoroughly
- Use configuration when possible

**Guidelines:**
- Prefer configuration over code changes
- Maintain framework contracts
- Document all customizations
- Test with standard apps
- Keep customizations isolated

#### Code Organization

**Organization:**
- Separate customization code
- Use clear naming
- Document customizations
- Maintain structure

**Structure:**
```
frameworks/base/services/core/java/com/android/server/
├── am/
│   ├── ActivityManagerService.java
│   └── oem/
│       └── OemActivityManagerService.java
```

### Debugging Customizations

#### Common Issues

**Development Issues:**
- Customization not working
- Compatibility problems
- Performance issues
- Integration problems

#### Debugging Tools

**Debugging:**
- Service dumps
- Logcat filtering
- Binder tracing
- Performance profiling

**Tools:**
```bash
# Dump service state
adb shell dumpsys activity

# Filter service logs
adb logcat | grep ActivityManager

# Binder tracing
adb shell setprop debug.binder.trace 1
```

## Key Takeaways

1. **Customizing framework services** involves modifying or extending existing system services to add OEM-specific functionality, change default behavior, or adapt services for specific hardware or use cases.

2. **Customization approaches** include service subclassing (extending service class), service wrapping (wrapping with custom wrapper), and configuration-based customization (using configuration files).

3. **Service modification** includes behavior modification (overriding methods, changing logic), policy customization (customizing service policies), and maintaining compatibility.

4. **Service extension** includes adding new methods (exposing via AIDL), feature addition (adding new features), and integrating with existing code.

5. **OEM customization** includes OEM-specific features (adding OEM functionality), hardware adaptation (adapting for specific hardware), and maintaining framework compatibility.

6. **Compatibility considerations** include backward compatibility (maintaining existing APIs), framework compatibility (maintaining framework contracts), and testing compatibility.

7. **Customization patterns** include strategy pattern (customization strategies), factory pattern (creating customized services), and maintaining maintainable code structure.

8. **Service integration** includes SystemServer integration (customizing service creation), service registration (registering custom services), and maintaining system integration.

9. **Best practices** include minimizing changes, maintaining compatibility, documenting customizations, testing thoroughly, and using configuration when possible.

10. **Understanding customizing framework services** is essential for AOSP development, enabling OEM customization, hardware adaptation, feature addition, and framework extension while maintaining compatibility.

## Related Topics

- **System Server Overview:** How system services are organized
- **ActivityManagerService (AMS) internals:** Example service for customization
- **Adding new system APIs:** How to add new APIs to services
- **Hooking into system services:** Alternative approach to customization

