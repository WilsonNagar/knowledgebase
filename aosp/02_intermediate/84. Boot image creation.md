---
number: 84
title: Boot image creation
slug: boot-image-creation
level: intermediate
tags:
  - aosp
  - art
  - boot-image
  - dex2oat
  - compilation
  - build-system
prerequisites:
  - dex2oat
  - oat-vdex-files
  - art-boot-image-dex-pre-optimization
estimated_minutes: 85
contributors: []
diagrams: []
examples: []
canonical_id: aosp-intermediate-84
---

# Boot image creation

## Overview

Boot image creation is the process of compiling and packaging critical system classes into a pre-compiled ART boot image during the AOSP build process. Understanding boot image creation is essential for AOSP development, as it explains how system classes are pre-compiled, how the boot image is generated, how it's integrated into the build system, and how it impacts boot time and system performance. This guide provides a comprehensive overview of boot image creation, the build process, class selection, compilation, and integration.

Think of boot image creation like preparing a starter kit: just as a starter kit contains all the essential tools and materials needed to begin a project, the boot image contains all the essential system classes needed for Android to start. By preparing this kit in advance (during build), the system can start much faster because everything essential is already compiled and ready to use.

## Deep Explanation

### What is Boot Image Creation?

Boot image creation is the build-time process of compiling critical system classes to native code and packaging them into a boot image file that ART loads at system startup.

**Key Characteristics:**
- **Build-Time:** Happens during AOSP build
- **Pre-Compilation:** Classes compiled before runtime
- **System Classes:** Critical framework classes
- **Fast Loading:** Loaded into memory at boot

**Why Boot Image?**
- **Boot Speed:** Faster system startup
- **Performance:** Pre-compiled code ready
- **Efficiency:** No compilation at boot
- **Optimization:** Build-time optimization

### Boot Image Contents

#### System Classes Included

**Core Framework Classes:**
- `java.lang.*` classes (String, Object, Class, etc.)
- `java.util.*` classes (ArrayList, HashMap, etc.)
- `java.io.*` classes (File, InputStream, etc.)
- `java.net.*` classes (URL, Socket, etc.)

**Android Framework Classes:**
- `android.*` framework classes
- System service classes
- Core utilities
- Framework components

**Selection Criteria:**
- Frequently used during boot
- Critical for system operation
- Performance-sensitive
- Required by multiple components

#### Boot Image Structure

**Image Components:**
```
Boot Image
├── Header
│   ├── Magic number
│   ├── Version
│   └── Metadata
├── Pre-compiled Classes
│   ├── Native code
│   ├── Class metadata
│   └── Method information
├── DEX Files (optional)
│   └── Original DEX for fallback
└── Optimization Info
    └── Compilation metadata
```

### Boot Image Creation Process

#### Step 1: Class Selection

**Selection Process:**
1. Identify critical system classes
2. Analyze class usage patterns
3. Select frequently used classes
4. Include boot-critical classes

**Selection Sources:**
- Framework JAR files
- Core libraries
- System services
- Boot-critical components

**Configuration:**
```makefile
# Boot image class list
BOOTCLASSPATH := \
    core-oj.jar:core-libart.jar:core-libart-ext.jar:...
```

#### Step 2: DEX File Preparation

**DEX Files:**
- Framework DEX files
- Core library DEX files
- System DEX files
- Combined for compilation

**DEX Sources:**
- Framework JAR files
- Core libraries
- System components
- Boot classpath

#### Step 3: Compilation with dex2oat

**Compilation Command:**
```bash
dex2oat \
    --dex-file=framework.dex \
    --oat-file=boot.oat \
    --boot-image=/system/framework/boot.art \
    --compiler-filter=speed \
    --instruction-set=arm64 \
    --android-root=/system \
    --base=0x70000000 \
    --image-classes=preloaded-classes \
    --generate-debug-info
```

**Key Options:**
- `--boot-image`: Output boot image path
- `--compiler-filter=speed`: Maximum optimization
- `--image-classes`: Classes to include
- `--instruction-set`: Target architecture

#### Step 3: Image Generation

**Image Creation:**
1. Compile selected classes
2. Generate native code
3. Optimize code
4. Package into boot image
5. Write image file

**Image Format:**
- ART image format
- Contains native code
- Includes metadata
- Architecture-specific

#### Step 4: Integration into Build

**Build Integration:**
```makefile
# Android.bp example
art_boot_image {
    name: "boot",
    dex_preopt: {
        enabled: true,
    },
    image_classes: "preloaded-classes",
    compiler_filter: "speed",
}
```

**Build Process:**
1. Build system identifies boot image target
2. Collects framework DEX files
3. Calls dex2oat for compilation
4. Generates boot image
5. Packages into system image

### Boot Image File Format

#### Image File Structure

**File Layout:**
```
┌─────────────────────────────────┐
│      Image Header                │
│  - Magic: "ART\n"               │
│  - Version                      │
│  - Image begin/end              │
│  - Image size                   │
├─────────────────────────────────┤
│      Bitmap                     │
│  - Object allocation bitmap    │
│  - Used for GC                  │
├─────────────────────────────────┤
│      Root Objects               │
│  - Class roots                 │
│  - String roots                │
│  - Object roots                │
├─────────────────────────────────┤
│      Pre-compiled Code          │
│  - Native method code          │
│  - Architecture-specific       │
│  - Optimized instructions      │
├─────────────────────────────────┤
│      Class Metadata             │
│  - Class definitions           │
│  - Method information          │
│  - Field information            │
└─────────────────────────────────┘
```

#### Image File Location

**System Partition:**
- `/system/framework/boot.art`
- `/system/framework/boot-<arch>.art`
- Architecture-specific images
- Read-only system files

**Architecture Variants:**
- `boot-arm.art` (32-bit ARM)
- `boot-arm64.art` (64-bit ARM)
- `boot-x86.art` (32-bit x86)
- `boot-x86_64.art` (64-bit x86_64)

### Boot Image Loading

#### Runtime Loading

**Loading Process:**
```
1. ART runtime starts
2. Locate boot image file
3. Map image into memory
4. Verify image integrity
5. Initialize from image
6. Ready for execution
```

**Loading Location:**
- System partition
- Architecture-specific
- Memory-mapped
- Shared across processes

#### Memory Mapping

**Memory Layout:**
```
┌─────────────────────────────────┐
│      Boot Image (shared)        │
│  - Pre-compiled classes         │
│  - Native code                  │
│  - Class metadata               │
└─────────────────────────────────┘
         │
         │ Memory-mapped
         │
         ▼
┌─────────────────────────────────┐
│      Process Memory             │
│  - Shared boot image            │
│  - Copy-on-write                │
└─────────────────────────────────┘
```

**Memory Sharing:**
- Boot image shared across processes
- Copy-on-write semantics
- Efficient memory usage
- Reduced duplication

### Build System Integration

#### Android.bp Configuration

**Boot Image Module:**
```makefile
art_boot_image {
    name: "boot",
    
    dex_preopt: {
        enabled: true,
        use_profile_file: true,
    },
    
    image_classes: "preloaded-classes",
    compiler_filter: "speed",
    
    base_address: "0x70000000",
    instruction_set: "arm64",
}
```

**Configuration Options:**
- `dex_preopt`: Enable pre-optimization
- `image_classes`: Classes to include
- `compiler_filter`: Optimization level
- `base_address`: Memory base address

#### Build Process

**Build Steps:**
```
1. Framework JARs built
2. DEX files generated
3. Boot image target identified
4. dex2oat compilation
5. Boot image generated
6. Packaged into system image
```

**Build Output:**
- Boot image file
- Architecture-specific
- System partition
- Ready for deployment

### Optimization

#### Compiler Filter

**Speed Filter:**
- Maximum optimization
- Best performance
- Longer compilation
- Used for boot image

**Optimization Passes:**
- Method inlining
- Dead code elimination
- Constant propagation
- Register allocation
- Loop optimization

#### Class Selection Optimization

**Selection Criteria:**
- Boot-critical classes
- Frequently used classes
- Performance-sensitive classes
- Framework core classes

**Balance:**
- Include essential classes
- Avoid unnecessary classes
- Balance image size
- Optimize boot time

### Boot Image Benefits

#### Boot Performance

**Faster Boot:**
- Pre-compiled classes ready
- No compilation at boot
- Faster class loading
- Reduced boot time

**Startup Time:**
- System services start faster
- Framework initialization faster
- Reduced boot time
- Better user experience

#### Runtime Performance

**Native Execution:**
- Pre-compiled native code
- Fast method execution
- Optimized code paths
- Better performance

**Memory Efficiency:**
- Shared boot image
- Copy-on-write
- Reduced memory usage
- Efficient sharing

### Boot Image Maintenance

#### Updating Boot Image

**When to Update:**
- Framework changes
- New system classes
- Performance improvements
- Bug fixes

**Update Process:**
1. Modify framework
2. Rebuild boot image
3. Update system image
4. Deploy to device

#### Debugging Boot Image

**Inspection Tools:**
```bash
# Dump boot image
oatdump --image=/system/framework/boot.art

# Check image classes
oatdump --image=/system/framework/boot.art --classes

# Verify image
art --image=/system/framework/boot.art --verify
```

**Common Issues:**
- Missing classes
- Compilation errors
- Image corruption
- Architecture mismatch

## Key Takeaways

1. **Boot image creation** is the build-time process of compiling critical system classes to native code and packaging them into a boot image file for fast system startup.

2. **Boot image contents** include core framework classes (java.lang.*, java.util.*), Android framework classes, and system service classes that are frequently used during boot.

3. **Creation process** involves class selection, DEX file preparation, compilation with dex2oat using speed filter, image generation, and integration into the build system.

4. **Boot image format** is an ART-specific format containing native code, class metadata, and optimization information, stored as architecture-specific files in the system partition.

5. **Boot image loading** happens at runtime when ART starts, with the image memory-mapped and shared across processes using copy-on-write semantics.

6. **Build system integration** uses Android.bp configuration to define boot image modules, specifying classes, compiler filters, and optimization settings.

7. **Boot image benefits** include faster boot time (pre-compiled classes ready), better runtime performance (native execution), and memory efficiency (shared image).

8. **Understanding boot image creation** is essential for AOSP development, explaining how system classes are pre-compiled, how boot images are generated, and how they impact boot time and system performance.

## Related Topics

- **dex2oat:** Compiler used to create boot images
- **OAT & VDEX files:** Output file formats
- **ART boot image & dex pre-optimization:** Related optimization techniques
- **Class preloading:** Runtime class loading from boot image

