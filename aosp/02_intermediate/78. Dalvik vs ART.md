---
number: 78
title: Dalvik vs ART
slug: dalvik-vs-art
level: intermediate
tags:
  - aosp
  - art
  - dalvik
  - runtime
  - jvm
  - compilation
  - dex
  - aot
  - jit
prerequisites:
  - android-architecture-complete-overview
  - zygote-startup-flow
estimated_minutes: 85
contributors: []
diagrams: []
examples: []
canonical_id: aosp-intermediate-78
---

# Dalvik vs ART

## Overview

Dalvik and ART are Android's runtime environments for executing applications, with Dalvik being the original runtime (Android 1.0-4.4) and ART being the modern replacement (Android 5.0+). Understanding the differences between Dalvik and ART is essential for AOSP development, as it explains Android's runtime evolution, compilation strategies, performance improvements, and how Android applications are executed. This guide provides a comprehensive overview of Dalvik vs ART, their architectures, compilation models, performance characteristics, and the transition from Dalvik to ART.

Think of Dalvik vs ART like the difference between an interpreter and a compiler: Dalvik is like an interpreter that reads and executes code line by line (slower but flexible), while ART is like a compiler that translates code to machine language before execution (faster but requires compilation time). ART took Android from interpreted execution to compiled execution, dramatically improving performance.

## Deep Explanation

### What are Dalvik and ART?

Dalvik and ART are Android's runtime environments that execute Android applications written in Java/Kotlin. Dalvik was the original runtime, while ART is the modern replacement that provides better performance.

**Key Characteristics:**
- **Dalvik:** Original runtime (Android 1.0-4.4)
- **ART:** Modern runtime (Android 5.0+)
- **Both:** Execute DEX bytecode
- **Purpose:** Run Android applications

**Why Two Runtimes?**
- **Evolution:** ART replaced Dalvik for better performance
- **Compatibility:** Both use DEX format
- **Transition:** Gradual migration from Dalvik to ART
- **Improvement:** ART provides significant performance gains

### Dalvik Runtime

#### What is Dalvik?

Dalvik was Android's original runtime environment, designed for mobile devices with limited resources. It used a register-based virtual machine to execute DEX bytecode.

**Key Characteristics:**
- **JIT Compilation:** Just-In-Time compilation
- **Interpreted Execution:** Interprets DEX bytecode
- **Register-Based VM:** Uses virtual registers
- **Multiple VMs:** One VM per app process

**Why Dalvik?**
- **Mobile Optimized:** Designed for mobile devices
- **DEX Format:** Compact bytecode format
- **Resource Efficient:** Lower memory usage
- **Fast Startup:** Quick app startup

#### Dalvik Architecture

**Execution Model:**
```
DEX Bytecode
     │
     │ Interpretation
     │
     ▼
Dalvik VM
     │
     │ JIT Compilation (optional)
     │
     ▼
Native Code (hot paths)
```

**Components:**
- **Dalvik VM:** Virtual machine
- **DEX Interpreter:** Bytecode interpreter
- **JIT Compiler:** Just-In-Time compiler
- **GC:** Garbage collector

#### Dalvik Compilation

**JIT (Just-In-Time) Compilation:**
- Compiles during execution
- Compiles hot methods
- Caches compiled code
- Improves performance over time

**Process:**
```
1. App starts
2. DEX interpreted
3. Methods executed
4. Hot methods identified
5. Hot methods compiled
6. Compiled code cached
7. Future calls use compiled code
```

**Limitations:**
- Compilation overhead during execution
- Startup performance not improved
- Memory overhead for compiled code
- Inconsistent performance

### ART Runtime

#### What is ART?

ART (Android Runtime) is Android's modern runtime environment that replaced Dalvik. It uses Ahead-Of-Time (AOT) compilation to compile apps to native code at install time.

**Key Characteristics:**
- **AOT Compilation:** Ahead-Of-Time compilation
- **Native Execution:** Runs compiled native code
- **Better Performance:** Faster than Dalvik
- **Improved GC:** Better garbage collection

**Why ART?**
- **Performance:** Native code execution
- **Battery Life:** Less CPU usage
- **Startup Time:** Faster app startup
- **Memory:** More efficient memory usage

#### ART Architecture

**Execution Model:**
```
DEX Bytecode
     │
     │ AOT Compilation (install time)
     │
     ▼
Native Code (OAT file)
     │
     │ Direct Execution
     │
     ▼
CPU Execution
```

**Components:**
- **dex2oat:** AOT compiler
- **ART Runtime:** Native code executor
- **GC:** Improved garbage collector
- **JIT:** Runtime optimization (Android 7.0+)

#### ART Compilation

**AOT (Ahead-Of-Time) Compilation:**
- Compiles at install time
- Compiles entire app
- Creates OAT files
- Native code ready at runtime

**Process:**
```
1. App installed
2. DEX extracted
3. dex2oat runs
4. DEX compiled to native code
5. OAT file created
6. App ready to run
```

**Benefits:**
- No compilation overhead at runtime
- Consistent performance
- Faster execution
- Better optimization

### Key Differences

#### Compilation Model

**Dalvik:**
- JIT compilation
- Compiles during execution
- Compiles hot methods only
- Runtime compilation overhead

**ART:**
- AOT compilation
- Compiles at install time
- Compiles entire app
- No runtime compilation overhead

#### Performance

**Dalvik:**
- Slower execution (interpreted)
- JIT improves over time
- Startup not optimized
- Variable performance

**ART:**
- Faster execution (native code)
- Consistent performance
- Faster startup
- Better overall performance

#### Memory Usage

**Dalvik:**
- Lower initial memory
- JIT code increases memory
- Multiple VM instances
- Less efficient sharing

**ART:**
- Higher initial memory (OAT files)
- More efficient memory usage
- Better memory sharing
- Improved garbage collection

#### Startup Time

**Dalvik:**
- Slower startup
- Interpretation overhead
- JIT compilation delay
- Class loading time

**ART:**
- Faster startup
- Pre-compiled code
- No interpretation
- Optimized class loading

### DEX Format

#### Common Format

**Both Use DEX:**
- Dalvik Executable format
- Compact bytecode
- Optimized for mobile
- Same format for both

**DEX Structure:**
```
DEX File
├── Header
├── String Table
├── Type Table
├── Prototype Table
├── Field Table
├── Method Table
├── Class Definitions
└── Code (bytecode)
```

#### DEX Execution

**Dalvik:**
- Interprets DEX directly
- JIT compiles hot methods
- Mixed execution model

**ART:**
- Compiles DEX to native
- Executes native code
- Pure native execution

### Garbage Collection

#### Dalvik GC

**Characteristics:**
- Mark-Sweep algorithm
- Stop-the-World pauses
- Concurrent marking (Android 2.3+)
- Fragmentation issues

**Limitations:**
- Longer pauses
- Heap fragmentation
- Less efficient
- Performance impact

#### ART GC

**Characteristics:**
- Improved algorithms
- Concurrent marking
- Generational collection
- Better pause times

**Improvements:**
- Shorter pauses
- Less fragmentation
- More efficient
- Better performance

### File Formats

#### Dalvik Files

**ODEX (Optimized DEX):**
- Optimized DEX format
- Pre-verified
- Faster loading
- Still interpreted

**Location:**
- `/data/dalvik-cache/`
- Per-app cache
- Optimized DEX

#### ART Files

**OAT (Optimized Android Type):**
- Compiled native code
- ELF format
- Executable code
- Larger file size

**VDEX (Verified DEX):**
- Verified DEX (Android 8.0+)
- Pre-verified
- Faster loading
- Skip verification

**Location:**
- `/data/app/<package>/oat/`
- Per-app directory
- Compiled code

### Performance Comparison

#### Execution Speed

**Dalvik:**
- Interpreted: ~10x slower than native
- JIT compiled: ~2-3x slower than native
- Variable performance
- Improves over time

**ART:**
- Native code: Near-native speed
- Consistent performance
- ~2-3x faster than Dalvik
- Immediate performance

#### Startup Time

**Dalvik:**
- Slower startup
- Interpretation overhead
- Class loading time
- JIT warm-up

**ART:**
- Faster startup
- Pre-compiled code
- Optimized loading
- No warm-up needed

#### Memory Usage

**Dalvik:**
- Lower initial footprint
- JIT code increases memory
- Less efficient
- More fragmentation

**ART:**
- Higher initial footprint (OAT)
- More efficient runtime
- Better sharing
- Less fragmentation

### Transition from Dalvik to ART

#### Android 4.4 (KitKat)

**Dual Runtime:**
- Dalvik default
- ART available as option
- Developer preview
- Experimental

**User Choice:**
- Enable ART in developer options
- Test ART compatibility
- Report issues
- Prepare for transition

#### Android 5.0 (Lollipop)

**ART Default:**
- ART becomes default
- Dalvik removed
- Full ART implementation
- Improved performance

**Breaking Changes:**
- Some apps incompatible
- Different behavior
- Performance improvements
- Better battery life

### ART Evolution

#### Android 5.0-6.0

**Pure AOT:**
- AOT compilation only
- Install-time compilation
- Longer install time
- Better runtime performance

#### Android 7.0+ (Nougat)

**Hybrid Compilation:**
- AOT + JIT
- Profile-guided optimization
- Faster install
- Better optimization

**Process:**
```
1. App installed (quick, no AOT)
2. App runs (interpreted initially)
3. JIT compiles hot methods
4. Profile collected
5. Background AOT compilation
6. Optimized code ready
```

### Best Practices

#### For Developers

**Code Optimization:**
- Write efficient code
- Avoid unnecessary allocations
- Optimize hot paths
- Profile and optimize

**Memory Management:**
- Avoid memory leaks
- Use object pooling
- Minimize allocations
- Monitor memory usage

### Debugging

#### Dalvik Debugging

**Tools:**
- Dalvik Debug Monitor (DDM)
- JIT profiling
- Memory profiling
- Performance analysis

#### ART Debugging

**Tools:**
- ART runtime logs
- OAT file inspection
- GC logging
- Performance profiling

**Logging:**
```bash
# ART GC logs
adb shell setprop dalvik.vm.extra-opts -XX:DumpGCPerformanceOnShutdown

# OAT file info
adb shell oatdump --oat-file=<oat_file>
```

## Key Takeaways

1. **Dalvik was Android's original runtime** using JIT compilation and interpreted execution, while **ART is the modern runtime** using AOT compilation and native code execution.

2. **Key difference is compilation timing**: Dalvik compiles during execution (JIT), while ART compiles at install time (AOT), resulting in better performance for ART.

3. **ART provides better performance** with native code execution, faster startup times, improved garbage collection, and more efficient memory usage compared to Dalvik.

4. **Both use DEX format** for bytecode, but ART compiles DEX to native code (OAT files) while Dalvik interprets DEX directly.

5. **ART evolution** moved from pure AOT (Android 5.0) to hybrid AOT+JIT (Android 7.0+) for better balance between install time and runtime performance.

6. **Garbage collection improved** in ART with concurrent marking, generational collection, and shorter pause times compared to Dalvik's mark-sweep algorithm.

7. **File formats differ**: Dalvik uses ODEX (optimized DEX), while ART uses OAT (compiled native code) and VDEX (verified DEX).

8. **Understanding Dalvik vs ART** is essential for AOSP development, explaining Android's runtime evolution, performance characteristics, and how applications are executed on Android devices.

## Related Topics

- **Zygote fork model:** How processes are created in ART
- **dex2oat:** ART's AOT compiler
- **AOT & JIT compilation:** Compilation strategies in ART
- **Android Architecture - Complete Overview:** How ART fits into overall architecture

