---
number: 65
title: HAL modules (hw/ directory)
slug: hal-modules-hw-directory
level: intermediate
tags:
  - aosp
  - hal
  - hardware
  - modules
  - hw-directory
  - libhardware
  - legacy-hal
prerequisites:
  - android-architecture-complete-overview
  - aosp-repo-structure
estimated_minutes: 85
contributors: []
diagrams: []
examples: []
canonical_id: aosp-intermediate-65
---

# HAL modules (hw/ directory)

## Overview

HAL modules in the `hw/` directory represent the legacy Hardware Abstraction Layer model used before Project Treble, where HAL implementations are loaded as shared libraries (.so files) from the `/vendor/lib/hw/` or `/system/lib/hw/` directories. Understanding HAL modules is essential for AOSP development, as many legacy HALs still use this model, it's the foundation for understanding HAL evolution, and it's important for maintaining and debugging existing hardware interfaces. This guide provides a comprehensive overview of HAL modules, the `hw/` directory structure, module loading, the legacy HAL model, and how it relates to modern HAL implementations.

Think of HAL modules like plug-in libraries: just as a software application can load plug-in libraries to add functionality, Android loads HAL modules (shared libraries) to provide hardware-specific functionality. The framework doesn't need to know the details of each hardware implementation - it just loads the appropriate module and calls standard functions, and the module handles the hardware-specific details.

## Deep Explanation

### What are HAL Modules?

HAL modules are shared libraries (.so files) that implement hardware-specific functionality, loaded dynamically by the Android framework to provide hardware abstraction. They follow a standard interface defined by `libhardware` and are stored in the `hw/` directory.

**Key Characteristics:**
- **Shared Libraries:** Compiled as .so files
- **Dynamic Loading:** Loaded at runtime
- **Standard Interface:** Follow libhardware interface
- **Hardware-Specific:** Each module implements specific hardware

**Why HAL Modules?**
- **Hardware Abstraction:** Hide hardware details from framework
- **Vendor Flexibility:** Vendors implement device-specific code
- **Dynamic Loading:** Load only needed modules
- **Standardization:** Consistent interface across devices

### HAL Module Structure

#### Directory Structure

**System HAL Modules:**
```
/system/lib/hw/
├── audio.primary.default.so
├── audio.primary.$(TARGET_BOARD_PLATFORM).so
├── camera.default.so
├── camera.$(TARGET_BOARD_PLATFORM).so
├── sensors.default.so
└── ...
```

**Vendor HAL Modules:**
```
/vendor/lib/hw/
├── audio.primary.$(TARGET_BOARD_PLATFORM).so
├── camera.$(TARGET_BOARD_PLATFORM).so
├── sensors.$(TARGET_BOARD_PLATFORM).so
└── ...
```

**Module Naming:**
- Format: `<module_name>.<variant>.so`
- Example: `audio.primary.default.so`
- Variant can be platform-specific or "default"

#### Module Components

**Shared Library (.so):**
- Compiled C/C++ code
- Implements HAL interface
- Hardware-specific logic
- Loaded dynamically

**Header Files:**
- Interface definitions
- Data structures
- Function prototypes
- In `hardware/libhardware/include/hardware/`

**Implementation:**
- Vendor-specific code
- Hardware driver interfaces
- Device-specific logic
- Platform optimizations

### libhardware Library

#### What is libhardware?

`libhardware` is the library that provides the interface and loading mechanism for HAL modules. It defines the standard HAL interface and provides functions to load and interact with HAL modules.

**Key Functions:**
- `hw_get_module()` - Load HAL module
- `hw_get_module_by_class()` - Load module by class
- Module structure definitions
- HAL interface definitions

**Location:**
- `hardware/libhardware/` in AOSP
- Provides HAL framework
- Standard interface definitions
- Module loading utilities

#### hw_get_module()

**Function Signature:**
```c
int hw_get_module(const char *id, const struct hw_module_t **module);
```

**Parameters:**
- `id`: Module ID (e.g., "audio", "camera")
- `module`: Output parameter for module structure

**Returns:**
- 0 on success
- Error code on failure

**Usage:**
```c
const struct hw_module_t *module;
int err = hw_get_module(AUDIO_HARDWARE_MODULE_ID, &module);
if (err == 0) {
    // Module loaded successfully
    // Use module->methods->open() to get device
}
```

#### Module Structure

**hw_module_t:**
```c
typedef struct hw_module_t {
    uint32_t tag;                    // Must be HARDWARE_MODULE_TAG
    uint16_t module_api_version;      // Module API version
    uint16_t hal_api_version;         // HAL API version
    const char *id;                   // Module ID
    const char *name;                 // Module name
    const char *author;               // Author
    struct hw_module_methods_t* methods;  // Module methods
    void* dso;                        // Shared library handle
    uint32_t reserved[32-7];          // Reserved
} hw_module_t;
```

**Key Fields:**
- `id`: Unique module identifier
- `methods`: Function pointers (especially `open`)
- `dso`: Handle to loaded library
- Version information

### HAL Module Loading

#### Loading Process

**Step 1: Framework Requests Module**
```c
// Framework code
const struct hw_module_t *module;
hw_get_module(AUDIO_HARDWARE_MODULE_ID, &module);
```

**Step 2: libhardware Searches for Module**
```
1. Check /vendor/lib/hw/
2. Check /system/lib/hw/
3. Try platform-specific variant
4. Fall back to default variant
5. Load .so file
```

**Step 3: Module Initialization**
```
1. Load shared library (dlopen)
2. Find HAL_MODULE_INFO_SYM symbol
3. Verify module structure
4. Return module to caller
```

**Step 4: Device Opening**
```c
// Open device from module
struct hw_device_t *device;
module->methods->open(module, "primary", &device);
```

#### Module Search Path

**Search Order:**
1. `/vendor/lib/hw/<module>.<variant>.so`
2. `/system/lib/hw/<module>.<variant>.so`
3. `/vendor/lib/hw/<module>.default.so`
4. `/system/lib/hw/<module>.default.so`

**Variant Selection:**
- Platform-specific variant preferred
- Falls back to "default" if not found
- Allows vendor overrides
- System fallback

### HAL Module Interface

#### Standard HAL Interface

**Module Methods:**
```c
typedef struct hw_module_methods_t {
    int (*open)(const struct hw_module_t* module,
                const char* id,
                struct hw_device_t** device);
} hw_module_methods_t;
```

**Device Structure:**
```c
typedef struct hw_device_t {
    uint32_t tag;                    // Must be HARDWARE_DEVICE_TAG
    uint32_t version;                 // Device API version
    struct hw_module_t* module;      // Module that owns device
    uint32_t reserved[12];           // Reserved
    void (*close)(struct hw_device_t* device);  // Close device
} hw_device_t;
```

#### Module Implementation

**Module Definition:**
```c
// HAL module implementation
static struct hw_module_methods_t hal_module_methods = {
    .open = hal_device_open,
};

// Module structure
struct audio_module HAL_MODULE_INFO_SYM = {
    .common = {
        .tag = HARDWARE_MODULE_TAG,
        .module_api_version = AUDIO_MODULE_API_VERSION_0_1,
        .hal_api_version = HARDWARE_HAL_API_VERSION,
        .id = AUDIO_HARDWARE_MODULE_ID,
        .name = "Audio HAL",
        .author = "Vendor",
        .methods = &hal_module_methods,
    },
};
```

**Device Opening:**
```c
static int hal_device_open(const struct hw_module_t* module,
                          const char* id,
                          struct hw_device_t** device) {
    // Create device structure
    struct audio_device *adev = calloc(1, sizeof(struct audio_device));
    
    // Initialize device
    adev->device.common.tag = HARDWARE_DEVICE_TAG;
    adev->device.common.version = AUDIO_DEVICE_API_VERSION_2_0;
    adev->device.common.module = (struct hw_module_t*)module;
    adev->device.common.close = hal_device_close;
    
    // Initialize device-specific methods
    adev->device.set_parameters = hal_set_parameters;
    adev->device.get_parameters = hal_get_parameters;
    // ... more methods
    
    *device = &adev->device.common;
    return 0;
}
```

### Common HAL Modules

#### Audio HAL

**Module ID:** `AUDIO_HARDWARE_MODULE_ID` ("audio")

**Variants:**
- `audio.primary.<platform>.so` - Primary audio HAL
- `audio.a2dp.default.so` - A2DP audio HAL
- `audio.usb.default.so` - USB audio HAL

**Interface:**
- `audio_hw_device_t` structure
- Audio stream management
- Audio routing
- Audio effects

#### Camera HAL

**Module ID:** `CAMERA_HARDWARE_MODULE_ID` ("camera")

**Variants:**
- `camera.<platform>.so` - Platform-specific camera
- `camera.default.so` - Default camera HAL

**Interface:**
- `camera_device_t` structure
- Camera operations
- Preview/capture
- Metadata

#### Sensors HAL

**Module ID:** `SENSORS_HARDWARE_MODULE_ID` ("sensors")

**Variants:**
- `sensors.<platform>.so` - Platform-specific
- `sensors.default.so` - Default sensors HAL

**Interface:**
- `sensors_poll_device_t` structure
- Sensor data polling
- Sensor activation
- Event handling

### HAL Module Development

#### Creating a HAL Module

**Step 1: Define Interface**
```c
// Define device structure
typedef struct {
    struct hw_device_t common;
    // Device-specific methods
    int (*method1)(struct my_device_t* dev, int param);
    int (*method2)(struct my_device_t* dev, void* data);
} my_device_t;
```

**Step 2: Implement Module**
```c
// Implement open function
static int my_device_open(const struct hw_module_t* module,
                         const char* id,
                         struct hw_device_t** device) {
    my_device_t* dev = calloc(1, sizeof(my_device_t));
    dev->common.tag = HARDWARE_DEVICE_TAG;
    dev->common.version = MY_DEVICE_API_VERSION;
    dev->common.module = (struct hw_module_t*)module;
    dev->common.close = my_device_close;
    dev->method1 = my_method1;
    dev->method2 = my_method2;
    *device = &dev->common;
    return 0;
}

// Define module methods
static struct hw_module_methods_t my_module_methods = {
    .open = my_device_open,
};

// Define module
struct my_module HAL_MODULE_INFO_SYM = {
    .common = {
        .tag = HARDWARE_MODULE_TAG,
        .module_api_version = MY_MODULE_API_VERSION,
        .hal_api_version = HARDWARE_HAL_API_VERSION,
        .id = MY_HARDWARE_MODULE_ID,
        .name = "My HAL",
        .author = "Vendor",
        .methods = &my_module_methods,
    },
};
```

**Step 3: Build Module**
```bp
// Android.bp
cc_library_shared {
    name: "my.hal.default",
    srcs: ["my_hal.c"],
    shared_libs: [
        "libhardware",
        "liblog",
    ],
    relative_install_path: "hw",
}
```

### HAL Module Usage

#### Framework Usage

**Loading Module:**
```c
// Framework code
const struct hw_module_t *module;
int err = hw_get_module(MY_HARDWARE_MODULE_ID, &module);
if (err != 0) {
    // Error handling
    return err;
}
```

**Opening Device:**
```c
struct hw_device_t *device;
err = module->methods->open(module, "default", &device);
if (err != 0) {
    // Error handling
    return err;
}

// Cast to specific device type
my_device_t *my_dev = (my_device_t*)device;
```

**Using Device:**
```c
// Call device methods
int result = my_dev->method1(my_dev, 42);
if (result < 0) {
    // Error handling
}

// Close device when done
device->close(device);
```

### HAL Module vs Modern HAL

#### Legacy HAL (hw/ modules)

**Characteristics:**
- Shared libraries in hw/ directory
- libhardware interface
- Loaded dynamically
- Pre-Treble model

**Limitations:**
- Tightly coupled with framework
- Difficult to update independently
- No versioning
- Process boundaries unclear

#### Modern HAL (HIDL/AIDL)

**Characteristics:**
- Interface-based design
- Versioned interfaces
- Process isolation
- Treble-compatible

**Advantages:**
- Independent updates
- Better isolation
- Version management
- Modern architecture

### HAL Module Best Practices

#### Module Design

**Standard Interface:**
- Follow libhardware interface
- Use standard structures
- Implement required methods
- Document device capabilities

**Error Handling:**
- Return appropriate error codes
- Handle invalid parameters
- Clean up on errors
- Log errors appropriately

**Resource Management:**
- Allocate resources in open()
- Free resources in close()
- Handle resource leaks
- Manage device lifecycle

#### Module Implementation

**Initialization:**
- Initialize in module open
- Validate parameters
- Set up hardware
- Return errors on failure

**Device Operations:**
- Implement all required methods
- Handle concurrent access
- Thread safety
- Performance optimization

**Cleanup:**
- Implement close() properly
- Free all resources
- Uninitialize hardware
- Handle cleanup errors

### Debugging HAL Modules

#### Common Issues

**Module Not Found:**
- Check module name
- Verify search path
- Check file permissions
- Verify .so file exists

**Symbol Not Found:**
- Verify HAL_MODULE_INFO_SYM
- Check symbol visibility
- Review build configuration
- Check library dependencies

**Device Open Fails:**
- Check device ID
- Verify device initialization
- Review error logs
- Check hardware state

#### Debugging Tools

**Module Loading:**
```bash
# Check loaded modules
adb shell lshal

# View module information
adb shell dumpsys hardware
```

**Logging:**
```c
#include <android/log.h>

ALOGD("Module loaded: %s", module->id);
ALOGE("Device open failed: %d", err);
```

**Library Inspection:**
```bash
# Check library symbols
nm -D /vendor/lib/hw/audio.primary.default.so

# Check library dependencies
ldd /vendor/lib/hw/audio.primary.default.so
```

## Key Takeaways

1. **HAL modules are shared libraries** stored in the `hw/` directory that implement hardware-specific functionality using the libhardware interface.

2. **libhardware provides the framework** for loading and interacting with HAL modules, with `hw_get_module()` being the primary loading function.

3. **HAL modules follow a standard structure** with `hw_module_t` for the module and `hw_device_t` for devices, with an `open()` method to get devices.

4. **Module loading searches** `/vendor/lib/hw/` first, then `/system/lib/hw/`, trying platform-specific variants before falling back to "default".

5. **Common HAL modules** include audio, camera, and sensors, each with platform-specific implementations while following standard interfaces.

6. **HAL modules are the legacy model** before Project Treble, replaced by HIDL/AIDL HALs for better isolation and versioning.

7. **Module development** requires implementing the standard interface, proper resource management, and following best practices for error handling and cleanup.

8. **Understanding HAL modules** is essential for maintaining legacy HALs, understanding HAL evolution, and debugging hardware interface issues in AOSP.

## Related Topics

- **libhardware:** The library that provides HAL module framework
- **Android Architecture - Complete Overview:** How HAL fits into overall architecture
- **AOSP Repo Structure:** Where HAL modules are located in the source tree
- **HIDL:** Modern HAL interface definition (replacement for legacy modules)

