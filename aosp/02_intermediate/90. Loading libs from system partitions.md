---
number: 90
title: Loading libs from system partitions
slug: loading-libs-from-system-partitions
level: intermediate
tags:
  - aosp
  - native
  - system-partitions
  - library-loading
  - dynamic-linking
  - native-libs
prerequisites:
  - native-shared-libraries
  - android-partitions
  - jni-basics
estimated_minutes: 85
contributors: []
diagrams: []
examples: []
canonical_id: aosp-intermediate-90
---

# Loading libs from system partitions

## Overview

Loading libraries from system partitions involves the mechanisms and paths used by Android to locate and load native shared libraries stored in system partitions like `/system/lib/`, `/vendor/lib/`, and other system partition directories. Understanding how libraries are loaded from system partitions is essential for AOSP development, as it explains library search paths, system library organization, partition-specific library locations, and how the dynamic linker resolves and loads system libraries. This guide provides a comprehensive overview of loading libraries from system partitions, search paths, library organization, and Android-specific loading mechanisms.

Think of loading libraries from system partitions like a library system: just as a public library has organized sections (reference, fiction, non-fiction) and a catalog system to find books, Android has organized system partitions (`/system/lib/`, `/vendor/lib/`) and a search path system to find and load native libraries. The dynamic linker acts like the librarian, searching through the catalog (search paths) to find the requested library.

## Deep Explanation

### What is Loading from System Partitions?

Loading libraries from system partitions is the process by which Android's dynamic linker locates and loads native shared libraries (`.so` files) stored in system partition directories like `/system/lib/`, `/vendor/lib/`, `/system/lib64/`, etc.

**Key Characteristics:**
- **System Libraries:** Libraries in system partitions
- **Search Paths:** Predefined search directories
- **Dynamic Linker:** Resolves and loads libraries
- **Partition-Specific:** Different partitions for different purposes

**Why System Partitions?**
- **Organization:** Libraries organized by purpose
- **Security:** System libraries protected
- **Updates:** System libraries updated via OTA
- **Efficiency:** Shared libraries across apps

### System Partition Library Locations

#### System Partition Libraries

**System Library Paths:**
- `/system/lib/` - 32-bit system libraries
- `/system/lib64/` - 64-bit system libraries
- `/system/framework/` - Framework libraries
- `/system/bin/` - System binaries (some load libraries)

**Contents:**
- Core system libraries (libc, libm, etc.)
- Framework native libraries
- System service libraries
- Android runtime libraries

#### Vendor Partition Libraries

**Vendor Library Paths:**
- `/vendor/lib/` - 32-bit vendor libraries
- `/vendor/lib64/` - 64-bit vendor libraries
- `/vendor/lib/hw/` - HAL libraries

**Contents:**
- Vendor-specific libraries
- HAL implementations
- Proprietary libraries
- Device-specific code

#### Other Partition Libraries

**Product Partition:**
- `/product/lib/` - Product libraries
- `/product/lib64/` - Product 64-bit libraries

**ODM Partition:**
- `/odm/lib/` - ODM libraries
- `/odm/lib64/` - ODM 64-bit libraries

**System Ext Partition:**
- `/system_ext/lib/` - System extension libraries
- `/system_ext/lib64/` - System extension 64-bit libraries

### Library Search Paths

#### Default Search Paths

**System Search Paths:**
```
1. /system/lib64/        (64-bit primary)
2. /system/lib/          (32-bit primary)
3. /vendor/lib64/        (64-bit vendor)
4. /vendor/lib/          (32-bit vendor)
5. /product/lib64/       (64-bit product)
6. /product/lib/         (32-bit product)
7. /odm/lib64/           (64-bit ODM)
8. /odm/lib/             (32-bit ODM)
9. /system_ext/lib64/    (64-bit system_ext)
10. /system_ext/lib/     (32-bit system_ext)
```

**Search Order:**
- Architecture-specific paths first
- System paths before vendor paths
- Standard paths before extension paths

#### Dynamic Linker Configuration

**Linker Configuration:**
- `/system/etc/ld.config.txt` - Linker configuration
- Defines search paths
- Sets library namespace
- Configures library loading

**Configuration Example:**
```
namespace.default.search.paths = /system/lib64:/vendor/lib64
namespace.default.permitted.paths = /system/lib64:/vendor/lib64
```

### Library Loading Process

#### Load Request

**Java Loading:**
```java
// Load system library
System.loadLibrary("mylib");
// Searches system paths for libmylib.so
```

**Native Loading:**
```c
// Load using dlopen
void *handle = dlopen("libmylib.so", RTLD_LAZY);
// Or with full path
void *handle = dlopen("/system/lib64/libmylib.so", RTLD_LAZY);
```

#### Search Algorithm

**Search Process:**
```
1. Receive load request (libmylib.so)
2. Check current directory (if path not specified)
3. Search system search paths in order:
   a. /system/lib64/
   b. /system/lib/
   c. /vendor/lib64/
   d. /vendor/lib/
   e. ... (other partitions)
4. First match found is loaded
5. If not found, return error
```

**Path Resolution:**
- Architecture-specific paths checked first
- 64-bit paths before 32-bit paths
- System paths before vendor paths
- First match wins

### Partition-Specific Considerations

#### System Partition

**Characteristics:**
- Read-only in normal operation
- Updated via OTA
- Contains core Android libraries
- Protected by SELinux

**Library Types:**
- Framework libraries
- Core system libraries
- Android runtime libraries
- System service libraries

**Access:**
- All apps can access (with permissions)
- System libraries available system-wide
- Loaded by dynamic linker
- Shared across processes

#### Vendor Partition

**Characteristics:**
- Vendor-specific content
- Device-specific implementations
- Can be updated independently (Treble)
- Protected by SELinux

**Library Types:**
- HAL implementations
- Vendor proprietary libraries
- Device-specific code
- Vendor customizations

**Access:**
- System-level access
- Framework can access
- Apps may have limited access
- Vendor-specific permissions

#### Product Partition

**Characteristics:**
- Product-specific features
- Carrier/operator customizations
- Can be updated independently
- Protected by SELinux

**Library Types:**
- Product feature libraries
- Carrier-specific libraries
- Operator customizations
- Product extensions

### Library Namespace

#### Namespace Isolation

**Library Namespaces:**
- Different namespaces for different components
- Isolates library access
- Prevents conflicts
- Security boundary

**Namespace Types:**
- `default` - Default namespace
- `sphal` - Vendor namespace
- `vndk` - VNDK namespace
- `rs` - RenderScript namespace

#### VNDK (Vendor Native Development Kit)

**VNDK Libraries:**
- Vendor-accessible system libraries
- Stable ABI/API
- Versioned libraries
- Treble compatibility

**VNDK Paths:**
- `/system/lib64/vndk-<version>/`
- `/vendor/lib64/vndk/`
- Version-specific directories

**Purpose:**
- Enable vendor updates
- Maintain compatibility
- Stable interfaces
- Treble support

### Library Loading from Java

#### System.loadLibrary()

**Loading System Library:**
```java
public class MyClass {
    static {
        // Load from system partition
        System.loadLibrary("mylib");
        // Searches: /system/lib64/, /system/lib/, etc.
    }
}
```

**Search Behavior:**
- Searches system paths
- Architecture-specific
- Finds first match
- Loads into process

#### System.load()

**Loading by Path:**
```java
// Load with explicit path
System.load("/system/lib64/libmylib.so");
```

**Use Cases:**
- Explicit path needed
- Custom library location
- Testing/debugging
- Non-standard paths

### Native Library Loading

#### dlopen()

**Native Loading:**
```c
#include <dlfcn.h>

// Load from system partition
void *handle = dlopen("libmylib.so", RTLD_LAZY);
if (handle) {
    // Library loaded from system path
    void (*func)() = dlsym(handle, "function_name");
    if (func) {
        func();
    }
    dlclose(handle);
}
```

**Path Resolution:**
- Uses linker search paths
- Searches system directories
- Architecture-specific
- First match loaded

#### Full Path Loading

**Explicit Path:**
```c
// Load with full path
void *handle = dlopen("/system/lib64/libmylib.so", RTLD_NOW);
```

**Benefits:**
- Explicit location
- No search needed
- Faster loading
- Predictable behavior

### Library Dependencies

#### System Library Dependencies

**Dependency Resolution:**
- System libraries can depend on other system libraries
- Dynamic linker resolves dependencies
- Searches system paths for dependencies
- Loads dependencies automatically

**Dependency Chain:**
```
App Library
  └── System Library (/system/lib64/libapp.so)
      └── Framework Library (/system/lib64/libframework.so)
          └── Core Library (/system/lib64/libc.so)
```

#### DT_RUNPATH

**Runpath:**
- Library can specify search paths
- DT_RUNPATH in ELF
- Additional search directories
- Library-specific paths

**Example:**
```c
// Library can specify runpath
// DT_RUNPATH: /system/lib64/vndk
// Searches vndk directory for dependencies
```

### Security Considerations

#### SELinux Contexts

**SELinux Protection:**
- Libraries have SELinux contexts
- Access controlled by policy
- Prevents unauthorized access
- Security boundaries

**Context Types:**
- `system_file` - System libraries
- `vendor_file` - Vendor libraries
- `product_file` - Product libraries
- Context-specific access

#### Library Verification

**Verification:**
- Libraries verified on load
- Integrity checking
- Signature verification (if enabled)
- Prevents tampering

### Best Practices

#### Library Organization

**Organization:**
- Place libraries in appropriate partitions
- Use architecture-specific directories
- Follow naming conventions
- Organize by purpose

**Structure:**
```
/system/lib64/
├── libc.so
├── libm.so
├── libdl.so
└── framework/
    └── libframework.so
```

#### Library Naming

**Naming:**
- Follow `lib<name>.so` convention
- Descriptive names
- Version information (if needed)
- Clear purpose

**Examples:**
- `libcamera_client.so` - Camera client library
- `libmedia.so` - Media framework library
- `libutils.so` - Utility library

### Debugging Library Loading

#### Common Issues

**Library Not Found:**
- Library not in search path
- Wrong architecture
- Missing dependencies
- Path issues

**Debugging:**
```bash
# Check library paths
adb shell ls -l /system/lib64/ | grep mylib

# Check loaded libraries
adb shell cat /proc/<pid>/maps | grep .so

# Check library dependencies
readelf -d /system/lib64/libmylib.so | grep NEEDED
```

#### Library Inspection

**Inspection Tools:**
```bash
# View library information
file /system/lib64/libmylib.so

# View library symbols
nm -D /system/lib64/libmylib.so

# View library dependencies
readelf -d /system/lib64/libmylib.so
```

## Key Takeaways

1. **Loading libraries from system partitions** involves the dynamic linker searching predefined paths in system partitions (`/system/lib/`, `/vendor/lib/`, etc.) to locate and load native shared libraries.

2. **System partition library locations** include `/system/lib/` and `/system/lib64/` for system libraries, `/vendor/lib/` and `/vendor/lib64/` for vendor libraries, and other partition-specific directories.

3. **Library search paths** follow a specific order: architecture-specific paths first (64-bit before 32-bit), system paths before vendor paths, with the first match being loaded.

4. **Partition-specific considerations** include system partition (read-only, core libraries), vendor partition (vendor-specific, HAL implementations), and product partition (product features, carrier customizations).

5. **Library namespace** provides isolation between different components, with VNDK (Vendor Native Development Kit) providing stable vendor-accessible system libraries for Treble compatibility.

6. **Library loading** can be done from Java using `System.loadLibrary()` (searches system paths) or `System.load()` (explicit path), and from native code using `dlopen()`.

7. **Library dependencies** are resolved automatically by the dynamic linker, which searches system paths for dependencies and loads them recursively.

8. **Understanding loading libraries from system partitions** is essential for AOSP development, explaining how system libraries are organized, located, and loaded, enabling proper library placement and access in Android system partitions.

## Related Topics

- **Native shared libraries:** How native libraries are structured and loaded
- **Android Partitions:** System partition structure and organization
- **JNI basics:** How Java code interacts with native libraries
- **Android Architecture - Complete Overview:** How system libraries fit into overall architecture

