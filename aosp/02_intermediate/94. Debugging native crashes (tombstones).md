---
number: 94
title: Debugging native crashes (tombstones)
slug: debugging-native-crashes-tombstones
level: intermediate
tags:
  - aosp
  - native
  - debugging
  - crashes
  - tombstones
  - native-crashes
  - stack-trace
prerequisites:
  - logging-in-native-layers
  - jni-basics
  - building-native-system-components
estimated_minutes: 90
contributors: []
diagrams: []
examples: []
canonical_id: aosp-intermediate-94
---

# Debugging native crashes (tombstones)

## Overview

Debugging native crashes involves analyzing tombstone files that Android generates when native processes crash, containing stack traces, register states, memory maps, and other diagnostic information. Understanding how to debug native crashes and read tombstones is essential for AOSP development, as it explains how native crashes are detected, how tombstones are generated, how to read and interpret tombstone files, how to analyze stack traces, and how to identify and fix the root causes of native crashes. This guide provides a comprehensive overview of debugging native crashes, tombstone files, stack trace analysis, and debugging techniques.

Think of tombstones like autopsy reports: just as an autopsy report contains detailed information about what happened to a person (cause of death, injuries, medical conditions), a tombstone contains detailed information about what happened to a crashed process (where it crashed, register states, memory contents, stack trace). This information helps developers understand why the crash occurred and how to fix it.

## Deep Explanation

### What are Native Crashes?

Native crashes occur when native C/C++ code encounters a fatal error that causes the process to terminate abnormally, such as segmentation faults, null pointer dereferences, or assertion failures.

**Key Characteristics:**
- **Fatal Errors:** Process terminates
- **Signal-Based:** Triggered by signals (SIGSEGV, SIGABRT, etc.)
- **Tombstone Generated:** Android creates tombstone file
- **Diagnostic Info:** Contains crash details

**Why Native Crashes?**
- **Memory Errors:** Invalid memory access
- **Null Pointers:** Dereferencing null pointers
- **Buffer Overflows:** Writing past buffer boundaries
- **Assertion Failures:** Failed assertions

### What are Tombstones?

Tombstones are diagnostic files created by Android's debuggerd daemon when a native process crashes, containing detailed information about the crash including stack traces, register states, memory maps, and process information.

**Key Characteristics:**
- **Automatic Generation:** Created by debuggerd
- **Detailed Information:** Comprehensive crash data
- **Text Format:** Human-readable format
- **Persistent:** Stored on device

**Why Tombstones?**
- **Crash Analysis:** Understand crash cause
- **Debugging:** Identify problematic code
- **Diagnostics:** System diagnostics
- **Development:** Development tooling

### Tombstone Location

#### Storage Location

**Tombstone Files:**
- `/data/tombstones/` - Tombstone directory
- `tombstone_XX` - Individual tombstone files
- Numbered sequentially
- Persistent until cleared

**File Naming:**
```
/data/tombstones/tombstone_00
/data/tombstones/tombstone_01
/data/tombstones/tombstone_02
...
```

**Access:**
```bash
# List tombstones
adb shell ls -l /data/tombstones/

# View tombstone
adb shell cat /data/tombstones/tombstone_00

# Pull tombstone
adb pull /data/tombstones/tombstone_00
```

#### Tombstone Retention

**Retention Policy:**
- Limited number of tombstones
- Oldest tombstones deleted
- Typically 10-20 tombstones kept
- Automatic cleanup

### Tombstone Contents

#### Header Information

**Process Information:**
```
*** *** *** *** *** *** *** *** *** *** *** *** *** *** *** ***
Build fingerprint: 'google/sdk_gphone64_arm64/emu64xa:13/...'
Revision: '0'
ABI: 'arm64'
Timestamp: 2024-01-15 10:30:45
Process: com.example.app
PID: 12345
UID: 10123
Signal: 11 (SIGSEGV), Code: 1 (SEGV_MAPERR), Fault addr: 0x0
```

**Key Fields:**
- Build fingerprint
- ABI (architecture)
- Process name
- PID (process ID)
- UID (user ID)
- Signal (crash signal)
- Fault address

#### Stack Trace

**Backtrace:**
```
backtrace:
  #00 pc 0000000000012345  /system/lib64/libmylib.so (function_name+123)
  #01 pc 0000000000056789  /system/lib64/libmylib.so (another_function+456)
  #02 pc 000000000009abcd  /system/lib64/libc.so (__libc_init+789)
```

**Stack Trace Format:**
- Frame number
- Program counter (PC)
- Library path
- Function name and offset

**Analysis:**
- Shows call chain
- Identifies crash location
- Shows function calls
- Helps locate bug

#### Register State

**Register Dump:**
```
registers:
  x0  0000000000000000  x1  0000007fe1234567
  x2  0000000000000001  x3  0000007fe1234568
  ...
  pc  0000007fe1234567  lr  0000007fe1234568
  sp  0000007fe1234abc  ...
```

**Key Registers:**
- `pc` - Program counter (crash location)
- `lr` - Link register (return address)
- `sp` - Stack pointer
- General purpose registers (x0-x30 on ARM64)

**Usage:**
- Understand crash context
- Inspect variable values
- Analyze memory state
- Debug crash cause

#### Memory Map

**Memory Mapping:**
```
memory map:
  0000007fe1000000-0000007fe2000000 r-xp 00000000 00:00 0  [anon:libc_malloc]
  0000007fe2000000-0000007fe3000000 rw-p 00000000 00:00 0  [anon:libc_malloc]
  ...
  0000007fe1234000-0000007fe1235000 r-xp 00000000 08:01 12345 /system/lib64/libmylib.so
```

**Memory Map Information:**
- Address ranges
- Permissions (r/w/x)
- Mapped files
- Memory regions

**Usage:**
- Understand memory layout
- Identify mapped libraries
- Check memory permissions
- Analyze memory access

### Crash Signals

#### Common Crash Signals

**SIGSEGV (Segmentation Fault):**
- Invalid memory access
- Null pointer dereference
- Buffer overflow
- Access violation

**SIGABRT (Abort):**
- Assertion failure
- Explicit abort
- Error handling
- Fatal error

**SIGBUS (Bus Error):**
- Misaligned access
- Invalid memory access
- Hardware error
- Memory alignment issue

**SIGILL (Illegal Instruction):**
- Invalid instruction
- Architecture mismatch
- Corrupted code
- Execution error

#### Signal Codes

**SIGSEGV Codes:**
- `SEGV_MAPERR` - Address not mapped
- `SEGV_ACCERR` - Invalid permissions

**Signal Information:**
- Signal number
- Signal code
- Fault address
- Process information

### Analyzing Tombstones

#### Reading Stack Traces

**Stack Trace Analysis:**
1. Identify crash location (frame #00)
2. Trace call chain
3. Identify problematic function
4. Analyze function parameters
5. Locate source code

**Example Analysis:**
```
#00 pc 0000000000012345  /system/lib64/libmylib.so (crash_function+123)
  → Crash occurred in crash_function at offset 123
  → Check crash_function implementation

#01 pc 0000000000056789  /system/lib64/libmylib.so (caller_function+456)
  → Called from caller_function
  → Check how crash_function is called
```

#### Symbol Resolution

**Symbol Information:**
- Function names (if symbols available)
- File names
- Line numbers (if debug info)
- Offset from function start

**Symbol Files:**
- Debug symbols needed
- `.so` files with symbols
- Symbol tables
- Debug information

**Resolving Symbols:**
```bash
# Use addr2line to resolve addresses
addr2line -e libmylib.so 0x12345

# Use nm to list symbols
nm -D libmylib.so | grep function_name

# Use objdump to disassemble
objdump -d libmylib.so
```

### Common Crash Causes

#### Null Pointer Dereference

**Symptom:**
- SIGSEGV with fault address 0x0
- Accessing null pointer
- Common cause

**Example:**
```c
void* ptr = NULL;
*ptr = 10;  // Crash: SIGSEGV
```

**Tombstone:**
```
Signal: 11 (SIGSEGV), Code: 1 (SEGV_MAPERR), Fault addr: 0x0
```

#### Buffer Overflow

**Symptom:**
- Writing past buffer boundary
- Memory corruption
- Unpredictable behavior

**Example:**
```c
char buffer[10];
strcpy(buffer, "very long string");  // Overflow
```

**Tombstone:**
```
Signal: 11 (SIGSEGV), Code: 1 (SEGV_MAPERR), Fault addr: 0x...
```

#### Use-After-Free

**Symptom:**
- Accessing freed memory
- Memory corruption
- Unpredictable crashes

**Example:**
```c
void* ptr = malloc(100);
free(ptr);
*ptr = 10;  // Crash: use-after-free
```

#### Stack Overflow

**Symptom:**
- Stack exhausted
- Recursive function
- Large stack allocation

**Example:**
```c
void recursive() {
    char large[1000000];  // Stack overflow
    recursive();
}
```

### Debugging Techniques

#### Using GDB

**Attach to Process:**
```bash
# Attach to running process
adb shell gdb -p <pid>

# Or attach to crashed process via core dump
gdb <binary> <core_file>
```

**GDB Commands:**
```gdb
# View backtrace
(gdb) bt

# Inspect registers
(gdb) info registers

# View memory
(gdb) x/10x $pc

# Disassemble
(gdb) disas $pc
```

#### Using addr2line

**Resolve Addresses:**
```bash
# Resolve address to source location
addr2line -e libmylib.so -f -C 0x12345

# With debug info
addr2line -e libmylib.so.debug -f -C 0x12345
```

**Output:**
```
function_name
/path/to/source/file.cpp:123
```

#### Using objdump

**Disassemble Code:**
```bash
# Disassemble function
objdump -d libmylib.so | grep -A 20 function_name

# View symbols
objdump -t libmylib.so
```

### Tombstone Tools

#### tombstone.py

**Android Tool:**
```bash
# Parse tombstone
tombstone.py tombstone_00

# Extract stack trace
tombstone.py --stack-trace tombstone_00

# Symbolize addresses
tombstone.py --symbols tombstone_00
```

#### stack

**Stack Tool:**
```bash
# Symbolize stack trace
stack --symbols-dir=/path/to/symbols tombstone_00
```

### Best Practices

#### Crash Prevention

**Prevention Techniques:**
- Null pointer checks
- Bounds checking
- Memory management
- Error handling

**Example:**
```c
// BAD
void process(int* data) {
    *data = 10;  // May crash if data is NULL
}

// GOOD
void process(int* data) {
    if (data == NULL) {
        ALOGE("MyModule", "Null pointer");
        return;
    }
    *data = 10;
}
```

#### Debugging Workflow

**Debugging Steps:**
1. Reproduce crash
2. Collect tombstone
3. Analyze stack trace
4. Identify crash location
5. Fix issue
6. Verify fix

### Common Issues

#### Missing Symbols

**Problem:**
- Stack trace shows addresses only
- No function names
- Hard to debug

**Solution:**
- Build with debug symbols
- Use symbol files
- Use addr2line
- Include debug info

#### Incomplete Stack Traces

**Problem:**
- Stack trace truncated
- Missing frames
- Incomplete information

**Solution:**
- Check stack size
- Increase stack limit
- Use alternative debugging
- Check for stack corruption

## Key Takeaways

1. **Native crashes** occur when native C/C++ code encounters fatal errors (SIGSEGV, SIGABRT, etc.), causing process termination and generating tombstone files.

2. **Tombstones** are diagnostic files created by Android's debuggerd daemon containing stack traces, register states, memory maps, and process information for crash analysis.

3. **Tombstone contents** include header information (process, signal, fault address), stack traces (call chain), register state (PC, SP, registers), and memory maps (memory layout).

4. **Crash signals** include SIGSEGV (segmentation fault), SIGABRT (abort), SIGBUS (bus error), and SIGILL (illegal instruction), each indicating different types of errors.

5. **Analyzing tombstones** involves reading stack traces to identify crash location, tracing call chains, resolving symbols using addr2line/objdump, and analyzing register states and memory maps.

6. **Common crash causes** include null pointer dereference, buffer overflow, use-after-free, and stack overflow, each with specific symptoms and tombstone patterns.

7. **Debugging techniques** include using GDB for live debugging, addr2line for symbol resolution, objdump for disassembly, and tombstone tools for analysis.

8. **Understanding debugging native crashes** is essential for AOSP development, enabling identification and resolution of native code issues through systematic tombstone analysis and debugging techniques.

## Related Topics

- **Logging in native layers:** How to add logging for debugging
- **AddressSanitizer, HWASan in Android:** Memory error detection tools
- **Building native system components:** Building native code that may crash
- **Working with frameworks/native/:** Native framework code debugging

