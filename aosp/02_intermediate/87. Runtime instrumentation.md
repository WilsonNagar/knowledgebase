---
number: 87
title: Runtime instrumentation
slug: runtime-instrumentation
level: intermediate
tags:
  - aosp
  - art
  - instrumentation
  - profiling
  - debugging
  - jvmti
  - runtime
prerequisites:
  - dalvik-vs-art
  - aot-jit-compilation
estimated_minutes: 85
contributors: []
diagrams: []
examples: []
canonical_id: aosp-intermediate-87
---

# Runtime instrumentation

## Overview

Runtime instrumentation is the ability to monitor, analyze, and modify application behavior at runtime in ART (Android Runtime). Understanding runtime instrumentation is essential for AOSP development, as it explains how debugging tools work, how profiling is performed, how runtime behavior can be observed and modified, and how instrumentation enables development tools, debugging, and performance analysis. This guide provides a comprehensive overview of runtime instrumentation, instrumentation mechanisms, JVMTI (Java Virtual Machine Tool Interface), profiling, debugging, and tooling support.

Think of runtime instrumentation like diagnostic equipment for a car: just as diagnostic equipment can monitor engine performance, track fuel consumption, and detect issues in real-time, runtime instrumentation can monitor application execution, track method calls, measure performance, and detect problems while the app is running. This enables developers to understand and optimize application behavior.

## Deep Explanation

### What is Runtime Instrumentation?

Runtime instrumentation is the capability to observe, analyze, and modify application execution at runtime, enabling debugging, profiling, monitoring, and analysis of running applications.

**Key Characteristics:**
- **Runtime Monitoring:** Observe execution in real-time
- **Analysis:** Analyze behavior and performance
- **Modification:** Modify execution behavior
- **Tooling:** Enable development tools

**Why Runtime Instrumentation?**
- **Debugging:** Identify and fix issues
- **Profiling:** Analyze performance
- **Monitoring:** Track application behavior
- **Development:** Enable development tools

### Instrumentation Mechanisms

#### JVMTI (Java Virtual Machine Tool Interface)

**What is JVMTI?**
- Standard interface for runtime instrumentation
- Java Virtual Machine Tool Interface
- Enables tools to interact with VM
- Profiling and debugging support

**Key Features:**
- Event notifications
- Method/field access
- Thread control
- Memory analysis

**JVMTI Capabilities:**
- Method entry/exit events
- Field access events
- Exception events
- Class load events
- Thread events

#### ART Instrumentation

**ART Support:**
- JVMTI implementation
- Native agent support
- Event callbacks
- Tool integration

**Instrumentation Points:**
- Method invocation
- Field access
- Class loading
- Exception handling
- Thread events

### Instrumentation Types

#### Method Instrumentation

**Method Entry/Exit:**
- Monitor method calls
- Track method execution
- Measure execution time
- Count invocations

**Implementation:**
```c
// JVMTI method entry callback
void JNICALL MethodEntry(jvmtiEnv *jvmti_env,
                         JNIEnv *jni_env,
                         jthread thread,
                         jmethodID method) {
    // Log method entry
    // Track execution
    // Measure time
}
```

**Use Cases:**
- Performance profiling
- Method call tracing
- Execution analysis
- Debugging

#### Field Instrumentation

**Field Access:**
- Monitor field reads/writes
- Track field modifications
- Detect field access patterns
- Analyze data flow

**Implementation:**
```c
// JVMTI field access callback
void JNICALL FieldAccess(jvmtiEnv *jvmti_env,
                        JNIEnv *jni_env,
                        jthread thread,
                        jmethodID method,
                        jlocation location,
                        jclass field_klass,
                        jobject object,
                        jfieldID field) {
    // Log field access
    // Track modifications
    // Analyze patterns
}
```

**Use Cases:**
- Data flow analysis
- Field access tracking
- Memory analysis
- Debugging

#### Class Loading Instrumentation

**Class Load Events:**
- Monitor class loading
- Track class usage
- Analyze class dependencies
- Detect class loading issues

**Implementation:**
```c
// JVMTI class load callback
void JNICALL ClassLoad(jvmtiEnv *jvmti_env,
                      JNIEnv *jni_env,
                      jthread thread,
                      jclass klass) {
    // Log class load
    // Track class usage
    // Analyze dependencies
}
```

**Use Cases:**
- Class loading analysis
- Dependency tracking
- Performance optimization
- Debugging

### Profiling

#### CPU Profiling

**CPU Profiling:**
- Measure CPU usage
- Identify hot methods
- Analyze execution time
- Performance bottlenecks

**Profiling Methods:**
- Sampling profiler
- Instrumentation profiler
- Statistical profiling
- Event-based profiling

**Tools:**
- Android Studio Profiler
- Systrace
- Perfetto
- Simpleperf

#### Memory Profiling

**Memory Profiling:**
- Track memory allocations
- Detect memory leaks
- Analyze heap usage
- Monitor GC activity

**Profiling Methods:**
- Allocation tracking
- Heap dumps
- GC event monitoring
- Memory statistics

**Tools:**
- Android Studio Memory Profiler
- MAT (Memory Analyzer Tool)
- LeakCanary
- Allocation Tracker

### Debugging

#### Breakpoints

**Breakpoint Support:**
- Set breakpoints in code
- Pause execution
- Inspect state
- Step through code

**Implementation:**
- JVMTI breakpoint events
- Debugger integration
- State inspection
- Execution control

**Tools:**
- Android Studio Debugger
- GDB
- LLDB
- JDB

#### Variable Inspection

**Variable Access:**
- Read variable values
- Modify variables
- Inspect object state
- Analyze data

**Capabilities:**
- Local variables
- Instance fields
- Static fields
- Object inspection

### Instrumentation Agents

#### Native Agents

**Native Agent:**
- Native library loaded into VM
- JVMTI interface
- Event callbacks
- Tool integration

**Agent Loading:**
```bash
# Load agent at startup
adb shell setprop wrap.<package> 'LD_PRELOAD=/path/to/agent.so'
```

**Agent Implementation:**
```c
// Agent entry point
JNIEXPORT jint JNICALL Agent_OnLoad(JavaVM *vm,
                                     char *options,
                                     void *reserved) {
    // Initialize JVMTI
    // Set event callbacks
    // Enable events
    return JNI_OK;
}
```

#### Java Agents

**Java Agent:**
- Java-based instrumentation
- Java Agent API
- Bytecode manipulation
- Tool integration

**Agent Loading:**
```bash
# Load Java agent
java -javaagent:agent.jar MyApp
```

**Agent Implementation:**
```java
public class MyAgent {
    public static void premain(String args, Instrumentation inst) {
        // Setup instrumentation
        // Add transformers
        // Enable monitoring
    }
}
```

### Performance Impact

#### Overhead

**Instrumentation Overhead:**
- Event callbacks add overhead
- Performance impact
- Memory usage
- CPU usage

**Impact Factors:**
- Event frequency
- Callback complexity
- Instrumentation type
- Tool configuration

#### Optimization

**Minimizing Overhead:**
- Selective instrumentation
- Efficient callbacks
- Sampling instead of full
- Optimized tooling

**Best Practices:**
- Use sampling profilers
- Limit instrumentation scope
- Optimize callbacks
- Disable when not needed

### Tooling Support

#### Android Studio

**Android Studio Integration:**
- Built-in profiler
- Debugger support
- Memory profiler
- CPU profiler

**Features:**
- Real-time monitoring
- Performance analysis
- Memory leak detection
- Thread analysis

#### Command-Line Tools

**ADB Tools:**
- `adb shell dumpsys`
- `adb shell am profile`
- `adb shell am start`
- Various profiling tools

**Usage:**
```bash
# Start method profiling
adb shell am profile start <package> /sdcard/trace.trace

# Stop profiling
adb shell am profile stop <package>
```

### Use Cases

#### Development

**Development Use:**
- Debugging applications
- Performance optimization
- Memory leak detection
- Code analysis

**Benefits:**
- Faster development
- Better code quality
- Performance optimization
- Issue detection

#### Testing

**Testing Use:**
- Test coverage
- Performance testing
- Memory testing
- Stress testing

**Benefits:**
- Comprehensive testing
- Performance validation
- Memory validation
- Quality assurance

#### Production Monitoring

**Production Use:**
- Performance monitoring
- Error tracking
- Usage analytics
- Health monitoring

**Considerations:**
- Overhead impact
- Privacy concerns
- Battery usage
- Data collection

## Key Takeaways

1. **Runtime instrumentation** is the capability to observe, analyze, and modify application execution at runtime, enabling debugging, profiling, monitoring, and analysis.

2. **JVMTI (Java Virtual Machine Tool Interface)** is the standard interface for runtime instrumentation, providing event notifications, method/field access, thread control, and memory analysis capabilities.

3. **Instrumentation types** include method instrumentation (entry/exit monitoring), field instrumentation (access tracking), and class loading instrumentation (class load events).

4. **Profiling** includes CPU profiling (measure CPU usage, identify hot methods) and memory profiling (track allocations, detect leaks, analyze heap usage).

5. **Debugging** support includes breakpoints (pause execution, inspect state) and variable inspection (read/modify variables, analyze data).

6. **Instrumentation agents** can be native (JVMTI-based) or Java-based (Java Agent API), loaded into the VM to provide tooling capabilities.

7. **Performance impact** includes overhead from event callbacks, which can be minimized through selective instrumentation, efficient callbacks, and sampling.

8. **Understanding runtime instrumentation** is essential for AOSP development, explaining how debugging tools work, how profiling is performed, and how runtime behavior can be observed and modified to enable development, testing, and production monitoring.

## Related Topics

- **Dalvik vs ART:** Runtime environment that supports instrumentation
- **AOT & JIT compilation:** Compilation strategies that interact with instrumentation
- **Garbage collectors:** Memory management that can be instrumented
- **Android Architecture - Complete Overview:** How instrumentation fits into overall architecture

