---
number: 105
title: Handler/Looper deep dive
slug: handler-looper-deep-dive
level: intermediate
tags:
  - aosp
  - framework
  - handler
  - looper
  - message-queue
  - threading
  - system-components
prerequisites:
  - system-server-overview
  - view-system-internals
  - android-architecture-complete-overview
estimated_minutes: 95
contributors: []
diagrams: []
examples: []
canonical_id: aosp-intermediate-105
---

# Handler/Looper deep dive

## Overview

Handler, Looper, and MessageQueue form the core of Android's threading and message passing system, enabling thread-safe communication, UI updates, and asynchronous task execution. Understanding Handler/Looper internals is essential for AOSP development, as it explains how messages are passed between threads, how the main thread (UI thread) works, how background threads communicate with the UI thread, how message queuing works, and how Handler/Looper integrates with the Android framework. This guide provides a comprehensive overview of Handler/Looper internals, MessageQueue, Looper implementation, Handler implementation, message passing, and threading patterns.

Think of Handler/Looper like a postal system: just as a postal system has mailboxes (MessageQueue), mail carriers (Looper), and senders (Handler) that enable people to send messages to each other, Handler/Looper has MessageQueue (message storage), Looper (message processor), and Handler (message sender) that enable threads to send messages to each other.

## Deep Explanation

### What are Handler, Looper, and MessageQueue?

Handler, Looper, and MessageQueue are the core components of Android's threading and message passing system that enable thread-safe communication, UI updates, and asynchronous task execution.

**Key Characteristics:**
- **Handler:** Sends messages to MessageQueue
- **Looper:** Processes messages from MessageQueue
- **MessageQueue:** Stores messages waiting to be processed
- **Thread-Safe:** Enables safe cross-thread communication
- **Framework Core:** Fundamental to Android framework

**Why Handler/Looper?**
- **Thread Communication:** Enables thread-to-thread communication
- **UI Updates:** Enables safe UI updates from background threads
- **Asynchronous Execution:** Enables asynchronous task execution
- **Message Ordering:** Ensures message processing order

### Handler/Looper Architecture

#### Component Relationship

**Component Structure:**
```
Thread
├── Looper (one per thread)
│   └── MessageQueue (one per Looper)
└── Handler (multiple per thread)
    └── Bound to Looper
```

**Component Flow:**
```
Handler → sendMessage() → MessageQueue → Looper → processMessage() → Handler.handleMessage()
```

#### Thread Association

**Thread Binding:**
- **Looper:** Bound to thread (one Looper per thread)
- **MessageQueue:** Bound to Looper (one queue per Looper)
- **Handler:** Bound to Looper (multiple handlers per thread)

**Thread Model:**
- Each thread can have one Looper
- Looper has one MessageQueue
- Multiple Handlers can use same Looper
- Handler sends messages to its Looper's queue

### MessageQueue

#### MessageQueue Structure

**MessageQueue Characteristics:**
- **FIFO Queue:** First In, First Out
- **Thread-Local:** One per thread
- **Blocking:** Can block waiting for messages
- **Native Implementation:** Implemented in native code

**Message Storage:**
```
MessageQueue
├── Message (head)
│   ├── what: int
│   ├── arg1: int
│   ├── arg2: int
│   ├── obj: Object
│   ├── target: Handler
│   ├── callback: Runnable
│   ├── when: long (timestamp)
│   └── next: Message (linked list)
├── Message
└── ...
```

#### MessageQueue Operations

**Enqueue Message:**
```
1. Handler.sendMessage() called
2. Message.target set to Handler
3. Message.when set (timestamp)
4. Message added to queue (sorted by when)
5. Looper woken if needed
```

**Dequeue Message:**
```
1. Looper calls MessageQueue.next()
2. Get head message
3. Check message.when (delay)
4. If ready, remove from queue
5. Return message
6. If not ready or empty, block
```

#### Message Ordering

**Ordering Rules:**
- Messages ordered by `when` (timestamp)
- Earlier messages processed first
- Same timestamp: FIFO order
- Delayed messages processed after delay

**Ordering Example:**
```java
handler.sendMessageDelayed(msg1, 100); // Processed second
handler.sendMessageDelayed(msg2, 50);  // Processed first (earlier)
handler.sendMessage(msg3);            // Processed third (immediate, but after delays)
```

### Looper

#### Looper Lifecycle

**Looper Creation:**
```
1. Looper.prepare() called
2. Looper created for current thread
3. MessageQueue created
4. Looper stored in ThreadLocal
```

**Looper Loop:**
```
1. Looper.loop() called
2. Infinite loop starts:
   a. Get next message from queue
   b. If message is null, quit
   c. Process message (dispatch to Handler)
   d. Recycle message
   e. Repeat
```

**Looper Quit:**
```
1. Looper.quit() called
2. MessageQueue quit flag set
3. Looper loop exits
4. Thread can terminate
```

#### Looper Implementation

**Simplified Loop:**
```java
public static void loop() {
    final Looper me = myLooper();
    final MessageQueue queue = me.mQueue;
    
    for (;;) {
        Message msg = queue.next(); // May block
        if (msg == null) {
            return; // Quit
        }
        
        msg.target.dispatchMessage(msg);
        msg.recycleUnchecked();
    }
}
```

#### Main Looper

**Main Thread Looper:**
- Created automatically for main thread
- Never quits (main thread never terminates)
- Accessible via `Looper.getMainLooper()`
- Used for UI updates

**Main Looper Setup:**
```
1. App process starts
2. Main thread created
3. Looper.prepareMainLooper() called automatically
4. Main Looper created
5. Looper.loop() starts
6. Main thread ready for UI
```

### Handler

#### Handler Creation

**Handler Creation Methods:**
```java
// Method 1: Default (current thread's Looper)
Handler handler = new Handler();
// Uses Looper of current thread
// Fails if no Looper prepared

// Method 2: Explicit Looper
Handler handler = new Handler(Looper.getMainLooper());
// Uses specified Looper

// Method 3: With Callback
Handler handler = new Handler(callback);
// Handler with callback for message handling
```

#### Handler Operations

**Send Message:**
```java
Message msg = Message.obtain();
msg.what = MSG_UPDATE;
handler.sendMessage(msg);
// Message added to queue
// Returns immediately
```

**Post Runnable:**
```java
handler.post(new Runnable() {
    @Override
    public void run() {
        // Code runs on handler's thread
    }
});
// Creates message with Runnable callback
// Adds to queue
```

**Send Delayed:**
```java
handler.sendMessageDelayed(msg, 1000);
// Message processed after 1 second delay
// Uses SystemClock.uptimeMillis()
```

#### Message Dispatching

**Dispatch Flow:**
```java
public void dispatchMessage(Message msg) {
    if (msg.callback != null) {
        // Runnable callback (highest priority)
        handleCallback(msg);
    } else {
        if (mCallback != null && mCallback.handleMessage(msg)) {
            return; // Handled by callback
        }
        // Default handler (lowest priority)
        handleMessage(msg);
    }
}
```

**Dispatch Priority:**
1. **Runnable callback:** `msg.callback` (highest)
2. **Handler callback:** `mCallback.handleMessage()` (middle)
3. **Override method:** `handleMessage()` (lowest)

### Message

#### Message Structure

**Message Fields:**
```java
class Message {
    int what;              // Message type
    int arg1;              // Integer argument 1
    int arg2;              // Integer argument 2
    Object obj;            // Object argument
    Handler target;        // Target handler
    Runnable callback;     // Runnable callback
    long when;             // Timestamp
    Message next;          // Next message (linked list)
    Bundle data;           // Additional data
}
```

#### Message Pooling

**Why Pool Messages?**
- **Performance:** Avoid object allocations
- **GC Pressure:** Reduce garbage collection
- **Efficiency:** Reuse message objects

**Message Pool Usage:**
```java
// Obtain message from pool
Message msg = Message.obtain();

// Use message
msg.what = MSG_UPDATE;
handler.sendMessage(msg);

// After handling, message recycled automatically
// Returns to pool for reuse
```

**Pool Implementation:**
- Static message pool
- Maximum pool size (typically 50)
- Thread-safe pool access
- Automatic recycling

### Threading Patterns

#### Main Thread (UI Thread)

**Main Thread Characteristics:**
- Has Looper automatically
- Never quits
- Handles UI updates
- Thread-safe for UI operations

**Posting to Main Thread:**
```java
// From background thread
Handler mainHandler = new Handler(Looper.getMainLooper());
mainHandler.post(new Runnable() {
    @Override
    public void run() {
        // Runs on main thread
        updateUI();
    }
});

// Or using Activity
activity.runOnUiThread(new Runnable() {
    @Override
    public void run() {
        // Runs on main thread
        updateUI();
    }
});
```

#### Background Threads

**Background Thread Setup:**
```java
Thread backgroundThread = new Thread(new Runnable() {
    @Override
    public void run() {
        // Prepare Looper for this thread
        Looper.prepare();
        
        // Create Handler for this thread
        Handler handler = new Handler();
        
        // Start Looper
        Looper.loop();
    }
});
backgroundThread.start();
```

**Background Thread Communication:**
```java
// From main thread to background thread
backgroundHandler.sendMessage(msg);

// From background thread to main thread
mainHandler.post(runnable);
```

### Handler/Looper Integration

#### Framework Integration

**Integration Points:**
- **View System:** UI updates via Handler
- **Activity:** Lifecycle callbacks via Handler
- **Service:** Background work via Handler
- **System Services:** Internal communication via Handler

**Integration Examples:**
- View.post() uses Handler
- Activity.runOnUiThread() uses Handler
- AsyncTask uses Handler
- System services use Handler for coordination

#### Choreographer Integration

**Choreographer:**
- Coordinates frame rendering
- Uses Handler for callbacks
- Synchronizes with VSync
- Schedules frame callbacks

**Choreographer Flow:**
```
VSync Signal
    ↓
Choreographer
    ↓
Handler.postFrameCallback()
    ↓
View drawing
```

### Handler/Looper Best Practices

#### Thread Safety

**Thread-Safe Operations:**
- Handler.sendMessage() is thread-safe
- Can be called from any thread
- Messages queued safely
- No synchronization needed

**UI Thread Safety:**
- UI operations must be on main thread
- Use Handler to post UI updates
- Never update UI from background thread
- Use runOnUiThread() for convenience

#### Memory Leaks

**Common Leak:**
```java
// BAD: Handler holds reference to Activity
Handler handler = new Handler() {
    @Override
    public void handleMessage(Message msg) {
        // Activity reference held
    }
};

// GOOD: Use static Handler or WeakReference
private static class MyHandler extends Handler {
    private final WeakReference<Activity> activityRef;
    
    MyHandler(Activity activity) {
        activityRef = new WeakReference<>(activity);
    }
    
    @Override
    public void handleMessage(Message msg) {
        Activity activity = activityRef.get();
        if (activity != null) {
            // Use activity
        }
    }
}
```

### Debugging Handler/Looper

#### Common Issues

**Development Issues:**
- Messages not processed
- Looper not prepared
- Handler on wrong thread
- Memory leaks
- Message queue overflow

#### Debugging Tools

**Looper Inspection:**
```java
// Check if Looper exists
Looper looper = Looper.myLooper();
if (looper == null) {
    // No Looper for current thread
}

// Check main Looper
Looper mainLooper = Looper.getMainLooper();
```

**Message Queue Inspection:**
```bash
# Dump message queue (requires root)
adb shell dumpsys activity | grep -A 20 "MessageQueue"
```

**Logcat:**
```bash
# Filter Handler/Looper logs
adb logcat | grep -E "Handler|Looper|MessageQueue"
```

## Key Takeaways

1. **Handler, Looper, and MessageQueue** form the core of Android's threading and message passing system, enabling thread-safe communication, UI updates, and asynchronous task execution.

2. **Handler/Looper architecture** includes Handler (sends messages), Looper (processes messages), MessageQueue (stores messages), and thread association (one Looper per thread, multiple Handlers per thread).

3. **MessageQueue** is a FIFO queue storing messages as a linked list, ordered by timestamp, with blocking operations for efficient message processing.

4. **Looper** loops through MessageQueue processing messages, with lifecycle (prepare, loop, quit), main Looper (automatic for main thread), and implementation (infinite loop processing messages).

5. **Handler** sends messages to MessageQueue, with creation methods (default, explicit Looper, callback), operations (sendMessage, post, sendDelayed), and message dispatching (priority: Runnable callback → Handler callback → handleMessage).

6. **Message** structure includes fields (what, arg1, arg2, obj, target, callback, when), message pooling (reuse for performance), and message delivery (synchronous and asynchronous).

7. **Threading patterns** include main thread (automatic Looper, UI updates), background threads (prepare Looper, create Handler), and thread communication (Handler for cross-thread messaging).

8. **Handler/Looper integration** with framework (View system, Activity, Services), Choreographer (frame rendering coordination), and system services enables proper Android functionality.

9. **Best practices** include thread safety (Handler is thread-safe), UI thread safety (post UI updates), and memory leak prevention (use static Handler or WeakReference).

10. **Understanding Handler/Looper internals** is essential for AOSP development, explaining how Android handles threading, message passing, UI updates, and asynchronous execution.

## Related Topics

- **System Server Overview:** How Handler/Looper fits into system architecture
- **View system internals:** How View system uses Handler/Looper for UI updates
- **ActivityManagerService (AMS) internals:** How AMS uses Handler/Looper
- **Android Architecture - Complete Overview:** How Handler/Looper fits into overall architecture

