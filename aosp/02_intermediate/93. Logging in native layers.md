---
number: 93
title: Logging in native layers
slug: logging-in-native-layers
level: intermediate
tags:
  - aosp
  - native
  - logging
  - logcat
  - alog
  - native-logging
  - debugging
prerequisites:
  - jni-basics
  - working-with-frameworks-native
  - building-native-system-components
estimated_minutes: 85
contributors: []
diagrams: []
examples: []
canonical_id: aosp-intermediate-93
---

# Logging in native layers

## Overview

Logging in native layers involves using Android's logging system from native C/C++ code to output debug information, error messages, and diagnostic data that can be viewed via logcat. Understanding native logging is essential for AOSP development, as it explains how to log from native code, how native logs integrate with Android's logging system, how to use different log levels, how to filter and view native logs, and best practices for native logging. This guide provides a comprehensive overview of logging in native layers, ALOG macros, log levels, logcat integration, and debugging techniques.

Think of logging in native layers like leaving breadcrumbs: just as breadcrumbs help you retrace your path, logging helps you trace execution through native code, understand what's happening, identify where problems occur, and debug issues. Native logs appear in logcat alongside Java logs, providing a complete picture of system behavior.

## Deep Explanation

### What is Native Logging?

Native logging is the mechanism for outputting log messages from native C/C++ code that integrates with Android's logging system (logcat), allowing native code to produce logs that can be viewed, filtered, and analyzed using standard Android logging tools.

**Key Characteristics:**
- **Native Code:** Logging from C/C++
- **Logcat Integration:** Appears in logcat
- **Structured:** Tag, priority, message
- **Filterable:** Can be filtered by tag/priority

**Why Native Logging?**
- **Debugging:** Identify and fix issues
- **Diagnostics:** Understand code behavior
- **Monitoring:** Track system behavior
- **Development:** Development tooling

### Android Logging System

#### Logcat Architecture

**Logging Flow:**
```
Native Code
    │
    │ ALOG macros
    │
    ▼
Logger Driver (kernel)
    │
    │ Log buffers
    │
    ▼
Logcat (user space)
    │
    │ View/filter logs
    │
    ▼
Developer
```

**Components:**
- Native logging macros (ALOG)
- Logger driver (kernel)
- Log buffers (main, system, radio, etc.)
- Logcat tool (viewing)

#### Log Buffers

**Buffer Types:**
- **main** - Application and system logs
- **system** - System service logs
- **radio** - Radio/telephony logs
- **events** - Structured events
- **crash** - Crash logs

**Native Logs:**
- Default to `main` buffer
- Can specify buffer
- Filterable by tag
- Viewable via logcat

### ALOG Macros

#### Basic ALOG Macros

**ALOG Macros:**
```c
#include <android/log.h>

// Log levels
ALOGV("tag", "format", ...);  // VERBOSE
ALOGD("tag", "format", ...);  // DEBUG
ALOGI("tag", "format", ...);  // INFO
ALOGW("tag", "format", ...);  // WARN
ALOGE("tag", "format", ...);  // ERROR
```

**Usage:**
```c
ALOGI("MyModule", "Function called with param=%d", param);
ALOGE("MyModule", "Error occurred: %s", error_msg);
```

#### ALOG Macros with android-base

**android-base Logging:**
```cpp
#include <android-base/logging.h>

// Log levels
LOG(VERBOSE) << "Verbose message";
LOG(DEBUG) << "Debug message";
LOG(INFO) << "Info message";
LOG(WARNING) << "Warning message";
LOG(ERROR) << "Error message";
LOG(FATAL) << "Fatal error";
```

**Usage:**
```cpp
LOG(INFO) << "Function called: " << functionName;
LOG(ERROR) << "Operation failed: " << error;
```

**Benefits:**
- Stream-based (C++ style)
- Automatic tag (from file/function)
- Type-safe
- More convenient

### Log Levels

#### Log Level Hierarchy

**Priority Levels (lowest to highest):**
- **VERBOSE (V)** - Most detailed, development only
- **DEBUG (D)** - Debug information
- **INFO (I)** - General information
- **WARN (W)** - Warnings
- **ERROR (E)** - Errors
- **FATAL (F)** - Fatal errors (crashes)

**Level Selection:**
- Use appropriate level
- VERBOSE for detailed debugging
- DEBUG for development
- INFO for important events
- WARN for potential issues
- ERROR for errors
- FATAL for fatal errors

#### Log Level Usage

**VERBOSE:**
```c
ALOGV("MyModule", "Entering function, param=%d", param);
```
- Detailed debugging
- Usually disabled in production
- Development only

**DEBUG:**
```c
ALOGD("MyModule", "Processing data: %s", data);
```
- Development debugging
- Useful for troubleshooting
- Can be enabled in debug builds

**INFO:**
```c
ALOGI("MyModule", "Service started successfully");
```
- Important events
- General information
- Always visible

**WARN:**
```c
ALOGW("MyModule", "Deprecated API used, consider updating");
```
- Potential issues
- Deprecation warnings
- Non-critical problems

**ERROR:**
```c
ALOGE("MyModule", "Failed to open device: %s", strerror(errno));
```
- Errors that need attention
- Operation failures
- Critical issues

**FATAL:**
```c
LOG(FATAL) << "Critical error, aborting";
```
- Fatal errors
- Causes abort
- System cannot continue

### Log Tags

#### Tag Selection

**Tag Guidelines:**
- Use module/component name
- Keep tags short
- Be descriptive
- Consistent naming

**Good Tags:**
```c
ALOGI("SurfaceFlinger", "Surface created");
ALOGI("InputFlinger", "Input event received");
ALOGI("SensorService", "Sensor activated");
```

**Bad Tags:**
```c
ALOGI("test", "message");        // Too generic
ALOGI("mymodule123", "message"); // Inconsistent
```

#### Tag Best Practices

**Tag Naming:**
- Use component name
- Match library/service name
- Consistent across module
- Short but descriptive

**Example:**
```c
// In libui
#define LOG_TAG "libui"
ALOGI(LOG_TAG, "Message");

// In SurfaceFlinger service
#define LOG_TAG "SurfaceFlinger"
ALOGI(LOG_TAG, "Message");
```

### Log Format

#### Log Message Format

**Standard Format:**
```
<priority>/<tag>(<pid>): <message>
```

**Example:**
```
I/SurfaceFlinger(  123): Surface created: id=5
E/InputFlinger(  456): Failed to read input: Permission denied
```

**Components:**
- Priority (I, D, W, E, V, F)
- Tag (component name)
- PID (process ID)
- Message (log content)

#### Formatted Logging

**Format Strings:**
```c
// Basic format
ALOGI("MyModule", "Value: %d", value);

// Multiple values
ALOGI("MyModule", "x=%d, y=%d, z=%s", x, y, z);

// String formatting
ALOGI("MyModule", "Path: %s", path);
```

**Format Specifiers:**
- `%d` - Integer
- `%f` - Float
- `%s` - String
- `%p` - Pointer
- `%x` - Hexadecimal

### Conditional Logging

#### Runtime Logging Control

**Conditional Logs:**
```c
if (DEBUG) {
    ALOGD("MyModule", "Debug information");
}
```

**Compile-Time Control:**
```c
#ifdef DEBUG
    ALOGD("MyModule", "Debug build");
#endif
```

**Verbose Logging:**
```c
if (LOG_NDEBUG == 0) {
    ALOGV("MyModule", "Verbose information");
}
```

#### Log Level Control

**Runtime Control:**
```bash
# Set log level via property
adb shell setprop log.tag.MyModule DEBUG

# Check log level
adb shell getprop log.tag.MyModule
```

**Property-Based:**
- `log.tag.<TAG>=<LEVEL>`
- Controls log level per tag
- Runtime configuration
- No rebuild needed

### Logcat Integration

#### Viewing Native Logs

**View All Logs:**
```bash
adb logcat
```

**Filter by Tag:**
```bash
adb logcat -s MyModule
adb logcat -s SurfaceFlinger InputFlinger
```

**Filter by Priority:**
```bash
adb logcat *:E    # Errors only
adb logcat *:W    # Warnings and above
adb logcat MyModule:D *:E  # MyModule debug, all errors
```

#### Logcat Filters

**Tag Filtering:**
```bash
# Single tag
adb logcat -s MyTag

# Multiple tags
adb logcat -s Tag1 Tag2 Tag3

# Suppress specific tags
adb logcat Tag1:V Tag2:S
```

**Priority Filter:**
- `V` - Verbose
- `D` - Debug
- `I` - Info
- `W` - Warning
- `E` - Error
- `F` - Fatal
- `S` - Silent (suppress)

### Advanced Logging

#### Structured Logging

**Event Logging:**
```c
#include <log/log_event_list.h>

// Structured event
android_log_event_list(LOG_ID_EVENTS)
    << "event_name"
    << "param1" << value1
    << "param2" << value2;
```

**Benefits:**
- Structured data
- Parseable format
- Better analysis
- Event tracking

#### Binary Logging

**Binary Data:**
```c
// Log binary data (hex dump)
ALOGD("MyModule", "Data: %s", hex_dump(data, size));
```

**Use Cases:**
- Protocol debugging
- Data inspection
- Binary analysis

### Performance Considerations

#### Logging Overhead

**Overhead Factors:**
- Log frequency
- Log level
- Message size
- String formatting

**Impact:**
- CPU usage
- I/O overhead
- Memory usage
- Battery impact

#### Optimization

**Minimize Logging:**
- Use appropriate log levels
- Conditional logging
- Avoid in hot paths
- Reduce log frequency

**Best Practices:**
```c
// BAD: Logging in hot path
for (int i = 0; i < 1000000; i++) {
    ALOGD("MyModule", "Iteration %d", i);  // Too frequent
}

// GOOD: Conditional or removed
#ifdef DEBUG
    if (i % 1000 == 0) {
        ALOGD("MyModule", "Progress: %d", i);
    }
#endif
```

### Debugging with Logs

#### Log Analysis

**Common Patterns:**
- Entry/exit logging
- State change logging
- Error logging
- Performance logging

**Entry/Exit:**
```c
void myFunction(int param) {
    ALOGD("MyModule", "Entering myFunction(param=%d)", param);
    // ... function body ...
    ALOGD("MyModule", "Exiting myFunction");
}
```

**State Changes:**
```c
ALOGI("MyModule", "State changed: %s -> %s", oldState, newState);
```

#### Log Filtering

**Effective Filtering:**
```bash
# Function entry/exit
adb logcat | grep "Entering\|Exiting"

# Errors only
adb logcat *:E

# Specific module
adb logcat -s MyModule

# Time-based
adb logcat -v time | grep "10:30"
```

### Best Practices

#### Logging Guidelines

**Do:**
- Use appropriate log levels
- Include context information
- Use descriptive tags
- Log important events
- Log errors with details

**Don't:**
- Log sensitive information
- Log too frequently
- Use generic tags
- Log in performance-critical paths
- Leave debug logs in production

#### Security Considerations

**Sensitive Data:**
- Don't log passwords
- Don't log tokens
- Don't log personal data
- Don't log encryption keys

**Example:**
```c
// BAD
ALOGI("Auth", "Password: %s", password);

// GOOD
ALOGI("Auth", "Authentication attempt for user: %s", username);
```

## Key Takeaways

1. **Native logging** uses Android's logging system (logcat) from native C/C++ code, integrating with Android's logging infrastructure for debugging and diagnostics.

2. **ALOG macros** provide logging functions (`ALOGV`, `ALOGD`, `ALOGI`, `ALOGW`, `ALOGE`) with tag and formatted message, while android-base provides stream-based logging (`LOG(INFO)`, etc.).

3. **Log levels** include VERBOSE (development), DEBUG (development), INFO (general), WARN (warnings), ERROR (errors), and FATAL (fatal errors), with appropriate usage for each level.

4. **Log tags** should use module/component names, be short and descriptive, and be consistent across the module for effective filtering.

5. **Log format** follows `<priority>/<tag>(<pid>): <message>` format, viewable via logcat with filtering by tag, priority, or other criteria.

6. **Conditional logging** can be controlled at compile-time (`#ifdef DEBUG`) or runtime (log properties), allowing flexible logging control.

7. **Performance considerations** include logging overhead (CPU, I/O, memory), which should be minimized by using appropriate levels, conditional logging, and avoiding logs in hot paths.

8. **Understanding logging in native layers** is essential for AOSP development, enabling effective debugging, diagnostics, and monitoring of native code behavior through Android's logging system.

## Related Topics

- **Working with frameworks/native/:** Native framework development where logging is used
- **JNI basics:** How native code integrates with Java, including logging
- **Building native system components:** Building native code that includes logging
- **Android Architecture - Complete Overview:** How logging fits into overall architecture

