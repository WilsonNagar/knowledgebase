---
number: 206
title: perf (performance profiling)
slug: perf-performance-profiling
level: intermediate
tags:
  - aosp
  - perf
  - performance-profiling
  - profiling
  - debugging
  - development-tools
prerequisites:
  - android-architecture-complete-overview
  - profiling-system-performance-at-kernel-framework-level
estimated_minutes: 95
contributors: []
diagrams: []
examples: []
canonical_id: aosp-intermediate-206
---

# perf (performance profiling)

## Overview

perf (Linux Performance Events) is a powerful performance profiling tool that provides hardware and software event-based performance analysis for Linux systems, including Android. Understanding perf is essential for AOSP development, as it explains how to profile system performance, how to analyze CPU usage, how to identify performance bottlenecks, how to measure hardware events, and how perf provides comprehensive performance analysis capabilities. This guide provides a comprehensive overview of perf, tool usage, event types, profiling workflows, analysis techniques, and best practices.

Think of perf like a performance monitoring dashboard: just as a dashboard shows real-time metrics about a vehicle's performance (speed, RPM, temperature, fuel level), perf shows real-time metrics about system performance (CPU usage, cache misses, branch predictions, memory access), providing comprehensive visibility into system behavior and performance characteristics.

## Deep Explanation

### What is perf?

perf (Linux Performance Events) is a performance profiling tool that uses hardware performance counters and software events to analyze system and application performance, providing detailed insights into CPU usage, memory access, cache behavior, and system bottlenecks.

**Key Characteristics:**
- **Hardware Events:** Uses CPU performance counters
- **Software Events:** Tracks software-level events
- **System-Wide:** Profiles entire system
- **Process-Specific:** Can profile specific processes
- **Low Overhead:** Minimal performance impact

**Why perf?**
- **Performance Analysis:** Comprehensive performance analysis
- **Bottleneck Identification:** Identify performance bottlenecks
- **Hardware Insights:** Access hardware performance counters
- **System Profiling:** Profile entire system
- **Development Tool:** Essential development tool

### perf Architecture

#### Event Types

**Hardware Events:**
- CPU cycles
- Instructions retired
- Cache misses
- Branch mispredictions
- Memory accesses

**Software Events:**
- Context switches
- Page faults
- CPU migrations
- Task migrations
- System calls

**Event Characteristics:**
- Hardware-level metrics
- Software-level metrics
- System-wide events
- Process-specific events
- Custom events

#### perf Subcommands

**Main Subcommands:**
- `perf stat` - Count events
- `perf record` - Record events
- `perf report` - Analyze recorded data
- `perf top` - Real-time profiling
- `perf annotate` - Source annotation

**Subcommand Characteristics:**
- Event counting
- Event recording
- Data analysis
- Real-time profiling
- Source-level analysis

### perf stat (Event Counting)

#### Basic Usage

**Basic stat:**
```bash
# Count events for a command
perf stat command

# Count events for a process
perf stat -p <pid>

# Count system-wide events
perf stat -a
```

**Output Example:**
```
 Performance counter stats for 'command':

         1,234,567      cpu-cycles
           987,654      instructions
            12,345      cache-references
             1,234      cache-misses
               567      page-faults

       0.123456789 seconds time elapsed
```

**Usage Characteristics:**
- Event counting
- Process profiling
- System-wide profiling
- Statistical output
- Time measurement

#### Advanced stat Options

**Advanced Options:**
```bash
# Count specific events
perf stat -e cpu-cycles,instructions,cache-misses command

# Count with intervals
perf stat -I 1000 command

# Count with detailed output
perf stat -d command

# Count with CSV output
perf stat -x, command

# Count with specific CPUs
perf stat -C 0,1 command
```

**Option Characteristics:**
- Event selection
- Interval reporting
- Detailed metrics
- Output formatting
- CPU selection

### perf record (Event Recording)

#### Basic Recording

**Basic record:**
```bash
# Record events for a command
perf record command

# Record events for a process
perf record -p <pid>

# Record system-wide events
perf record -a
```

**Recording Characteristics:**
- Event recording
- Process recording
- System-wide recording
- Data file creation
- Sampling configuration

#### Recording Options

**Recording Options:**
```bash
# Record with call graphs
perf record -g command

# Record with specific events
perf record -e cpu-cycles,instructions command

# Record with sampling frequency
perf record -F 1000 command

# Record with output file
perf record -o output.data command

# Record with CPU selection
perf record -C 0,1 command
```

**Option Characteristics:**
- Call graph recording
- Event selection
- Sampling control
- Output file specification
- CPU selection

### perf report (Data Analysis)

#### Basic Reporting

**Basic report:**
```bash
# Analyze recorded data
perf report

# Analyze specific file
perf report -i perf.data

# Report with call graphs
perf report -g
```

**Report Output:**
```
# Overhead  Command  Shared Object      Symbol
# ........  .......  ................  ......................
#
    42.50%  command  libc.so            [.] malloc
    25.30%  command  command            [.] process_data
    15.20%  command  libc.so            [.] free
    10.00%  command  [kernel]            [k] do_syscall_64
```

**Report Characteristics:**
- Overhead analysis
- Symbol resolution
- Call graph display
- Interactive navigation
- Data filtering

#### Advanced Reporting

**Advanced Options:**
```bash
# Report with specific sort
perf report --sort comm,symbol

# Report with threshold
perf report --percent-limit 1.0

# Report with call graph
perf report -g graph,0.5

# Report with source annotation
perf report --source

# Report with assembly
perf report --asm-raw
```

**Advanced Characteristics:**
- Custom sorting
- Threshold filtering
- Call graph analysis
- Source annotation
- Assembly view

### perf top (Real-Time Profiling)

#### Basic top Usage

**Basic top:**
```bash
# Real-time system profiling
perf top

# Real-time process profiling
perf top -p <pid>

# Real-time with call graphs
perf top -g
```

**Top Output:**
```
Samples: 1K of event 'cpu-cycles', Event count (approx.): 123456789
Overhead  Shared Object       Symbol
  42.50%  libc.so              [.] malloc
  25.30%  command              [.] process_data
  15.20%  libc.so              [.] free
```

**Top Characteristics:**
- Real-time updates
- System-wide view
- Process-specific view
- Interactive interface
- Hotspot identification

#### top Options

**Top Options:**
```bash
# Top with specific events
perf top -e cpu-cycles,instructions

# Top with specific CPUs
perf top -C 0,1

# Top with call graphs
perf top -g

# Top with refresh rate
perf top --delay 1
```

**Option Characteristics:**
- Event selection
- CPU selection
- Call graph display
- Refresh control
- Interactive features

### Using perf on Android

#### Building perf for Android

**Building perf:**
```bash
# perf is available in AOSP
# Build perf
m perf

# Or use pre-built binaries
```

**Installation:**
```bash
# Push to device
adb push perf /data/local/tmp/

# Make executable
adb shell chmod 755 /data/local/tmp/perf

# Verify installation
adb shell /data/local/tmp/perf --version
```

**Installation Characteristics:**
- AOSP build support
- Device deployment
- Permission setup
- Tool verification
- Availability

#### Profiling Android Processes

**Profiling Native Processes:**
```bash
# Get process PID
PID=$(adb shell pidof -s process_name)

# Profile with stat
adb shell perf stat -p $PID

# Profile with record
adb shell perf record -p $PID -o /sdcard/perf.data

# Pull data file
adb pull /sdcard/perf.data

# Analyze on host
perf report -i perf.data
```

**Profiling Characteristics:**
- Process identification
- Remote profiling
- Data collection
- Host analysis
- Cross-platform workflow

### Profiling Workflows

#### CPU Profiling Workflow

**CPU Profiling:**
```
1. Identify process to profile
2. Record CPU events
3. Analyze recorded data
4. Identify hotspots
5. Optimize hotspots
```

**Workflow Steps:**
```bash
# 1. Record CPU events
perf record -g -p $PID

# 2. Analyze data
perf report

# 3. Identify hotspots
# Look for high overhead functions

# 4. Optimize
# Focus on high overhead areas
```

**Workflow Characteristics:**
- Event recording
- Data analysis
- Hotspot identification
- Optimization guidance
- Performance improvement

#### Memory Profiling Workflow

**Memory Profiling:**
```
1. Record memory events
2. Analyze memory access patterns
3. Identify cache issues
4. Optimize memory access
```

**Workflow Steps:**
```bash
# 1. Record memory events
perf record -e cache-misses,cache-references -p $PID

# 2. Analyze cache behavior
perf report

# 3. Identify cache issues
# Look for high cache miss rates

# 4. Optimize
# Improve memory access patterns
```

**Workflow Characteristics:**
- Memory event recording
- Cache analysis
- Issue identification
- Optimization guidance
- Performance improvement

### Advanced Techniques

#### Custom Events

**Custom Events:**
```bash
# Define custom event
perf stat -e r1234:u command

# Use raw events
perf stat -e rCPU_CYCLES command

# Event modifiers
perf stat -e cpu-cycles:u command  # user space only
perf stat -e cpu-cycles:k command  # kernel space only
```

**Custom Characteristics:**
- Raw event access
- Event modifiers
- Custom configurations
- Hardware-specific events
- Advanced profiling

#### Scripting and Automation

**Scripting:**
```bash
#!/bin/bash
# Profile script
PID=$1
perf record -g -p $PID -o perf.data
perf report -i perf.data > report.txt
```

**Automation:**
- Script-based profiling
- Automated analysis
- Report generation
- CI/CD integration
- Continuous profiling

### Best Practices

#### Best Practices

**Best Practices:**
- Use appropriate events
- Record with call graphs
- Analyze systematically
- Combine with other tools
- Document findings

**Practice Guidelines:**
- **Events:** Use appropriate events
- **Call Graphs:** Record with call graphs
- **Analysis:** Analyze systematically
- **Combination:** Combine with other tools
- **Documentation:** Document findings

#### Common Use Cases

**Common Use Cases:**
- CPU performance analysis
- Memory access optimization
- Cache behavior analysis
- System bottleneck identification
- Application optimization

**Use Case Examples:**
- CPU profiling
- Memory profiling
- Cache optimization
- System analysis
- Application optimization

## Key Takeaways

1. **perf (Linux Performance Events)** is a powerful performance profiling tool that provides hardware and software event-based performance analysis for Linux systems, including Android, providing detailed insights into CPU usage, memory access, cache behavior, and system bottlenecks.

2. **perf architecture** includes event types (hardware events - CPU cycles, instructions retired, cache misses, branch mispredictions, memory accesses; software events - context switches, page faults, CPU migrations, task migrations, system calls), perf subcommands (perf stat - count events, perf record - record events, perf report - analyze recorded data, perf top - real-time profiling, perf annotate - source annotation), and architecture characteristics.

3. **perf stat (event counting)** includes basic usage (event counting, process profiling, system-wide profiling, statistical output, time measurement), advanced stat options (event selection, interval reporting, detailed metrics, output formatting, CPU selection), and stat characteristics.

4. **perf record (event recording)** includes basic recording (event recording, process recording, system-wide recording, data file creation, sampling configuration), recording options (call graph recording, event selection, sampling control, output file specification, CPU selection), and recording characteristics.

5. **perf report (data analysis)** includes basic reporting (overhead analysis, symbol resolution, call graph display, interactive navigation, data filtering), advanced reporting (custom sorting, threshold filtering, call graph analysis, source annotation, assembly view), and report characteristics.

6. **perf top (real-time profiling)** includes basic top usage (real-time updates, system-wide view, process-specific view, interactive interface, hotspot identification), top options (event selection, CPU selection, call graph display, refresh control, interactive features), and top characteristics.

7. **Using perf on Android** includes building perf for Android (AOSP build support, device deployment, permission setup, tool verification, availability), profiling Android processes (process identification, remote profiling, data collection, host analysis, cross-platform workflow), and Android usage characteristics.

8. **Profiling workflows** include CPU profiling workflow (event recording, data analysis, hotspot identification, optimization guidance, performance improvement), memory profiling workflow (memory event recording, cache analysis, issue identification, optimization guidance, performance improvement), and workflow characteristics.

9. **Advanced techniques** include custom events (raw event access, event modifiers, custom configurations, hardware-specific events, advanced profiling), scripting and automation (script-based profiling, automated analysis, report generation, CI/CD integration, continuous profiling), and advanced characteristics.

10. **Best practices** include best practices (use appropriate events, record with call graphs, analyze systematically, combine with other tools, document findings), common use cases (CPU performance analysis, memory access optimization, cache behavior analysis, system bottleneck identification, application optimization), and practice guidelines.

11. **Understanding perf** is essential for AOSP development, enabling performance profiling, bottleneck identification, hardware insights, system profiling, application optimization, and proper performance tool usage.

## Related Topics

- **Android Architecture - Complete Overview:** Architecture details
- **Profiling system performance at kernelâ†’framework level:** Performance profiling details

