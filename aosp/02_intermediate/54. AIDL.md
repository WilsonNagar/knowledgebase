---
number: 54
title: AIDL
slug: aidl
level: intermediate
tags:
  - aosp
  - aidl
  - binder
  - ipc
  - interface
  - code-generation
  - parcelable
prerequisites:
  - binder-architecture
  - binder-ipc-basics
  - servicemanager
estimated_minutes: 90
contributors: []
diagrams: []
examples: []
canonical_id: aosp-intermediate-54
---

# AIDL

## Overview

AIDL (Android Interface Definition Language) is the primary language for defining Binder IPC interfaces in Android. It provides a simple, type-safe way to define the contract between client and server processes, with the build system automatically generating the necessary Binder proxy and stub code. Understanding AIDL is essential for AOSP development, as it's used throughout the system for service interfaces, app-to-framework communication, and inter-process communication. This guide provides a comprehensive overview of AIDL syntax, data types, code generation, usage patterns, and best practices.

Think of AIDL like a contract or API specification: just as a contract defines the terms of an agreement between parties, AIDL defines the interface contract between client and server processes. The build system then automatically generates the "legal documents" (proxy and stub code) that implement this contract, ensuring both sides follow the same rules and can communicate correctly.

## Deep Explanation

### What is AIDL?

AIDL (Android Interface Definition Language) is a language for defining interfaces that can be used for Binder IPC. It looks similar to Java interfaces but is specifically designed for inter-process communication.

**Key Characteristics:**
- **Interface Definition:** Defines service interfaces
- **Code Generation:** Build system generates Binder code
- **Type Safety:** Provides compile-time type checking
- **IPC-Optimized:** Designed specifically for Binder IPC

**Why AIDL?**
- **Automatic Code Generation:** No manual Binder code writing
- **Type Safety:** Compile-time interface checking
- **Simplified Development:** Easy to define and use
- **Standardized:** Consistent interface definition format

### AIDL File Structure

#### Basic AIDL File

**File Location:**
- AIDL files go in `src/main/aidl/` directory
- Package structure matches Java packages
- File extension: `.aidl`

**Basic Structure:**
```aidl
// IMyService.aidl
package com.example;

interface IMyService {
    int add(int a, int b);
    String processData(String input);
}
```

**Components:**
- **Package Declaration:** Java package name
- **Interface Declaration:** Interface name (starts with 'I')
- **Method Signatures:** Methods with parameters and return types

#### AIDL Syntax Rules

**Naming Conventions:**
- Interface names start with 'I' (e.g., `IMyService`)
- Package names match Java packages
- File names match interface names
- Case-sensitive

**Method Signatures:**
- Similar to Java method syntax
- Parameters: `type name`
- Return type before method name
- Can throw `RemoteException`

### AIDL Data Types

#### Supported Primitive Types

**Basic Primitives:**
- `int` - 32-bit integer
- `long` - 64-bit integer
- `float` - 32-bit floating point
- `double` - 64-bit floating point
- `boolean` - Boolean value
- `byte` - 8-bit integer
- `char` - 16-bit Unicode character

**Usage:**
```aidl
interface IMyService {
    int calculate(int a, int b);
    boolean isValid(String input);
    double getValue();
}
```

#### String and CharSequence

**String Types:**
- `String` - java.lang.String
- `CharSequence` - java.lang.CharSequence

**Usage:**
```aidl
interface IMyService {
    String processText(String input);
    CharSequence getDescription();
}
```

#### Collections

**List:**
- Must be `ArrayList`
- Contents must be AIDL-supported types
- Generic syntax: `List<Type>`

**Map:**
- Must be `HashMap`
- Keys and values must be AIDL-supported
- Generic syntax: `Map<KeyType, ValueType>`

**Usage:**
```aidl
interface IMyService {
    List<String> getItems();
    Map<String, Integer> getCounts();
    void processList(List<MyData> data);
}
```

#### Parcelable Types

**Parcelable:**
- Custom classes implementing `Parcelable`
- Must define AIDL file for Parcelable
- Used for complex data structures

**Parcelable AIDL:**
```aidl
// MyData.aidl
package com.example;

parcelable MyData;
```

**Java Implementation:**
```java
public class MyData implements Parcelable {
    // Parcelable implementation
}
```

**Usage in Interface:**
```aidl
interface IMyService {
    MyData processData(MyData input);
    List<MyData> getDataList();
}
```

#### AIDL Interfaces

**Interface Types:**
- Other AIDL interfaces can be parameters
- Used for callbacks
- Supports bidirectional communication

**Usage:**
```aidl
// IMyService.aidl
package com.example;

import com.example.IMyCallback;

interface IMyService {
    void registerCallback(IMyCallback callback);
    void unregisterCallback(IMyCallback callback);
}

// IMyCallback.aidl
package com.example;

interface IMyCallback {
    void onResult(String result);
    void onError(int errorCode);
}
```

### AIDL Method Modifiers

#### One-Way Methods

**oneway Keyword:**
- Asynchronous method calls
- Client doesn't wait for reply
- Fire-and-forget semantics
- No return value allowed

**Syntax:**
```aidl
interface IMyService {
    oneway void notifyEvent(String event);
    oneway void sendMessage(String message);
}
```

**Characteristics:**
- Non-blocking
- No return value
- No exception handling
- Faster for notifications

#### In, Out, Inout Parameters

**Parameter Directions:**
- `in` - Parameter passed from client to server (default)
- `out` - Parameter passed from server to client
- `inout` - Parameter passed both ways

**Usage:**
```aidl
interface IMyService {
    void processData(in String input, out String result);
    void swapValues(inout int a, inout int b);
}
```

**Default Behavior:**
- Parameters are `in` by default
- Primitives are always `in`
- Objects can be `in`, `out`, or `inout`

### AIDL Code Generation

#### Generated Files

**For Interface `IMyService.aidl`:**
- `IMyService.java` - Main interface
- `IMyService.Stub` - Server-side base class
- `IMyService.Stub.Proxy` - Client-side proxy

**Generated Structure:**
```java
// IMyService.java (generated)
public interface IMyService extends android.os.IInterface {
    // Interface methods
    public int add(int a, int b) throws android.os.RemoteException;
    
    // Stub (server-side base class)
    public static abstract class Stub extends android.os.Binder 
            implements IMyService {
        // Transaction handling
        @Override
        public boolean onTransact(int code, Parcel data, Parcel reply, int flags) {
            // Unmarshal parameters, call implementation, marshal reply
        }
        
        // Proxy (client-side)
        private static class Proxy implements IMyService {
            private IBinder mRemote;
            
            @Override
            public int add(int a, int b) throws RemoteException {
                // Marshal parameters, send transaction, unmarshal reply
            }
        }
    }
}
```

#### Stub Class

**What It Is:**
- Abstract base class for server implementation
- Handles transaction routing
- Unmarshals parameters
- Marshals return values

**Usage:**
```java
public class MyService extends IMyService.Stub {
    @Override
    public int add(int a, int b) throws RemoteException {
        return a + b;
    }
    
    @Override
    public String processData(String input) throws RemoteException {
        return "Processed: " + input;
    }
}
```

#### Proxy Class

**What It Is:**
- Client-side proxy implementation
- Marshals parameters
- Sends transactions
- Unmarshals return values

**Usage:**
```java
IBinder binder = ServiceManager.getService("my_service");
IMyService service = IMyService.Stub.asInterface(binder);
int result = service.add(5, 3);
```

### Using AIDL

#### Step 1: Define AIDL File

**Create AIDL File:**
```aidl
// src/main/aidl/com/example/IMyService.aidl
package com.example;

interface IMyService {
    int add(int a, int b);
    String processData(String input);
    void registerCallback(IMyCallback callback);
}
```

#### Step 2: Implement Service (Server Side)

**Extend Stub:**
```java
public class MyService extends IMyService.Stub {
    @Override
    public int add(int a, int b) throws RemoteException {
        return a + b;
    }
    
    @Override
    public String processData(String input) throws RemoteException {
        return "Processed: " + input;
    }
    
    @Override
    public void registerCallback(IMyCallback callback) throws RemoteException {
        // Store callback
    }
}
```

**Register Service:**
```java
MyService service = new MyService();
ServiceManager.addService("my_service", service);
```

#### Step 3: Use Service (Client Side)

**Get Service:**
```java
IBinder binder = ServiceManager.getService("my_service");
IMyService service = IMyService.Stub.asInterface(binder);
```

**Call Methods:**
```java
try {
    int result = service.add(5, 3);
    String processed = service.processData("input");
} catch (RemoteException e) {
    // Handle error
}
```

### Advanced AIDL Features

#### Callbacks

**Callback Pattern:**
```aidl
// IMyService.aidl
interface IMyService {
    void registerCallback(IMyCallback callback);
    void unregisterCallback(IMyCallback callback);
}

// IMyCallback.aidl
interface IMyCallback {
    void onResult(String result);
}
```

**Server Implementation:**
```java
private IMyCallback mCallback;

@Override
public void registerCallback(IMyCallback callback) {
    mCallback = callback;
}

// Later, notify callback
if (mCallback != null) {
    mCallback.onResult("result");
}
```

**Client Implementation:**
```java
IMyCallback callback = new IMyCallback.Stub() {
    @Override
    public void onResult(String result) {
        // Handle result
    }
};

service.registerCallback(callback);
```

#### Parcelable Objects

**Define Parcelable:**
```aidl
// MyData.aidl
package com.example;

parcelable MyData;
```

**Implement Parcelable:**
```java
public class MyData implements Parcelable {
    private String name;
    private int value;
    
    // Parcelable implementation
    protected MyData(Parcel in) {
        name = in.readString();
        value = in.readInt();
    }
    
    @Override
    public void writeToParcel(Parcel dest, int flags) {
        dest.writeString(name);
        dest.writeInt(value);
    }
    
    // ... other Parcelable methods
}
```

**Use in AIDL:**
```aidl
interface IMyService {
    MyData processData(MyData input);
    List<MyData> getDataList();
}
```

### AIDL Best Practices

#### Interface Design

**Clear Naming:**
- Use descriptive interface names
- Follow naming conventions (I prefix)
- Use clear method names
- Document complex methods

**Method Design:**
- Keep methods focused
- Avoid too many parameters
- Use Parcelable for complex data
- Consider oneway for notifications

#### Error Handling

**RemoteException:**
- All AIDL methods can throw RemoteException
- Always handle in client code
- Service death causes RemoteException
- Check for null services

**Example:**
```java
try {
    String result = service.processData(input);
} catch (RemoteException e) {
    // Handle service death or communication error
    Log.e(TAG, "Service error", e);
}
```

#### Performance Considerations

**Minimize IPC Calls:**
- Batch operations when possible
- Use oneway for notifications
- Cache service references
- Avoid frequent small calls

**Data Size:**
- Keep transaction data reasonable
- Use Parcelable efficiently
- Consider ashmem for large data
- Optimize serialization

### AIDL vs Other IPC Methods

#### AIDL vs Manual Binder

**AIDL Advantages:**
- Automatic code generation
- Type safety
- Less error-prone
- Easier to maintain

**Manual Binder:**
- More control
- Custom optimizations
- Lower-level access
- More complex

#### AIDL vs HIDL

**AIDL:**
- Java/Kotlin focused
- Framework services
- App-to-framework IPC
- Modern (Android 11+)

**HIDL:**
- HAL interfaces
- C++ focused
- Vendor interfaces
- Deprecated (replaced by AIDL HAL)

### Common Patterns

#### Service Pattern

**Standard Service:**
```aidl
interface IMyService {
    void doWork(String input);
    String getResult();
}
```

**Implementation:**
```java
public class MyService extends IMyService.Stub {
    // Implementation
}
```

#### Callback Pattern

**Callback Interface:**
```aidl
interface IMyCallback {
    void onEvent(String event);
}
```

**Registration:**
```aidl
interface IMyService {
    void registerCallback(IMyCallback callback);
    void unregisterCallback(IMyCallback callback);
}
```

#### Data Transfer Pattern

**Parcelable Data:**
```aidl
parcelable MyData;

interface IMyService {
    MyData processData(MyData input);
}
```

### Debugging AIDL

#### Common Issues

**Build Errors:**
- Check AIDL file syntax
- Verify package names
- Ensure Parcelable defined
- Check imports

**Runtime Errors:**
- Handle RemoteException
- Check service registration
- Verify service availability
- Review transaction data

**Type Mismatches:**
- Verify AIDL types match Java
- Check Parcelable implementation
- Ensure collections use correct types
- Review parameter directions

## Key Takeaways

1. **AIDL is Android's interface definition language** for defining Binder IPC interfaces with automatic code generation.

2. **AIDL supports primitives, Strings, Collections, Parcelables, and AIDL interfaces** as data types for method parameters and return values.

3. **The build system generates Stub and Proxy classes** automatically, handling transaction marshaling and unmarshaling.

4. **oneway methods provide asynchronous communication** for fire-and-forget operations without return values.

5. **Parcelable objects allow complex data structures** to be passed through Binder by implementing the Parcelable interface.

6. **Callbacks enable bidirectional communication** by passing AIDL interfaces as parameters.

7. **AIDL provides type safety and simplifies IPC development** compared to manual Binder code.

8. **Understanding AIDL is essential** for AOSP development, system service implementation, and app-to-framework communication.

## Related Topics

- **Binder architecture:** How AIDL fits into Binder architecture
- **Binder IPC Basics:** Introduction to using AIDL for IPC
- **Parcelables:** How to implement Parcelable for AIDL
- **ServiceManager:** How services using AIDL are registered and discovered

