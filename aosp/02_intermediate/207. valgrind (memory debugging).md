---
number: 207
title: valgrind (memory debugging)
slug: valgrind-memory-debugging
level: intermediate
tags:
  - aosp
  - valgrind
  - memory-debugging
  - debugging
  - development-tools
  - memory-profiling
prerequisites:
  - android-architecture-complete-overview
  - debugging-native-crashes-tombstones
estimated_minutes: 95
contributors: []
diagrams: []
examples: []
canonical_id: aosp-intermediate-207
---

# valgrind (memory debugging)

## Overview

valgrind is a powerful memory debugging and profiling tool that detects memory leaks, invalid memory access, use of uninitialized memory, and other memory-related errors in native code. Understanding valgrind is essential for AOSP development, as it explains how to debug memory issues, how to detect memory leaks, how to identify invalid memory access, how to profile memory usage, and how valgrind provides comprehensive memory debugging capabilities. This guide provides a comprehensive overview of valgrind, tool usage, memory debugging, leak detection, profiling capabilities, and best practices.

Think of valgrind like a memory detective: just as a detective investigates crimes by examining evidence, tracking suspects, and analyzing patterns, valgrind investigates memory issues by examining memory access, tracking allocations and deallocations, and analyzing memory usage patterns, helping identify memory leaks, invalid accesses, and other memory-related problems.

## Deep Explanation

### What is valgrind?

valgrind is a memory debugging and profiling tool that uses dynamic binary instrumentation to detect memory errors, memory leaks, and performance issues in native code. It provides detailed information about memory usage, allocations, and errors.

**Key Characteristics:**
- **Memory Debugging:** Detects memory errors
- **Leak Detection:** Identifies memory leaks
- **Dynamic Instrumentation:** Uses binary instrumentation
- **Detailed Reports:** Provides detailed error reports
- **Low-Level Analysis:** Analyzes at binary level

**Why valgrind?**
- **Memory Leaks:** Detect memory leaks
- **Invalid Access:** Identify invalid memory access
- **Uninitialized Memory:** Detect use of uninitialized memory
- **Memory Profiling:** Profile memory usage
- **Development Tool:** Essential development tool

### valgrind Architecture

#### Tool Suite

**valgrind Tools:**
- **Memcheck:** Memory error detector (default)
- **Massif:** Heap profiler
- **Helgrind:** Thread error detector
- **Cachegrind:** Cache profiler
- **Callgrind:** Call graph profiler

**Tool Characteristics:**
- Multiple specialized tools
- Memory-focused tools
- Performance tools
- Thread analysis tools
- Comprehensive suite

#### Dynamic Binary Instrumentation

**Instrumentation:**
- Instruments binary code at runtime
- Adds checking code
- Monitors memory operations
- Tracks allocations/deallocations
- Detects errors

**Instrumentation Characteristics:**
- Runtime instrumentation
- Binary-level analysis
- No source code changes needed
- Comprehensive coverage
- Performance overhead

### Memcheck (Memory Error Detector)

#### Basic Usage

**Basic memcheck:**
```bash
# Run with memcheck (default)
valgrind program

# Run with specific tool
valgrind --tool=memcheck program

# Run with options
valgrind --leak-check=full program
```

**Usage Characteristics:**
- Default tool
- Memory error detection
- Leak detection
- Error reporting
- Detailed output

#### Memory Error Detection

**Detected Errors:**
- Invalid memory access
- Use of uninitialized memory
- Memory leaks
- Double free
- Invalid free
- Buffer overflows

**Error Types:**
- **Invalid read/write:** Accessing invalid memory
- **Use of uninitialized values:** Using uninitialized memory
- **Memory leaks:** Allocated memory not freed
- **Double free:** Freeing already freed memory
- **Invalid free:** Freeing invalid pointers

**Error Detection:**
```bash
# Run with full leak check
valgrind --leak-check=full --show-leak-kinds=all program

# Output shows:
# - Invalid memory access
# - Memory leaks
# - Uninitialized values
# - Error locations
```

**Detection Characteristics:**
- Comprehensive error detection
- Detailed error reports
- Source location information
- Stack traces
- Error classification

#### Leak Detection

**Leak Types:**
- **Definitely lost:** Memory definitely leaked
- **Indirectly lost:** Memory lost through pointer chain
- **Possibly lost:** Memory possibly leaked
- **Still reachable:** Memory still accessible

**Leak Detection:**
```bash
# Full leak check
valgrind --leak-check=full program

# Show all leak kinds
valgrind --leak-check=full --show-leak-kinds=all program

# Show reachable blocks
valgrind --leak-check=full --show-reachable=yes program
```

**Leak Characteristics:**
- Leak classification
- Leak location
- Leak size
- Leak stack trace
- Leak summary

### Massif (Heap Profiler)

#### Heap Profiling

**Massif Usage:**
```bash
# Profile heap usage
valgrind --tool=massif program

# Profile with options
valgrind --tool=massif --massif-out-file=massif.out program
```

**Profiling Characteristics:**
- Heap snapshot collection
- Time-based snapshots
- Peak detection
- Memory growth analysis
- Detailed reports

#### Heap Analysis

**Analysis Output:**
```
n        time(i)         total(B)   useful-heap(B) extra-heap(B)    stacks(B)
--------------------------------------------------------------------------------
 0              0                0                0             0            0
 1        100,000           65,536           65,536             0            0
 2        200,000          131,072          131,072             0            0
```

**Analysis Features:**
- Heap size over time
- Peak heap usage
- Memory growth patterns
- Allocation sites
- Time-based analysis

### Using valgrind on Android

#### Building valgrind for Android

**Building valgrind:**
```bash
# valgrind can be built for Android
# Requires cross-compilation
# Or use pre-built binaries
```

**Installation:**
```bash
# Push to device
adb push valgrind /data/local/tmp/

# Make executable
adb shell chmod 755 /data/local/tmp/valgrind

# Verify installation
adb shell /data/local/tmp/valgrind --version
```

**Installation Characteristics:**
- Cross-compilation required
- Device deployment
- Permission setup
- Tool verification
- Availability

#### Debugging Android Native Code

**Debugging Workflow:**
```bash
# 1. Get process or binary
# Native binary or process

# 2. Run with valgrind
adb shell valgrind --tool=memcheck --leak-check=full /path/to/binary

# 3. Analyze output
# Review valgrind output for errors

# 4. Fix issues
# Address detected memory issues
```

**Workflow Characteristics:**
- Process/binary identification
- Remote debugging
- Output analysis
- Issue fixing
- Verification

### valgrind Options

#### Common Options

**Memory Options:**
```bash
# Leak check level
--leak-check=no|summary|yes|full

# Show leak kinds
--show-leak-kinds=kind1,kind2

# Track origins
--track-origins=yes

# Error limit
--error-limit=yes|no

# Suppressions file
--suppressions=file.supp
```

**Output Options:**
```bash
# Verbose output
--verbose

# Quiet mode
--quiet

# Log file
--log-file=filename

# XML output
--xml=yes
```

**Performance Options:**
```bash
# Reduce overhead
--tool=memcheck --track-origins=no

# Profile specific functions
--tool=callgrind

# Cache profiling
--tool=cachegrind
```

**Option Characteristics:**
- Memory checking control
- Output formatting
- Performance tuning
- Error filtering
- Customization

### Debugging Workflows

#### Memory Leak Debugging

**Leak Debugging:**
```
1. Run program with valgrind
2. Identify leaks in output
3. Analyze leak stack traces
4. Find allocation sites
5. Fix leaks
6. Verify fix
```

**Workflow Steps:**
```bash
# 1. Run with full leak check
valgrind --leak-check=full --show-leak-kinds=all program

# 2. Analyze output
# Look for "definitely lost" or "indirectly lost"

# 3. Find allocation sites
# Stack traces show where memory was allocated

# 4. Fix leaks
# Add appropriate free() calls

# 5. Verify
valgrind --leak-check=full program
```

**Workflow Characteristics:**
- Leak identification
- Stack trace analysis
- Allocation site finding
- Leak fixing
- Verification

#### Invalid Memory Access Debugging

**Access Debugging:**
```
1. Run program with valgrind
2. Identify invalid access errors
3. Analyze error stack traces
4. Find problematic code
5. Fix invalid access
6. Verify fix
```

**Workflow Steps:**
```bash
# 1. Run with memcheck
valgrind --tool=memcheck program

# 2. Identify errors
# Look for "Invalid read" or "Invalid write"

# 3. Analyze stack traces
# Stack traces show where error occurred

# 4. Fix issues
# Correct memory access

# 5. Verify
valgrind --tool=memcheck program
```

**Workflow Characteristics:**
- Error identification
- Stack trace analysis
- Problem location
- Issue fixing
- Verification

### Advanced Techniques

#### Suppressions

**Suppression Files:**
```bash
# Create suppression file
valgrind --gen-suppressions=all program > suppressions.supp

# Use suppressions
valgrind --suppressions=suppressions.supp program
```

**Suppression Format:**
```
{
   <suppression_name>
   Memcheck:Leak
   ...
   fun:function_name
}
```

**Suppression Characteristics:**
- Error filtering
- Known issue suppression
- Custom suppressions
- File-based configuration
- Selective suppression

#### Integration with Build System

**Build Integration:**
```bash
# Run during build
make test VALGRIND=valgrind

# CI/CD integration
valgrind --tool=memcheck --error-exitcode=1 test_suite
```

**Integration Characteristics:**
- Build system integration
- Automated testing
- CI/CD support
- Error exit codes
- Automated validation

### Best Practices

#### Best Practices

**Best Practices:**
- Use full leak checking
- Enable origin tracking
- Save output to files
- Use suppressions for known issues
- Verify fixes

**Practice Guidelines:**
- **Leak Checking:** Use full leak checking
- **Origin Tracking:** Enable origin tracking for uninitialized values
- **Output:** Save output to files for analysis
- **Suppressions:** Use suppressions for known issues
- **Verification:** Always verify fixes

#### Common Use Cases

**Common Use Cases:**
- Memory leak detection
- Invalid memory access debugging
- Uninitialized memory detection
- Heap profiling
- Memory optimization

**Use Case Examples:**
- Native library debugging
- System service debugging
- HAL debugging
- Performance optimization
- Memory issue resolution

## Key Takeaways

1. **valgrind** is a powerful memory debugging and profiling tool that uses dynamic binary instrumentation to detect memory errors, memory leaks, and performance issues in native code, providing detailed information about memory usage, allocations, and errors.

2. **valgrind architecture** includes tool suite (Memcheck - memory error detector, Massif - heap profiler, Helgrind - thread error detector, Cachegrind - cache profiler, Callgrind - call graph profiler), dynamic binary instrumentation (instruments binary code at runtime, adds checking code, monitors memory operations, tracks allocations/deallocations, detects errors), and architecture characteristics.

3. **Memcheck (memory error detector)** includes basic usage (default tool, memory error detection, leak detection, error reporting, detailed output), memory error detection (invalid memory access, use of uninitialized memory, memory leaks, double free, invalid free, buffer overflows), leak detection (leak classification, leak location, leak size, leak stack trace, leak summary), and memcheck characteristics.

4. **Massif (heap profiler)** includes heap profiling (heap snapshot collection, time-based snapshots, peak detection, memory growth analysis, detailed reports), heap analysis (heap size over time, peak heap usage, memory growth patterns, allocation sites, time-based analysis), and profiler characteristics.

5. **Using valgrind on Android** includes building valgrind for Android (cross-compilation required, device deployment, permission setup, tool verification, availability), debugging Android native code (process/binary identification, remote debugging, output analysis, issue fixing, verification), and Android usage characteristics.

6. **valgrind options** include common options (memory options - leak check level, show leak kinds, track origins, error limit, suppressions file; output options - verbose output, quiet mode, log file, XML output; performance options - reduce overhead, profile specific functions, cache profiling), and option characteristics.

7. **Debugging workflows** include memory leak debugging (leak identification, stack trace analysis, allocation site finding, leak fixing, verification), invalid memory access debugging (error identification, stack trace analysis, problem location, issue fixing, verification), and workflow characteristics.

8. **Advanced techniques** include suppressions (error filtering, known issue suppression, custom suppressions, file-based configuration, selective suppression), integration with build system (build system integration, automated testing, CI/CD support, error exit codes, automated validation), and advanced characteristics.

9. **Best practices** include best practices (use full leak checking, enable origin tracking, save output to files, use suppressions for known issues, verify fixes), common use cases (memory leak detection, invalid memory access debugging, uninitialized memory detection, heap profiling, memory optimization), and practice guidelines.

10. **Understanding valgrind** is essential for AOSP development, enabling memory debugging, leak detection, invalid access identification, memory profiling, native code debugging, and proper memory debugging tool usage.

## Related Topics

- **Android Architecture - Complete Overview:** Architecture details
- **Debugging native crashes (tombstones):** Native crash debugging details

