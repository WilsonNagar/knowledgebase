---
number: 195
title: Implementing new display pipeline modifications
slug: implementing-new-display-pipeline-modifications
level: intermediate
tags:
  - aosp
  - graphics
  - display-pipeline
  - surfaceflinger
  - hwc
  - graphics-modification
prerequisites:
  - surfaceflinger-composition-engine
  - surfaceflinger-hwc-interactions
  - gpu-composition
  - hwui
estimated_minutes: 95
contributors: []
diagrams: []
examples: []
canonical_id: aosp-intermediate-195
---

# Implementing new display pipeline modifications

## Overview

Implementing new display pipeline modifications refers to the process of extending and customizing the Android display pipeline, including SurfaceFlinger, Hardware Composer (HWC), and related graphics components to add new features, optimize performance, or adapt to specific hardware requirements. Understanding how to implement new display pipeline modifications is essential for AOSP development, as it enables custom graphics features, hardware-specific optimizations, performance improvements, and display pipeline customization. This guide provides a comprehensive overview of implementing new display pipeline modifications, modification approaches, SurfaceFlinger customization, HWC integration, framework integration, and best practices.

Think of implementing new display pipeline modifications like customizing a video production pipeline: just as you might add new video effects, optimize rendering for specific hardware, or customize the output format in a video production pipeline, implementing new display pipeline modifications allows you to add new graphics features, optimize for specific hardware, and customize how frames are composited and displayed.

## Deep Explanation

### What is Implementing New Display Pipeline Modifications?

Implementing new display pipeline modifications refers to the process of extending and customizing the Android display pipeline, including SurfaceFlinger, Hardware Composer (HWC), and related graphics components to add new features, optimize performance, or adapt to specific hardware requirements.

**Key Characteristics:**
- **Pipeline Extension:** Extend display pipeline functionality
- **Feature Addition:** Add new graphics features
- **Performance Optimization:** Optimize pipeline performance
- **Hardware Adaptation:** Adapt to specific hardware
- **System Integration:** Integrate with system

**Why Implement Display Pipeline Modifications?**
- **Custom Features:** Add custom graphics features
- **Hardware Optimization:** Optimize for specific hardware
- **Performance:** Improve rendering performance
- **Device Requirements:** Meet device-specific requirements
- **System Customization:** Customize display behavior

### Modification Approaches

#### SurfaceFlinger Customization

**SurfaceFlinger Customization:**
- Extend SurfaceFlinger functionality
- Add custom composition modes
- Modify layer handling
- Customize VSync behavior
- Add new rendering features

**Customization Example:**
```cpp
// Custom SurfaceFlinger
class CustomSurfaceFlinger : public SurfaceFlinger {
public:
    CustomSurfaceFlinger();
    ~CustomSurfaceFlinger();
    
    // Override composition
    void onMessageReceived(int32_t what, int nsecs) override {
        // Custom pre-composition
        customPreComposition();
        
        // Call parent
        SurfaceFlinger::onMessageReceived(what, nsecs);
        
        // Custom post-composition
        customPostComposition();
    }
    
    // Custom composition method
    void customComposition() {
        // Custom composition logic
        // Add custom effects
        // Optimize for hardware
    }
    
private:
    void customPreComposition();
    void customPostComposition();
};
```

**Customization Characteristics:**
- Service extension
- Method overriding
- Custom functionality
- Framework integration
- Compatibility maintenance

#### Layer Modification

**Layer Modification:**
- Extend layer functionality
- Add custom layer types
- Modify layer composition
- Customize layer effects
- Optimize layer handling

**Modification Example:**
```cpp
// Custom layer
class CustomLayer : public Layer {
public:
    CustomLayer(const sp<SurfaceFlinger>& flinger, const String8& name);
    ~CustomLayer();
    
    // Override composition
    void onDraw(const sp<const DisplayDevice>& hw,
                const Region& clip, bool useIdentityTransform) override {
        // Custom pre-draw
        customPreDraw();
        
        // Call parent
        Layer::onDraw(hw, clip, useIdentityTransform);
        
        // Custom post-draw
        customPostDraw();
    }
    
    // Custom layer effects
    void applyCustomEffects() {
        // Apply custom effects
        // Hardware-specific optimizations
    }
    
private:
    void customPreDraw();
    void customPostDraw();
};
```

**Modification Characteristics:**
- Layer extension
- Composition customization
- Effect addition
- Hardware optimization
- System integration

### HWC Integration

#### HWC Customization

**HWC Customization:**
- Extend HWC functionality
- Add custom HWC features
- Modify composition selection
- Optimize HWC usage
- Hardware-specific optimizations

**Customization Example:**
```cpp
// Custom HWC integration
class CustomHWComposer : public HWComposer {
public:
    CustomHWComposer(std::unique_ptr<Hwc2::Composer> composer);
    ~CustomHWComposer();
    
    // Override validate
    status_t validateDisplay(DisplayId displayId,
                             uint32_t* outNumTypes,
                             uint32_t* outNumRequests) override {
        // Custom validation
        customPreValidate(displayId);
        
        // Call parent
        status_t result = HWComposer::validateDisplay(
            displayId, outNumTypes, outNumRequests);
        
        // Custom post-validation
        customPostValidate(displayId, result);
        
        return result;
    }
    
    // Custom HWC features
    void enableCustomFeature(bool enable) {
        // Enable custom HWC feature
        mCustomFeatureEnabled = enable;
    }
    
private:
    bool mCustomFeatureEnabled;
    void customPreValidate(DisplayId displayId);
    void customPostValidate(DisplayId displayId, status_t result);
};
```

**Customization Characteristics:**
- HWC extension
- Feature addition
- Validation customization
- Hardware optimization
- System integration

#### Composition Mode Selection

**Composition Mode Selection:**
- Customize composition mode selection
- Optimize HWC/GPU choice
- Add custom selection logic
- Hardware-specific selection
- Performance-based selection

**Selection Example:**
```cpp
// Custom composition mode selection
CompositionType selectCompositionMode(Layer* layer) {
    // Custom selection logic
    if (mCustomPolicy.shouldUseHWC(layer)) {
        return CompositionType::HWC;
    } else if (mCustomPolicy.shouldUseGPU(layer)) {
        return CompositionType::GPU;
    } else {
        // Default selection
        return defaultCompositionMode(layer);
    }
}

bool shouldUseHWC(Layer* layer) {
    // Custom HWC selection criteria
    // Hardware capabilities
    // Layer complexity
    // Performance requirements
    return checkHWCCapabilities(layer);
}
```

**Selection Characteristics:**
- Mode customization
- Policy-based selection
- Hardware consideration
- Performance optimization
- System integration

### Framework Integration

#### DisplayManager Integration

**DisplayManager Integration:**
- Integrate with DisplayManagerService
- Expose custom display features
- Handle display configuration
- Support custom display modes
- Coordinate with framework

**Integration Example:**
```java
// Custom DisplayManager integration
public class CustomDisplayManagerService extends DisplayManagerService {
    private CustomDisplayFeature mCustomFeature;
    
    @Override
    public void systemReady() {
        super.systemReady();
        // Initialize custom feature
        mCustomFeature = new CustomDisplayFeature();
        mCustomFeature.initialize();
    }
    
    @Override
    public void setDisplayMode(int displayId, DisplayMode mode) {
        // Custom pre-processing
        mCustomFeature.onPreSetDisplayMode(displayId, mode);
        
        // Call parent
        super.setDisplayMode(displayId, mode);
        
        // Custom post-processing
        mCustomFeature.onPostSetDisplayMode(displayId, mode);
    }
}
```

**Integration Characteristics:**
- Service integration
- Feature exposure
- Configuration handling
- Framework coordination
- System integration

#### WindowManager Integration

**WindowManager Integration:**
- Coordinate with WindowManagerService
- Handle window surface creation
- Support custom window types
- Integrate with window management
- System-wide coordination

**Integration Example:**
```java
// WindowManager integration
public class CustomWindowManagerService extends WindowManagerService {
    @Override
    public SurfaceControl createSurface(Session session, String name,
                                       int width, int height, int format,
                                       int flags, SurfaceControl parent,
                                       int windowType, int ownerUid) {
        // Custom surface creation
        SurfaceControl surface = super.createSurface(
            session, name, width, height, format, flags, parent,
            windowType, ownerUid);
        
        // Apply custom modifications
        applyCustomSurfaceModifications(surface);
        
        return surface;
    }
    
    private void applyCustomSurfaceModifications(SurfaceControl surface) {
        // Custom surface configuration
        // Hardware-specific settings
        // Performance optimizations
    }
}
```

**Integration Characteristics:**
- Service coordination
- Surface management
- Window type support
- System integration
- Framework compatibility

### Build System Integration

#### Native Build Integration

**Native Build:**
- Integrate with Android.bp
- Configure native compilation
- Link with graphics libraries
- Include custom sources
- Build system configuration

**Build Configuration:**
```python
# Android.bp
cc_library_shared {
    name: "libsurfaceflinger_custom",
    srcs: [
        "CustomSurfaceFlinger.cpp",
        "CustomLayer.cpp",
        "CustomHWComposer.cpp",
    ],
    shared_libs: [
        "libsurfaceflinger",
        "libgui",
        "libui",
        "libutils",
        "liblog",
    ],
    cflags: [
        "-Wall",
        "-Werror",
    ],
}
```

**Build Characteristics:**
- Build system integration
- Native compilation
- Library linking
- Source inclusion
- Configuration management

#### Service Integration

**Service Integration:**
- Configure service binary
- Set up service initialization
- Configure service properties
- System integration
- Service lifecycle

**Service Configuration:**
```init
# In init.rc
service surfaceflinger /system/bin/surfaceflinger
    class core
    user system
    group graphics drmrpc
    onrestart restart zygote
    writepid /dev/cpuset/system-background/tasks
```

**Service Characteristics:**
- Service definition
- Lifecycle management
- Resource configuration
- System integration
- Service properties

### Best Practices

#### Best Practices

**Best Practices:**
- Understand display pipeline architecture
- Test thoroughly
- Optimize for performance
- Document changes
- Maintain compatibility

**Practice Guidelines:**
- **Architecture:** Understand display pipeline architecture
- **Testing:** Test thoroughly
- **Performance:** Optimize for performance
- **Documentation:** Document changes
- **Compatibility:** Maintain compatibility

#### Common Modifications

**Common Modifications:**
- Custom composition modes
- Hardware-specific optimizations
- Performance improvements
- Feature additions
- Display mode support

**Modification Examples:**
- Custom blending modes
- Hardware composition optimization
- Frame rate control
- Display color management
- Multi-display support

## Key Takeaways

1. **Implementing new display pipeline modifications** refers to the process of extending and customizing the Android display pipeline, including SurfaceFlinger, Hardware Composer (HWC), and related graphics components to add new features, optimize performance, or adapt to specific hardware requirements.

2. **Modification approaches** include SurfaceFlinger customization (extend SurfaceFlinger functionality, add custom composition modes, modify layer handling, customize VSync behavior, add new rendering features), layer modification (extend layer functionality, add custom layer types, modify layer composition, customize layer effects, optimize layer handling), and approach characteristics.

3. **HWC integration** includes HWC customization (extend HWC functionality, add custom HWC features, modify composition selection, optimize HWC usage, hardware-specific optimizations), composition mode selection (customize composition mode selection, optimize HWC/GPU choice, add custom selection logic, hardware-specific selection, performance-based selection), and integration characteristics.

4. **Framework integration** includes DisplayManager integration (integrate with DisplayManagerService, expose custom display features, handle display configuration, support custom display modes, coordinate with framework), WindowManager integration (coordinate with WindowManagerService, handle window surface creation, support custom window types, integrate with window management, system-wide coordination), and integration characteristics.

5. **Build system integration** includes native build integration (integrate with Android.bp, configure native compilation, link with graphics libraries, include custom sources, build system configuration), service integration (configure service binary, set up service initialization, configure service properties, system integration, service lifecycle), and integration characteristics.

6. **Best practices** include best practices (understand display pipeline architecture, test thoroughly, optimize for performance, document changes, maintain compatibility), common modifications (custom composition modes, hardware-specific optimizations, performance improvements, feature additions, display mode support), and practice guidelines.

7. **Understanding how to implement new display pipeline modifications** is essential for AOSP development, enabling custom graphics features, hardware-specific optimizations, performance improvements, display pipeline customization, and proper display pipeline modification implementation.

## Related Topics

- **SurfaceFlinger (composition engine):** SurfaceFlinger details
- **SurfaceFlinger + HWC interactions:** HWC interactions details
- **GPU composition:** GPU composition details
- **HWUI:** HWUI details

