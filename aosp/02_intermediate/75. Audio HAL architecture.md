---
number: 75
title: Audio HAL architecture
slug: audio-hal-architecture
level: intermediate
tags:
  - aosp
  - audio
  - hal
  - audio-hal
  - audio-routing
  - audio-streams
  - audio-effects
prerequisites:
  - creating-your-own-hal
  - aidl-based-hals
  - android-architecture-complete-overview
estimated_minutes: 95
contributors: []
diagrams: []
examples: []
canonical_id: aosp-intermediate-75
---

# Audio HAL architecture

## Overview

Audio HAL architecture is the complete system for managing audio input and output in Android, including audio routing, stream management, audio effects, and hardware abstraction. Understanding Audio HAL architecture is essential for AOSP development, as it enables audio functionality, manages audio routing, handles multiple audio streams, supports audio effects, and provides standardized audio interfaces to the framework. This guide provides a comprehensive overview of Audio HAL architecture, audio routing, stream management, audio effects, and how audio flows through the system.

Think of Audio HAL architecture like an audio mixing console: just as a mixing console manages multiple audio inputs, routes them to outputs, applies effects, and controls volume levels, Audio HAL manages multiple audio streams, routes them to audio devices, applies audio effects, and controls audio parameters. The HAL abstracts the hardware complexity and provides a standardized interface for audio management.

## Deep Explanation

### What is Audio HAL Architecture?

Audio HAL architecture is the complete system for audio management in Android, including the Hardware Abstraction Layer that interfaces with audio hardware, audio routing mechanisms, stream management, and audio effects processing.

**Key Characteristics:**
- **Hardware Abstraction:** Abstracts audio hardware
- **Audio Routing:** Routes audio to/from devices
- **Stream Management:** Manages multiple audio streams
- **Audio Effects:** Supports audio processing

**Why Audio HAL Architecture?**
- **Audio Functionality:** Enables audio I/O
- **Hardware Independence:** Framework doesn't need hardware details
- **Vendor Flexibility:** Vendors implement hardware-specific code
- **Standardization:** Consistent audio API

### Audio HAL Architecture Overview

#### Architecture Layers

**Complete Stack:**
```
Applications
     │
     │ Audio API
     │
     ▼
Audio Framework
     │
     │ Audio Service
     │
     ▼
Audio HAL
     │
     │ Audio Routing
     │
     ▼
Audio Hardware
     │
     │ Audio Codec
     │
     ▼
Audio Devices
```

#### Audio HAL Components

**Core Components:**
- **Audio HAL Interface:** Standard interface
- **Audio Routing:** Device routing
- **Stream Management:** Multiple streams
- **Audio Effects:** Processing effects
- **Hardware Interface:** Hardware access

### Audio HAL Interface

#### AIDL Audio HAL

**Interface Definition:**
```aidl
package android.hardware.audio.core@7.0;

@VintfStability
interface IStream {
    Return<void> getBufferSizeBytes(out int32_t size);
    Return<void> getFrameCount(out int32_t count);
    Return<void> getSampleRate(out int32_t rate);
    Return<void> setSampleRate(int32_t rate);
    Return<void> getChannelMask(out AudioChannelMask mask);
    Return<void> setChannelMask(AudioChannelMask mask);
    Return<void> getFormat(out AudioFormat format);
    Return<void> setFormat(AudioFormat format);
    Return<void> write(in byte[] buffer, out int32_t written);
    Return<void> read(out byte[] buffer, out int32_t read);
}
```

**Key Methods:**
- `getBufferSizeBytes()`: Get buffer size
- `getFrameCount()`: Get frame count
- `getSampleRate()`: Get sample rate
- `setSampleRate()`: Set sample rate
- `write()`: Write audio data
- `read()`: Read audio data

#### Audio Device Interface

**Device Interface:**
```aidl
@VintfStability
interface IDevice {
    Return<void> getAudioPorts(out AudioPort[] ports);
    Return<void> getAudioRoutes(out AudioRoute[] routes);
    Return<void> setAudioPortConfig(in AudioPortConfig config);
    Return<void> setAudioRoute(in AudioRoute route);
}
```

**Key Methods:**
- `getAudioPorts()`: List audio ports
- `getAudioRoutes()`: List audio routes
- `setAudioPortConfig()`: Configure port
- `setAudioRoute()`: Set routing

### Audio Routing

#### Routing Architecture

**Routing Flow:**
```
Audio Source
     │
     │ Audio Stream
     │
     ▼
Audio HAL
     │
     │ Route Selection
     │
     ▼
Audio Device
     │
     │ Audio Output
     │
     ▼
Speaker/Headphones/etc.
```

#### Audio Devices

**Output Devices:**
- **Speaker:** Built-in speaker
- **Headphones:** Wired headphones
- **Bluetooth:** Bluetooth audio
- **USB:** USB audio devices
- **HDMI:** HDMI audio

**Input Devices:**
- **Microphone:** Built-in mic
- **Headset Mic:** Headset microphone
- **Bluetooth Mic:** Bluetooth input
- **USB Mic:** USB microphone

#### Routing Logic

**Route Selection:**
```
1. Audio source requests route
   ↓
2. Audio HAL checks available devices
   ↓
3. HAL selects appropriate device
   ↓
4. HAL configures routing
   ↓
5. Audio routed to device
```

**Routing Rules:**
- Priority-based selection
- Device availability
- User preferences
- System policies

### Audio Stream Management

#### Stream Types

**Audio Stream Types:**
- **MUSIC:** Music playback
- **RING:** Ringtone
- **NOTIFICATION:** Notifications
- **ALARM:** Alarms
- **VOICE_CALL:** Phone calls
- **SYSTEM:** System sounds

#### Stream Attributes

**Stream Attributes:**
```cpp
struct AudioAttributes {
    AudioUsage usage;        // How audio is used
    AudioContentType contentType;  // Content type
    AudioFlags flags;       // Stream flags
    AudioSource source;     // Input source
};
```

**Usage Types:**
- MEDIA
- VOICE_COMMUNICATION
- ALARM
- NOTIFICATION
- RINGTONE

#### Stream Management

**Multiple Streams:**
- Multiple streams active simultaneously
- Stream mixing
- Priority handling
- Volume control per stream

**Stream Mixing:**
```
Stream 1 (Music)
     │
     ├─┐
     │ │ Mix
Stream 2 (Notification) ──┤ │───▶ Output
     │ │
     └─┘
Stream 3 (System)
```

### Audio Effects

#### Effect Architecture

**Effect Pipeline:**
```
Audio Input
     │
     ▼
Effect 1 (EQ)
     │
     ▼
Effect 2 (Reverb)
     │
     ▼
Effect 3 (Compression)
     │
     ▼
Audio Output
```

#### Effect Types

**Common Effects:**
- **Equalizer (EQ):** Frequency adjustment
- **Reverb:** Room simulation
- **Compression:** Dynamic range
- **Noise Suppression:** Noise reduction
- **Echo Cancellation:** Echo removal

#### Effect Processing

**Effect Chain:**
- Effects applied in sequence
- Each effect processes audio
- Effects can be enabled/disabled
- Effect parameters configurable

### Audio HAL Implementation

#### HAL Service Structure

**Service Implementation:**
```cpp
class AudioStream : public BnStream {
public:
    ::ndk::ScopedAStatus getBufferSizeBytes(
            int32_t* _aidl_return) override;
    ::ndk::ScopedAStatus getSampleRate(
            int32_t* _aidl_return) override;
    ::ndk::ScopedAStatus setSampleRate(
            int32_t rate) override;
    ::ndk::ScopedAStatus write(
            const std::vector<uint8_t>& buffer,
            int32_t* _aidl_return) override;
    ::ndk::ScopedAStatus read(
            std::vector<uint8_t>* _aidl_return,
            int32_t* _aidl_return) override;

private:
    // Audio hardware interface
    int openAudioDevice();
    int configureAudioDevice();
    int writeAudioData(const void* data, size_t size);
    int readAudioData(void* data, size_t size);
    void closeAudioDevice();
    
    // Stream state
    int32_t mSampleRate;
    AudioFormat mFormat;
    AudioChannelMask mChannelMask;
    int mAudioFd;
};
```

#### Hardware Interface

**Open Audio Device:**
```cpp
int AudioStream::openAudioDevice() {
    // Open audio device
    mAudioFd = open("/dev/snd/pcmC0D0p", O_RDWR);
    if (mAudioFd < 0) {
        return -1;
    }
    
    // Configure audio parameters
    struct snd_pcm_hw_params params;
    snd_pcm_hw_params_any(mAudioFd, &params);
    snd_pcm_hw_params_set_rate(mAudioFd, &params, mSampleRate, 0);
    snd_pcm_hw_params_set_channels(mAudioFd, &params, getChannelCount());
    snd_pcm_hw_params_set_format(mAudioFd, &params, convertFormat(mFormat));
    
    snd_pcm_hw_params(mAudioFd, &params);
    
    return 0;
}
```

**Write Audio Data:**
```cpp
int AudioStream::writeAudioData(const void* data, size_t size) {
    // Write to audio hardware
    ssize_t written = write(mAudioFd, data, size);
    if (written < 0) {
        return -1;
    }
    return written;
}
```

**Read Audio Data:**
```cpp
int AudioStream::readAudioData(void* data, size_t size) {
    // Read from audio hardware
    ssize_t read_bytes = read(mAudioFd, data, size);
    if (read_bytes < 0) {
        return -1;
    }
    return read_bytes;
}
```

### Audio Routing Implementation

#### Route Selection

**Select Route:**
```cpp
AudioRoute AudioHAL::selectRoute(
        const AudioAttributes& attributes) {
    // Determine routing based on attributes
    if (attributes.usage == VOICE_COMMUNICATION) {
        // Route to headset if available
        if (isHeadsetConnected()) {
            return AudioRoute::HEADSET;
        }
    }
    
    // Default routing
    return AudioRoute::SPEAKER;
}
```

**Configure Route:**
```cpp
int AudioHAL::configureRoute(const AudioRoute& route) {
    // Configure audio routing
    switch (route) {
        case AudioRoute::SPEAKER:
            setOutputDevice(OUTPUT_DEVICE_SPEAKER);
            break;
        case AudioRoute::HEADSET:
            setOutputDevice(OUTPUT_DEVICE_HEADPHONES);
            break;
        case AudioRoute::BLUETOOTH:
            setOutputDevice(OUTPUT_DEVICE_BLUETOOTH);
            break;
    }
    return 0;
}
```

### Audio Format and Configuration

#### Audio Formats

**Supported Formats:**
- **PCM_16_BIT:** 16-bit PCM
- **PCM_24_BIT:** 24-bit PCM
- **PCM_32_BIT:** 32-bit PCM
- **PCM_FLOAT:** Float PCM
- **MP3:** MP3 compressed
- **AAC:** AAC compressed

#### Sample Rates

**Common Sample Rates:**
- 8000 Hz (telephony)
- 16000 Hz (wideband)
- 44100 Hz (CD quality)
- 48000 Hz (professional)
- 96000 Hz (high-res)

#### Channel Configurations

**Channel Masks:**
- **MONO:** Single channel
- **STEREO:** Two channels (L/R)
- **5.1:** Surround sound
- **7.1:** Extended surround

### Audio Performance

#### Latency Management

**Low Latency:**
- Minimize buffer sizes
- Fast processing
- Efficient routing
- Hardware acceleration

**Buffer Management:**
- Appropriate buffer sizes
- Prevent underruns
- Minimize latency
- Balance performance

#### Power Management

**Power Optimization:**
- Deactivate unused devices
- Reduce processing when idle
- Efficient codec usage
- Power-aware routing

### Audio Best Practices

#### Implementation

**Error Handling:**
- Handle device disconnection
- Manage routing failures
- Handle format mismatches
- Return appropriate errors

**Resource Management:**
- Manage audio devices properly
- Release resources on close
- Handle multiple streams
- Clean up on errors

#### Performance

**Optimization:**
- Use hardware acceleration
- Minimize data copying
- Efficient processing
- Optimize routing

### Audio Debugging

#### Common Issues

**No Audio Output:**
- Check device routing
- Verify device connection
- Review audio configuration
- Check hardware

**Audio Distortion:**
- Check sample rate
- Verify format
- Review buffer sizes
- Check hardware settings

#### Debugging Tools

**Audio Testing:**
```bash
# Test audio
adb shell audio_test

# Check audio service
adb shell dumpsys audio
```

**Logging:**
```cpp
ALOGD("Audio stream opened: rate=%d, format=%d", 
      mSampleRate, mFormat);
ALOGD("Audio routed to: %s", routeToString(route));
ALOGD("Audio data written: %d bytes", written);
```

## Key Takeaways

1. **Audio HAL architecture** provides complete audio management including hardware abstraction, routing, stream management, and audio effects.

2. **Audio routing** manages audio flow from sources to output devices, handling device selection and configuration.

3. **Stream management** handles multiple audio streams simultaneously with mixing, priority, and per-stream volume control.

4. **Audio effects** provide processing capabilities including EQ, reverb, compression, and noise suppression in an effect chain.

5. **Audio HAL interface** includes methods for stream configuration, audio I/O, format management, and device routing.

6. **Audio formats** support various PCM formats and compressed formats with different sample rates and channel configurations.

7. **Performance optimization** focuses on latency management, buffer management, and power efficiency for optimal audio experience.

8. **Understanding Audio HAL architecture** is essential for implementing audio functionality, managing audio routing, and providing audio capabilities to Android applications in AOSP.

## Related Topics

- **Creating your own HAL:** Complete HAL development workflow
- **AIDL-based HALs:** Modern HAL implementation approach
- **Android Architecture - Complete Overview:** How Audio HAL fits into overall architecture
- **Bluetooth HAL:** Audio routing for Bluetooth devices

