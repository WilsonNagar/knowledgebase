---
number: 194
title: Profiling system performance at kernel→framework level
slug: profiling-system-performance-kernel-framework-level
level: overachiever
tags:
  - aosp
  - profiling
  - performance
  - kernel
  - framework
  - system-profiling
  - perfetto
  - ftrace
prerequisites:
  - systrace-perfetto
  - ftrace
  - atrace
  - binder-tracing
  - power-management
estimated_minutes: 95
contributors: []
diagrams: []
examples: []
canonical_id: aosp-overachiever-194
---

# Profiling system performance at kernel→framework level

## Overview

Profiling system performance at kernel→framework level refers to the process of analyzing and measuring system performance across the entire software stack, from kernel-level operations through framework services to application behavior. Understanding how to profile system performance at kernel→framework level is essential for AOSP development, as it enables performance analysis, bottleneck identification, system optimization, and comprehensive performance debugging. This guide provides a comprehensive overview of profiling system performance at kernel→framework level, profiling tools, kernel profiling, framework profiling, cross-layer analysis, and best practices.

Think of profiling system performance at kernel→framework level like using a comprehensive diagnostic system for a complex machine: just as you might use multiple diagnostic tools (pressure gauges, temperature sensors, flow meters, vibration analyzers) to understand how different parts of a machine work together, profiling at kernel→framework level uses multiple tools (ftrace, perfetto, systrace, perf) to understand how the kernel, framework, and applications work together to identify performance issues across the entire system stack.

## Deep Explanation

### What is Profiling System Performance at Kernel→Framework Level?

Profiling system performance at kernel→framework level refers to the process of analyzing and measuring system performance across the entire software stack, from kernel-level operations through framework services to application behavior.

**Key Characteristics:**
- **Cross-Layer Analysis:** Analyze across kernel and framework
- **Comprehensive:** Complete system view
- **Performance Measurement:** Measure performance metrics
- **Bottleneck Identification:** Identify bottlenecks
- **System Optimization:** Guide system optimization

**Why Profile at Kernel→Framework Level?**
- **Complete Picture:** Understand complete system behavior
- **Bottleneck Identification:** Identify bottlenecks across layers
- **Performance Optimization:** Optimize system performance
- **Debugging:** Debug performance issues
- **System Understanding:** Understand system behavior

### Profiling Tools

#### Kernel Profiling Tools

**Kernel Tools:**
- **ftrace:** Function tracing
- **perf:** Performance analysis
- **eBPF:** Extended Berkeley Packet Filter
- **trace-cmd:** Command-line tracing
- **perfetto:** Unified tracing

**Tool Selection:**
- **ftrace:** Function-level tracing
- **perf:** Hardware event profiling
- **eBPF:** Custom kernel instrumentation
- **trace-cmd:** ftrace command-line interface
- **perfetto:** Modern unified tracing

**Tool Characteristics:**
- Kernel-level access
- Low overhead
- Detailed information
- System-wide coverage
- Performance analysis

#### Framework Profiling Tools

**Framework Tools:**
- **systrace:** Legacy system tracing
- **perfetto:** Modern unified tracing
- **atrace:** Application tracing
- **dumpsys:** Service state dumps
- **Method tracing:** Java/Kotlin method tracing

**Tool Selection:**
- **systrace:** Legacy tracing (deprecated)
- **perfetto:** Modern unified tracing (recommended)
- **atrace:** Application-level tracing
- **dumpsys:** Service state analysis
- **Method tracing:** Code-level profiling

**Tool Characteristics:**
- Framework-level access
- Application visibility
- Service analysis
- Method-level detail
- Performance metrics

### Kernel Profiling

#### ftrace Profiling

**ftrace Usage:**
- Function tracing
- Event tracing
- Function graph tracing
- Latency tracing
- Custom tracepoints

**Profiling Example:**
```bash
# Enable function tracing
adb shell "echo function > /sys/kernel/debug/tracing/current_tracer"
adb shell "echo 1 > /sys/kernel/debug/tracing/tracing_on"

# Run workload
adb shell "am start -n com.example.app/.MainActivity"

# Stop tracing
adb shell "echo 0 > /sys/kernel/debug/tracing/tracing_on"

# View trace
adb shell "cat /sys/kernel/debug/tracing/trace" > trace.txt
```

**Profiling Characteristics:**
- Function-level detail
- Low overhead
- Kernel visibility
- Event tracking
- Performance analysis

#### perf Profiling

**perf Usage:**
- CPU profiling
- Hardware event counting
- Call graph analysis
- System-wide profiling
- Sampling-based profiling

**Profiling Example:**
```bash
# Record CPU profile
adb shell "perf record -g -a sleep 10"

# Analyze profile
adb shell "perf report" > profile.txt

# System-wide profiling
adb shell "perf record -a -g -F 99 sleep 10"
```

**Profiling Characteristics:**
- Hardware events
- Call graphs
- System-wide coverage
- Sampling-based
- Performance metrics

### Framework Profiling

#### Perfetto Profiling

**Perfetto Usage:**
- Unified kernel and framework tracing
- Comprehensive event capture
- Visual analysis
- Performance analysis
- System-wide tracing

**Profiling Example:**
```bash
# Record trace with kernel and framework events
adb shell perfetto -t 10s -o /data/misc/perfetto-traces/trace.pb \
  -c - <<EOF
data_sources: {
    config {
        name: "linux.ftrace"
        ftrace_config {
            ftrace_events: "sched/sched_switch"
            ftrace_events: "sched/sched_waking"
            ftrace_events: "power/suspend_resume"
        }
    }
}
data_sources: {
    config {
        name: "android.surfaceflinger.frame"
    }
}
data_sources: {
    config {
        name: "android.binder"
    }
}
EOF

# Pull trace
adb pull /data/misc/perfetto-traces/trace.pb

# Open in perfetto UI
# https://ui.perfetto.dev/
```

**Profiling Characteristics:**
- Unified tracing
- Visual analysis
- Comprehensive coverage
- Performance metrics
- System-wide visibility

#### atrace Profiling

**atrace Usage:**
- Application-level tracing
- Framework event tracing
- Category-based tracing
- Simple command-line interface
- Integration with systrace

**Profiling Example:**
```bash
# Trace with categories
adb shell atrace -t 10 -b 32768 gfx view input webview

# Trace with kernel events
adb shell atrace -t 10 -b 32768 -k gfx view sched freq idle

# Save trace
adb shell atrace -t 10 -b 32768 gfx view > trace.html
```

**Profiling Characteristics:**
- Application visibility
- Category-based
- Simple interface
- Framework events
- Performance analysis

### Cross-Layer Analysis

#### Kernel-to-Framework Correlation

**Correlation Analysis:**
- Correlate kernel events with framework events
- Understand system call patterns
- Analyze IPC performance
- Track thread scheduling
- Identify cross-layer bottlenecks

**Analysis Example:**
```bash
# Record unified trace
adb shell perfetto -t 10s -o trace.pb \
  -c - <<EOF
data_sources: {
    config {
        name: "linux.ftrace"
        ftrace_config {
            ftrace_events: "sched/sched_switch"
            ftrace_events: "binder/binder_transaction"
        }
    }
}
data_sources: {
    config {
        name: "android.binder"
    }
}
data_sources: {
    config {
        name: "android.surfaceflinger.frame"
    }
}
EOF

# Analyze in perfetto UI
# Correlate kernel scheduling with framework rendering
```

**Analysis Characteristics:**
- Event correlation
- Cross-layer understanding
- Bottleneck identification
- Performance analysis
- System understanding

#### Performance Bottleneck Identification

**Bottleneck Identification:**
- Identify CPU bottlenecks
- Find I/O bottlenecks
- Detect memory bottlenecks
- Analyze IPC bottlenecks
- Identify rendering bottlenecks

**Identification Process:**
```
1. Record comprehensive trace
2. Analyze kernel events
3. Analyze framework events
4. Correlate events
5. Identify bottlenecks
6. Optimize
```

**Identification Characteristics:**
- Comprehensive analysis
- Multi-layer visibility
- Bottleneck detection
- Performance optimization
- System improvement

### Performance Metrics

#### CPU Performance

**CPU Metrics:**
- CPU utilization
- CPU frequency
- Context switches
- Interrupts
- CPU idle time

**Metric Collection:**
```bash
# CPU utilization
adb shell "top -n 1"

# CPU frequency
adb shell "cat /sys/devices/system/cpu/cpu*/cpufreq/scaling_cur_freq"

# Context switches
adb shell "cat /proc/stat | grep ctxt"
```

**Metric Characteristics:**
- CPU usage analysis
- Frequency monitoring
- Context switch tracking
- Performance metrics
- System load

#### Memory Performance

**Memory Metrics:**
- Memory usage
- Page faults
- Memory pressure
- Swap usage
- Memory allocation

**Metric Collection:**
```bash
# Memory usage
adb shell "cat /proc/meminfo"

# Page faults
adb shell "cat /proc/vmstat | grep pgfault"

# Memory pressure
adb shell "cat /proc/pressure/memory"
```

**Metric Characteristics:**
- Memory analysis
- Pressure monitoring
- Allocation tracking
- Performance metrics
- System health

### Best Practices

#### Best Practices

**Best Practices:**
- Use appropriate tools
- Record comprehensive traces
- Analyze systematically
- Correlate across layers
- Document findings

**Practice Guidelines:**
- **Tool Selection:** Use appropriate tools
- **Comprehensive Tracing:** Record comprehensive traces
- **Systematic Analysis:** Analyze systematically
- **Correlation:** Correlate across layers
- **Documentation:** Document findings

#### Common Profiling Scenarios

**Common Scenarios:**
- Frame drop analysis
- ANR investigation
- Battery drain analysis
- Startup performance
- IPC performance

**Scenario Examples:**
- Frame drops: Trace rendering pipeline
- ANRs: Trace system server and app
- Battery drain: Trace power events
- Startup: Trace boot sequence
- IPC: Trace Binder transactions

## Key Takeaways

1. **Profiling system performance at kernel→framework level** refers to the process of analyzing and measuring system performance across the entire software stack, from kernel-level operations through framework services to application behavior.

2. **Profiling tools** include kernel profiling tools (ftrace, perf, eBPF, trace-cmd, perfetto), framework profiling tools (systrace, perfetto, atrace, dumpsys, method tracing), and tool characteristics.

3. **Kernel profiling** includes ftrace profiling (function tracing, event tracing, function graph tracing, latency tracing, custom tracepoints), perf profiling (CPU profiling, hardware event counting, call graph analysis, system-wide profiling, sampling-based profiling), and profiling characteristics.

4. **Framework profiling** includes Perfetto profiling (unified kernel and framework tracing, comprehensive event capture, visual analysis, performance analysis, system-wide tracing), atrace profiling (application-level tracing, framework event tracing, category-based tracing, simple command-line interface, integration with systrace), and profiling characteristics.

5. **Cross-layer analysis** includes kernel-to-framework correlation (correlate kernel events with framework events, understand system call patterns, analyze IPC performance, track thread scheduling, identify cross-layer bottlenecks), performance bottleneck identification (identify CPU bottlenecks, find I/O bottlenecks, detect memory bottlenecks, analyze IPC bottlenecks, identify rendering bottlenecks), and analysis characteristics.

6. **Performance metrics** include CPU performance (CPU utilization, CPU frequency, context switches, interrupts, CPU idle time), memory performance (memory usage, page faults, memory pressure, swap usage, memory allocation), and metric characteristics.

7. **Best practices** include best practices (use appropriate tools, record comprehensive traces, analyze systematically, correlate across layers, document findings), common profiling scenarios (frame drop analysis, ANR investigation, battery drain analysis, startup performance, IPC performance), and practice guidelines.

8. **Understanding how to profile system performance at kernel→framework level** is essential for AOSP development, enabling performance analysis, bottleneck identification, system optimization, comprehensive performance debugging, and proper system profiling implementation.

## Related Topics

- **systrace & perfetto:** Tracing tools details
- **ftrace:** ftrace details
- **atrace:** atrace details
- **binder tracing:** Binder tracing details

