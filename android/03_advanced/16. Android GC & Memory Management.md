---
number: 16
title: "Android GC & Memory Management"
slug: "android-gc-memory-management"
level: "advanced"
tags: ["android", "gc", "art", "dalvik", "memory", "heap", "oom"]
prerequisites: ["advanced-gc-tuning", "garbage-collection-fundamentals"]
estimated_minutes: 120
contributors: []
diagrams: []
examples: []
canonical_id: "android-advanced-16"
---



# Android GC & Memory Management

## Overview

Android's memory management differs significantly from standard Java VMs. This comprehensive guide covers ART (Android Runtime) vs Dalvik, ART's garbage collection algorithms, Android's generational heap structure, concurrent marking, sticky GC, allocation tracking, memory churn, bitmap handling, native memory, and common OOM causes. Master these concepts to build memory-efficient Android applications.

## Table of Contents

1. [ART vs Dalvik Runtime](#art-vs-dalvik)
2. [ART GC Types](#art-gc-types)
3. [Android Generational Heap](#android-heap)
4. [Concurrent Marking in ART](#concurrent-marking)
5. [Sticky GC in Android](#sticky-gc)
6. [Allocation Tracker](#allocation-tracker)
7. [Memory Churn & Object Pooling](#memory-churn)
8. [Bitmap Memory Handling](#bitmap-memory)
9. [Native Memory vs Java Heap](#native-memory)
10. [OOM Causes in Android](#oom-causes)
11. [Memory Leak Sources](#memory-leaks)

## ART vs Dalvik Runtime

### Dalvik (Android 4.4 and earlier)

**Characteristics**:
- **JIT Compilation**: Just-In-Time compilation
- **DEX files**: Dalvik Executable format
- **Register-based**: Uses virtual registers
- **Multiple VMs**: One VM per app process

**GC Characteristics**:
- **Mark-Sweep**: Basic mark and sweep algorithm
- **Stop-the-World**: Pauses application
- **Concurrent**: Limited concurrency (Android 2.3+)
- **Fragmentation**: Can cause heap fragmentation

### ART (Android 5.0+)

**Characteristics**:
- **AOT Compilation**: Ahead-Of-Time compilation
- **DEX files**: Still uses DEX, compiles to native
- **Native code**: Runs compiled native code
- **Single VM**: Improved memory sharing

**GC Improvements**:
- **Concurrent**: More concurrent operations
- **Generational**: Better generational collection
- **Lower pauses**: Reduced pause times
- **Better performance**: Faster execution

### Key Differences

| Aspect | Dalvik | ART |
|--------|--------|-----|
| **Compilation** | JIT (runtime) | AOT (install time) |
| **Startup** | Slower (interpretation) | Faster (native code) |
| **Storage** | Less (DEX only) | More (.oat files) |
| **GC** | Basic | Advanced (concurrent) |
| **Performance** | Good | Better |

## ART GC Types

### 1. Concurrent Partial GC

**Purpose**: Collect Young Generation

**Process**:
```
1. Stop application threads briefly (initial mark)
2. Concurrent marking of live objects
3. Stop application threads (evacuation)
4. Move survivors to Survivor Space
5. Resume application threads
```

**Characteristics**:
- **Fast**: Usually <5ms pause
- **Frequent**: Runs when Young Gen fills
- **Concurrent**: Most work concurrent

### 2. Concurrent Sticky GC

**Purpose**: Collect recently allocated objects

**Process**:
```
1. Only mark objects allocated since last GC
2. Faster than full GC
3. Less thorough
```

**Characteristics**:
- **Very fast**: <2ms pause
- **Limited scope**: Only recent allocations
- **Frequent**: Runs more often

### 3. Full Heap GC

**Purpose**: Collect entire heap

**Process**:
```
1. Stop application threads
2. Mark all live objects
3. Sweep garbage
4. Compact heap (optional)
5. Resume application threads
```

**Characteristics**:
- **Slow**: 10-100ms+ pause
- **Thorough**: Collects all garbage
- **Rare**: Only when needed

### 4. Native Heap GC

**Purpose**: Collect native memory

**Process**:
```
1. Triggered by native memory pressure
2. Collects native allocations
3. Different from Java heap GC
```

## Android Generational Heap Structure

### Heap Organization

```
┌─────────────────────────────────────────┐
│         Zygote Space (Shared)            │
│  - Pre-loaded classes                   │
│  - Shared across all apps               │
└─────────────────────────────────────────┘
┌─────────────────────────────────────────┐
│         App Heap                        │
│  ┌──────────────────────────────────┐  │
│  │     Young Generation              │  │
│  │  ┌──────────┬──────────┐         │  │
│  │  │  Eden    │ Survivor │         │  │
│  │  │  (new)   │  Space   │         │  │
│  │  └──────────┴──────────┘         │  │
│  ├──────────────────────────────────┤  │
│  │     Old Generation                │  │
│  │  ┌──────────────────────────────┐ │  │
│  │  │    Tenured Space             │ │  │
│  │  │  (long-lived objects)       │ │  │
│  │  └──────────────────────────────┘ │  │
│  └──────────────────────────────────┘  │
└─────────────────────────────────────────┘
┌─────────────────────────────────────────┐
│         Large Object Space              │
│  - Objects >12KB (Android 8.0+)        │
│  - Separate from generational heap      │
└─────────────────────────────────────────┘
```

### Zygote Space

**Purpose**: Share memory across app processes

**Contents**:
- Pre-loaded classes
- Framework code
- Common libraries

**Benefits**:
- **Memory savings**: Shared across all apps
- **Faster startup**: Classes already loaded
- **Lower memory footprint**: Per-app overhead reduced

### App Heap

**Young Generation**:
- **Eden Space**: New object allocations
- **Survivor Space**: Objects that survived GC
- **Size**: Typically 32-64MB

**Old Generation**:
- **Tenured Space**: Long-lived objects
- **Size**: Rest of heap (varies by device)

### Large Object Space (LOS)

**Android 8.0+**: Separate space for large objects

**Threshold**: Objects >12KB (varies by device)

**Benefits**:
- **Prevents promotion**: Large objects don't go to Old Gen immediately
- **Better GC**: Large objects handled separately
- **Reduces fragmentation**: Large objects in separate area

## Concurrent Marking in ART

### How Concurrent Marking Works

**Phase 1: Initial Mark (Stop-the-World)**
```
1. Stop application threads
2. Mark GC roots
3. Mark objects directly reachable from roots
4. Resume application threads
Duration: <1ms
```

**Phase 2: Concurrent Mark**
```
1. GC thread marks reachable objects concurrently
2. Application threads continue running
3. Handle concurrent modifications
4. Use write barriers to track changes
Duration: Variable (concurrent)
```

**Phase 3: Final Mark (Stop-the-World)**
```
1. Stop application threads
2. Finish marking (handle concurrent changes)
3. Prepare for evacuation
Duration: <5ms
```

**Phase 4: Evacuation (Stop-the-World)**
```
1. Move live objects to Survivor/Old Gen
2. Update references
3. Clear Young Generation
Duration: <5ms
```

### Write Barriers

**Purpose**: Track object modifications during concurrent marking

**How It Works**:
```kotlin
// During concurrent marking:
val obj = MyObject()
obj.field = newValue // Write barrier triggered

// Write barrier:
// 1. Marks object as modified
// 2. Ensures new references are marked
// 3. Prevents missing live objects
```

**Overhead**:
- **Small**: Minimal performance impact
- **Necessary**: Ensures correctness
- **Optimized**: ART optimizes barriers

## Sticky GC in Android

### What is Sticky GC?

**Sticky GC**: Only marks objects allocated since last GC

**Purpose**: Fast GC for recently allocated objects

### How It Works

```
1. Remember allocation point from last GC
2. Only mark objects allocated after that point
3. Much faster than full GC
4. Less thorough (may miss some garbage)
```

### When Sticky GC Runs

- **Frequent**: More often than full GC
- **Low memory pressure**: When heap has space
- **Recent allocations**: Focuses on new objects

### Benefits

- **Very fast**: <2ms pause time
- **Low overhead**: Minimal CPU usage
- **Frequent collection**: Keeps heap clean

### Limitations

- **Not thorough**: May miss older garbage
- **Fragmentation**: Doesn't compact
- **Complementary**: Works with full GC

## Allocation Tracker

### What is Allocation Tracker?

**Tool**: Tracks object allocations in real-time

**Available in**: Android Studio Profiler

### How to Use

```
1. Open Android Studio Profiler
2. Select Memory profiler
3. Click "Record allocations"
4. Perform operations
5. Stop recording
6. Analyze allocations
```

### What It Shows

- **Allocations**: Objects created during recording
- **Deallocations**: Objects garbage collected
- **Stack traces**: Where allocations occurred
- **Object types**: What types were allocated
- **Sizes**: How much memory allocated

### Analyzing Allocations

**Look for**:
- **Hot allocations**: Frequently allocated types
- **Large allocations**: Big objects
- **Allocations in loops**: Repeated allocations
- **Unnecessary allocations**: Can be avoided

### Example Analysis

```kotlin
// Allocation Tracker shows:
// String: 1000 allocations
//   └─ 500 in onDraw() ← Problem!
//   └─ 300 in processData()
//   └─ 200 elsewhere

// Fix: Move string creation out of onDraw()
class MyView : View {
    private val cachedString = "cached" // Allocate once
    
    override fun onDraw(canvas: Canvas) {
        // Use cachedString instead of creating new
        canvas.drawText(cachedString, 0f, 0f, paint)
    }
}
```

## Memory Churn & Object Pooling

### What is Memory Churn?

**Memory Churn**: Rapid allocation and deallocation of objects

**Problem**:
- Frequent GC
- Performance degradation
- Battery drain

### Identifying Churn

**Signs**:
- Frequent Minor GC (every few seconds)
- High allocation rate
- Objects die young (high turnover)

**Measurement**:
```
Allocation Tracker shows:
- Many allocations
- Objects quickly deallocated
- High GC frequency
```

### Reducing Churn

#### 1. Object Pooling

```kotlin
class ObjectPool<T>(private val factory: () -> T) {
    private val pool = mutableListOf<T>()
    private val maxSize = 10
    
    fun acquire(): T {
        return if (pool.isNotEmpty()) {
            pool.removeAt(pool.size - 1)
        } else {
            factory()
        }
    }
    
    fun release(obj: T) {
        if (pool.size < maxSize) {
            pool.add(obj)
        }
        // Otherwise, let it be GC'd
    }
}

// Usage
val pool = ObjectPool { StringBuilder() }

fun processData() {
    val sb = pool.acquire()
    try {
        sb.append("data")
        // Use sb
    } finally {
        pool.release(sb) // Reuse instead of GC
    }
}
```

#### 2. Reuse Objects

```kotlin
// BAD: New object every time
fun onDraw(canvas: Canvas) {
    val paint = Paint() // Allocation every frame!
    canvas.drawCircle(0f, 0f, 10f, paint)
}

// GOOD: Reuse object
class MyView : View {
    private val paint = Paint() // Allocated once
    
    override fun onDraw(canvas: Canvas) {
        canvas.drawCircle(0f, 0f, 10f, paint) // Reused
    }
}
```

#### 3. Avoid Allocations in Hot Paths

```kotlin
// BAD: Allocation in hot path
fun processItem(item: Item) {
    val processed = item.toString() // Allocation
        .toLowerCase() // Allocation
        .trim() // Allocation
}

// GOOD: Minimize allocations
fun processItem(item: Item) {
    val processed = buildString {
        append(item.toString().lowercase().trim())
    } // Single allocation
}
```

## Bitmap Memory Handling

### Bitmap Memory Location

**Android 2.3-7.1**: Java heap
**Android 8.0+**: Native heap (mostly)

### Bitmap Memory Calculation

```
Memory = width * height * bytesPerPixel

bytesPerPixel:
- ARGB_8888: 4 bytes
- RGB_565: 2 bytes
- ALPHA_8: 1 byte
```

**Example**:
```kotlin
val bitmap = Bitmap.createBitmap(1920, 1080, Bitmap.Config.ARGB_8888)
// Memory = 1920 * 1080 * 4 = 8,294,400 bytes ≈ 8MB
```

### Bitmap Memory Issues

**Problem 1: Large Bitmaps**
```kotlin
// Loading full-resolution image
val bitmap = BitmapFactory.decodeResource(resources, R.drawable.large_image)
// Might be 10MB+!

// Solution: Downsample
val options = BitmapFactory.Options().apply {
    inSampleSize = 4 // Load at 1/4 size
}
val bitmap = BitmapFactory.decodeResource(resources, R.drawable.large_image, options)
```

**Problem 2: Bitmap Leaks**
```kotlin
// BAD: Static reference
companion object {
    var bitmap: Bitmap? = null // Never GC'd!
}

// GOOD: Proper lifecycle management
class MyActivity : AppCompatActivity() {
    private var bitmap: Bitmap? = null
    
    override fun onDestroy() {
        bitmap?.recycle() // Free native memory
        bitmap = null
        super.onDestroy()
    }
}
```

**Problem 3: Multiple Copies**
```kotlin
// Loading same image multiple times
val bitmap1 = loadImage("image.jpg") // 8MB
val bitmap2 = loadImage("image.jpg") // Another 8MB!

// Solution: Use image loading library (Glide, Coil)
Glide.with(context)
    .load("image.jpg")
    .into(imageView) // Cached, reused
```

### Bitmap Best Practices

**1. Use Image Loading Libraries**:
```kotlin
// Glide handles:
// - Memory caching
// - Disk caching
// - Downsampling
// - Lifecycle awareness
Glide.with(context)
    .load(url)
    .into(imageView)
```

**2. Recycle Bitmaps**:
```kotlin
bitmap.recycle() // Free native memory
bitmap = null
```

**3. Use Appropriate Config**:
```kotlin
// If transparency not needed
Bitmap.Config.RGB_565 // 2 bytes instead of 4
```

## Native Memory vs Java Heap

### Native Memory

**What**: Memory allocated outside Java heap

**Sources**:
- **JNI allocations**: Native code (C/C++)
- **Bitmaps**: Android 8.0+ (mostly native)
- **Media codecs**: Video/audio buffers
- **OpenGL**: Graphics buffers

### Java Heap

**What**: Memory for Java objects

**Managed by**: ART GC

**Limits**: Set by Android system

### Memory Limits

**Java Heap**:
```
Device-dependent:
- Low-end: 48-96MB
- Mid-range: 128-256MB
- High-end: 256-512MB+
```

**Native Memory**:
```
Limited by:
- Device RAM
- System limits
- Process limits
```

### Monitoring Native Memory

```kotlin
// Get native memory usage
val runtime = Runtime.getRuntime()
val nativeHeap = Debug.getNativeHeapSize()
val nativeHeapUsed = Debug.getNativeHeapAllocatedSize()
val nativeHeapFree = Debug.getNativeHeapFreeSize()

Log.d("Memory", "Native heap: ${nativeHeapUsed / 1024 / 1024}MB")
```

### Native Memory Leaks

**Common Causes**:
- **JNI leaks**: Not freeing native allocations
- **Bitmap leaks**: Not recycling bitmaps
- **Media leaks**: Not releasing media resources

**Detection**:
```
1. Monitor native heap growth
2. Use Memory Profiler
3. Check for unreleased resources
```

## OOM Causes in Android

### OutOfMemoryError Types

**1. Java Heap OOM**:
```
java.lang.OutOfMemoryError: Java heap space
```

**Causes**:
- Heap exhausted
- Memory leak
- Too many/large objects

**2. Native Heap OOM**:
```
java.lang.OutOfMemoryError: Failed to allocate
```

**Causes**:
- Native memory exhausted
- Bitmap allocations
- JNI leaks

**3. Metaspace OOM** (rare):
```
java.lang.OutOfMemoryError: Metaspace
```

**Causes**:
- Too many classes loaded
- Dynamic class loading

### Common OOM Scenarios

#### Scenario 1: Loading Large Images

```kotlin
// BAD: Loads full-resolution image
val bitmap = BitmapFactory.decodeResource(
    resources,
    R.drawable.huge_image
) // Might be 20MB+ → OOM!

// GOOD: Downsample
val options = BitmapFactory.Options().apply {
    inJustDecodeBounds = true
}
BitmapFactory.decodeResource(resources, R.drawable.huge_image, options)

val scale = calculateScale(options.outWidth, options.outHeight, maxWidth, maxHeight)
options.inJustDecodeBounds = false
options.inSampleSize = scale

val bitmap = BitmapFactory.decodeResource(
    resources,
    R.drawable.huge_image,
    options
) // Much smaller → No OOM
```

#### Scenario 2: Memory Leak

```kotlin
// BAD: Static reference
object Cache {
    val data = mutableListOf<LargeObject>()
    // Objects never GC'd → OOM eventually
}

// GOOD: Use appropriate references
object Cache {
    val data = mutableListOf<SoftReference<LargeObject>>()
    // Can be GC'd when memory needed
}
```

#### Scenario 3: Too Many Objects

```kotlin
// BAD: Creating many objects
fun processLargeList(items: List<Item>) {
    val results = mutableListOf<ProcessedItem>()
    items.forEach { item ->
        results.add(ProcessedItem(item)) // Many allocations
    }
    // If items list is huge → OOM
}

// GOOD: Process in batches
fun processLargeList(items: List<Item>) {
    items.chunked(1000).forEach { batch ->
        val results = batch.map { ProcessedItem(it) }
        processBatch(results)
        // Batch can be GC'd before next batch
    }
}
```

## Memory Leak Sources

### 1. Static References

```kotlin
// BAD: Static reference to Activity
class Leaky {
    companion object {
        var activity: Activity? = null // Holds Activity!
    }
}

// Activity cannot be GC'd
// Memory leak!

// GOOD: Use Application context
class NonLeaky {
    companion object {
        var appContext: Context? = null // Application context OK
    }
}
```

### 2. Inner Classes

```kotlin
// BAD: Non-static inner class
class OuterActivity : AppCompatActivity() {
    inner class InnerHandler : Handler() {
        // Holds implicit reference to OuterActivity!
    }
}

// GOOD: Static inner class with WeakReference
class OuterActivity : AppCompatActivity() {
    private class InnerHandler(activity: OuterActivity) : Handler() {
        private val activityRef = WeakReference(activity)
        
        override fun handleMessage(msg: Message) {
            activityRef.get()?.let { activity ->
                // Use activity
            }
        }
    }
}
```

### 3. Listeners/Callbacks

```kotlin
// BAD: Listener holds reference
class Manager {
    private var listener: Listener? = null
    
    fun setListener(listener: Listener) {
        this.listener = listener // Strong reference
    }
    // Listener never removed → Leak
}

// GOOD: Use WeakReference or remove listener
class Manager {
    private var listenerRef: WeakReference<Listener>? = null
    
    fun setListener(listener: Listener) {
        listenerRef = WeakReference(listener)
    }
    
    fun removeListener() {
        listenerRef = null
    }
}
```

### 4. Views Holding Context

```kotlin
// BAD: Static View reference
companion object {
    var view: View? = null // View → Context → Activity
}

// GOOD: Don't hold View references
// Or use WeakReference if needed
```

### 5. Threads

```kotlin
// BAD: Thread holds reference
class Leaky {
    private val thread = Thread {
        while (true) {
            // Thread holds reference to Leaky
            // Leaky cannot be GC'd
        }
    }
}

// GOOD: Use static inner class or stop thread
class NonLeaky {
    private var thread: Thread? = null
    
    fun start() {
        thread = Thread {
            // Work
        }
        thread?.start()
    }
    
    fun stop() {
        thread?.interrupt()
        thread = null
    }
}
```

## Real Code Examples

### Example 1: Memory-Efficient Image Loading

```kotlin
class ImageLoader(private val context: Context) {
    private val memoryCache = LruCache<String, Bitmap>(getCacheSize()) {
        size -> size * 4 // ARGB_8888 = 4 bytes per pixel
    }
    
    private fun getCacheSize(): Int {
        val activityManager = context.getSystemService(Context.ACTIVITY_SERVICE) as ActivityManager
        val memoryClass = activityManager.memoryClass
        return (memoryClass * 1024 * 1024 / 8) // 1/8 of available memory
    }
    
    fun loadImage(url: String, imageView: ImageView) {
        // Check memory cache
        val cached = memoryCache.get(url)
        if (cached != null) {
            imageView.setImageBitmap(cached)
            return
        }
        
        // Load asynchronously
        CoroutineScope(Dispatchers.IO).launch {
            val bitmap = loadBitmapFromUrl(url)
            bitmap?.let {
                memoryCache.put(url, it)
                withContext(Dispatchers.Main) {
                    imageView.setImageBitmap(it)
                }
            }
        }
    }
    
    private suspend fun loadBitmapFromUrl(url: String): Bitmap? = withContext(Dispatchers.IO) {
        val options = BitmapFactory.Options().apply {
            inJustDecodeBounds = true
        }
        // ... calculate sample size ...
        options.inJustDecodeBounds = false
        options.inSampleSize = calculateSampleSize(options)
        
        // Load downsampled bitmap
        // ... load logic ...
    }
}
```

### Example 2: Preventing Memory Leaks

```kotlin
class SafeActivity : AppCompatActivity() {
    private var handler: Handler? = null
    private var listener: Listener? = null
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        
        // Use static handler
        handler = MyHandler(this)
        
        // Register listener
        Manager.getInstance().addListener(this)
        listener = this
    }
    
    override fun onDestroy() {
        super.onDestroy()
        
        // Remove callbacks
        handler?.removeCallbacksAndMessages(null)
        handler = null
        
        // Remove listener
        listener?.let {
            Manager.getInstance().removeListener(it)
        }
        listener = null
    }
    
    // Static handler with WeakReference
    private class MyHandler(activity: SafeActivity) : Handler(Looper.getMainLooper()) {
        private val activityRef = WeakReference(activity)
        
        override fun handleMessage(msg: Message) {
            activityRef.get()?.let { activity ->
                // Handle message
            }
        }
    }
}
```

## Common Pitfalls

### Problem: Not Recycling Bitmaps

```kotlin
// BAD: Bitmaps accumulate
fun loadImages(urls: List<String>) {
    urls.forEach { url ->
        val bitmap = loadBitmap(url)
        // Bitmap never recycled
        // Native memory leak
    }
}

// GOOD: Recycle bitmaps
fun loadImages(urls: List<String>) {
    urls.forEach { url ->
        val bitmap = loadBitmap(url)
        // Use bitmap
        bitmap.recycle() // Free native memory
    }
}
```

### Problem: Holding Context References

```kotlin
// BAD: Static Activity reference
companion object {
    var activity: Activity? = null
}

// GOOD: Use Application context or WeakReference
companion object {
    var appContext: Context? = null // Application context
    // Or
    var activityRef: WeakReference<Activity>? = null
}
```

## Quiz

1. What is the main difference between ART and Dalvik GC?
   - **A)** ART uses reference counting
   - **B)** ART has more concurrent operations
   - **C)** Dalvik is faster
   - **D)** No difference

2. What is Sticky GC?
   - **A)** Full heap collection
   - **B)** Collection of only recently allocated objects
   - **C)** Native memory collection
   - **D)** Bitmap collection

3. Where are bitmaps stored in Android 8.0+?
   - **A)** Java heap only
   - **B)** Native heap (mostly)
   - **C)** Stack
   - **D)** Metaspace

**Answers:**
1. **B** - ART has more concurrent GC operations, reducing pause times
2. **B** - Sticky GC only marks objects allocated since last GC, making it very fast
3. **B** - Android 8.0+ stores bitmaps mostly in native heap, not Java heap

## Next Steps

- [Performance Profiling & Memory Leaks](./21.%20Performance%20Profiling%20%26%20Memory%20Leaks.md) - Finding leaks
- [Android OS Internals - Process & Memory](./29.%20Android%20OS%20Internals%20-%20Process%20%26%20Memory.md) - System-level memory

