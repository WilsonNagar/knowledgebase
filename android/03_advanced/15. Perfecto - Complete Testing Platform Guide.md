---
number: 15
title: "Perfecto - Complete Testing Platform Guide"
slug: "perfecto-complete-testing-platform-guide"
level: "advanced"
tags: ["perfecto", "testing", "automation", "ci-cd", "mobile-testing", "cloud-devices"]
prerequisites: ["unit-testing-android", "testing-compose-uis"]
estimated_minutes: 90
contributors: []
diagrams: []
examples: []
canonical_id: "android-advanced-15"
---



# Perfecto - Complete Testing Platform Guide

## Overview

Perfecto is a cloud-based mobile testing platform that provides access to real devices, automated testing capabilities, and comprehensive test reporting. This comprehensive guide covers everything from setup to advanced automation, helping you master mobile app testing at scale using Perfecto's powerful platform.

## Table of Contents

1. [Introduction to Perfecto](#introduction)
2. [Getting Started](#getting-started)
3. [Device Management](#device-management)
4. [Manual Testing](#manual-testing)
5. [Automated Testing](#automated-testing)
6. [CI/CD Integration](#cicd-integration)
7. [Advanced Features](#advanced-features)
8. [Best Practices](#best-practices)
9. [Real-World Scenarios](#real-world-scenarios)

## Introduction to Perfecto

### What is Perfecto?

Perfecto is a cloud-based mobile testing platform that provides:
- **Real Devices**: Access to hundreds of real Android/iOS devices
- **Automation**: Support for Appium, Espresso, XCUITest
- **Manual Testing**: Remote device access for manual testing
- **CI/CD Integration**: Seamless integration with Jenkins, GitLab CI, etc.
- **Reporting**: Comprehensive test reports and analytics
- **Debugging**: Screenshots, videos, logs, network capture

### Why Use Perfecto?

**Advantages**:
- **Real Devices**: Test on actual hardware, not emulators
- **Device Variety**: Access to many device models and OS versions
- **Scalability**: Run tests in parallel on multiple devices
- **No Setup**: No need to maintain physical device lab
- **Cloud-Based**: Access from anywhere
- **Enterprise Features**: Security, compliance, team collaboration

**Use Cases**:
- **Regression Testing**: Run full test suite on multiple devices
- **Compatibility Testing**: Test on various Android versions
- **Performance Testing**: Measure app performance across devices
- **Manual QA**: Remote access for QA team
- **CI/CD**: Automated testing in pipeline

## Getting Started

### Account Setup

1. **Sign Up**: Create Perfecto account
2. **Choose Plan**: Select appropriate plan (trial/enterprise)
3. **Configure Organization**: Set up teams and permissions
4. **Get Credentials**: Note your cloud URL and credentials

### Installation

#### Method 1: Perfecto Web UI
```
1. Go to https://[your-cloud].perfectomobile.com
2. Login with credentials
3. Access web-based interface
```

#### Method 2: Perfecto CLI
```bash
# Install Perfecto CLI
npm install -g perfecto-cli

# Configure
perfecto config set cloud [your-cloud].perfectomobile.com
perfecto config set securityToken [your-token]
```

#### Method 3: Android Studio Plugin
```
1. File → Settings → Plugins
2. Search "Perfecto"
3. Install Perfecto Plugin
4. Configure credentials
```

### Authentication

```kotlin
// In your test code
val cloudURL = "https://[your-cloud].perfectomobile.com"
val securityToken = "[your-token]"

val capabilities = DesiredCapabilities().apply {
    setCapability("securityToken", securityToken)
    setCapability("platformName", "Android")
    setCapability("deviceName", "device-id")
}
```

## Device Management

### Browsing Available Devices

#### Web UI
```
1. Login to Perfecto
2. Go to "Devices" section
3. Filter by:
   - Platform (Android/iOS)
   - OS Version
   - Manufacturer
   - Model
   - Availability
```

#### REST API
```bash
# List available devices
curl -X GET \
  "https://[cloud].perfectomobile.com/services/devices" \
  -H "PERFECTO_AUTHORIZATION: [token]"
```

#### Programmatic Access
```kotlin
// Using Perfecto SDK
val deviceRepository = DeviceRepository(cloudURL, securityToken)
val devices = deviceRepository.getDevices(
    platform = Platform.ANDROID,
    osVersion = "13",
    available = true
)
```

### Device Selection Criteria

**For Android Testing**:
- **OS Versions**: Test on multiple Android versions (10, 11, 12, 13, 14)
- **Screen Sizes**: Small, medium, large, extra-large
- **Manufacturers**: Samsung, Google, OnePlus, Xiaomi, etc.
- **Hardware**: Different RAM, CPU, storage configurations

**Example Device Matrix**:
```
Android 13:
  - Pixel 7 (Latest Google)
  - Samsung Galaxy S23 (Popular)
  - OnePlus 11 (High-end)

Android 12:
  - Pixel 6
  - Samsung Galaxy S22

Android 11:
  - Pixel 5
  - Samsung Galaxy S21
```

### Reserving Devices

```kotlin
// Reserve device for testing
val device = deviceRepository.reserveDevice(
    deviceId = "device-id",
    duration = Duration.ofMinutes(30)
)

// Use device
// ...

// Release device
deviceRepository.releaseDevice(deviceId)
```

## Manual Testing

### Remote Device Access

#### Web-Based Access
```
1. Select device from device list
2. Click "Use" or "Reserve"
3. Device screen appears in browser
4. Interact with device:
   - Click/tap
   - Swipe
   - Type text
   - Rotate device
   - Take screenshots
```

#### Features Available:
- **Touch Controls**: Tap, swipe, pinch, long-press
- **Keyboard Input**: Type text, special characters
- **Device Controls**: Home, Back, Recent Apps, Power
- **Sensors**: Rotate, shake, GPS location
- **Media**: Play audio, record video
- **Screenshots**: Capture screens at any time
- **Video Recording**: Record test sessions

### Manual Test Workflow

```
1. Reserve device
2. Install app (or use pre-installed)
3. Perform test steps:
   - Navigate through app
   - Test features
   - Verify behavior
4. Take screenshots for evidence
5. Record video if needed
6. Document findings
7. Release device
```

### Screenshots and Videos

```kotlin
// Take screenshot programmatically
val screenshot = device.takeScreenshot()
screenshot.save("screenshot.png")

// Record video
device.startVideoRecording()
// Perform actions
device.stopVideoRecording()
val video = device.getVideoRecording()
video.save("test-recording.mp4")
```

## Automated Testing

### Appium Integration

#### Setup

```kotlin
// Add dependencies
dependencies {
    testImplementation("io.appium:java-client:8.5.0")
    testImplementation("org.junit.jupiter:junit-jupiter:5.9.2")
}

// Create driver
val capabilities = DesiredCapabilities().apply {
    setCapability("securityToken", securityToken)
    setCapability("platformName", "Android")
    setCapability("deviceName", "device-id")
    setCapability("app", "PUBLIC:my-app.apk")
    setCapability("appPackage", "com.example.myapp")
    setCapability("appActivity", ".MainActivity")
}

val driver = AndroidDriver(
    URI("https://[cloud].perfectomobile.com/nexperience/perfectomobile/wd/hub"),
    capabilities
)
```

#### Writing Tests

```kotlin
class LoginTest {
    private lateinit var driver: AndroidDriver<MobileElement>
    
    @BeforeEach
    fun setup() {
        val capabilities = DesiredCapabilities().apply {
            setCapability("securityToken", securityToken)
            setCapability("platformName", "Android")
            setCapability("deviceName", "device-id")
        }
        driver = AndroidDriver(URI(cloudURL), capabilities)
    }
    
    @Test
    fun testLogin() {
        // Find elements
        val usernameField = driver.findElement(By.id("username"))
        val passwordField = driver.findElement(By.id("password"))
        val loginButton = driver.findElement(By.id("login"))
        
        // Perform actions
        usernameField.sendKeys("testuser")
        passwordField.sendKeys("password123")
        loginButton.click()
        
        // Verify
        val welcomeMessage = driver.findElement(By.id("welcome"))
        assertEquals("Welcome!", welcomeMessage.text)
        
        // Take screenshot
        val screenshot = driver.getScreenshotAs(OutputType.FILE)
        screenshot.copyTo(File("login-success.png"))
    }
    
    @AfterEach
    fun teardown() {
        driver.quit()
    }
}
```

### Espresso Integration

#### Setup

```kotlin
// Add dependencies
dependencies {
    androidTestImplementation("androidx.test.espresso:espresso-core:3.5.1")
    androidTestImplementation("com.perfecto:perfecto-sdk:1.0.0")
}

// Configure Perfecto
@RunWith(AndroidJUnit4::class)
class LoginEspressoTest {
    @get:Rule
    val activityRule = ActivityScenarioRule(MainActivity::class.java)
    
    @Before
    fun setup() {
        Perfecto.setCloudURL(cloudURL)
        Perfecto.setSecurityToken(securityToken)
        Perfecto.setDeviceId(deviceId)
    }
    
    @Test
    fun testLogin() {
        // Espresso test
        onView(withId(R.id.username))
            .perform(typeText("testuser"))
        
        onView(withId(R.id.password))
            .perform(typeText("password123"))
        
        onView(withId(R.id.login))
            .perform(click())
        
        // Verify
        onView(withId(R.id.welcome))
            .check(matches(withText("Welcome!")))
        
        // Perfecto reporting
        Perfecto.report("Login test passed")
    }
}
```

### Test Execution

#### Running Tests Locally
```bash
# Run Appium tests
./gradlew test

# Run Espresso tests
./gradlew connectedAndroidTest

# Run with Perfecto reporting
./gradlew test -Pperfecto.cloudURL=[cloud] -Pperfecto.token=[token]
```

#### Running Tests in Perfecto Cloud
```bash
# Upload app and run tests
perfecto upload app.apk
perfecto run tests --device "device-id" --app "app.apk"
```

## CI/CD Integration

### Jenkins Integration

#### Jenkinsfile

```groovy
pipeline {
    agent any
    
    stages {
        stage('Build') {
            steps {
                sh './gradlew assembleDebug'
            }
        }
        
        stage('Upload to Perfecto') {
            steps {
                sh '''
                    perfecto upload app-debug.apk
                '''
            }
        }
        
        stage('Run Tests') {
            parallel {
                stage('Test on Android 13') {
                    steps {
                        sh '''
                            perfecto run tests \
                                --device "Android13-Device" \
                                --app "app-debug.apk" \
                                --report "test-report.html"
                        '''
                    }
                }
                stage('Test on Android 12') {
                    steps {
                        sh '''
                            perfecto run tests \
                                --device "Android12-Device" \
                                --app "app-debug.apk" \
                                --report "test-report.html"
                        '''
                    }
                }
            }
        }
        
        stage('Publish Results') {
            steps {
                publishHTML([
                    reportName: 'Perfecto Test Report',
                    reportDir: '.',
                    reportFiles: 'test-report.html'
                ])
            }
        }
    }
}
```

### GitLab CI Integration

#### .gitlab-ci.yml

```yaml
stages:
  - build
  - test
  - deploy

build:
  stage: build
  script:
    - ./gradlew assembleDebug
  artifacts:
    paths:
      - app/build/outputs/apk/debug/app-debug.apk

test-perfecto:
  stage: test
  script:
    - npm install -g perfecto-cli
    - perfecto config set cloud $PERFECTO_CLOUD
    - perfecto config set securityToken $PERFECTO_TOKEN
    - perfecto upload app-debug.apk
    - perfecto run tests --device "Android13-Device" --app "app-debug.apk"
  only:
    - main
    - develop
```

### GitHub Actions Integration

#### .github/workflows/test.yml

```yaml
name: Perfecto Tests

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Set up JDK
        uses: actions/setup-java@v3
        with:
          java-version: '17'
      
      - name: Build app
        run: ./gradlew assembleDebug
      
      - name: Install Perfecto CLI
        run: npm install -g perfecto-cli
      
      - name: Configure Perfecto
        run: |
          perfecto config set cloud ${{ secrets.PERFECTO_CLOUD }}
          perfecto config set securityToken ${{ secrets.PERFECTO_TOKEN }}
      
      - name: Upload and test
        run: |
          perfecto upload app/build/outputs/apk/debug/app-debug.apk
          perfecto run tests --device "Android13-Device" --app "app-debug.apk"
      
      - name: Download reports
        run: perfecto download reports --output ./reports
      
      - name: Upload test results
        uses: actions/upload-artifact@v3
        with:
          name: test-reports
          path: ./reports
```

## Advanced Features

### Parallel Test Execution

```kotlin
// Run tests on multiple devices simultaneously
val devices = listOf("device-1", "device-2", "device-3")

devices.parallelStream().forEach { deviceId ->
    val capabilities = DesiredCapabilities().apply {
        setCapability("deviceName", deviceId)
        // ... other capabilities
    }
    
    val driver = AndroidDriver(URI(cloudURL), capabilities)
    try {
        runTestSuite(driver)
    } finally {
        driver.quit()
    }
}
```

### Network Conditioning

```kotlin
// Simulate network conditions
val networkProfile = NetworkProfile().apply {
    profile = NetworkProfile.Profile.WIFI_GOOD
    // Or custom:
    // bandwidth = 10000 // 10 Mbps
    // latency = 50 // 50ms
    // packetLoss = 0.1 // 0.1%
}

device.setNetworkProfile(networkProfile)

// Test app behavior under different network conditions
```

### Location Simulation

```kotlin
// Set device location
val location = Location().apply {
    latitude = 37.7749
    longitude = -122.4194
    altitude = 100.0
}

device.setLocation(location)

// Test location-based features
```

### Biometric Simulation

```kotlin
// Simulate fingerprint
device.authenticate(AuthenticationType.FINGERPRINT, true)

// Simulate face recognition
device.authenticate(AuthenticationType.FACE, true)

// Test biometric authentication flows
```

### Advanced Reporting

```kotlin
// Custom reporting
Perfecto.report("Test started", ReportType.START_TEST)
Perfecto.report("Step 1 completed", ReportType.STEP)
Perfecto.report("Verification passed", ReportType.VERIFICATION)
Perfecto.report("Test completed", ReportType.END_TEST)

// Add screenshots to report
val screenshot = driver.getScreenshotAs(OutputType.BASE64)
Perfecto.reportWithImage("Login screen", screenshot)

// Add video to report
Perfecto.reportWithVideo("User flow", videoPath)
```

## Best Practices

### 1. Device Selection Strategy

```
Test Matrix:
- Latest Android version (most users)
- Previous 2 versions (legacy support)
- Different manufacturers (Samsung, Google, etc.)
- Different screen sizes (phone, tablet)
- Different hardware specs (low-end, mid-range, high-end)
```

### 2. Test Organization

```
Organize tests by:
- Feature (Login, Payment, etc.)
- Priority (Critical, High, Medium)
- Type (Smoke, Regression, E2E)
- Device category (Android 13, Android 12, etc.)
```

### 3. Test Data Management

```kotlin
// Use test data providers
class TestDataProvider {
    companion object {
        val validUsers = listOf(
            User("user1", "pass1"),
            User("user2", "pass2")
        )
        
        val invalidUsers = listOf(
            User("", ""),
            User("user", "wrong")
        )
    }
}

// Use in tests
@Test
fun testLoginWithValidUser() {
    TestDataProvider.validUsers.forEach { user ->
        login(user.username, user.password)
        verifyLoginSuccess()
    }
}
```

### 4. Error Handling

```kotlin
// Robust error handling
try {
    performAction()
} catch (e: NoSuchElementException) {
    Perfecto.report("Element not found: ${e.message}", ReportType.ERROR)
    val screenshot = driver.getScreenshotAs(OutputType.BASE64)
    Perfecto.reportWithImage("Error screenshot", screenshot)
    throw e
} catch (e: TimeoutException) {
    Perfecto.report("Timeout: ${e.message}", ReportType.ERROR)
    throw e
}
```

### 5. Test Maintenance

```
- Keep tests independent
- Use page object pattern
- Regular test reviews
- Update tests with app changes
- Remove obsolete tests
```

## Real-World Scenarios

### Scenario 1: Regression Testing

```kotlin
// Run full regression suite on multiple devices
class RegressionTestSuite {
    @Test
    fun runRegressionTests() {
        val devices = listOf("device-1", "device-2", "device-3")
        
        devices.forEach { deviceId ->
            val driver = createDriver(deviceId)
            try {
                // Run all regression tests
                testLogin(driver)
                testPayment(driver)
                testProfile(driver)
                testSearch(driver)
                // ... more tests
            } finally {
                driver.quit()
            }
        }
    }
}
```

### Scenario 2: Compatibility Testing

```kotlin
// Test app compatibility across Android versions
class CompatibilityTest {
    @Test
    fun testCompatibility() {
        val androidVersions = listOf("13", "12", "11", "10")
        
        androidVersions.forEach { version ->
            val device = findDeviceWithVersion(version)
            val driver = createDriver(device)
            try {
                // Test critical features
                testCoreFeatures(driver)
                verifyUICompatibility(driver)
            } finally {
                driver.quit()
            }
        }
    }
}
```

### Scenario 3: Performance Testing

```kotlin
// Measure app performance across devices
class PerformanceTest {
    @Test
    fun testAppPerformance() {
        val devices = getPerformanceTestDevices()
        
        devices.forEach { device ->
            val driver = createDriver(device)
            try {
                // Measure startup time
                val startTime = System.currentTimeMillis()
                launchApp(driver)
                val startupTime = System.currentTimeMillis() - startTime
                
                Perfecto.report("Startup time: ${startupTime}ms on ${device}")
                
                // Measure screen load times
                measureScreenLoadTimes(driver)
                
                // Measure network request times
                measureNetworkPerformance(driver)
            } finally {
                driver.quit()
            }
        }
    }
}
```

## Common Issues and Solutions

### Issue 1: Device Not Available

**Problem**: Device is busy or offline
**Solution**:
- Use device reservation
- Implement retry logic
- Use device pools
- Check device status before use

### Issue 2: Test Timeouts

**Problem**: Tests timeout on slow devices
**Solution**:
- Increase timeout values
- Optimize test execution
- Use explicit waits
- Handle network delays

### Issue 3: Flaky Tests

**Problem**: Tests fail intermittently
**Solution**:
- Add proper waits
- Handle race conditions
- Use stable selectors
- Retry failed tests

## Quiz

1. What is Perfecto's main advantage over local testing?
   - **A)** Free testing
   - **B)** Access to real devices in cloud
   - **C)** Faster execution
   - **D)** No setup required

2. How do you run tests on multiple devices in parallel?
   - **A)** Sequential execution
   - **B)** Use parallel streams or threads
   - **C)** One device at a time
   - **D)** Not possible

3. What should you include in CI/CD integration?
   - **A)** Only build step
   - **B)** Build, upload, test, report
   - **C)** Only test step
   - **D)** Manual testing only

**Answers:**
1. **B** - Perfecto provides access to real devices in the cloud without maintaining physical device lab
2. **B** - Use parallel streams or threads to execute tests simultaneously on multiple devices
3. **B** - Complete CI/CD pipeline includes build, upload to Perfecto, run tests, and generate reports

## Next Steps

- [Unit Testing in Android](../02_intermediate/14.%20Unit%20Testing%20in%20Android.md) - Local unit testing
- [Testing Compose UIs](../02_intermediate/12.%20Testing%20Compose%20UIs.md) - UI testing

