---
number: 8
title: "Android OS Internals - System Services"
slug: "android-os-internals-system-services"
level: "advanced"
tags: ["android", "os", "internals", "system-services", "ams", "pms", "wms"]
prerequisites: ["android-os-internals-ipc-binder"]
estimated_minutes: 110
contributors: []
diagrams: []
examples: []
canonical_id: "android-advanced-08"
---



# Android OS Internals - System Services

## Overview

Android's system services are the backbone of the operating system, managing everything from app lifecycle to window management to package installation. This comprehensive guide covers ActivityManagerService (AMS), PackageManagerService (PMS), WindowManagerService (WMS), the input event pipeline, and how these services coordinate to provide Android's functionality.

## Table of Contents

1. [System Services Overview](#overview)
2. [ActivityManagerService (AMS)](#ams)
3. [PackageManagerService (PMS)](#pms)
4. [WindowManagerService (WMS)](#wms)
5. [Input Event Pipeline](#input-pipeline)
6. [Service Coordination](#service-coordination)
7. [Service Lifecycle](#service-lifecycle)

## System Services Overview

### What are System Services?

**System Services**: Core services running in SystemServer process

**Purpose**:
- **Manage system resources**: Memory, processes, windows
- **Coordinate app lifecycle**: Start, stop, manage apps
- **Handle system events**: Input, power, display
- **Provide APIs**: Framework APIs for apps

### Key System Services

**Core Services**:
- **ActivityManagerService**: Manages activities and processes
- **PackageManagerService**: Manages app installations
- **WindowManagerService**: Manages windows and displays
- **PowerManagerService**: Manages power states
- **InputManagerService**: Handles input events

**Other Services**:
- **LocationManagerService**: Location services
- **NotificationManagerService**: System notifications
- **AlarmManagerService**: Scheduled tasks
- **ConnectivityService**: Network management
- **And 100+ more services**

## ActivityManagerService (AMS)

### What is AMS?

**ActivityManagerService**: Manages activities, tasks, and processes

**Responsibilities**:
- **Activity lifecycle**: Start, stop, pause, resume activities
- **Process management**: Create, kill, manage processes
- **Task management**: Manage task stacks
- **Memory management**: Monitor and manage memory
- **App permissions**: Enforce permissions

### AMS Architecture

```
┌─────────────────────────────────────────┐
│      Applications                        │
│  - Activities call AMS via Binder        │
└──────────────┬──────────────────────────┘
               │ Binder IPC
┌──────────────▼──────────────────────────┐
│      ActivityManagerService              │
│  - ActivityStackSupervisor               │
│  - ProcessRecord management             │
│  - Task management                      │
└──────────────┬──────────────────────────┘
               │
┌──────────────▼──────────────────────────┐
│      Zygote Process                      │
│  - Process forking                      │
└─────────────────────────────────────────┘
```

### Activity Lifecycle Management

**Starting an Activity**:
```
1. App calls startActivity()
2. AMS receives request via Binder
3. AMS checks permissions
4. AMS creates or resumes process
5. AMS creates ActivityRecord
6. AMS calls onCreate() on app process
7. Activity is displayed
```

**Activity States**:
- **STOPPED**: Not visible, in background
- **PAUSED**: Partially visible (transparent activity on top)
- **RESUMED**: Visible and interactive
- **DESTROYED**: Removed from memory

### Process Management

**Process States**:
- **Foreground**: User interacting
- **Visible**: App visible but not foreground
- **Service**: Background service running
- **Background**: App in background
- **Empty**: No active components

**Process Creation**:
```
1. AMS determines process doesn't exist
2. AMS requests Zygote to fork process
3. Zygote forks new process
4. AMS sends process name and main component
5. Process starts and loads app
6. AMS tracks process in ProcessRecord
```

**Process Termination**:
```
1. AMS determines process should be killed
2. AMS sends SIGTERM to process
3. Process can cleanup gracefully
4. If not terminated, AMS sends SIGKILL
5. Process memory freed
```

### Task Management

**Task**: Stack of activities

**Task Stack**:
```
Task 1:
  - Activity A (bottom)
  - Activity B
  - Activity C (top, visible)

Task 2:
  - Activity X (bottom)
  - Activity Y (top, visible)
```

**Task Management**:
- **Launch modes**: Standard, singleTop, singleTask, singleInstance
- **Task affinity**: Which task activity belongs to
- **Back stack**: Navigation history

## PackageManagerService (PMS)

### What is PMS?

**PackageManagerService**: Manages app installations and packages

**Responsibilities**:
- **Package installation**: Install, uninstall, update apps
- **APK parsing**: Parse AndroidManifest.xml
- **Permission management**: Grant, revoke permissions
- **Component resolution**: Resolve intents to components
- **Package scanning**: Scan for installed packages

### Package Installation Process

**Step 1: APK Verification**:
```
1. Verify APK signature
2. Check certificate chain
3. Verify package name matches certificate
4. Check for tampering
```

**Step 2: APK Parsing**:
```
1. Parse AndroidManifest.xml
2. Extract package name, version
3. Extract components (activities, services, etc.)
4. Extract permissions
5. Create Package object
```

**Step 3: Installation**:
```
1. Copy APK to /data/app/
2. Extract native libraries (if any)
3. Create data directory /data/data/package.name/
4. Grant permissions
5. Register components with system
```

**Step 4: Optimization**:
```
1. dex2oat compiles DEX to native code
2. Creates .oat file
3. Optimizes for device
4. Stores optimized code
```

### Permission Management

**Permission Types**:
- **Normal**: Granted automatically
- **Dangerous**: Requires user approval
- **Signature**: Same signature as declaring app
- **System**: System apps only

**Permission Granting**:
```
1. App requests permission
2. PMS checks if already granted
3. If dangerous, show user dialog
4. User approves/denies
5. PMS stores permission grant
6. App can use permission
```

**Permission Enforcement**:
```
1. App tries to access protected resource
2. System service checks permission
3. PMS queried for grant status
4. Access allowed or denied
```

### Component Resolution

**Intent Resolution**:
```
1. App calls startActivity(intent)
2. AMS receives intent
3. AMS queries PMS for matching components
4. PMS searches installed packages
5. PMS matches intent filters
6. PMS returns matching components
7. AMS starts selected component
```

**Intent Matching**:
- **Action**: Intent action matches
- **Category**: Intent categories match
- **Data**: Intent data URI matches
- **Type**: Intent MIME type matches

## WindowManagerService (WMS)

### What is WMS?

**WindowManagerService**: Manages windows and displays

**Responsibilities**:
- **Window management**: Create, destroy, manage windows
- **Layout**: Calculate window positions and sizes
- **Input dispatch**: Route input events to windows
- **Animation**: Coordinate window animations
- **Display management**: Manage multiple displays

### Window Hierarchy

**Window Types**:
- **Application windows**: App windows (Activity windows)
- **Sub-windows**: Dialogs, popups
- **System windows**: Status bar, navigation bar
- **Toast windows**: Toast notifications

**Window Layers**:
```
Top Layer:
  - System Alert Windows
  - Sub-windows
  - Application Windows
  - System Windows (Status bar)
Bottom Layer:
```

### Window Layout

**Layout Process**:
```
1. WMS receives layout request
2. WMS calculates window positions
3. WMS applies layout constraints
4. WMS sends layout to SurfaceFlinger
5. Windows rendered on screen
```

**Layout Constraints**:
- **Parent bounds**: Window cannot exceed parent
- **System insets**: Status bar, navigation bar
- **Window flags**: Fullscreen, immersive, etc.
- **Display metrics**: Screen size, density

### Input Event Routing

**Input Flow**:
```
1. Input event from touchscreen/keyboard
2. InputManagerService receives event
3. InputManagerService determines target window
4. InputManagerService sends to WMS
5. WMS routes to target window
6. Window receives input event
```

**Hit Testing**:
```
1. InputManagerService gets touch coordinates
2. WMS performs hit test (which window?)
3. WMS finds topmost window at coordinates
4. WMS routes event to that window
```

### Surface Management

**Surface**: Drawing surface for window

**Surface Creation**:
```
1. Window created
2. WMS requests Surface from SurfaceFlinger
3. SurfaceFlinger creates Surface
4. WMS assigns Surface to window
5. App can draw on Surface
```

**Surface Composition**:
```
1. App draws to Surface
2. SurfaceFlinger composites Surfaces
3. SurfaceFlinger renders to display
4. User sees final image
```

## Input Event Pipeline

### Input Flow Overview

```
Touchscreen/Keyboard
    ↓
Input Driver (Kernel)
    ↓
InputManagerService
    ↓
InputDispatcher
    ↓
WindowManagerService
    ↓
Target Window
    ↓
View Hierarchy
    ↓
OnTouchEvent/OnKeyEvent
```

### InputManagerService

**Responsibilities**:
- **Receive input**: From input drivers
- **Process input**: Convert to events
- **Dispatch input**: Route to windows
- **Handle focus**: Manage input focus

**Input Event Types**:
- **Motion events**: Touch, mouse
- **Key events**: Keyboard input
- **Trackball events**: Trackball (rare)

### Input Dispatcher

**Process**:
```
1. Receive input event
2. Determine target window
3. Apply input policy
4. Dispatch to window
5. Handle input focus
```

**Input Policy**:
- **Focus management**: Which window has focus
- **Key interception**: System keys (home, back)
- **Input filtering**: Filter certain inputs
- **Accessibility**: Accessibility features

### View Event Handling

**Event Propagation**:
```
Activity
  ↓ dispatchTouchEvent()
ViewGroup
  ↓ onInterceptTouchEvent()
  ↓ dispatchTouchEvent()
View
  ↓ onTouchEvent()
```

**Event Consumption**:
- **View consumes**: Returns true, stops propagation
- **View doesn't consume**: Returns false, continues propagation
- **Parent intercepts**: Parent handles event

## Service Coordination

### How Services Work Together

**Example: Starting Activity**:
```
1. App calls startActivity()
2. AMS receives request
3. AMS queries PMS for component
4. PMS resolves intent to component
5. AMS checks if process exists
6. If not, AMS requests Zygote fork process
7. AMS creates ActivityRecord
8. AMS requests WMS to create window
9. WMS creates Surface for window
10. Activity starts and displays
```

**Example: Input Event**:
```
1. User touches screen
2. InputManagerService receives touch
3. InputManagerService determines target window
4. WMS provides window information
5. InputManagerService routes to window
6. Activity receives touch event
7. View hierarchy processes touch
```

### Service Dependencies

**AMS depends on**:
- **PMS**: Component resolution
- **WMS**: Window management
- **Zygote**: Process creation

**WMS depends on**:
- **AMS**: Process/activity information
- **SurfaceFlinger**: Surface creation
- **InputManagerService**: Input routing

**PMS depends on**:
- **File system**: APK storage
- **Security**: Permission checking

## Service Lifecycle

### SystemServer Startup

**Boot Sequence**:
```
1. Kernel boots
2. init process starts
3. Zygote starts
4. SystemServer starts
5. SystemServer initializes services:
   - AMS
   - PMS
   - WMS
   - And 100+ more
6. Services register with ServiceManager
7. System ready
```

### Service Initialization Order

**Critical Services First**:
1. **ActivityManagerService**: Needed for other services
2. **PackageManagerService**: Needed for component resolution
3. **WindowManagerService**: Needed for UI
4. **Other services**: In dependency order

### Service Registration

**ServiceManager**:
```
1. Service creates Binder
2. Service calls ServiceManager.addService(name, binder)
3. ServiceManager stores mapping
4. Other processes can get service by name
```

**Getting Services**:
```
1. Process calls ServiceManager.getService(name)
2. ServiceManager returns Binder reference
3. Process can call service methods
```

## Real Code Examples

### Example 1: Understanding AMS

```kotlin
// App code
class MyActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        
        // This calls AMS via Binder
        // AMS creates ActivityRecord
        // AMS manages activity lifecycle
    }
    
    override fun onStart() {
        super.onStart()
        // AMS calls this when activity becomes visible
    }
    
    override fun onResume() {
        super.onResume()
        // AMS calls this when activity is interactive
    }
}

// Behind the scenes:
// 1. ActivityManager.getService() → Gets AMS Binder
// 2. Calls AMS.startActivity() via Binder
// 3. AMS creates process (if needed)
// 4. AMS creates ActivityRecord
// 5. AMS calls activity lifecycle methods
```

### Example 2: Understanding PMS

```kotlin
// App code
val pm = packageManager

// This calls PMS via Binder
val packages = pm.getInstalledPackages(0)

// Behind the scenes:
// 1. PackageManager.getService() → Gets PMS Binder
// 2. Calls PMS.getInstalledPackages() via Binder
// 3. PMS scans /data/app/ directory
// 4. PMS parses package information
// 5. PMS returns list of packages
```

### Example 3: Understanding WMS

```kotlin
// App code
class MyActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        
        // Behind the scenes:
        // 1. Activity creates window
        // 2. AMS requests WMS to create window
        // 3. WMS creates WindowState
        // 4. WMS requests Surface from SurfaceFlinger
        // 5. WMS assigns Surface to window
        // 6. View hierarchy draws to Surface
    }
}
```

## Common Pitfalls

### Problem: Assuming Services Are Always Available

```kotlin
// BAD: Assume service always available
fun getSystemService() {
    val am = getSystemService(Context.ACTIVITY_SERVICE) as ActivityManager
    // Service might not be ready during boot
}

// GOOD: Handle null/errors
fun getSystemService() {
    try {
        val am = getSystemService(Context.ACTIVITY_SERVICE) as? ActivityManager
        am?.let {
            // Use service
        }
    } catch (e: Exception) {
        // Handle error
    }
}
```

### Problem: Not Understanding Service Lifecycle

```kotlin
// BAD: Assume service persists
class MyService : Service() {
    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
        // Service might be killed by AMS
        // Don't assume it runs forever
        return START_NOT_STICKY
    }
}

// GOOD: Use appropriate start mode
class MyService : Service() {
    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
        // Use START_STICKY if service should restart
        // Use WorkManager for long tasks
        return START_STICKY
    }
}
```

## Quiz

1. What does ActivityManagerService manage?
   - **A)** Only activities
   - **B)** Activities, processes, and tasks
   - **C)** Only processes
   - **D)** Only windows

2. What does PackageManagerService do?
   - **A)** Manages app installations and packages
   - **B)** Manages windows
   - **C)** Manages input events
   - **D)** Manages power

3. What does WindowManagerService manage?
   - **A)** Only windows
   - **B)** Windows, layouts, and input routing
   - **C)** Only input events
   - **D)** Only displays

**Answers:**
1. **B** - AMS manages activities, processes (creation/killing), and task stacks
2. **A** - PMS manages app installations, APK parsing, permissions, and component resolution
3. **B** - WMS manages windows, calculates layouts, routes input events, and coordinates with SurfaceFlinger

## Next Steps

- [Android OS Internals - Rendering Pipeline](./32.%20Android%20OS%20Internals%20-%20Rendering%20Pipeline.md) - UI rendering
- [Android OS Internals - Power Management](./33.%20Android%20OS%20Internals%20-%20Power%20Management.md) - Doze, App Standby

