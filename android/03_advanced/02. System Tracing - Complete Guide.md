---
number: 2
title: "System Tracing - Complete Guide"
slug: "system-tracing-complete-guide"
level: "advanced"
tags: ["systrace", "perfetto", "tracing", "system-performance", "kernel"]
prerequisites: ["android-studio-profiler-mastery"]
estimated_minutes: 100
contributors: []
diagrams: []
examples: []
canonical_id: "android-advanced-02"
---



# System Tracing - Complete Guide

## Overview

System Tracing (Systrace/Perfetto) provides low-level visibility into Android system behavior, kernel events, and app performance. This comprehensive guide covers everything from basic tracing to advanced kernel-level analysis, helping you understand system bottlenecks, frame drops, and performance issues that are invisible to high-level profilers.

## Table of Contents

1. [Introduction to System Tracing](#introduction)
2. [Systrace - Legacy Tool](#systrace)
3. [Perfetto - Modern Tracing](#perfetto)
4. [Understanding Trace Files](#understanding-traces)
5. [Kernel-Level Analysis](#kernel-analysis)
6. [Frame Analysis](#frame-analysis)
7. [Advanced Techniques](#advanced-techniques)
8. [Real-World Debugging](#real-world-debugging)

## Introduction to System Tracing

### What is System Tracing?

System Tracing captures:
- **CPU Scheduling**: Which threads run on which CPU cores
- **Kernel Events**: System calls, interrupts, CPU frequency
- **App Events**: Method calls, binder transactions
- **Graphics**: Frame rendering, VSync, GPU work
- **I/O Operations**: Disk reads/writes, network activity

### Why Use System Tracing?

**Android Studio Profiler shows**: What your app does
**System Tracing shows**: How the system executes your app

**Use System Tracing when**:
- Profiler shows "everything is fine" but app is slow
- Investigating frame drops
- Understanding system-level bottlenecks
- Debugging kernel/driver issues
- Analyzing multi-process interactions

### Tools Overview

1. **Systrace** (Legacy, but still useful)
   - Command-line tool
   - Text-based trace files
   - Good for quick analysis

2. **Perfetto** (Modern, recommended)
   - Web-based UI
   - Rich visualization
   - Better performance
   - More event types

## Systrace - Legacy Tool

### Installing Systrace

```bash
# Systrace is part of Android SDK Platform Tools
# Usually located at:
# ~/Library/Android/sdk/platform-tools/systrace/

# Or install via Android Studio SDK Manager
# Tools → SDK Manager → SDK Tools → Android SDK Platform-Tools
```

### Basic Systrace Usage

#### Recording a Trace

```bash
# Basic trace (10 seconds)
python systrace.py -t 10 -o trace.html

# Trace specific categories
python systrace.py -t 10 -o trace.html sched freq idle am wm gfx view binder_driver hal dalvik camera input res

# Trace specific app
python systrace.py -t 10 -o trace.html -a com.example.myapp

# List available categories
python systrace.py --list-categories
```

#### Common Categories

- **sched**: CPU scheduling
- **freq**: CPU frequency scaling
- **idle**: CPU idle states
- **am**: Activity Manager
- **wm**: Window Manager
- **gfx**: Graphics (most important for UI)
- **view**: View system
- **binder_driver**: Inter-process communication
- **hal**: Hardware Abstraction Layer
- **dalvik**: Dalvik VM (legacy)
- **art**: ART runtime
- **camera**: Camera subsystem
- **input**: Touch/input events
- **res**: Resource loading

### Reading Systrace Output

#### Timeline View

```
┌─────────────────────────────────────────────────┐
│ CPU 0  [Thread A] [Thread B] [Thread C]       │
│ CPU 1  [Thread D] [Thread E]                  │
│ CPU 2  [Thread F]                              │
│ CPU 3  [Idle]                                   │
├─────────────────────────────────────────────────┤
│ Main Thread [Method1][Method2][Method3]        │
│ RenderThread [Draw][VSync]                      │
│ Binder Thread [Transaction]                     │
└─────────────────────────────────────────────────┘
```

**Key Elements**:
- **Horizontal bars**: Thread execution time
- **Colors**: Different threads/processes
- **Gaps**: Idle time or blocked threads
- **Vertical lines**: VSync (frame boundaries)

#### Understanding Thread States

- **Running (Green)**: Thread is executing
- **Runnable (Blue)**: Ready to run, waiting for CPU
- **Sleeping (Purple)**: Blocked (I/O, locks, etc.)
- **Uninterruptible Sleep (Red)**: Kernel blocking

### Analyzing Systrace

#### Finding Frame Drops

```
Look for:
1. Main thread bars longer than 16ms (60fps)
2. Gaps in RenderThread
3. VSync lines without corresponding frames
4. "Choreographer#doFrame" taking >16ms
```

#### Finding CPU Bottlenecks

```
Look for:
1. Threads running for long periods
2. CPU frequency scaling down
3. Threads waiting for CPU (runnable state)
4. CPU cores staying idle when work exists
```

## Perfetto - Modern Tracing

### What is Perfetto?

Perfetto is Google's next-generation tracing system:
- **Replaces Systrace**: More powerful, better UI
- **Web-based**: Open trace files in browser
- **Rich Events**: More event types than Systrace
- **Better Performance**: Lower overhead

### Recording Perfetto Traces

#### Method 1: Android Studio

```
1. View → Tool Windows → Profiler
2. Click "+" → Select device
3. Click "System Trace" button
4. Click "Record"
5. Perform operation
6. Click "Stop"
7. Trace opens in Perfetto UI
```

#### Method 2: Command Line

```bash
# Record trace
adb shell perfetto -t 10s -o /data/misc/perfetto-traces/trace.pb \
  -c - <<EOF
buffers: {
    size_kb: 63488
    fill_policy: DISCARD
}
buffers: {
    size_kb: 2048
    fill_policy: DISCARD
}
data_sources: {
    config {
        name: "android.surfaceflinger.frame"
    }
}
data_sources: {
    config {
        name: "android.java_hprof"
        target_buffer: 1
    }
}
data_sources: {
    config {
        name: "linux.ftrace"
        ftrace_config {
            ftrace_events: "sched/sched_switch"
            ftrace_events: "sched/sched_waking"
            ftrace_events: "power/suspend_resume"
            ftrace_events: "power/cpu_frequency"
            ftrace_events: "power/cpu_idle"
            ftrace_events: "power/gpu_frequency"
            ftrace_events: "gpu_mem_total/gpu_mem_total"
            ftrace_events: "binder/binder_transaction"
            ftrace_events: "binder/binder_transaction_received"
            ftrace_events: "binder/binder_set_priority"
            ftrace_events: "i2c/i2c_read"
            ftrace_events: "i2c/i2c_write"
            ftrace_events: "i2c/i2c_result"
            ftrace_events: "i2c/i2c_reply"
            ftrace_events: "regulators/regulator_set_voltage"
            ftrace_events: "regulators/regulator_set_voltage_complete"
            atrace_categories: "gfx"
            atrace_categories: "input"
            atrace_categories: "view"
            atrace_categories: "webview"
            atrace_categories: "wm"
            atrace_categories: "am"
            atrace_categories: "sm"
            atrace_categories: "audio"
            atrace_categories: "video"
            atrace_categories: "camera"
            atrace_categories: "hal"
            atrace_categories: "app"
            atrace_categories: "res"
            atrace_categories: "dalvik"
            atrace_categories: "rs"
            atrace_categories: "bionic"
            atrace_categories: "power"
            atrace_categories: "sched"
            atrace_categories: "irq"
            atrace_categories: "idle"
            atrace_categories: "disk"
            atrace_categories: "mmc"
            atrace_categories: "load"
            atrace_categories: "sync"
            atrace_categories: "workq"
            atrace_categories: "memreclaim"
            atrace_categories: "regulators"
            atrace_categories: "binder_driver"
            atrace_categories: "binder_lock"
            buffer_size_kb: 2048
        }
    }
}
duration_ms: 10000
EOF

# Pull trace file
adb pull /data/misc/perfetto-traces/trace.pb

# Open in browser
# Go to https://ui.perfetto.dev/
# Click "Open trace file"
```

#### Method 3: Perfetto UI (Device)

```
1. Settings → Developer Options → System Tracing
2. Enable "System Tracing"
3. Tap "Record trace"
4. Perform operation
5. Tap "Stop trace"
6. Share trace file
7. Open in Perfetto UI
```

### Understanding Perfetto UI

#### Main Views

1. **Timeline View**: Shows all events over time
2. **Track View**: Groups related events
3. **Slice View**: Detailed view of selected event
4. **Counter View**: Numeric metrics over time

#### Key Tracks

- **CPU**: CPU cores and scheduling
- **Processes**: App processes and threads
- **Graphics**: Frame rendering pipeline
- **Power**: CPU frequency, GPU frequency
- **Memory**: Memory allocations, GC
- **I/O**: Disk and network activity

### Reading Perfetto Traces

#### Frame Analysis

```
Look for these tracks:
1. "SurfaceView" or "Choreographer": App frame boundaries
2. "RenderThread": GPU work
3. "GPU completion": When frame is ready
4. VSync: Frame refresh boundaries

Frame is good if:
- Choreographer#doFrame < 16ms
- RenderThread completes before next VSync
- No gaps or delays
```

#### CPU Analysis

```
Look for:
1. CPU frequency: Should scale up during work
2. CPU utilization: Should match workload
3. Thread states: Running vs Runnable vs Sleeping
4. CPU migration: Threads moving between cores
```

#### Binder Analysis

```
Look for:
1. Binder transactions: IPC calls
2. Transaction duration: Should be fast
3. Binder threads: Should not be blocked
4. Transaction queue: Should not be backed up
```

## Understanding Trace Files

### Trace File Structure

```
Trace File Contains:
├── Metadata
│   ├── Device info
│   ├── Android version
│   ├── Trace duration
│   └── Enabled categories
├── Events
│   ├── CPU events
│   ├── Kernel events
│   ├── App events
│   └── System events
└── Counters
    ├── CPU frequency
    ├── GPU frequency
    └── Memory stats
```

### Event Types

#### 1. Slice Events
```
Represents: Time intervals (method execution, system calls)
Example: "Choreographer#doFrame" from t1 to t2
```

#### 2. Instant Events
```
Represents: Point in time (GC, frame submitted)
Example: "VSync" at time t
```

#### 3. Counter Events
```
Represents: Numeric values over time
Example: CPU frequency, memory usage
```

#### 4. Flow Events
```
Represents: Relationships between events
Example: Frame submission → GPU processing → Display
```

## Kernel-Level Analysis

### Understanding Kernel Events

#### CPU Scheduling

```
sched_switch: Thread A → Thread B
- Shows which thread runs on which CPU
- Shows thread priorities
- Shows why threads were preempted
```

#### CPU Frequency Scaling

```
cpu_frequency: CPU frequency changes
- Shows when CPU speeds up/slows down
- Helps identify thermal throttling
- Shows power management behavior
```

#### Interrupts

```
irq_handler_entry/exit: Hardware interrupts
- Shows interrupt frequency
- Helps identify hardware issues
- Shows interrupt overhead
```

### Analyzing Kernel Behavior

#### Finding CPU Bottlenecks

```
1. Look for threads in "Runnable" state
2. Check CPU frequency (should be max during work)
3. Look for CPU migration (threads moving cores)
4. Check for CPU idle when work exists
```

#### Finding Thermal Throttling

```
1. Look for CPU frequency dropping
2. Check temperature sensors (if available)
3. Look for performance degradation over time
4. Check for CPU cores going offline
```

## Frame Analysis

### Understanding Frame Rendering

#### Frame Pipeline

```
1. VSync (16.67ms for 60fps)
   ↓
2. Choreographer#doFrame (App work)
   ↓
3. View drawing (onDraw, measure, layout)
   ↓
4. RenderThread (GPU work)
   ↓
5. SurfaceFlinger (Composition)
   ↓
6. Display (Next VSync)
```

#### Frame Drop Detection

```
Frame drops occur when:
1. Choreographer#doFrame > 16ms
2. RenderThread work > 16ms
3. Missing VSync signals
4. SurfaceFlinger composition issues
```

### Analyzing Frame Drops

#### Step-by-Step Analysis

```
1. Identify dropped frames
   - Look for gaps in frame timeline
   - Check "Frame" counter for drops

2. Find the bottleneck
   - Check Choreographer duration
   - Check RenderThread duration
   - Check for blocking operations

3. Identify root cause
   - Main thread blocking?
   - Heavy GPU work?
   - System overload?

4. Optimize
   - Move work off main thread
   - Optimize rendering
   - Reduce frame complexity
```

### Real Code Examples

#### Example 1: Finding Frame Drops

```kotlin
// BEFORE: Heavy work on main thread
override fun onDraw(canvas: Canvas) {
    super.onDraw(canvas)
    
    // Heavy computation on main thread
    val data = processLargeDataset() // Takes 50ms!
    drawData(canvas, data)
}

// Perfetto shows:
// Choreographer#doFrame: 50ms (should be <16ms)
// Frame dropped!

// AFTER: Pre-compute off main thread
class MyView : View {
    private var cachedData: ProcessedData? = null
    
    init {
        viewModelScope.launch(Dispatchers.Default) {
            cachedData = processLargeDataset()
            postInvalidate() // Trigger redraw
        }
    }
    
    override fun onDraw(canvas: Canvas) {
        super.onDraw(canvas)
        cachedData?.let { data ->
            drawData(canvas, data) // Fast, just drawing
        }
    }
}

// Perfetto shows:
// Choreographer#doFrame: 8ms
// No frame drops!
```

#### Example 2: Optimizing RenderThread

```kotlin
// BEFORE: Complex path operations
override fun onDraw(canvas: Canvas) {
    val path = Path()
    for (i in 0 until 1000) {
        path.addCircle(i.toFloat(), i.toFloat(), 10f, Path.Direction.CW)
    }
    canvas.drawPath(path, paint) // Heavy GPU work
}

// Perfetto shows:
// RenderThread: 25ms (too long!)
// Frame dropped!

// AFTER: Simplify rendering
override fun onDraw(canvas: Canvas) {
    // Use simpler primitives
    for (i in 0 until 100) { // Fewer circles
        canvas.drawCircle(i * 10f, i * 10f, 10f, paint)
    }
    // Or use hardware layers
    setLayerType(LAYER_TYPE_HARDWARE, null)
}

// Perfetto shows:
// RenderThread: 5ms
// Smooth frames!
```

## Advanced Techniques

### Custom Trace Events

```kotlin
// Add custom trace points in your code
import android.os.Trace

class MyActivity : AppCompatActivity() {
    fun loadData() {
        Trace.beginSection("load_data")
        try {
            val data = repository.getData()
            processData(data)
        } finally {
            Trace.endSection()
        }
    }
    
    private fun processData(data: Data) {
        Trace.beginSection("process_data")
        // Processing...
        Trace.endSection()
    }
}

// In Perfetto:
// See "load_data" and "process_data" sections
// Helps identify specific code paths
```

### Tracing Specific Operations

```kotlin
// Trace specific user flow
fun performUserFlow() {
    Trace.beginSection("user_flow_start")
    
    Trace.beginSection("step_1_login")
    login()
    Trace.endSection()
    
    Trace.beginSection("step_2_load_data")
    loadData()
    Trace.endSection()
    
    Trace.beginSection("step_3_display")
    displayUI()
    Trace.endSection()
    
    Trace.endSection()
}

// In Perfetto:
// See complete user flow breakdown
// Identify slowest step
```

### Comparing Traces

```
1. Record baseline trace
2. Make optimizations
3. Record new trace
4. Load both in Perfetto
5. Compare side-by-side
6. Verify improvements
```

### Exporting and Sharing Traces

```bash
# Export trace
# Perfetto UI → Share → Download

# Share with team
# Upload to shared location
# Team members open in Perfetto UI

# Analyze offline
# Perfetto UI works offline
# Can analyze traces without device
```

## Real-World Debugging

### Case Study 1: Janky Scrolling

**Symptoms**:
- RecyclerView stutters while scrolling
- Frames drop during scroll
- UI feels unresponsive

**Tracing Steps**:
1. Record Perfetto trace during scroll
2. Look for frame drops
3. Analyze Choreographer#doFrame

**Findings**:
```
Choreographer#doFrame: 25ms during scroll
  └─ RecyclerView.onDraw: 20ms
      └─ ViewHolder binding: 15ms
          └─ Image loading: 12ms (blocking!)
```

**Solution**:
```kotlin
// Use async image loading
class MyAdapter : RecyclerView.Adapter<ViewHolder>() {
    override fun onBindViewHolder(holder: ViewHolder, position: Int) {
        val item = items[position]
        
        // BEFORE: Blocking image load
        // holder.imageView.setImageBitmap(loadImage(item.imageUrl))
        
        // AFTER: Async with Glide
        Glide.with(holder.itemView)
            .load(item.imageUrl)
            .into(holder.imageView)
    }
}

// Result: Choreographer#doFrame: 8ms
// Smooth scrolling!
```

### Case Study 2: Slow App Launch

**Symptoms**:
- App takes 5+ seconds to launch
- Blank screen for long time
- Users complain

**Tracing Steps**:
1. Record trace from app launch
2. Analyze main thread activity
3. Look for blocking operations

**Findings**:
```
Main thread blocked:
- Database initialization: 2000ms (on main thread!)
- Network request: 1500ms (blocking!)
- Heavy computation: 800ms
Total: 4300ms
```

**Solution**:
```kotlin
class Application : Application() {
    override fun onCreate() {
        super.onCreate()
        
        // Move to background
        CoroutineScope(Dispatchers.IO).launch {
            initializeDatabase()
            preloadData()
        }
        
        // Show splash screen immediately
        // Load data in background
    }
}

// Result: Launch time: 500ms
// Much better user experience!
```

### Case Study 3: Battery Drain

**Symptoms**:
- Battery drains quickly
- Device heats up
- CPU usage high

**Tracing Steps**:
1. Record trace during normal usage
2. Analyze CPU frequency
3. Check for wake locks
4. Look for background activity

**Findings**:
```
- CPU frequency stuck at max
- Wake lock held continuously
- Background service running constantly
- Location updates every second
```

**Solution**:
```kotlin
// Optimize wake lock usage
class MyService : Service() {
    private val wakeLock: PowerManager.WakeLock
    
    fun doWork() {
        wakeLock.acquire(10*60*1000L) // 10 min timeout
        try {
            // Do work
        } finally {
            wakeLock.release()
        }
    }
}

// Optimize location updates
val locationRequest = LocationRequest.create()
    .setInterval(5000) // 5 seconds instead of 1
    .setMaxUpdateDelayMillis(10000)

// Result: Better battery life
```

## Best Practices

### 1. Record Representative Traces
- Record during actual usage
- Not just synthetic tests
- Include real user flows

### 2. Record Long Enough
- At least 10-30 seconds
- Capture multiple operations
- Include warm-up period

### 3. Enable Right Categories
- Don't enable everything (too much data)
- Enable what you need
- Start broad, narrow down

### 4. Analyze Systematically
- Start with high-level view
- Drill down into details
- Verify findings with code

### 5. Compare Before/After
- Always compare traces
- Measure improvements
- Document changes

## Common Issues and Solutions

### Issue 1: Trace File Too Large

**Problem**: Trace file is several GB
**Solution**:
- Reduce trace duration
- Enable fewer categories
- Use sampling instead of full tracing

### Issue 2: Can't See App Events

**Problem**: App events not visible in trace
**Solution**:
- Ensure app is debuggable
- Use `-a` flag for systrace
- Check app package name

### Issue 3: Trace Overhead Affects Performance

**Problem**: Tracing slows down app significantly
**Solution**:
- Use sampling mode
- Reduce trace duration
- Enable only necessary categories

## Quiz

1. What tool replaced Systrace?
   - **A)** Android Studio Profiler
   - **B)** Perfetto
   - **C)** Traceview
   - **D)** DDMS

2. What indicates a frame drop in Perfetto?
   - **A)** Choreographer#doFrame > 16ms
   - **B)** High CPU usage
   - **C)** Many threads
   - **D)** Large heap size

3. What should you do before optimizing based on trace?
   - **A)** Optimize everything
   - **B)** Compare before/after traces
   - **C)** Only optimize main thread
   - **D)** Ignore system events

**Answers:**
1. **B** - Perfetto is the modern replacement for Systrace
2. **A** - Choreographer#doFrame > 16ms indicates frame drop (60fps = 16.67ms per frame)
3. **B** - Always compare traces to verify improvements

## Next Steps

- [Android Studio Profiler - Complete Mastery Guide](./25.%20Android%20Studio%20Profiler%20-%20Complete%20Mastery%20Guide.md) - High-level profiling
- [Performance Profiling & Memory Leaks](./21.%20Performance%20Profiling%20%26%20Memory%20Leaks.md) - Memory analysis

