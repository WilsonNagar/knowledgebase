---
number: 11
title: "Android OS Internals - Dex Loading & Optimization"
slug: "android-os-internals-dex-loading-optimization"
level: "advanced"
tags: ["android", "os", "internals", "dex", "art", "dalvik", "dexopt", "odex", "vdex"]
prerequisites: ["android-os-internals-architecture-process"]
estimated_minutes: 90
contributors: []
diagrams: []
examples: []
canonical_id: "android-advanced-11"
---



# Android OS Internals - Dex Loading & Optimization

## Overview

Understanding how Android loads and optimizes DEX files is crucial for understanding app startup performance, installation time, and storage usage. This comprehensive guide covers DEX file format, the loading mechanism, ART's optimization process (dexopt, odex, vdex), AOT vs JIT compilation, and how these processes impact app performance.

## Table of Contents

1. [DEX File Format](#dex-format)
2. [DEX Loading Process](#dex-loading)
3. [ART Optimization](#art-optimization)
4. [dexopt Process](#dexopt)
5. [ODEX Files](#odex)
6. [VDEX Files](#vdex)
7. [AOT vs JIT Compilation](#aot-jit)
8. [R8 Code Shrinker](#r8)
9. [Compiled Framework Code](#compiled-framework)
10. [Machine Code](#machine-code)
11. [Profile-Guided Optimizations](#profile-guided)
12. [Baseline Profiles](#baseline-profiles)
13. [Benchmarks](#benchmarks)
14. [Performance Implications](#performance)

## DEX File Format

### What is DEX?

**DEX**: Dalvik Executable format

**Purpose**: Compiled Java/Kotlin bytecode for Android

**Created From**: Java/Kotlin source → .class files → DEX

### DEX File Structure

**DEX File Components**:
```
┌─────────────────┐
│   DEX Header    │  ← File metadata
├─────────────────┤
│   String Table  │  ← String constants
├─────────────────┤
│   Type Table    │  ← Type definitions
├─────────────────┤
│   Proto Table   │  ← Method signatures
├─────────────────┤
│   Field Table   │  ← Field definitions
├─────────────────┤
│   Method Table  │  ← Method definitions
├─────────────────┤
│   Class Defs     │  ← Class definitions
├─────────────────┤
│   Code Items    │  ← Method bytecode
└─────────────────┘
```

**Key Features**:
- **Compact**: Optimized for mobile
- **Register-based**: Uses virtual registers (not stack)
- **Multiple classes**: One DEX can contain multiple classes

### DEX Creation Process

**Build Process**:
```
Java/Kotlin Source
    ↓ javac/kotlinc
.class Files
    ↓ dx/d8
DEX File (.dex)
    ↓ (packaged in APK)
APK File
```

**D8/R8**:
- **D8**: DEX compiler (replaces dx)
- **R8**: Code shrinker + DEX compiler + optimizer
- **Optimizations**: Inlining, dead code elimination, obfuscation

### R8 Code Shrinker Deep Dive

**R8**: Google's code shrinker and optimizer

**Functions**:
- **Code Shrinking**: Remove unused code (classes, methods, fields)
- **Code Obfuscation**: Rename classes/methods to shorter names
- **Optimization**: Optimize bytecode (inlining, constant propagation)
- **DEX Compilation**: Compile .class files to DEX

**R8 Process**:
```
.class Files
    ↓ R8 Analysis
Dependency Graph
    ↓ R8 Shrinking
Remove Unused Code
    ↓ R8 Obfuscation
Rename Classes/Methods
    ↓ R8 Optimization
Optimize Bytecode
    ↓ R8 DEX Compilation
DEX File (shrunk, obfuscated, optimized)
```

**R8 Optimizations**:
- **Dead Code Elimination**: Remove unused classes, methods, fields
- **Method Inlining**: Inline small methods
- **Constant Propagation**: Propagate constants
- **Class Merging**: Merge similar classes
- **Method Removal**: Remove unused methods

**R8 Configuration**:
```kotlin
android {
    buildTypes {
        release {
            isMinifyEnabled = true
            isShrinkResources = true
            proguardFiles(
                getDefaultProguardFile("proguard-android-optimize.txt"),
                "proguard-rules.pro"
            )
        }
    }
}
```

**R8 Benefits**:
- **APK Size**: 30-60% reduction
- **Performance**: Optimized bytecode
- **Security**: Code obfuscation

## DEX Loading Process

### Loading Steps

**Step 1: Extract DEX from APK**:
```
APK contains classes.dex (and possibly classes2.dex, etc.)
System extracts DEX files to /data/dalvik-cache/
```

**Step 2: Verify DEX**:
```
- Verify DEX file format
- Check for corruption
- Validate bytecode
```

**Step 3: Load into Memory**:
```
- Parse DEX structure
- Load class definitions
- Create Class objects
- Link classes
```

**Step 4: Initialize**:
```
- Execute static initializers
- Initialize static fields
- Ready for execution
```

### DEX Loading Locations

**Dalvik Cache** (Android 4.4 and earlier):
```
/data/dalvik-cache/
  └─ data@app@com.example.app@classes.dex
```

**ART Cache** (Android 5.0+):
```
/data/app/com.example.app-*/oat/
  └─ base.odex
  └─ base.vdex
```

### Multi-DEX

**Why Multi-DEX?**:
- **64K Method Limit**: Single DEX limited to 65,536 methods
- **Large Apps**: Exceed method limit
- **Solution**: Split into multiple DEX files

**Multi-DEX Structure**:
```
APK:
  ├─ classes.dex (primary)
  ├─ classes2.dex
  ├─ classes3.dex
  └─ ...
```

**Loading**:
```
1. Load classes.dex (primary)
2. Load classes2.dex
3. Load classes3.dex
4. Link all DEX files together
```

## ART Optimization

### What is ART Optimization?

**ART Optimization**: Compiles DEX to optimized native code

**Purpose**: Faster execution, better performance

**Process**: Happens during app installation or first run

### Optimization Types

**1. dexopt** (Dalvik, Android 4.4 and earlier):
- Optimizes DEX for interpretation
- Creates .odex files
- Faster interpretation

**2. dex2oat** (ART, Android 5.0+):
- Compiles DEX to native code
- Creates .odex and .vdex files
- AOT compilation

## dexopt Process

### What is dexopt?

**dexopt**: DEX optimizer (Dalvik era)

**Purpose**: Optimize DEX for faster interpretation

**Process**:
```
1. Read DEX file
2. Verify and optimize
3. Create .odex file
4. Store optimized DEX
```

### dexopt Output

**ODEX File** (Optimized DEX):
- **Location**: `/data/dalvik-cache/`
- **Format**: Optimized DEX
- **Purpose**: Faster interpretation

**Benefits**:
- **Faster loading**: Pre-verified DEX
- **Optimized**: Bytecode optimizations
- **Cached**: Don't re-optimize every time

## ODEX Files

### What is ODEX?

**ODEX**: Optimized DEX

**Purpose**: Pre-optimized DEX for faster loading

**ART ODEX** (Android 5.0+):
- **Contains**: Compiled native code
- **Format**: ELF (Executable and Linkable Format)
- **Purpose**: AOT compiled code

### ODEX File Structure

**ART ODEX**:
```
┌─────────────────┐
│   ELF Header    │
├─────────────────┤
│   Native Code   │  ← Compiled methods
├─────────────────┤
│   Metadata      │  ← Class/method info
└─────────────────┘
```

**Benefits**:
- **Faster execution**: Native code, no interpretation
- **Better performance**: Optimized code
- **Trade-off**: Larger file size, longer installation

## VDEX Files

### What is VDEX?

**VDEX**: Verified DEX (Android 8.0+)

**Purpose**: Store verified DEX for faster loading

**Process**:
```
1. Verify DEX during installation
2. Store verified DEX in VDEX
3. Skip verification on subsequent loads
```

### VDEX Benefits

**Faster Startup**:
- **Skip verification**: DEX already verified
- **Faster loading**: No verification overhead
- **Better performance**: Reduced startup time

**VDEX Structure**:
```
┌─────────────────┐
│   VDEX Header   │
├─────────────────┤
│   Verified DEX  │  ← Pre-verified DEX
└─────────────────┘
```

## AOT vs JIT Compilation

### AOT (Ahead-of-Time) Compilation

**When**: During app installation or first run

**Process**:
```
DEX → dex2oat → Native Code (.odex)
```

**Benefits**:
- **Faster execution**: Native code
- **No runtime compilation**: Pre-compiled
- **Better performance**: Optimized code

**Drawbacks**:
- **Longer installation**: Compilation takes time
- **Larger storage**: Native code larger than DEX
- **Less flexible**: Can't optimize based on runtime

### JIT (Just-In-Time) Compilation

**When**: During app execution

**Process**:
```
DEX → Interpret → Hot Methods → JIT Compile → Native Code
```

**Benefits**:
- **Faster installation**: No compilation during install
- **Adaptive**: Optimizes based on actual usage
- **Smaller storage**: Only compiles hot methods

**Drawbacks**:
- **Runtime overhead**: Compilation during execution
- **Warm-up time**: Performance improves over time

### Hybrid Approach (Android 7.0+)

**Profile-Guided Optimization**:
```
1. App runs with JIT initially
2. Profile collects hot methods
3. Background compilation of hot methods
4. Next launch uses compiled code
```

**Benefits**:
- **Fast installation**: No AOT during install
- **Optimized hot code**: AOT for frequently used methods
- **Best of both**: Combines AOT and JIT benefits

## R8 Code Shrinker

### What is R8?

**R8**: Google's code shrinker, obfuscator, and optimizer

**Replaces**: ProGuard (since Android Gradle Plugin 3.4.0)

**Functions**:
- **Code Shrinking**: Remove unused code (classes, methods, fields)
- **Code Obfuscation**: Rename classes/methods to shorter names
- **Optimization**: Optimize bytecode (inlining, constant propagation)
- **DEX Compilation**: Compile .class files to DEX

### R8 Process

**Build Process**:
```
.class Files
    ↓ R8 Analysis
Dependency Graph
    ↓ R8 Shrinking
Remove Unused Code
    ↓ R8 Obfuscation
Rename Classes/Methods
    ↓ R8 Optimization
Optimize Bytecode
    ↓ R8 DEX Compilation
DEX File (shrunk, obfuscated, optimized)
```

**Steps**:
1. **Analysis**: Analyze code dependencies
2. **Shrinking**: Remove unused code
3. **Obfuscation**: Rename classes/methods
4. **Optimization**: Optimize code
5. **DEX Compilation**: Compile to DEX

### R8 Optimizations

**1. Dead Code Elimination**:
```
Remove unused classes, methods, fields
```

**2. Method Inlining**:
```
Inline small methods
Reduce method call overhead
```

**3. Constant Propagation**:
```
Propagate constants
Evaluate at compile time
```

**4. Class Merging**:
```
Merge similar classes
Reduce class count
```

**5. Method Removal**:
```
Remove unused methods
```

### R8 Configuration

**build.gradle.kts**:
```kotlin
android {
    buildTypes {
        release {
            isMinifyEnabled = true
            isShrinkResources = true
            proguardFiles(
                getDefaultProguardFile("proguard-android-optimize.txt"),
                "proguard-rules.pro"
            )
        }
    }
}
```

**proguard-rules.pro**:
```proguard
# Keep classes
-keep class com.example.model.** { *; }

# Keep annotations
-keepattributes *Annotation*

# Keep native methods
-keepclasseswithmembernames class * {
    native <methods>;
}

# Keep data classes
-keep class com.example.data.** { *; }
```

### R8 Benefits

**APK Size**:
- **Reduction**: 30-60% size reduction
- **Unused Code**: Removes unused code
- **Resources**: Shrinks resources

**Performance**:
- **Optimization**: Code optimizations
- **Faster**: Optimized bytecode
- **Security**: Obfuscation

## Compiled Framework Code

### What is Compiled Framework Code?

**Framework Code**: Android framework classes

**Location**: `/system/framework/`

**Format**:
- **Pre-compiled**: Pre-compiled to native code at system build time
- **Shared**: Shared across all apps
- **Optimized**: Highly optimized system code

### Framework Compilation

**System Framework**:
```
Android Framework Source
    ↓ System Build Time
Pre-compiled Native Code (.odex)
    ↓ Shared Storage
/system/framework/
```

**Benefits**:
- **Performance**: Pre-compiled, fast execution
- **Sharing**: Shared across apps (saves storage)
- **Optimization**: System-level optimizations

### Framework Views

**Framework Views**: Pre-compiled UI components

**Examples**:
- **TextView**: Pre-compiled TextView
- **Button**: Pre-compiled Button
- **LinearLayout**: Pre-compiled layouts

**Compilation**:
- **Pre-compiled**: Compiled at system build time
- **Native Code**: Runs as native machine code
- **Optimized**: System-level optimizations

**Use**: All apps use the same compiled framework views

## Machine Code

### What is Machine Code?

**Machine Code**: Native CPU instructions

**Format**:
- **Binary**: Binary format
- **CPU-Specific**: Specific to CPU architecture (ARM, x86, ARM64)
- **Direct Execution**: Executed directly by CPU

### Compilation to Machine Code

**Process**:
```
DEX Bytecode
    ↓ dex2oat (AOT) or JIT
Intermediate Representation (IR)
    ↓ Optimization Passes
Optimized IR
    ↓ Code Generation
Machine Code (ARM/x86/ARM64)
```

### Machine Code Characteristics

**Architecture-Specific**:
- **ARM**: ARM instructions (most Android devices)
- **x86**: x86 instructions (emulators, some devices)
- **ARM64**: 64-bit ARM (modern devices)

**Optimizations**:
- **Register Allocation**: Efficient register usage
- **Instruction Scheduling**: Optimal instruction order
- **Branch Prediction**: Optimize branches
- **Loop Optimization**: Optimize loops

### Machine Code Execution

**Execution Flow**:
```
Machine Code → CPU → Direct Execution
```

**No Interpretation**:
```
Direct CPU execution
No bytecode interpretation
Maximum performance
```

**Performance**: Native code performance, no interpretation overhead

## Profile-Guided Optimizations

### What is Profile-Guided Optimization?

**Profile-Guided Optimization**: Optimize based on runtime profiles

**Process** (Android 7.0+):
```
1. App runs with JIT initially
2. Profile collects hot methods during execution
3. Background compilation of hot methods
4. Next launch uses optimized compiled code
```

### Profile Collection

**What is Profiled**:
- **Hot Methods**: Frequently called methods
- **Hot Classes**: Frequently used classes
- **Code Paths**: Common execution paths

**Collection**:
- **Runtime**: Collected during execution
- **Background**: Collected in background
- **Persistent**: Stored for next launch

### Profile-Guided Benefits

**Adaptive**:
- **Real Usage**: Based on actual usage patterns
- **Hot Code**: Optimizes frequently used code
- **Better Performance**: Better than static optimization

**Installation**:
- **Fast Install**: Fast initial installation (no AOT)
- **Progressive**: Performance improves over time

## Baseline Profiles

### What are Baseline Profiles?

**Baseline Profiles**: Pre-defined profiles specifying critical code paths

**Purpose**:
- **Startup Optimization**: Optimize startup code paths
- **Critical Paths**: Optimize critical user flows
- **First Launch**: Better first launch performance

### Baseline Profile Format

**Profile Format**:
```
Lcom/example/MainActivity;->onCreate(Landroid/os/Bundle;)V
Lcom/example/MainActivity;->onStart()V
Lcom/example/ViewModel;-><init>()V
Lcom/example/Repository;->loadData()Ljava/util/List;
```

**Syntax**:
```
L<fully-qualified-class>;-><method-name>(<signature>)V
```

### Creating Baseline Profiles

**Method 1: Manual Creation**:
```kotlin
// src/main/baseline-prof.txt
Lcom/example/MainActivity;->onCreate(Landroid/os/Bundle;)V
Lcom/example/MainActivity;->onStart()V
Lcom/example/MainActivity;->onResume()V
Lcom/example/ViewModel;-><init>()V
```

**Method 2: Profile Installer Library**:
```kotlin
// build.gradle.kts
dependencies {
    implementation("androidx.profileinstaller:profileinstaller:1.3.1")
}

// Baseline profile automatically included in APK
// ART uses it during installation
```

**Method 3: Macrobenchmark**:
```kotlin
@RunWith(AndroidJUnit4::class)
class StartupBenchmark {
    @get:Rule
    val benchmarkRule = MacrobenchmarkRule()
    
    @BaselineProfileRule
    @Test
    fun baselineProfile() {
        benchmarkRule.measureRepeated(
            packageName = "com.example.app"
        ) {
            // Critical user flows
            pressHome()
            startActivityAndWait()
            // Profile these paths
        }
    }
}
```

### Baseline Profile Benefits

**Performance**:
- **Faster Startup**: Optimized startup code
- **Better First Launch**: Better first launch experience
- **Critical Paths**: Optimized critical user flows

**User Experience**:
- **Smoother**: Smoother app experience
- **Faster**: Faster app responsiveness

## Benchmarks

### What are Benchmarks?

**Benchmarks**: Performance measurements to compare and validate optimizations

**Types**:
- **Microbenchmarks**: Small code sections (high precision)
- **Macrobenchmarks**: Complete user flows (real-world scenarios)
- **Startup Benchmarks**: App startup time measurements

### Microbenchmarks

**Microbenchmark**: Measure small code sections with high precision

**Library**: `androidx.benchmark:benchmark-junit4`

**Example**:
```kotlin
@RunWith(AndroidJUnit4::class)
class MyBenchmark {
    @get:Rule
    val benchmarkRule = BenchmarkRule()
    
    @Test
    fun benchmarkFunction() {
        benchmarkRule.measureRepeated {
            // Code to benchmark
            myFunction()
        }
    }
    
    @Test
    fun benchmarkListOperation() {
        val list = (1..1000).toList()
        benchmarkRule.measureRepeated {
            list.sorted()
        }
    }
}
```

**Use**: Measure specific operations, compare implementations

### Macrobenchmarks

**Macrobenchmark**: Measure complete user flows

**Library**: `androidx.benchmark:benchmark-macro-junit4`

**Example**:
```kotlin
@RunWith(AndroidJUnit4::class)
class StartupBenchmark {
    @get:Rule
    val benchmarkRule = MacrobenchmarkRule()
    
    @Test
    fun startupBenchmark() {
        benchmarkRule.measureRepeated(
            packageName = "com.example.app",
            metrics = listOf(
                StartupTimingMetric(),
                FrameTimingMetric()
            ),
            iterations = 5
        ) {
            pressHome()
            startActivityAndWait()
        }
    }
}
```

**Use**: Measure real-world scenarios, validate optimizations

### Benchmark Metrics

**1. Startup Time**:
- **Time to First Frame**: Time until first frame rendered
- **Time to Interactive**: Time until app is interactive

**2. Frame Timing**:
- **Frame Render Time**: Time to render each frame
- **Jank Detection**: Detect dropped frames

**3. Memory**:
- **Memory Allocations**: Track allocations
- **GC Events**: Garbage collection events

**4. CPU**:
- **CPU Usage**: CPU utilization
- **Method Execution Time**: Method timing

## Performance Implications

### Installation Time

**AOT Compilation Impact**:
```
Small App: ~5-10 seconds
Medium App: ~10-30 seconds
Large App: ~30-60+ seconds
```

**Factors**:
- **App size**: More code = longer compilation
- **Device performance**: Faster CPU = faster compilation
- **Storage speed**: Faster storage = faster I/O

### Startup Time

**AOT Benefits**:
- **Faster startup**: No interpretation overhead
- **Native code**: Direct execution
- **Optimized**: Better performance

**JIT Benefits**:
- **Faster initial startup**: No compilation delay
- **Adaptive**: Optimizes based on usage
- **Warm-up**: Performance improves over time

### Storage Usage

**AOT Storage**:
```
DEX: 10MB
ODEX: 30-50MB (3-5x larger)
Total: 40-60MB
```

**JIT Storage**:
```
DEX: 10MB
JIT Cache: 5-10MB (only hot methods)
Total: 15-20MB
```

### Runtime Performance

**AOT Performance**:
- **Consistent**: Same performance every run
- **Fast**: Native code execution
- **Optimized**: Pre-optimized code

**JIT Performance**:
- **Improving**: Performance improves over time
- **Adaptive**: Optimizes based on actual usage
- **Warm-up**: Needs warm-up period

## Real Code Examples

### Example 1: Understanding DEX Loading

```kotlin
// When app starts:
// 1. System loads DEX from APK
// 2. Verifies DEX
// 3. Loads classes into memory
// 4. Initializes Application class

class MyApplication : Application() {
    override fun onCreate() {
        super.onCreate()
        // DEX already loaded at this point
        // Classes available for use
    }
}
```

### Example 2: Multi-DEX Handling

```kotlin
// build.gradle
android {
    defaultConfig {
        multiDexEnabled true
    }
}

// Application class
class MyApplication : Application() {
    override fun attachBaseContext(base: Context) {
        super.attachBaseContext(base)
        MultiDex.install(this) // Install multi-DEX support
    }
}
```

### Example 3: Checking Optimization Status

```bash
# Check if app is optimized
adb shell dumpsys package com.example.app | grep -A 5 "dex"

# Force re-optimization
adb shell pm compile -f -m speed com.example.app

# Check compilation status
adb shell pm get-app-info com.example.app
```

## Common Pitfalls

### Problem: Slow Installation

```kotlin
// Large apps take longer to install due to AOT compilation
// Solution: Use JIT or profile-guided optimization

// Android 7.0+ uses profile-guided optimization by default
// First install: Fast (JIT)
// After usage: Background compilation
// Next launch: Faster (AOT for hot methods)
```

### Problem: Storage Usage

```kotlin
// AOT compilation increases storage usage
// Solution: Use code shrinking (R8)

android {
    buildTypes {
        release {
            minifyEnabled true
            shrinkResources true
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt')
        }
    }
}
```

### Problem: Multi-DEX Issues

```kotlin
// BAD: Not handling multi-DEX
class MyApplication : Application() {
    // Might crash if classes.dex doesn't contain Application class
}

// GOOD: Handle multi-DEX
class MyApplication : Application() {
    override fun attachBaseContext(base: Context) {
        super.attachBaseContext(base)
        MultiDex.install(this)
    }
}
```

## Quiz

1. What is DEX?
   - **A)** Source code format
   - **B)** Dalvik Executable format (compiled bytecode)
   - **C)** Native code format
   - **D)** Resource format

2. What does dex2oat do?
   - **A)** Optimizes DEX for interpretation
   - **B)** Compiles DEX to native code (AOT)
   - **C)** Interprets DEX
   - **D)** Verifies DEX

3. What is the benefit of AOT compilation?
   - **A)** Faster installation
   - **B)** Faster execution (native code)
   - **C)** Smaller storage
   - **D)** No compilation overhead

**Answers:**
1. **B** - DEX is Dalvik Executable format, the compiled bytecode format for Android
2. **B** - dex2oat compiles DEX to native code using AOT (Ahead-of-Time) compilation
3. **B** - AOT compilation provides faster execution because code is compiled to native code before runtime

## Real-World Examples

### Example 1: Optimizing App Startup

**Problem**: Slow app startup

**Solution**:
- **Baseline Profile**: Create baseline profile for startup code
- **R8**: Enable R8 optimization
- **Profile-Guided**: Use profile-guided optimization

**Result**: Faster startup, better first launch experience

### Example 2: Reducing APK Size

**Problem**: Large APK size

**Solution**:
- **R8**: Enable R8 code shrinking
- **Resource Shrinking**: Shrink resources
- **Code Analysis**: Remove unused code

**Result**: 40% APK size reduction

### Example 3: Performance Benchmarking

**Use**: Validate optimizations

**Method**:
- **Microbenchmarks**: Measure specific operations
- **Macrobenchmarks**: Measure user flows
- **Continuous**: Continuous benchmarking

**Result**: Data-driven optimizations

## Common Pitfalls

### Problem: Missing Baseline Profiles

```kotlin
// BAD: No baseline profile
// Slower startup, especially first launch

// GOOD: Create baseline profile
// Optimize startup code paths
// Better first launch experience
```

### Problem: R8 Configuration Issues

```kotlin
// BAD: Wrong R8 rules
// Code removed incorrectly
// App crashes

// GOOD: Proper R8 rules
// Keep necessary code
// Test thoroughly
```

### Problem: Not Benchmarking

```kotlin
// BAD: Optimize without measuring
// May not improve performance

// GOOD: Benchmark before/after
// Measure improvements
// Validate optimizations
```

## Next Steps

- [Android OS Internals - Architecture & Process Management](./06.%20Android%20OS%20Internals%20-%20Architecture%20%26%20Process%20Management.md) - Process management
- [Performance Profiling & Memory Leaks](./03.%20Performance%20Profiling%20%26%20Memory%20Leaks.md) - Performance optimization
- [Jetpack Compose State Management](../02_intermediate/01.%20Jetpack%20Compose%20State%20Management.md) - Compose performance

