---
number: 29
title: "Android OS Internals - Architecture & Process Management"
slug: "android-os-internals-architecture-process"
level: "advanced"
tags: ["android", "os", "internals", "architecture", "zygote", "process", "systemserver"]
prerequisites: []
estimated_minutes: 120
contributors: []
diagrams: []
examples: []
canonical_id: "android-29"
---

# Android OS Internals - Architecture & Process Management

## Overview

Understanding Android's OS architecture and process management is essential for building efficient applications and debugging system-level issues. This comprehensive guide covers Android's layered architecture (HAL, native layer, framework), the Zygote process and app startup, SystemServer, process lifecycle, app sandboxing, and how Android manages processes and memory at the system level.

## Table of Contents

1. [Android Architecture Layers](#architecture-layers)
2. [Zygote Process & App Startup](#zygote-startup)
3. [SystemServer Process](#systemserver)
4. [Process Lifecycle](#process-lifecycle)
5. [App Sandboxing & SELinux](#sandboxing)
6. [Low Memory Killer (LMK)](#lmk)
7. [OOM_adj Scoring System](#oom-adj)
8. [How Android Kills Background Apps](#killing-apps)

## Android Architecture Layers

### Layer Overview

```
┌─────────────────────────────────────────┐
│      Applications (Java/Kotlin)          │
│  - Your apps, system apps               │
└──────────────┬──────────────────────────┘
               │
┌──────────────▼──────────────────────────┐
│      Application Framework (Java)        │
│  - ActivityManager, PackageManager       │
│  - ContentProvider, ViewSystem           │
└──────────────┬──────────────────────────┘
               │
┌──────────────▼──────────────────────────┐
│      Native Libraries (C/C++)           │
│  - ART Runtime, Bionic libc             │
│  - OpenGL, Media Framework              │
└──────────────┬──────────────────────────┘
               │
┌──────────────▼──────────────────────────┐
│      Hardware Abstraction Layer (HAL)    │
│  - Camera HAL, Audio HAL                 │
│  - Sensor HAL, Display HAL               │
└──────────────┬──────────────────────────┘
               │
┌──────────────▼──────────────────────────┐
│      Linux Kernel                        │
│  - Process management, Memory            │
│  - Device drivers, Binder IPC            │
└─────────────────────────────────────────┘
```

### Layer 1: Applications

**What**: User-facing applications

**Characteristics**:
- **Java/Kotlin**: Written in high-level languages
- **APK format**: Packaged as Android packages
- **Sandboxed**: Each app runs in isolated process

**Examples**:
- System apps (Settings, Phone, etc.)
- Third-party apps (your apps)
- Launcher apps

### Layer 2: Application Framework

**What**: System services and APIs for apps

**Key Components**:
- **ActivityManager**: Manages activities and tasks
- **PackageManager**: Manages app installations
- **WindowManager**: Manages windows and displays
- **ContentProvider**: Data sharing between apps
- **ViewSystem**: UI rendering system
- **NotificationManager**: System notifications

**Purpose**:
- Provides APIs to applications
- Manages app lifecycle
- Coordinates system resources

### Layer 3: Native Libraries

**What**: C/C++ libraries and runtime

**Key Components**:
- **ART Runtime**: Executes Java/Kotlin code
- **Bionic libc**: C standard library
- **OpenGL ES**: Graphics rendering
- **Media Framework**: Audio/video processing
- **SQLite**: Database engine
- **WebKit**: Web rendering

**Purpose**:
- Performance-critical operations
- System-level functionality
- Hardware access

### Layer 4: Hardware Abstraction Layer (HAL)

**What**: Interface between framework and hardware

**Purpose**:
- **Abstraction**: Hides hardware details from framework
- **Standardization**: Consistent API across devices
- **Vendor-specific**: Implemented by device manufacturers

**HAL Modules**:
- **Camera HAL**: Camera hardware interface
- **Audio HAL**: Audio hardware interface
- **Sensor HAL**: Sensor hardware interface
- **Display HAL**: Display hardware interface
- **Bluetooth HAL**: Bluetooth hardware interface

### Layer 5: Linux Kernel

**What**: Core operating system

**Responsibilities**:
- **Process management**: Creates/kills processes
- **Memory management**: Allocates/manages memory
- **Device drivers**: Hardware communication
- **Security**: SELinux, permissions
- **IPC**: Binder, sockets, pipes

## Zygote Process & App Startup

### What is Zygote?

**Zygote**: Special process that pre-loads common resources

**Purpose**: Fast app startup through process forking

### Zygote Initialization

**Boot Process**:
```
1. Linux kernel boots
2. init process starts
3. Zygote process created
4. Zygote pre-loads:
   - Core Java classes
   - Framework resources
   - Common libraries
5. Zygote listens for fork requests
```

### Zygote Pre-loading

**What Gets Pre-loaded**:
- **Core classes**: `java.lang.*`, `java.util.*`
- **Framework classes**: `android.*` packages
- **Resources**: Common drawables, strings
- **Native libraries**: Commonly used libraries

**Benefits**:
- **Faster startup**: Apps don't need to load these
- **Memory sharing**: Copy-on-write memory
- **Consistency**: All apps use same pre-loaded code

### App Startup Process

**Step 1: Fork Zygote**
```
App launch request → ActivityManager
ActivityManager → Zygote: "fork new process"
Zygote forks itself → New process created
```

**Step 2: Specialize Process**
```
New process:
1. Sets process name (package name)
2. Loads app-specific classes
3. Initializes app-specific resources
4. Creates main thread
```

**Step 3: Launch App**
```
Process:
1. Creates Application instance
2. Calls onCreate()
3. Launches main activity
4. App is running
```

### Process Forking Benefits

**Copy-on-Write (COW)**:
```
Zygote memory: [Pre-loaded classes]
                ↓ fork
App process:   [Same memory pages] (shared, read-only)
                ↓ write
App process:   [Copy page] (private copy)
```

**Memory Savings**:
- **Shared memory**: Pre-loaded classes shared
- **Copy-on-write**: Only copy when modified
- **Efficient**: Multiple apps share same memory

### Zygote Socket Communication

**Communication Method**: Unix domain socket

**Process**:
```
1. Zygote listens on socket
2. ActivityManager sends fork request
3. Zygote forks process
4. Returns process info to ActivityManager
```

## SystemServer Process

### What is SystemServer?

**SystemServer**: Core system service process

**Purpose**: Runs all system services

### SystemServer Initialization

**Boot Process**:
```
1. Zygote forks SystemServer process
2. SystemServer starts system services:
   - ActivityManagerService
   - PackageManagerService
   - WindowManagerService
   - PowerManagerService
   - And 100+ more services
3. Services register with ServiceManager
4. System ready
```

### Key System Services

**ActivityManagerService (AMS)**:
- Manages activities, tasks, processes
- Handles app lifecycle
- Process management

**PackageManagerService (PMS)**:
- Manages app installations
- Handles permissions
- APK parsing

**WindowManagerService (WMS)**:
- Manages windows and displays
- Handles input events
- Coordinates UI rendering

**PowerManagerService**:
- Manages power states
- Handles wake locks
- Battery optimization

### Service Registration

**ServiceManager**: Registry for all system services

**Process**:
```
1. Service starts
2. Service calls ServiceManager.addService()
3. Service registered with name
4. Other processes can get service by name
```

**Example**:
```java
// SystemServer starts ActivityManagerService
ActivityManagerService ams = new ActivityManagerService();
ServiceManager.addService(Context.ACTIVITY_SERVICE, ams);

// App gets service
IActivityManager am = ActivityManager.getService();
```

## Process Lifecycle

### Process States

**1. Foreground Process**:
- User is interacting with app
- Highest priority
- Last to be killed

**2. Visible Process**:
- App is visible but not foreground
- High priority
- Killed only if memory needed

**3. Service Process**:
- Running background service
- Medium priority
- Killed if memory needed

**4. Background Process**:
- App not visible
- Low priority
- Killed when memory needed

**5. Empty Process**:
- No active components
- Lowest priority
- First to be killed

### Process Priority

**Priority Order** (highest to lowest):
```
1. Foreground Process
2. Visible Process
3. Service Process
4. Background Process
5. Empty Process
```

**Determined by**:
- **Highest component**: Process priority = highest component priority
- **Component types**: Activity, Service, BroadcastReceiver, ContentProvider

## App Sandboxing & SELinux

### App Sandboxing

**Concept**: Each app runs in isolated environment

**Isolation Mechanisms**:
- **Separate process**: Each app has own process
- **Unique UID**: Each app has unique user ID
- **File permissions**: Can only access own files
- **Network isolation**: Limited network access

### Linux UID/GID

**UID (User ID)**:
```
Each app gets unique UID
App A: UID 10000
App B: UID 10001
App C: UID 10002
```

**File Permissions**:
```
App files: /data/data/com.example.app/
Owner: UID 10000 (app's UID)
Permissions: 700 (owner read/write/execute only)
Other apps: Cannot access
```

### SELinux (Security-Enhanced Linux)

**What**: Mandatory access control system

**Purpose**: Additional security layer beyond Linux permissions

**How It Works**:
```
1. Every process has security context
2. Every file has security context
3. SELinux policies define allowed operations
4. Even root cannot bypass SELinux
```

### SELinux Contexts

**Process Context**:
```
u:r:untrusted_app:s0
│ │ │              │
│ │ │              └─ MLS level
│ │ └─────────────── Domain (untrusted_app)
│ └───────────────── Role
└─────────────────── User
```

**File Context**:
```
u:object_r:app_data_file:s0
│ │        │              │
│ │        │              └─ MLS level
│ │        └─────────────── Type (app_data_file)
│ └──────────────────────── Role
└────────────────────────── User
```

### SELinux Policies

**Policy Rules**:
```
allow untrusted_app app_data_file:file { read write };
```

**Meaning**:
- **Subject**: `untrusted_app` (process)
- **Object**: `app_data_file` (file type)
- **Permission**: `read`, `write`
- **Action**: `allow`

**Enforcement**:
- **Enforcing**: Policies enforced (production)
- **Permissive**: Policies logged but not enforced (debugging)
- **Disabled**: SELinux disabled

## Low Memory Killer (LMK)

### What is LMK?

**Low Memory Killer**: Kernel module that kills processes when memory is low

**Purpose**: Prevent system from running out of memory

### How LMK Works

**Process**:
```
1. System memory gets low
2. LMK checks process priorities (oom_adj)
3. Kills lowest priority processes
4. Frees memory
5. Repeats until memory sufficient
```

**Trigger Points**:
- **Low memory threshold**: Memory below threshold
- **Multiple thresholds**: Different thresholds for different priorities
- **Progressive killing**: Kills more processes as memory gets lower

### LMK Thresholds

**Android LMK Levels**:
```
Foreground:    18432 KB (never kill)
Visible:       22528 KB
Secondary:     26624 KB
Hidden:        30720 KB
Content:       34816 KB
Empty:         38912 KB (kill first)
```

**When Memory Below Threshold**:
- LMK kills processes at that level and below
- Frees memory
- System continues

## OOM_adj Scoring System

### What is OOM_adj?

**OOM_adj**: Out-Of-Memory adjustment score

**Purpose**: Determines process kill priority

**Range**: -1000 to 1000 (lower = less likely to be killed)

### OOM_adj Values

**System Processes**:
```
-1000: System processes (never kill)
-900:  Core system services
-800:  Persistent processes
```

**App Processes**:
```
0:     Foreground app
100:   Visible app
200:   Perceptible app (background music)
300:   Service
400:   Home app
500:   Previous app
600:   Background app
700:   Cached app (empty process)
```

### How OOM_adj is Set

**By Process State**:
```
Foreground Activity → oom_adj = 0
Visible Activity → oom_adj = 100
Background Service → oom_adj = 300
Background App → oom_adj = 600
Empty Process → oom_adj = 700
```

**By ActivityManagerService**:
- AMS tracks process state
- Updates oom_adj based on components
- Kernel uses oom_adj for LMK

### OOM Score Calculation

**Final Score**:
```
oom_score = base_oom_score + oom_adj

Lower score = Less likely to be killed
Higher score = More likely to be killed
```

## How Android Kills Background Apps

### Killing Process

**Step 1: Check Process State**
```
Is process empty? → Kill immediately
Is process background? → Check memory
Is process service? → Check if needed
```

**Step 2: Calculate Priority**
```
oom_adj = getOomAdj(process)
oom_score = calculateScore(oom_adj, memory_usage)
```

**Step 3: Kill Process**
```
if (oom_score > threshold) {
    killProcess(pid)
    freeMemory()
}
```

### Process Termination

**Graceful Termination**:
```
1. Send SIGTERM signal
2. Process can cleanup
3. If not terminated, send SIGKILL
4. Force kill process
```

**Memory Reclamation**:
```
1. Process memory freed
2. File descriptors closed
3. Resources released
4. Memory available for other processes
```

### Background App Limits

**Android 7.0+ Background Limits**:
- **Background execution limits**: Restricted background execution
- **Doze mode**: Aggressive battery saving
- **App Standby**: Limits background activity

**Impact**:
- Background apps killed more aggressively
- Services limited
- Network access restricted

### Preserving Important Processes

**Ways to Preserve**:
- **Foreground service**: Higher priority
- **Notification**: Keeps process visible
- **High priority**: Set process priority
- **Sticky service**: System tries to restart

**Limitations**:
- **Not guaranteed**: System can still kill
- **Battery impact**: May drain battery
- **User experience**: May affect UX

## Real Code Examples

### Example 1: Understanding Process Priority

```kotlin
class MyActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        
        // Activity is foreground → oom_adj = 0
        // Process has highest priority
        // Less likely to be killed
        
        // Start background service
        val serviceIntent = Intent(this, MyService::class.java)
        startService(serviceIntent)
        // Service runs in same process
        // Process priority = foreground (highest component)
    }
}

class MyService : Service() {
    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
        // Service is background → oom_adj = 300
        // But process has foreground activity
        // So process priority = foreground
        
        return START_STICKY // System tries to restart if killed
    }
}
```

### Example 2: Process State Monitoring

```kotlin
class ProcessMonitor {
    fun getProcessInfo(): ProcessInfo {
        val am = getSystemService(Context.ACTIVITY_SERVICE) as ActivityManager
        val runningApps = am.runningAppProcesses
        
        runningApps?.forEach { processInfo ->
            Log.d("Process", """
                Process: ${processInfo.processName}
                PID: ${processInfo.pid}
                UID: ${processInfo.uid}
                Importance: ${processInfo.importance}
                PSS: ${processInfo.pss} KB
            """.trimIndent())
        }
        
        return processInfo
    }
}

// Importance values:
// FOREGROUND_SERVICE = 125
// VISIBLE = 100
// SERVICE = 300
// BACKGROUND = 400
// EMPTY = 500
```

## Common Pitfalls

### Problem: Assuming Process Won't Be Killed

```kotlin
// BAD: Assume process always runs
class MyService : Service() {
    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
        // Long-running task
        doLongTask() // Process might be killed!
        return START_NOT_STICKY
    }
}

// GOOD: Handle process death
class MyService : Service() {
    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
        // Use WorkManager for long tasks
        WorkManager.getInstance(this)
            .enqueue(OneTimeWorkRequestBuilder<MyWorker>().build())
        return START_STICKY
    }
}
```

### Problem: Not Understanding Process Priority

```kotlin
// BAD: Background service expects to run forever
class BackgroundService : Service() {
    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
        while (true) {
            // Might be killed when memory needed
            doWork()
        }
    }
}

// GOOD: Use foreground service if needed
class ForegroundService : Service() {
    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
        val notification = createNotification()
        startForeground(1, notification) // Higher priority
        return START_STICKY
    }
}
```

## Quiz

1. What is the purpose of Zygote?
   - **A)** Manage system services
   - **B)** Fast app startup through process forking
   - **C)** Handle UI rendering
   - **D)** Manage permissions

2. What determines process kill priority?
   - **A)** App size
   - **B)** oom_adj score
   - **C)** Number of activities
   - **D)** Battery usage

3. What is SELinux?
   - **A)** Process manager
   - **B)** Mandatory access control system
   - **C)** Memory allocator
   - **D)** File system

**Answers:**
1. **B** - Zygote pre-loads common resources and forks processes for fast app startup
2. **B** - oom_adj score determines process kill priority (lower = less likely to be killed)
3. **B** - SELinux is a mandatory access control system providing additional security

## Next Steps

- [Android OS Internals - IPC & Binder](./30.%20Android%20OS%20Internals%20-%20IPC%20%26%20Binder.md) - Inter-process communication
- [Android OS Internals - System Services](./31.%20Android%20OS%20Internals%20-%20System%20Services.md) - AMS, PMS, WMS

