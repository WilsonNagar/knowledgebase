---
number: 12
title: "Android OS Internals - Looper, Handler & MessageQueue"
slug: "android-os-internals-looper-handler-messagequeue"
level: "advanced"
tags: ["android", "os", "internals", "looper", "handler", "messagequeue", "threading"]
prerequisites: ["java-threads-concurrency-basics"]
estimated_minutes: 95
contributors: []
diagrams: []
examples: []
canonical_id: "android-advanced-12"
---



# Android OS Internals - Looper, Handler & MessageQueue

## Overview

Looper, Handler, and MessageQueue form the core of Android's threading and message passing system. Understanding these internals is essential for building responsive applications, handling background work, and avoiding common threading pitfalls. This comprehensive guide covers how these components work together, their internal implementation, and best practices.

## Table of Contents

1. [Overview of Looper, Handler, MessageQueue](#overview)
2. [MessageQueue Internals](#messagequeue)
3. [Looper Internals](#looper)
4. [Handler Internals](#handler)
5. [Message Passing Mechanism](#message-passing)
6. [Main Thread (UI Thread)](#main-thread)
7. [Background Threads](#background-threads)
8. [Common Patterns & Best Practices](#patterns)

## Overview of Looper, Handler, MessageQueue

### The Three Components

**MessageQueue**:
- **Purpose**: Queue of messages/runnables
- **Thread-local**: One per thread
- **FIFO**: First In, First Out

**Looper**:
- **Purpose**: Loops through MessageQueue
- **Thread-local**: One per thread
- **Processes**: Messages one by one

**Handler**:
- **Purpose**: Send messages to MessageQueue
- **Multiple per thread**: Can have multiple handlers
- **Target**: Associated with Looper's thread

### How They Work Together

```
Handler (Thread A)
    ↓ sendMessage()
MessageQueue (Thread A)
    ↓
Looper (Thread A)
    ↓ loop()
Process Message
    ↓ handleMessage()
Handler (Thread A)
```

### Key Concepts

**Thread Association**:
- **Looper**: Bound to thread (one Looper per thread)
- **Handler**: Bound to Looper (can post to that thread)
- **MessageQueue**: Bound to Looper (one queue per Looper)

**Message Flow**:
```
1. Handler sends message
2. Message added to MessageQueue
3. Looper processes message
4. Handler receives message
5. Handler handles message
```

## MessageQueue Internals

### What is MessageQueue?

**MessageQueue**: Queue of messages waiting to be processed

**Characteristics**:
- **Thread-local**: Each thread has its own queue
- **FIFO**: Messages processed in order
- **Blocking**: Can block thread waiting for messages
- **Native**: Implemented in native code (C++)

### MessageQueue Structure

**Internal Structure**:
```
MessageQueue
├─ Message (head)
│  ├─ what: int
│  ├─ arg1: int
│  ├─ arg2: int
│  ├─ obj: Object
│  ├─ target: Handler
│  ├─ callback: Runnable
│  └─ next: Message (linked list)
├─ Message
├─ Message
└─ ...
```

**Linked List**:
- Messages stored as linked list
- Head points to first message
- Each message has `next` pointer

### MessageQueue Operations

**Enqueue Message**:
```kotlin
// Handler sends message
handler.sendMessage(message)

// Internally:
// 1. Set message.target = handler
// 2. Add message to queue (sorted by when)
// 3. Wake up Looper if needed
```

**Dequeue Message**:
```kotlin
// Looper gets next message
val message = messageQueue.next()

// Internally:
// 1. Get head message
// 2. Remove from queue
// 3. Return message
// 4. Block if queue empty
```

### Message Ordering

**By Time**:
```
Messages ordered by when (timestamp)
Earlier messages processed first
Same time: FIFO order
```

**Example**:
```kotlin
handler.sendMessageDelayed(msg1, 100) // Processed first
handler.sendMessageDelayed(msg2, 50)  // Processed second (earlier)
handler.sendMessage(msg3)              // Processed third (immediate)
```

### Native Implementation

**Native Methods**:
- `nativeInit()`: Initialize native queue
- `nativePollOnce()`: Poll for messages (can block)
- `nativeWake()`: Wake up polling thread

**Why Native?**:
- **Performance**: Faster message handling
- **Blocking**: Efficient thread blocking
- **Integration**: Better OS integration

## Looper Internals

### What is Looper?

**Looper**: Loops through MessageQueue processing messages

**Purpose**: Keep thread alive and process messages

**Characteristics**:
- **Thread-local**: One Looper per thread
- **Infinite loop**: Loops until quit
- **Blocking**: Blocks when no messages

### Looper Lifecycle

**1. Prepare**:
```kotlin
Looper.prepare()
// Creates Looper for current thread
// Creates MessageQueue
// Stores in ThreadLocal
```

**2. Loop**:
```kotlin
Looper.loop()
// Infinite loop:
//   1. Get next message from queue
//   2. Process message
//   3. Recycle message
//   4. Repeat
```

**3. Quit**:
```kotlin
looper.quit()
// Stops loop
// Clears queue
// Thread can exit
```

### Looper Implementation

**Simplified Loop**:
```kotlin
fun loop() {
    val me = myLooper() // Get Looper for current thread
    val queue = me.mQueue
    
    while (true) {
        val msg = queue.next() // Blocks if no messages
        if (msg == null) {
            return // Quit
        }
        
        msg.target.dispatchMessage(msg) // Handle message
        msg.recycleUnchecked() // Recycle message
    }
}
```

### Main Looper

**Main Thread Looper**:
```kotlin
// Created automatically for main thread
// Accessible via:
Looper.getMainLooper()

// Used by:
Handler(Looper.getMainLooper()) // Handler for main thread
```

**Why Special?**:
- **Auto-created**: Created automatically
- **Never quits**: Main thread never quits
- **UI thread**: Handles UI updates

## Handler Internals

### What is Handler?

**Handler**: Sends messages to MessageQueue

**Purpose**: Post messages/runnables to thread

**Characteristics**:
- **Bound to Looper**: Associated with specific Looper
- **Thread-safe**: Can be used from any thread
- **Multiple**: Can have multiple handlers per thread

### Handler Creation

**Method 1: Default (Current Thread)**:
```kotlin
val handler = Handler()
// Uses Looper of current thread
// Fails if no Looper prepared
```

**Method 2: Explicit Looper**:
```kotlin
val handler = Handler(Looper.getMainLooper())
// Uses specified Looper
```

**Method 3: Callback**:
```kotlin
val handler = Handler {
    // Handle message
    true
}
```

### Handler Operations

**Send Message**:
```kotlin
handler.sendMessage(message)
// Adds message to queue
// Returns immediately
```

**Post Runnable**:
```kotlin
handler.post {
    // Code runs on handler's thread
}
// Creates message with Runnable callback
// Adds to queue
```

**Send Delayed**:
```kotlin
handler.sendMessageDelayed(message, 1000)
// Message processed after delay
// Uses SystemClock.uptimeMillis()
```

### Message Dispatching

**dispatchMessage() Flow**:
```kotlin
fun dispatchMessage(msg: Message) {
    if (msg.callback != null) {
        // Runnable callback
        handleCallback(msg)
    } else {
        if (mCallback != null && mCallback.handleMessage(msg)) {
            return // Handled by callback
        }
        // Default handler
        handleMessage(msg)
    }
}
```

**Priority**:
1. **Runnable callback**: `msg.callback` (highest)
2. **Handler callback**: `mCallback.handleMessage()`
3. **Override method**: `handleMessage()` (lowest)

## Message Passing Mechanism

### Message Structure

**Message Fields**:
```kotlin
class Message {
    var what: Int = 0           // Message type
    var arg1: Int = 0           // Integer argument 1
    var arg2: Int = 0           // Integer argument 2
    var obj: Any? = null        // Object argument
    var target: Handler? = null // Target handler
    var callback: Runnable? = null // Runnable callback
    var `when`: Long = 0        // Timestamp
    var next: Message? = null  // Next message (linked list)
    var data: Bundle? = null    // Additional data
}
```

### Message Pooling

**Why Pool?**:
- **Performance**: Avoid allocations
- **GC pressure**: Reduce garbage collection
- **Efficiency**: Reuse message objects

**How It Works**:
```kotlin
// Obtain message
val msg = Message.obtain() // Gets from pool

// Use message
handler.sendMessage(msg)

// After handling:
msg.recycle() // Returns to pool
```

**Pool Implementation**:
```kotlin
// Simplified
private var sPool: Message? = null
private var sPoolSize = 0
private val MAX_POOL_SIZE = 50

fun obtain(): Message {
    synchronized(this) {
        if (sPool != null) {
            val m = sPool
            sPool = m.next
            m.next = null
            sPoolSize--
            return m
        }
    }
    return Message() // Create new if pool empty
}
```

### Message Delivery

**Synchronous**:
```kotlin
handler.sendMessage(message)
// Message added to queue
// Returns immediately
// Processed later by Looper
```

**Asynchronous**:
```kotlin
message.setAsynchronous(true)
handler.sendMessage(message)
// Processed immediately if possible
// Bypasses some synchronization
```

## Main Thread (UI Thread)

### Main Thread Setup

**Automatic Setup**:
```
1. App process starts
2. Main thread created
3. Looper.prepareMainLooper() called
4. Main Looper created
5. Looper.loop() starts
6. Main thread ready
```

**Main Looper**:
```kotlin
// Created automatically
val mainLooper = Looper.getMainLooper()

// Used by:
Activity.onCreate() // Runs on main thread
View.onDraw()        // Runs on main thread
Handler(Looper.getMainLooper()) // Handler for UI
```

### UI Thread Operations

**Why Main Thread?**:
- **Thread safety**: UI not thread-safe
- **Consistency**: Single thread for UI updates
- **Performance**: Avoids synchronization overhead

**Posting to Main Thread**:
```kotlin
// From background thread
Handler(Looper.getMainLooper()).post {
    // Runs on main thread
    updateUI()
}

// Or using Activity
runOnUiThread {
    // Runs on main thread
    updateUI()
}
```

## Background Threads

### Creating Background Thread with Looper

**Standard Pattern**:
```kotlin
class WorkerThread : Thread() {
    lateinit var handler: Handler
    
    override fun run() {
        Looper.prepare() // Prepare Looper
        handler = Handler() // Create Handler
        Looper.loop() // Start loop
    }
    
    fun quit() {
        handler.looper.quit()
    }
}

// Usage
val workerThread = WorkerThread()
workerThread.start()
workerThread.handler.post {
    // Runs on worker thread
}
```

### HandlerThread

**Built-in Solution**:
```kotlin
val handlerThread = HandlerThread("WorkerThread")
handlerThread.start()
val handler = Handler(handlerThread.looper)

handler.post {
    // Runs on HandlerThread
}

// Cleanup
handlerThread.quit()
```

**Benefits**:
- **Simpler**: Less boilerplate
- **Managed**: Handles lifecycle
- **Standard**: Android framework class

## Common Patterns & Best Practices

### Pattern 1: UI Updates from Background

```kotlin
class MyActivity : AppCompatActivity() {
    private val mainHandler = Handler(Looper.getMainLooper())
    
    fun loadData() {
        // Background work
        thread {
            val data = fetchData()
            
            // Update UI on main thread
            mainHandler.post {
                updateUI(data)
            }
        }
    }
}
```

### Pattern 2: Delayed Execution

```kotlin
class MyActivity : AppCompatActivity() {
    private val handler = Handler(Looper.getMainLooper())
    
    fun scheduleWork() {
        handler.postDelayed({
            // Runs after 1 second
            doWork()
        }, 1000)
    }
    
    override fun onDestroy() {
        super.onDestroy()
        // Cancel pending messages
        handler.removeCallbacksAndMessages(null)
    }
}
```

### Pattern 3: Periodic Updates

```kotlin
class MyActivity : AppCompatActivity() {
    private val handler = Handler(Looper.getMainLooper())
    private var updateCallback: Runnable? = null
    
    fun startUpdates() {
        updateCallback = object : Runnable {
            override fun run() {
                updateUI()
                handler.postDelayed(this, 1000) // Schedule next
            }
        }
        handler.post(updateCallback!!)
    }
    
    fun stopUpdates() {
        updateCallback?.let {
            handler.removeCallbacks(it)
        }
    }
}
```

### Pattern 4: Message-Based Communication

```kotlin
class WorkerThread : Thread() {
    lateinit var handler: Handler
    
    override fun run() {
        Looper.prepare()
        handler = Handler {
            when (it.what) {
                MSG_START -> handleStart()
                MSG_STOP -> handleStop()
                MSG_DATA -> handleData(it.obj as Data)
            }
            true
        }
        Looper.loop()
    }
    
    companion object {
        const val MSG_START = 1
        const val MSG_STOP = 2
        const val MSG_DATA = 3
    }
}

// Usage
val msg = Message.obtain().apply {
    what = WorkerThread.MSG_DATA
    obj = data
}
workerThread.handler.sendMessage(msg)
```

## Real Code Examples

### Example 1: Custom Looper Thread

```kotlin
class CustomLooperThread(name: String) : Thread(name) {
    private var looper: Looper? = null
    lateinit var handler: Handler
    
    override fun run() {
        Looper.prepare()
        synchronized(this) {
            looper = Looper.myLooper()
            handler = Handler(looper!!)
            notifyAll()
        }
        Looper.loop()
    }
    
    fun quit() {
        looper?.quit()
    }
    
    fun waitForLooper() {
        synchronized(this) {
            while (looper == null) {
                try {
                    wait()
                } catch (e: InterruptedException) {
                    // Ignore
                }
            }
        }
    }
}

// Usage
val thread = CustomLooperThread("Worker")
thread.start()
thread.waitForLooper()
thread.handler.post {
    // Runs on custom thread
}
```

### Example 2: Message-Based Task Queue

```kotlin
class TaskQueue {
    private val handlerThread = HandlerThread("TaskQueue").apply { start() }
    private val handler = Handler(handlerThread.looper)
    
    fun enqueue(task: Task) {
        handler.post {
            task.execute()
        }
    }
    
    fun enqueueDelayed(task: Task, delayMs: Long) {
        handler.postDelayed({
            task.execute()
        }, delayMs)
    }
    
    fun shutdown() {
        handlerThread.quit()
    }
}
```

## Common Pitfalls

### Problem: Memory Leak with Handler

```kotlin
// BAD: Handler holds reference to Activity
class LeakyActivity : AppCompatActivity() {
    private val handler = Handler {
        // Handler holds implicit reference to Activity
        // Activity cannot be GC'd
        updateUI()
        true
    }
}

// GOOD: Use static Handler or WeakReference
class SafeActivity : AppCompatActivity() {
    private class MyHandler(activity: SafeActivity) : Handler(Looper.getMainLooper()) {
        private val activityRef = WeakReference(activity)
        
        override fun handleMessage(msg: Message) {
            activityRef.get()?.let { activity ->
                activity.updateUI()
            }
        }
    }
    
    private val handler = MyHandler(this)
}
```

### Problem: Not Removing Callbacks

```kotlin
// BAD: Callbacks not removed
class LeakyActivity : AppCompatActivity() {
    private val handler = Handler(Looper.getMainLooper())
    
    fun startUpdates() {
        handler.postDelayed({
            updateUI()
            startUpdates() // Recursive
        }, 1000)
    }
    // Callbacks never removed → Memory leak
}

// GOOD: Remove callbacks
class SafeActivity : AppCompatActivity() {
    private val handler = Handler(Looper.getMainLooper())
    private var updateCallback: Runnable? = null
    
    fun startUpdates() {
        updateCallback = {
            updateUI()
            handler.postDelayed(updateCallback!!, 1000)
        }
        handler.post(updateCallback!!)
    }
    
    override fun onDestroy() {
        super.onDestroy()
        updateCallback?.let {
            handler.removeCallbacks(it)
        }
    }
}
```

### Problem: Blocking Main Thread

```kotlin
// BAD: Blocking operation on main thread
Handler(Looper.getMainLooper()).post {
    val data = heavyComputation() // Blocks UI thread!
    updateUI(data)
}

// GOOD: Do work off main thread
thread {
    val data = heavyComputation()
    Handler(Looper.getMainLooper()).post {
        updateUI(data)
    }
}
```

## Quiz

1. What is the relationship between Looper, Handler, and MessageQueue?
   - **A)** One Handler per Looper, one MessageQueue per Handler
   - **B)** One Looper per thread, one MessageQueue per Looper, multiple Handlers per Looper
   - **C)** One MessageQueue per Handler, one Looper per MessageQueue
   - **D)** No relationship

2. What happens when you call Looper.loop()?
   - **A)** Processes one message and returns
   - **B)** Loops infinitely processing messages until quit
   - **C)** Processes all messages and returns
   - **D)** Does nothing

3. Why is message pooling used?
   - **A)** To store messages permanently
   - **B)** To avoid allocations and reduce GC pressure
   - **C)** To share messages between threads
   - **D)** To encrypt messages

**Answers:**
1. **B** - One Looper per thread, one MessageQueue per Looper, and multiple Handlers can be associated with the same Looper
2. **B** - Looper.loop() runs an infinite loop processing messages from the MessageQueue until quit() is called
3. **B** - Message pooling reuses Message objects to avoid allocations and reduce garbage collection pressure

## Next Steps

- [Kotlin Coroutines Basics](../01_beginners/03.%20Kotlin%20Coroutines%20Basics.md) - Modern alternative
- [Advanced Coroutines & Cancellation](./05.%20Advanced%20Coroutines%20%26%20Cancellation.md) - Advanced patterns

