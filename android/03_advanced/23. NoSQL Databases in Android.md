---
number: 23
title: "NoSQL Databases in Android"
slug: "nosql-databases-android"
level: "advanced"
tags: ["nosql", "database", "firebase", "realm", "mongodb"]
prerequisites: ["room-database-data-persistence"]
estimated_minutes: 55
contributors: []
diagrams: []
examples: []
canonical_id: "android-23"
---

# NoSQL Databases in Android

## Overview

NoSQL databases offer flexible schema design and are ideal for unstructured data, real-time synchronization, and cloud-based storage. This guide covers Firebase Firestore, Realm, and when to choose NoSQL over SQL databases like Room.

## Deep Explanation

### NoSQL vs SQL

**SQL (Room):**
- Structured data with relationships
- ACID transactions
- Complex queries
- Local-first

**NoSQL (Firestore/Realm):**
- Flexible schema
- Real-time sync
- Cloud-native
- Document/object storage

### When to Use NoSQL

- Real-time collaboration features
- Flexible, evolving data structures
- Cloud synchronization required
- Unstructured or semi-structured data

## Real Code Examples

### Firebase Firestore

```kotlin
// Add dependency: implementation 'com.google.firebase:firebase-firestore-ktx'

class FirestoreRepository {
    private val db = FirebaseFirestore.getInstance()
    
    // Write data
    fun addUser(user: User) {
        db.collection("users")
            .add(user)
            .addOnSuccessListener { documentReference ->
                // Success
            }
            .addOnFailureListener { e ->
                // Error
            }
    }
    
    // Read data
    fun getUsers(callback: (List<User>) -> Unit) {
        db.collection("users")
            .get()
            .addOnSuccessListener { result ->
                val users = result.toObjects(User::class.java)
                callback(users)
            }
    }
    
    // Real-time updates
    fun observeUsers(callback: (List<User>) -> Unit) {
        db.collection("users")
            .addSnapshotListener { snapshot, e ->
                if (e != null) return@addSnapshotListener
                snapshot?.let {
                    val users = it.toObjects(User::class.java)
                    callback(users)
                }
            }
    }
    
    // Query
    fun getUsersByAge(minAge: Int) {
        db.collection("users")
            .whereGreaterThan("age", minAge)
            .get()
            .addOnSuccessListener { result ->
                // Process results
            }
    }
}
```

### Realm Database

```kotlin
// Add dependency: implementation 'io.realm:realm-android-library'

// Define Realm model
open class User : RealmObject() {
    @PrimaryKey
    var id: String = ""
    var name: String = ""
    var email: String = ""
}

class RealmRepository {
    private val realm: Realm = Realm.getDefaultInstance()
    
    // Write
    fun saveUser(user: User) {
        realm.executeTransaction {
            it.copyToRealmOrUpdate(user)
        }
    }
    
    // Read
    fun getUsers(): List<User> {
        return realm.where(User::class.java).findAll()
    }
    
    // Query
    fun getUsersByName(name: String): List<User> {
        return realm.where(User::class.java)
            .equalTo("name", name)
            .findAll()
    }
    
    // Observe changes
    fun observeUsers(callback: (RealmResults<User>) -> Unit) {
        val users = realm.where(User::class.java).findAll()
        users.addChangeListener { results ->
            callback(results)
        }
    }
}
```

## Common Pitfalls

### Problem: Not handling offline scenarios

**BAD:**
```kotlin
// Assumes always online
db.collection("users").get().addOnSuccessListener { ... }
```

**GOOD:**
```kotlin
// Enable offline persistence
val settings = FirebaseFirestoreSettings.Builder()
    .setPersistenceEnabled(true)
    .build()
db.firestoreSettings = settings
```

## Quiz

1. When should you use NoSQL over SQL?
   - **A)** Always
   - **B)** For structured relational data
   - **C)** For real-time sync and flexible schemas
   - **D)** Never

2. What is Firestore's main advantage?
   - **A)** Local storage
   - **B)** Real-time synchronization
   - **C)** Complex joins
   - **D)** ACID transactions

**Answers:**
1. **C** - NoSQL is best for real-time sync and flexible data structures
2. **B** - Firestore excels at real-time synchronization across devices

## Next Steps

- [Room Database & Data Persistence](../01_beginners/04.%20Room%20Database%20%26%20Data%20Persistence.md) - SQL databases
- [Building Offline-First Apps](./22.%20Building%20Offline-First%20Apps.md) - Offline strategies

