---
number: 33
title: "Android OS Internals - Power Management"
slug: "android-os-internals-power-management"
level: "advanced"
tags: ["android", "os", "internals", "power", "doze", "app-standby", "wakelocks", "battery"]
prerequisites: ["android-os-internals-rendering-pipeline"]
estimated_minutes: 110
contributors: []
diagrams: []
examples: []
canonical_id: "android-33"
---

# Android OS Internals - Power Management

## Overview

Android's power management system is crucial for battery life. Understanding Doze mode, App Standby, wakelocks, battery stats, and how Android manages power consumption is essential for building battery-efficient applications. This comprehensive guide covers all aspects of Android's power management internals.

## Table of Contents

1. [Power Management Overview](#overview)
2. [Doze Mode](#doze-mode)
3. [App Standby](#app-standby)
4. [Wakelocks](#wakelocks)
5. [Battery Stats](#battery-stats)
6. [Power Optimization](#power-optimization)
7. [Battery Optimization APIs](#battery-apis)

## Power Management Overview

### Power Consumption Sources

**Major Power Consumers**:
- **CPU**: Processing computations
- **Display**: Screen brightness
- **Radio**: Cellular, WiFi, Bluetooth
- **GPS**: Location services
- **Sensors**: Accelerometer, gyroscope, etc.

### Android Power Management Goals

**Objectives**:
- **Maximize battery life**: Extend device usage
- **Maintain responsiveness**: Don't sacrifice UX
- **Background restrictions**: Limit background activity
- **User control**: Allow user preferences

### Power Management Components

**1. Doze Mode**:
- Aggressive battery saving when device idle
- Restricts app activity
- Android 6.0+

**2. App Standby**:
- Puts unused apps in standby
- Restricts background activity
- Android 6.0+

**3. Wakelocks**:
- Prevent CPU from sleeping
- Must be used carefully
- Can drain battery

**4. Battery Optimization**:
- System optimizations
- User exemptions
- App restrictions

## Doze Mode

### What is Doze Mode?

**Doze Mode**: Aggressive power-saving mode when device is idle

**Triggered When**:
- Device is stationary (no movement)
- Screen is off
- Device is unplugged
- No recent user interaction

### Doze Mode States

**State 1: Light Doze** (Android 7.0+):
```
- Partial restrictions
- Network access limited
- Jobs delayed
- Alarms deferred
```

**State 2: Deep Doze**:
```
- Full restrictions
- Network access blocked (except whitelist)
- Jobs suspended
- Alarms deferred
- Wake locks ignored
- GPS disabled
- Wi-Fi scans disabled
```

### Doze Mode Restrictions

**Network Access**:
- **Blocked**: Most network access
- **Whitelist**: Apps on whitelist can access network
- **Maintenance windows**: Periodic network access allowed

**Wake Locks**:
- **Ignored**: Wake locks don't prevent sleep
- **Exceptions**: Some system wake locks still work

**Jobs**:
- **Deferred**: JobScheduler jobs delayed
- **Maintenance windows**: Jobs run during windows

**Alarms**:
- **Deferred**: Alarms delayed until maintenance window
- **Exceptions**: RTC_WAKEUP alarms still work (with restrictions)

**GPS**:
- **Disabled**: Location services suspended
- **Exceptions**: Foreground services can still use GPS

**Wi-Fi Scans**:
- **Disabled**: Wi-Fi scanning suspended
- **Maintenance windows**: Scans allowed during windows

### Doze Mode Maintenance Windows

**Purpose**: Periodic windows for app activity

**Frequency**:
- **First hour**: Every 15 minutes
- **After first hour**: Every 30 minutes
- **After several hours**: Every 60 minutes

**What Happens**:
- Network access restored
- Jobs can run
- Alarms can fire
- Apps can sync

**Duration**: ~5 minutes per window

### Testing Doze Mode

**Enable Doze Mode**:
```bash
# Via ADB
adb shell dumpsys battery unplug
adb shell dumpsys deviceidle force-idle

# Check status
adb shell dumpsys deviceidle
```

**Exiting Doze**:
- Wake device (screen on)
- Move device (motion detected)
- Plug in charger

### Handling Doze Mode

**1. Use GCM/FCM for Notifications**:
```kotlin
// GCM/FCM can wake device from Doze
// Use for important notifications
FirebaseMessaging.getInstance().token.addOnCompleteListener { task ->
    val token = task.result
    // Send to server
}
```

**2. Request Whitelist** (if needed):
```kotlin
// Request user to whitelist app
if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
    val pm = getSystemService(Context.POWER_SERVICE) as PowerManager
    val isIgnoringBatteryOptimizations = pm.isIgnoringBatteryOptimizations(packageName)
    
    if (!isIgnoringBatteryOptimizations) {
        val intent = Intent(Settings.ACTION_REQUEST_IGNORE_BATTERY_OPTIMIZATIONS).apply {
            data = Uri.parse("package:$packageName")
        }
        startActivity(intent)
    }
}
```

**3. Use Foreground Services**:
```kotlin
// Foreground services less restricted
class MyForegroundService : Service() {
    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
        val notification = createNotification()
        startForeground(1, notification)
        return START_STICKY
    }
}
```

## App Standby

### What is App Standby?

**App Standby**: Puts unused apps in standby mode

**Triggered When**:
- App not used for several days
- App has no foreground components
- No user-initiated actions

### App Standby Restrictions

**Network Access**:
- **Blocked**: No network access
- **Exceptions**: Foreground services, high-priority FCM

**Jobs**:
- **Deferred**: JobScheduler jobs delayed
- **Batching**: Jobs batched together

**Syncs**:
- **Deferred**: SyncAdapter syncs delayed
- **Batching**: Syncs batched together

**Alarms**:
- **Deferred**: Alarms delayed
- **Batching**: Alarms batched

### App Standby Buckets

**Android 9.0+ Bucket System**:

**1. Active**:
- App currently in use
- No restrictions

**2. Working Set**:
- App used regularly
- Minimal restrictions

**3. Frequent**:
- App used occasionally
- Some restrictions

**4. Rare**:
- App rarely used
- Strong restrictions

**5. Never**:
- App never used
- Maximum restrictions

### Checking App Standby Status

```kotlin
if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P) {
    val appStandby = getSystemService(Context.USAGE_STATS_SERVICE) as UsageStatsManager
    val standbyBucket = appStandby.appStandbyBucket
    
    when (standbyBucket) {
        UsageStatsManager.STANDBY_BUCKET_ACTIVE -> {
            // No restrictions
        }
        UsageStatsManager.STANDBY_BUCKET_WORKING_SET -> {
            // Minimal restrictions
        }
        UsageStatsManager.STANDBY_BUCKET_FREQUENT -> {
            // Some restrictions
        }
        UsageStatsManager.STANDBY_BUCKET_RARE -> {
            // Strong restrictions
        }
        UsageStatsManager.STANDBY_BUCKET_NEVER -> {
            // Maximum restrictions
        }
    }
}
```

### Exiting App Standby

**Ways to Exit**:
- **User opens app**: Immediately exits standby
- **Foreground service**: App exits standby
- **High-priority notification**: Can exit standby
- **User interaction**: Any user action

## Wakelocks

### What is a Wakelock?

**Wakelock**: Prevents CPU from sleeping

**Purpose**: Keep device awake for operations

**Types**:
- **Partial wakelock**: Keeps CPU awake, screen can be off
- **Full wakelock**: Keeps screen on
- **Screen dim wakelock**: Keeps screen dimmed

### Wakelock Types

**PARTIAL_WAKE_LOCK**:
```kotlin
// Keeps CPU awake, screen can be off
val wakeLock = powerManager.newWakeLock(
    PowerManager.PARTIAL_WAKE_LOCK,
    "MyApp::WakeLock"
)
wakeLock.acquire()
// Do work
wakeLock.release()
```

**SCREEN_DIM_WAKE_LOCK** (deprecated):
```kotlin
// Keeps screen dimmed
// Deprecated, use Window flags instead
```

**SCREEN_BRIGHT_WAKE_LOCK** (deprecated):
```kotlin
// Keeps screen bright
// Deprecated, use Window flags instead
```

**FULL_WAKE_LOCK** (deprecated):
```kotlin
// Keeps screen bright and keyboard on
// Deprecated, use Window flags instead
```

### Using Wakelocks

**Acquiring Wakelock**:
```kotlin
val powerManager = getSystemService(Context.POWER_SERVICE) as PowerManager
val wakeLock = powerManager.newWakeLock(
    PowerManager.PARTIAL_WAKE_LOCK,
    "MyApp::WakeLock"
)

wakeLock.acquire(10 * 60 * 1000L) // 10 minutes timeout
// Do work
wakeLock.release()
```

**Best Practices**:
- **Always release**: Use try-finally
- **Use timeouts**: Prevent indefinite holding
- **Minimize usage**: Only when necessary
- **Use WorkManager**: For background work instead

**Example**:
```kotlin
class MyService : Service() {
    private var wakeLock: PowerManager.WakeLock? = null
    
    override fun onCreate() {
        super.onCreate()
        val powerManager = getSystemService(Context.POWER_SERVICE) as PowerManager
        wakeLock = powerManager.newWakeLock(
            PowerManager.PARTIAL_WAKE_LOCK,
            "MyService::WakeLock"
        )
    }
    
    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
        wakeLock?.acquire(10 * 60 * 1000L) // 10 minutes
        
        try {
            // Do work
            doWork()
        } finally {
            wakeLock?.release()
        }
        
        return START_STICKY
    }
    
    override fun onDestroy() {
        super.onDestroy()
        wakeLock?.release()
    }
}
```

### Wakelock Restrictions

**Doze Mode**:
- **Ignored**: Wake locks don't prevent Doze
- **Exceptions**: Some system wake locks still work

**App Standby**:
- **Restricted**: Wake locks less effective
- **Battery optimization**: May be ignored

**Best Practice**: Use WorkManager or Foreground Services instead

## Battery Stats

### What are Battery Stats?

**Battery Stats**: System tracking of power consumption

**Tracks**:
- **App usage**: Which apps use battery
- **Wake locks**: Wakelock usage per app
- **Network**: Network usage per app
- **CPU**: CPU time per app
- **GPS**: Location usage per app

### Accessing Battery Stats

**Via Settings**:
```
Settings → Battery → Battery Usage
Shows per-app battery usage
```

**Via ADB**:
```bash
# Dump battery stats
adb shell dumpsys batterystats

# Reset battery stats
adb shell dumpsys batterystats --reset
```

**Programmatically**:
```kotlin
// Get battery usage (requires BATTERY_STATS permission)
// Usually not accessible to apps
// Use BatteryManager for basic info
val batteryManager = getSystemService(Context.BATTERY_SERVICE) as BatteryManager
val batteryLevel = batteryManager.getIntProperty(BatteryManager.BATTERY_PROPERTY_CAPACITY)
```

### Battery Usage Breakdown

**Components Tracked**:
- **CPU**: CPU time and wake locks
- **Network**: Mobile data and Wi-Fi usage
- **GPS**: Location requests
- **Wake locks**: Wakelock hold time
- **Foreground time**: Time app in foreground

**Example Output**:
```
com.example.app:
  CPU: 2h 30m
  Network: 50MB
  GPS: 15m
  Wake locks: 5m
  Foreground: 1h
```

## Power Optimization

### Optimization Strategies

**1. Minimize Wake Locks**:
```kotlin
// BAD: Hold wakelock unnecessarily
wakeLock.acquire()
doQuickWork() // Only takes 1 second
wakeLock.release() // Held for longer than needed

// GOOD: Use WorkManager
WorkManager.getInstance(this)
    .enqueue(OneTimeWorkRequestBuilder<MyWorker>().build())
```

**2. Batch Operations**:
```kotlin
// BAD: Many small network requests
items.forEach { item ->
    networkRequest(item) // Many wake-ups
}

// GOOD: Batch requests
val batch = items.chunked(10)
batch.forEach { batchItems ->
    networkRequest(batchItems) // Fewer wake-ups
}
```

**3. Use JobScheduler**:
```kotlin
// Schedule work efficiently
val jobInfo = JobInfo.Builder(1, ComponentName(this, MyJobService::class.java))
    .setRequiredNetworkType(JobInfo.NETWORK_TYPE_UNMETERED)
    .setRequiresCharging(true)
    .setPeriodic(15 * 60 * 1000L) // 15 minutes
    .build()

val jobScheduler = getSystemService(Context.JOB_SCHEDULER_SERVICE) as JobScheduler
jobScheduler.schedule(jobInfo)
```

**4. Optimize Location Updates**:
```kotlin
// BAD: High frequency updates
locationRequest.interval = 1000 // 1 second

// GOOD: Lower frequency when possible
locationRequest.interval = 60000 // 1 minute
locationRequest.fastestInterval = 30000 // 30 seconds minimum
```

**5. Reduce Network Usage**:
```kotlin
// BAD: Frequent polling
Timer().scheduleAtFixedRate(timerTask {
    fetchData() // Every second
}, 0, 1000)

// GOOD: Use push notifications or longer intervals
// Or use WorkManager with constraints
```

## Battery Optimization APIs

### Checking Optimization Status

```kotlin
if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
    val powerManager = getSystemService(Context.POWER_SERVICE) as PowerManager
    val isIgnoring = powerManager.isIgnoringBatteryOptimizations(packageName)
    
    if (!isIgnoring) {
        // App is being optimized (restricted)
    } else {
        // App is whitelisted (less restricted)
    }
}
```

### Requesting Whitelist

```kotlin
fun requestBatteryOptimizationWhitelist() {
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
        val powerManager = getSystemService(Context.POWER_SERVICE) as PowerManager
        
        if (!powerManager.isIgnoringBatteryOptimizations(packageName)) {
            val intent = Intent(Settings.ACTION_REQUEST_IGNORE_BATTERY_OPTIMIZATIONS).apply {
                data = Uri.parse("package:$packageName")
            }
            startActivity(intent)
        }
    }
}
```

### Background Restrictions

**Android 8.0+ Background Limits**:
- **Background execution limits**: Restricted background execution
- **Background location limits**: Restricted location updates
- **Background service limits**: Services killed more aggressively

**Handling Restrictions**:
```kotlin
// Use Foreground Services for important work
class MyForegroundService : Service() {
    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
        val notification = createNotification()
        startForeground(1, notification)
        return START_STICKY
    }
}

// Use WorkManager for background work
WorkManager.getInstance(this)
    .enqueue(OneTimeWorkRequestBuilder<MyWorker>()
        .setConstraints(Constraints.Builder()
            .setRequiredNetworkType(NetworkType.CONNECTED)
            .build())
        .build())
```

## Real Code Examples

### Example 1: Power-Efficient Background Work

```kotlin
class PowerEfficientWorker(context: Context, params: WorkerParameters) : Worker(context, params) {
    override fun doWork(): Result {
        // WorkManager handles power optimization
        // Runs during maintenance windows
        // Batched with other work
        
        return try {
            // Do work
            performWork()
            Result.success()
        } catch (e: Exception) {
            Result.retry() // Retry if failed
        }
    }
}

// Schedule work
val workRequest = OneTimeWorkRequestBuilder<PowerEfficientWorker>()
    .setConstraints(Constraints.Builder()
        .setRequiredNetworkType(NetworkType.UNMETERED)
        .setRequiresCharging(true)
        .build())
    .setInitialDelay(1, TimeUnit.HOURS)
    .build()

WorkManager.getInstance(context).enqueue(workRequest)
```

### Example 2: Handling Doze Mode

```kotlin
class DozeAwareService : Service() {
    private val notificationManager by lazy {
        getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
    }
    
    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
        // Check if in Doze mode
        val powerManager = getSystemService(Context.POWER_SERVICE) as PowerManager
        
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
            val isDeviceIdleMode = powerManager.isDeviceIdleMode
            
            if (isDeviceIdleMode) {
                // In Doze mode
                // Use high-priority notification to wake device
                showHighPriorityNotification()
            } else {
                // Normal operation
                doWork()
            }
        }
        
        return START_STICKY
    }
    
    private fun showHighPriorityNotification() {
        val notification = NotificationCompat.Builder(this, CHANNEL_ID)
            .setContentTitle("Important")
            .setContentText("Wake from Doze")
            .setPriority(NotificationCompat.PRIORITY_HIGH)
            .setCategory(NotificationCompat.CATEGORY_ALARM)
            .build()
        
        notificationManager.notify(1, notification)
    }
}
```

## Common Pitfalls

### Problem: Holding Wake Locks Too Long

```kotlin
// BAD: Indefinite wake lock
wakeLock.acquire() // No timeout!
doWork()
// If work fails, wake lock never released

// GOOD: Use timeout and try-finally
wakeLock.acquire(10 * 60 * 1000L) // 10 minutes timeout
try {
    doWork()
} finally {
    wakeLock.release() // Always released
}
```

### Problem: Not Handling Doze Mode

```kotlin
// BAD: Assume network always available
fun syncData() {
    networkRequest() // Might fail in Doze mode!
}

// GOOD: Handle Doze restrictions
fun syncData() {
    if (isInDozeMode()) {
        // Schedule for maintenance window
        scheduleForMaintenanceWindow()
    } else {
        networkRequest()
    }
}
```

## Quiz

1. What triggers Doze mode?
   - **A)** Low battery
   - **B)** Device idle (stationary, screen off, unplugged)
   - **C)** Too many apps running
   - **D)** Network unavailable

2. What happens to wake locks in Doze mode?
   - **A)** They work normally
   - **B)** They are ignored (don't prevent Doze)
   - **C)** They are stronger
   - **D)** They are automatically released

3. What is App Standby?
   - **A)** App sleeping
   - **B)** Puts unused apps in standby with restrictions
   - **C)** App paused
   - **D)** App killed

**Answers:**
1. **B** - Doze mode triggers when device is idle (stationary, screen off, unplugged)
2. **B** - Wake locks are ignored in Doze mode (don't prevent device from entering Doze)
3. **B** - App Standby puts unused apps in standby mode with network and background restrictions

## Next Steps

- [Performance Profiling & Memory Leaks](./21.%20Performance%20Profiling%20%26%20Memory%20Leaks.md) - Profiling power usage
- [WorkManager & Background Tasks](../02_intermediate/13.%20WorkManager%20%26%20Background%20Tasks.md) - Power-efficient background work

