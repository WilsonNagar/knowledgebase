---
number: 4
title: "Room Database & Data Persistence"
slug: "room-database-data-persistence"
level: "beginner"
tags: ["room", "database", "persistence", "sqlite", "data-layer"]
prerequisites: ["introduction-to-android-architecture"]
estimated_minutes: 60
contributors: []
diagrams: []
examples: []
canonical_id: "android-beginner-04"
---




# Room Database & Data Persistence

## Overview

Room is Android's official persistence library that provides an abstraction layer over SQLite. It simplifies database operations, ensures compile-time query verification, and integrates seamlessly with LiveData and Flow for reactive data updates. Understanding Room is essential for building robust data layers in Android applications.

## Deep Explanation

### Why Room?

Before Room, developers had to:
- Write boilerplate SQL code
- Manually handle database migrations
- Manage database connections
- Convert between SQLite cursors and objects

Room solves these problems by:
- **Compile-time safety**: SQL queries are verified at compile time
- **Type-safe**: No raw SQL strings, everything is type-checked
- **Less boilerplate**: Annotations handle most of the work
- **Reactive**: Built-in support for LiveData and Flow
- **Migration support**: Easy database schema migrations

### Room Components

Room consists of three main components:

1. **Entity**: Represents a table in the database
2. **DAO (Data Access Object)**: Contains methods to access the database
3. **Database**: Main database class that ties everything together

## Real Code Examples

### Basic Room Setup

```kotlin
// 1. Entity - Represents a table
@Entity(tableName = "users")
data class User(
    @PrimaryKey(autoGenerate = true)
    val id: Int = 0,
    val name: String,
    val email: String,
    val age: Int
)

// 2. DAO - Database access methods
@Dao
interface UserDao {
    @Query("SELECT * FROM users")
    fun getAllUsers(): Flow<List<User>>
    
    @Query("SELECT * FROM users WHERE id = :id")
    suspend fun getUserById(id: Int): User?
    
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertUser(user: User)
    
    @Update
    suspend fun updateUser(user: User)
    
    @Delete
    suspend fun deleteUser(user: User)
}

// 3. Database - Main database class
@Database(
    entities = [User::class],
    version = 1,
    exportSchema = false
)
abstract class AppDatabase : RoomDatabase() {
    abstract fun userDao(): UserDao
    
    companion object {
        @Volatile
        private var INSTANCE: AppDatabase? = null
        
        fun getDatabase(context: Context): AppDatabase {
            return INSTANCE ?: synchronized(this) {
                val instance = Room.databaseBuilder(
                    context.applicationContext,
                    AppDatabase::class.java,
                    "app_database"
                ).build()
                INSTANCE = instance
                instance
            }
        }
    }
}
```

### Using Room with Repository Pattern

```kotlin
class UserRepository(private val userDao: UserDao) {
    fun getAllUsers(): Flow<List<User>> = userDao.getAllUsers()
    
    suspend fun getUserById(id: Int): User? = userDao.getUserById(id)
    
    suspend fun insertUser(user: User) = userDao.insertUser(user)
    
    suspend fun updateUser(user: User) = userDao.updateUser(user)
    
    suspend fun deleteUser(user: User) = userDao.deleteUser(user)
}
```

### Using Room with ViewModel

```kotlin
class UserViewModel(
    private val repository: UserRepository
) : ViewModel() {
    val users: Flow<List<User>> = repository.getAllUsers()
    
    fun insertUser(name: String, email: String, age: Int) {
        viewModelScope.launch {
            repository.insertUser(User(name = name, email = email, age = age))
        }
    }
}
```

### Complex Queries

```kotlin
@Dao
interface UserDao {
    // Query with parameters
    @Query("SELECT * FROM users WHERE age > :minAge")
    fun getUsersOlderThan(minAge: Int): Flow<List<User>>
    
    // Query with multiple conditions
    @Query("SELECT * FROM users WHERE name LIKE :searchQuery OR email LIKE :searchQuery")
    suspend fun searchUsers(searchQuery: String): List<User>
    
    // Join queries
    @Query("""
        SELECT * FROM users 
        INNER JOIN orders ON users.id = orders.userId 
        WHERE orders.total > :minTotal
    """)
    fun getUsersWithLargeOrders(minTotal: Double): Flow<List<User>>
    
    // Transactions
    @Transaction
    suspend fun updateUserAndOrders(user: User, orders: List<Order>) {
        updateUser(user)
        // Update orders...
    }
}
```

### Database Migrations

```kotlin
val MIGRATION_1_2 = object : Migration(1, 2) {
    override fun migrate(database: SupportSQLiteDatabase) {
        database.execSQL("ALTER TABLE users ADD COLUMN phone_number TEXT")
    }
}

val MIGRATION_2_3 = object : Migration(2, 3) {
    override fun migrate(database: SupportSQLiteDatabase) {
        database.execSQL("CREATE TABLE addresses (id INTEGER PRIMARY KEY, user_id INTEGER, address TEXT)")
    }
}

@Database(
    entities = [User::class, Address::class],
    version = 3,
    exportSchema = false
)
abstract class AppDatabase : RoomDatabase() {
    // ...
    
    companion object {
        fun getDatabase(context: Context): AppDatabase {
            return Room.databaseBuilder(
                context.applicationContext,
                AppDatabase::class.java,
                "app_database"
            )
            .addMigrations(MIGRATION_1_2, MIGRATION_2_3)
            .build()
        }
    }
}
```

## Common Pitfalls

### Problem: Not using suspend functions for database operations

**BAD:**
```kotlin
@Dao
interface UserDao {
    @Query("SELECT * FROM users")
    fun getAllUsers(): List<User> // Blocks main thread!
}
```

**GOOD:**
```kotlin
@Dao
interface UserDao {
    @Query("SELECT * FROM users")
    suspend fun getAllUsers(): List<User> // Runs on background thread
}
```

### Problem: Not handling database operations in coroutines

**BAD:**
```kotlin
class UserViewModel(private val repository: UserRepository) : ViewModel() {
    fun loadUsers() {
        val users = repository.getAllUsers() // Blocks!
        // ...
    }
}
```

**GOOD:**
```kotlin
class UserViewModel(private val repository: UserRepository) : ViewModel() {
    fun loadUsers() {
        viewModelScope.launch {
            val users = repository.getAllUsers()
            // ...
        }
    }
}
```

## Quiz

1. What are the three main components of Room?
   - **A)** Entity, DAO, Database
   - **B)** Model, View, Controller
   - **C)** Repository, ViewModel, View
   - **D)** SQLite, Cursor, ContentProvider

2. Why should database operations use suspend functions?
   - **A)** To make code cleaner
   - **B)** To avoid blocking the main thread
   - **C)** To use less memory
   - **D)** To improve compile time

3. How do you handle database migrations in Room?
   - **A)** Delete and recreate the database
   - **B)** Use Migration objects with version numbers
   - **C)** Manually update SQLite
   - **D)** Room handles it automatically

**Answers:**
1. **A** - Entity represents tables, DAO provides access methods, Database ties everything together
2. **B** - Suspend functions run on background threads, preventing UI blocking
3. **B** - Migration objects define how to upgrade from one version to another

## Next Steps

- [Building Offline-First Apps](../03_advanced/22.%20Building%20Offline-First%20Apps.md) - Advanced Room usage
- [Introduction to Android Architecture](./01.%20Introduction%20to%20Android%20Architecture.md) - Repository pattern

