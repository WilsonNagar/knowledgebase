---
number: 8
title: "Garbage Collection Fundamentals"
slug: "garbage-collection-fundamentals"
level: "beginner"
tags: ["gc", "garbage-collection", "memory-management", "heap", "algorithms"]
prerequisites: ["jvm-architecture-java-memory-model"]
estimated_minutes: 100
contributors: []
diagrams: []
examples: []
canonical_id: "android-beginner-08"
---




# Garbage Collection Fundamentals

## Overview

Garbage Collection is the automatic memory management system in Java and Android. This comprehensive guide covers how garbage collectors work, different GC algorithms (Mark & Sweep, Mark-Compact, Copying, Generational), GC pauses, and performance optimization. Understanding GC is essential for writing memory-efficient Android applications.

## Table of Contents

1. [What is Garbage Collection?](#what-is-gc)
2. [How Garbage Collectors Work](#how-gc-works)
3. [Mark & Sweep Algorithm](#mark-sweep)
4. [Mark-Compact GC](#mark-compact)
5. [Copying / Generational GC](#copying-generational)
6. [GC Pauses](#gc-pauses)
7. [GC Generations](#gc-generations)
8. [Reference Counting](#reference-counting)
9. [GC Tuning & Performance](#gc-tuning)

## What is Garbage Collection?

### The Problem: Manual Memory Management

**Without GC** (C/C++):
```c
// Manual allocation
int* array = malloc(100 * sizeof(int));

// Must manually free
free(array); // Forget this = memory leak!
```

**Problems**:
- **Memory leaks**: Forgetting to free memory
- **Use-after-free**: Using freed memory
- **Double-free**: Freeing same memory twice
- **Dangling pointers**: Pointers to freed memory

### The Solution: Automatic GC

**With GC** (Java/Kotlin):
```kotlin
val array = IntArray(100)
// No manual free needed!
// GC automatically collects when unreachable
```

**Benefits**:
- **No memory leaks**: Automatic cleanup
- **No use-after-free**: Objects valid until GC'd
- **Simpler code**: Focus on logic, not memory

**Costs**:
- **GC pauses**: Application stops during GC
- **CPU overhead**: GC uses CPU cycles
- **Memory overhead**: Extra memory for GC

## How Garbage Collectors Work

### GC Process Overview

```
1. Identify Garbage (unreachable objects)
   ↓
2. Mark Garbage Objects
   ↓
3. Optional: Finalize Objects
   ↓
4. Collect Garbage (free memory)
   ↓
5. Optional: Compact Heap
```

### GC Roots

**GC Roots**: Starting points for reachability analysis

**Types of GC Roots**:
1. **Static variables**: `static Object obj`
2. **Local variables**: Active method parameters
3. **Active threads**: Thread objects
4. **JNI references**: Native code references
5. **Monitor locks**: Objects used in synchronized

### Reachability Analysis

```
GC Roots
  ↓
Object A (reachable)
  ↓
Object B (reachable)
  ↓
Object C (reachable)

Object D (unreachable) ← Garbage
Object E (unreachable) ← Garbage
```

**Algorithm**:
1. Start from GC roots
2. Mark all reachable objects
3. Unmarked objects = garbage
4. Collect garbage

## Mark & Sweep Algorithm

### Algorithm Steps

**Phase 1: Mark**
```
1. Start from GC roots
2. Traverse object graph
3. Mark all reachable objects
```

**Phase 2: Sweep**
```
1. Scan entire heap
2. Find unmarked objects
3. Free their memory
```

### Visual Example

```
Before GC:
┌─────┬─────┬─────┬─────┬─────┐
│  A  │  B  │  C  │  D  │  E  │
│  ✓  │  ✓  │  ✗  │  ✗  │  ✓  │
└─────┴─────┴─────┴─────┴─────┘
      ↑           ↑
   Reachable   Garbage

After Mark & Sweep:
┌─────┬─────┬─────┬─────┬─────┐
│  A  │  B  │  ?  │  ?  │  ✓  │
│  ✓  │  ✓  │free │free │  ✓  │
└─────┴─────┴─────┴─────┴─────┘
```

### Implementation Example

```kotlin
// Simplified Mark & Sweep
class MarkAndSweepGC {
    fun mark(root: Object) {
        val visited = mutableSetOf<Object>()
        val stack = mutableListOf(root)
        
        while (stack.isNotEmpty()) {
            val obj = stack.removeAt(stack.size - 1)
            if (visited.add(obj)) {
                obj.marked = true
                stack.addAll(obj.references) // Mark referenced objects
            }
        }
    }
    
    fun sweep(heap: List<Object>) {
        heap.forEach { obj ->
            if (!obj.marked) {
                freeMemory(obj) // Free garbage
            } else {
                obj.marked = false // Reset for next GC
            }
        }
    }
}
```

### Advantages

- **Simple**: Easy to understand and implement
- **No moving**: Objects stay in place
- **Handles cycles**: Detects circular references

### Disadvantages

- **Fragmentation**: Creates memory holes
- **Stop-the-world**: Pauses application
- **Slow**: Scans entire heap

## Mark-Compact GC

### Algorithm Steps

**Phase 1: Mark** (same as Mark & Sweep)
```
Mark all reachable objects
```

**Phase 2: Compact**
```
1. Move reachable objects together
2. Update all references
3. Free space at end
```

### Visual Example

```
Before GC:
┌─────┬─────┬─────┬─────┬─────┐
│  A  │  ✗  │  B  │  ✗  │  C  │
└─────┴─────┴─────┴─────┴─────┘
      ↑           ↑
   Fragmented

After Mark-Compact:
┌─────┬─────┬─────┬─────┬─────┐
│  A  │  B  │  C  │free │free │
└─────┴─────┴─────┴─────┴─────┘
      ↑
   Compacted
```

### Advantages

- **No fragmentation**: Memory is compacted
- **Better allocation**: Contiguous free space
- **Cache friendly**: Objects close together

### Disadvantages

- **More overhead**: Moving objects is expensive
- **Stop-the-world**: Longer pauses
- **Reference updates**: Must update all references

## Copying / Generational GC

### Basic Copying GC

**Concept**: Divide heap into two spaces

```
From Space          To Space
┌─────────┐        ┌─────────┐
│ Objects │   →    │         │
│  (old)  │  Copy  │ Objects │
│         │        │  (new)  │
└─────────┘        └─────────┘
```

**Process**:
1. Allocate in "From Space"
2. When full, copy live objects to "To Space"
3. Swap spaces
4. Repeat

### Generational Hypothesis

**Observation**: Most objects die young

```
Object Lifetime Distribution:
┌─────────────────────────┐
│                         │
│  Most objects           │ ← Die young
│  die quickly            │
│                         │
├─────────────────────────┤
│                         │
│  Few objects            │ ← Live long
│  survive                │
│                         │
└─────────────────────────┘
```

### Generational Heap Structure

```
┌─────────────────────────────────────┐
│         Young Generation             │
│  ┌──────────┬──────────┬──────────┐ │
│  │  Eden    │   S0     │    S1    │ │
│  │  (new)   │ (survivor)│(survivor)│ │
│  └──────────┴──────────┴──────────┘ │
├─────────────────────────────────────┤
│         Old Generation               │
│  ┌──────────────────────────────┐   │
│  │      Tenured Space            │   │
│  │   (long-lived objects)       │   │
│  └──────────────────────────────┘   │
└─────────────────────────────────────┘
```

### Generational GC Process

**Minor GC** (Young Generation):
```
1. Objects allocated in Eden
2. Eden fills up
3. Minor GC:
   - Mark live objects in Eden
   - Copy survivors to S0
   - Clear Eden
4. Survivors age (survive multiple GCs)
5. Promoted to Old Generation
```

**Major GC** (Full GC):
```
1. Old Generation fills up
2. Major GC:
   - Collect entire heap
   - Mark all live objects
   - Collect garbage
   - Compact (optional)
```

### Survivor Spaces

**Purpose**: Age objects before promoting to Old Generation

```
Eden → S0 → S1 → Old Generation

Process:
1. New objects in Eden
2. Minor GC: Survivors → S0
3. Next Minor GC: S0 survivors → S1
4. Next Minor GC: S1 survivors → S0
5. After N survivals → Promote to Old
```

## GC Pauses

### Stop-the-World Pauses

**What**: Application threads stop during GC

**Why**: 
- Need consistent heap state
- Can't modify objects during marking
- Reference updates must be atomic

**Impact**:
- Application freezes
- User-visible jank
- Latency spikes

### Types of GC Pauses

**1. Minor GC Pause**:
- Collects Young Generation only
- Usually fast (<10ms)
- Frequent (every few seconds)

**2. Major GC Pause**:
- Collects entire heap
- Slower (10ms - several seconds)
- Less frequent

**3. Full GC Pause**:
- Complete collection + compaction
- Slowest (can be seconds)
- Rare (when heap nearly full)

### Reducing Pauses

**Concurrent GC**:
- Marking happens concurrently
- Application continues running
- Shorter pauses

**Incremental GC**:
- GC work spread over time
- Smaller, more frequent pauses
- Better latency

## GC Generations

### Young Generation

**Purpose**: Hold newly created objects

**Characteristics**:
- **Small**: Usually 10-20% of heap
- **Fast GC**: Copying is fast
- **High turnover**: Most objects die here

**GC Frequency**: Very frequent (every few seconds)

### Old Generation

**Purpose**: Hold long-lived objects

**Characteristics**:
- **Large**: Usually 80-90% of heap
- **Slow GC**: Mark-Compact is slower
- **Low turnover**: Objects live long

**GC Frequency**: Less frequent (minutes/hours)

### Promotion Threshold

**Age-based Promotion**:
```
Object survives N Minor GCs → Promote to Old
```

**Size-based Promotion**:
```
Large object (>threshold) → Directly to Old
```

## Reference Counting

### How It Works

**Concept**: Each object has a reference count

```kotlin
val obj = MyObject() // refCount = 1

val ref2 = obj // refCount = 2

ref2 = null // refCount = 1

obj = null // refCount = 0 → GC'd immediately
```

### Why Not Used in Java?

**Problem 1: Circular References**

```kotlin
class Node {
    var next: Node? = null
}

val node1 = Node()
val node2 = Node()
node1.next = node2
node2.next = node1

// Both have refCount = 1
// But unreachable from roots
// Never GC'd! Memory leak!
```

**Problem 2: Performance**

- **Overhead**: Increment/decrement on every assignment
- **Atomic operations**: Need synchronization for thread safety
- **Cache misses**: Scattered reference count updates

**Problem 3: Stop-the-World**

- Still need pauses for cycles
- Doesn't eliminate pauses

### Where Reference Counting is Used

- **Python**: Uses reference counting + cycle detector
- **Objective-C**: Uses reference counting (ARC)
- **Swift**: Uses reference counting (ARC)
- **Not Java/Android**: Uses tracing GC instead

## GC Tuning & Performance

### GC Metrics

**1. Throughput**:
```
Throughput = (Total Time - GC Time) / Total Time
Goal: > 95%
```

**2. Latency**:
```
Pause Time: How long GC pauses application
Goal: < 10ms for Minor GC, < 100ms for Major GC
```

**3. Footprint**:
```
Heap Size: Memory used by application
Goal: Minimize while maintaining performance
```

### GC Tuning Strategies

#### 1. Heap Size Tuning

```bash
# Increase heap size
-Xms2g -Xmx4g

# -Xms: Initial heap size
# -Xmx: Maximum heap size
```

**Trade-offs**:
- **Larger heap**: Fewer GCs, longer pauses
- **Smaller heap**: More GCs, shorter pauses

#### 2. Generation Sizing

```bash
# Young generation size
-XX:NewRatio=2  # Old:Young = 2:1
-XX:NewSize=512m
-XX:MaxNewSize=1g
```

**Guidelines**:
- **Larger Young Gen**: Fewer promotions, more Minor GCs
- **Smaller Young Gen**: More promotions, fewer Minor GCs

#### 3. GC Algorithm Selection

**Serial GC** (Single thread):
```bash
-XX:+UseSerialGC
# Good for: Small apps, single-core
```

**Parallel GC** (Multi-threaded):
```bash
-XX:+UseParallelGC
# Good for: Throughput-focused apps
```

**G1 GC** (Low latency):
```bash
-XX:+UseG1GC
# Good for: Large heaps, low pause times
```

**ZGC** (Ultra-low latency):
```bash
-XX:+UseZGC
# Good for: Very large heaps, <10ms pauses
```

### Performance Optimization

#### Reduce Allocations

```kotlin
// BAD: Many allocations
fun process(items: List<Item>) {
    items.forEach { item ->
        val processed = item.toString() // Allocation
            .toLowerCase() // Allocation
            .trim() // Allocation
    }
}

// GOOD: Fewer allocations
fun process(items: List<Item>) {
    items.forEach { item ->
        val processed = buildString {
            append(item.toString().lowercase().trim())
        } // Single allocation
    }
}
```

#### Object Pooling

```kotlin
class ObjectPool<T>(private val factory: () -> T) {
    private val pool = mutableListOf<T>()
    
    fun acquire(): T {
        return if (pool.isNotEmpty()) {
            pool.removeAt(pool.size - 1)
        } else {
            factory()
        }
    }
    
    fun release(obj: T) {
        pool.add(obj)
    }
}

// Reuse objects instead of creating new ones
val pool = ObjectPool { StringBuilder() }
val sb = pool.acquire()
// Use sb
pool.release(sb) // Reuse instead of GC
```

## Real Code Examples

### Example 1: Understanding GC Behavior

```kotlin
fun demonstrateGC() {
    // Create objects
    val list = mutableListOf<LargeObject>()
    
    for (i in 0 until 1000) {
        list.add(LargeObject()) // Allocations in Young Gen
    }
    
    // Minor GC occurs when Eden fills
    // Survivors copied to Survivor Space
    // Most objects die (not referenced)
    // Few survivors promoted to Old Gen
    
    // Keep reference to some objects
    val kept = list.take(10)
    list.clear() // 990 objects become garbage
    
    // Next Minor GC collects 990 objects
    // 10 objects survive, age, eventually promote
}
```

### Example 2: Memory Pressure

```kotlin
fun causeMemoryPressure() {
    val largeList = mutableListOf<ByteArray>()
    
    while (true) {
        // Allocate large arrays
        largeList.add(ByteArray(10 * 1024 * 1024)) // 10MB each
        
        // When heap fills:
        // 1. Minor GC tries to free space
        // 2. Not enough space freed
        // 3. Major GC triggered
        // 4. Still not enough? OutOfMemoryError
    }
}
```

## Common Pitfalls

### Problem: Too Many Allocations

```kotlin
// BAD: Allocations in hot path
override fun onDraw(canvas: Canvas) {
    for (i in 0 until 1000) {
        val paint = Paint() // Allocation every frame!
        canvas.drawCircle(i.toFloat(), i.toFloat(), 10f, paint)
    }
}

// GOOD: Reuse objects
class MyView : View {
    private val paint = Paint() // Reused
    
    override fun onDraw(canvas: Canvas) {
        for (i in 0 until 1000) {
            canvas.drawCircle(i.toFloat(), i.toFloat(), 10f, paint)
        }
    }
}
```

### Problem: Holding References Too Long

```kotlin
// BAD: Objects kept longer than needed
class Cache {
    private val cache = mutableMapOf<String, LargeObject>()
    
    fun get(key: String): LargeObject? {
        return cache[key] // Keeps objects alive
    }
    // Objects never GC'd while in cache
}

// GOOD: Use appropriate references
class Cache {
    private val cache = mutableMapOf<String, SoftReference<LargeObject>>()
    
    fun get(key: String): LargeObject? {
        return cache[key]?.get() // Can be GC'd when memory needed
    }
}
```

## Quiz

1. What is the main advantage of Generational GC?
   - **A)** No pauses
   - **B)** Faster collection by focusing on young objects
   - **C)** No memory overhead
   - **D)** Handles circular references

2. Why is reference counting not used in Java?
   - **A)** Too slow
   - **B)** Can't handle circular references
   - **C)** Uses too much memory
   - **D)** Not thread-safe

3. What causes Stop-the-World pauses?
   - **A)** Too many objects
   - **B)** Need consistent heap state during GC
   - **C)** Memory leaks
   - **D)** Circular references

**Answers:**
1. **B** - Generational GC is faster because it focuses on Young Generation where most objects die
2. **B** - Reference counting can't handle circular references, causing memory leaks
3. **B** - Stop-the-world pauses ensure heap consistency during GC operations

## Next Steps

- [Advanced GC & Tuning](../02_intermediate/31.%20Advanced%20GC%20%26%20Tuning.md) - GC algorithms and tuning
- [Android GC & Memory Management](../03_advanced/16.%20Android%20GC%20%26%20Memory%20Management.md) - Android-specific GC

