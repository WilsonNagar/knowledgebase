---
number: 5
title: "Android Lifecycle Components"
slug: "android-lifecycle-components"
level: "beginner"
tags: ["lifecycle", "viewmodel", "livedata", "lifecycle-aware"]
prerequisites: ["introduction-to-android-architecture"]
estimated_minutes: 45
contributors: []
diagrams: []
examples: []
canonical_id: "android-beginner-05"
---




# Android Lifecycle Components

## Overview

Android Lifecycle Components (part of Android Jetpack) help you build lifecycle-aware components that automatically respond to lifecycle changes. Understanding Lifecycle, LiveData, and ViewModel is crucial for building robust Android applications that handle configuration changes, memory leaks, and data persistence correctly.

## Deep Explanation

### The Lifecycle Problem

Without lifecycle awareness, common issues occur:
- **Memory leaks**: Holding references to Activities/Fragments
- **Crashes**: Updating UI after Activity is destroyed
- **Wasted resources**: Continuing work when not needed
- **Data loss**: Losing data on configuration changes

### Lifecycle Components

1. **Lifecycle**: Tracks lifecycle state of components
2. **LiveData**: Observable data holder that's lifecycle-aware
3. **ViewModel**: Stores UI-related data that survives configuration changes
4. **LifecycleObserver**: Interface for observing lifecycle events

## Real Code Examples

### Using ViewModel

```kotlin
class UserViewModel : ViewModel() {
    private val _users = MutableLiveData<List<User>>()
    val users: LiveData<List<User>> = _users
    
    init {
        loadUsers()
    }
    
    private fun loadUsers() {
        viewModelScope.launch {
            val userList = repository.getUsers()
            _users.value = userList
        }
    }
}

// In Activity/Fragment
class MainActivity : AppCompatActivity() {
    private lateinit var viewModel: UserViewModel
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        viewModel = ViewModelProvider(this)[UserViewModel::class.java]
        
        viewModel.users.observe(this) { users ->
            // Update UI - automatically handles lifecycle
            updateUI(users)
        }
    }
}
```

### Using LiveData

```kotlin
class UserRepository {
    private val _users = MutableLiveData<List<User>>()
    val users: LiveData<List<User>> = _users
    
    fun loadUsers() {
        viewModelScope.launch {
            val userList = api.getUsers()
            _users.postValue(userList) // Use postValue from background thread
        }
    }
}

// Observer automatically stops when lifecycle is destroyed
viewModel.users.observe(this) { users ->
    // This only runs when lifecycle is active
    updateUI(users)
}
```

### Custom LifecycleObserver

```kotlin
class LocationObserver(private val lifecycle: Lifecycle) : LifecycleObserver {
    
    @OnLifecycleEvent(Lifecycle.Event.ON_START)
    fun startLocationUpdates() {
        // Start location updates when lifecycle starts
    }
    
    @OnLifecycleEvent(Lifecycle.Event.ON_STOP)
    fun stopLocationUpdates() {
        // Stop location updates when lifecycle stops
    }
}

// Register observer
lifecycle.addObserver(LocationObserver(lifecycle))
```

### LiveData Transformations

```kotlin
// Transform LiveData
val userName: LiveData<String> = Transformations.map(user) { user ->
    "${user.firstName} ${user.lastName}"
}

// Switch between LiveData sources
val userPosts: LiveData<List<Post>> = Transformations.switchMap(user) { user ->
    repository.getPostsForUser(user.id)
}

// Combine multiple LiveData sources
val combinedData: LiveData<CombinedResult> = MediatorLiveData<CombinedResult>().apply {
    addSource(user) { user ->
        value = CombinedResult(user, posts.value)
    }
    addSource(posts) { posts ->
        value = CombinedResult(user.value, posts)
    }
}
```

## Common Pitfalls

### Problem: Not using ViewModel for configuration changes

**BAD:**
```kotlin
class MainActivity : AppCompatActivity() {
    private var data: List<User>? = null // Lost on rotation!
    
    override fun onCreate(savedInstanceState: Bundle?) {
        loadData() // Loads again on rotation
    }
}
```

**GOOD:**
```kotlin
class MainActivity : AppCompatActivity() {
    private lateinit var viewModel: UserViewModel
    
    override fun onCreate(savedInstanceState: Bundle?) {
        viewModel = ViewModelProvider(this)[UserViewModel::class.java]
        // Data persists across configuration changes
    }
}
```

### Problem: Updating UI after lifecycle is destroyed

**BAD:**
```kotlin
viewModelScope.launch {
    val data = fetchData()
    textView.text = data // Might crash if Activity is destroyed
}
```

**GOOD:**
```kotlin
viewModelScope.launch {
    val data = fetchData()
    _uiState.postValue(data) // Safe - LiveData handles lifecycle
}

// In Activity
viewModel.uiState.observe(this) { data ->
    textView.text = data // Only updates if lifecycle is active
}
```

## Quiz

1. What survives configuration changes?
   - **A)** Activity instance
   - **B)** ViewModel instance
   - **C)** Fragment instance
   - **D)** All of the above

2. When does LiveData notify observers?
   - **A)** Always, even if lifecycle is destroyed
   - **B)** Only when lifecycle is in active state
   - **C)** Only in onCreate
   - **D)** Never automatically

3. What is the purpose of ViewModelScope?
   - **A)** To limit coroutine scope to ViewModel lifecycle
   - **B)** To create new threads
   - **C)** To manage memory
   - **D)** To handle errors

**Answers:**
1. **B** - ViewModel survives configuration changes, Activities and Fragments don't
2. **B** - LiveData only notifies observers when lifecycle is active (STARTED or RESUMED)
3. **A** - ViewModelScope automatically cancels coroutines when ViewModel is cleared

## Next Steps

- [Jetpack Compose State Management](../02_intermediate/10.%20Jetpack%20Compose%20State%20Management.md) - State management in Compose
- [Introduction to Android Architecture](./01.%20Introduction%20to%20Android%20Architecture.md) - Architecture patterns

