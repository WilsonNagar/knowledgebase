---
number: 6
title: "JVM Architecture & Java Memory Model"
slug: "jvm-architecture-java-memory-model"
level: "beginner"
tags: ["java", "jvm", "memory", "heap", "stack", "class-loading", "jit"]
prerequisites: []
estimated_minutes: 90
contributors: []
diagrams: []
examples: []
canonical_id: "android-06"
---

# JVM Architecture & Java Memory Model

## Overview

Understanding the Java Virtual Machine (JVM) architecture and memory model is fundamental to writing efficient Android applications. This comprehensive guide covers JVM internals, memory organization, class loading, and compilation strategies, providing deep insights into how Java code executes on Android devices.

## Table of Contents

1. [JVM Architecture Overview](#jvm-architecture)
2. [Java Memory Model](#memory-model)
3. [Heap vs Stack Memory](#heap-stack)
4. [Class Loading Mechanism](#class-loading)
5. [JIT Compiler & AOT](#compilation)
6. [Memory Organization Deep Dive](#memory-organization)

## JVM Architecture Overview

### What is the JVM?

The Java Virtual Machine is an abstract computing machine that:
- **Executes Java bytecode**: Converts `.class` files to machine code
- **Manages memory**: Allocates and deallocates memory automatically
- **Provides runtime environment**: Threads, garbage collection, security
- **Platform independence**: Write once, run anywhere

### JVM Components

```
┌─────────────────────────────────────────┐
│         Java Application                 │
│  (Your Kotlin/Java Code)                │
└──────────────┬──────────────────────────┘
               │
┌──────────────▼──────────────────────────┐
│         Class Loader Subsystem           │
│  - Loading, Linking, Initialization     │
└──────────────┬──────────────────────────┘
               │
┌──────────────▼──────────────────────────┐
│         Runtime Data Areas               │
│  - Method Area, Heap, Stack, PC Reg     │
└──────────────┬──────────────────────────┘
               │
┌──────────────▼──────────────────────────┐
│         Execution Engine                 │
│  - Interpreter, JIT Compiler, GC        │
└──────────────┬──────────────────────────┘
               │
┌──────────────▼──────────────────────────┐
│         Native Method Interface          │
│  - JNI, Native Libraries                 │
└──────────────────────────────────────────┘
```

### JVM Architecture Components

#### 1. Class Loader Subsystem
- **Loading**: Reads `.class` files into memory
- **Linking**: Verifies, prepares, resolves references
- **Initialization**: Executes static initializers

#### 2. Runtime Data Areas
- **Method Area**: Class metadata, static variables
- **Heap**: Object instances
- **Stack**: Method frames, local variables
- **PC Register**: Current instruction pointer
- **Native Method Stack**: Native code execution

#### 3. Execution Engine
- **Interpreter**: Executes bytecode line by line
- **JIT Compiler**: Compiles hot code to native code
- **Garbage Collector**: Manages memory

#### 4. Native Method Interface (JNI)
- Bridge between Java and native code
- Allows calling C/C++ libraries

## Java Memory Model

### Memory Areas in JVM

```
┌─────────────────────────────────────────┐
│         Method Area (PermGen/Metaspace)  │
│  - Class metadata                       │
│  - Static variables                      │
│  - Method bytecode                      │
│  - Runtime constant pool                │
└─────────────────────────────────────────┘
┌─────────────────────────────────────────┐
│              Heap Memory                │
│  ┌──────────────┬──────────────┐        │
│  │ Young Gen    │  Old Gen     │        │
│  │ - Eden       │  - Tenured   │        │
│  │ - S0/S1      │               │        │
│  └──────────────┴──────────────┘        │
└─────────────────────────────────────────┘
┌─────────────────────────────────────────┐
│         Stack Memory (Per Thread)        │
│  - Method frames                        │
│  - Local variables                      │
│  - Method parameters                     │
│  - Return addresses                      │
└─────────────────────────────────────────┘
┌─────────────────────────────────────────┐
│         PC Register (Per Thread)        │
│  - Current instruction pointer         │
└─────────────────────────────────────────┘
┌─────────────────────────────────────────┐
│    Native Method Stack (Per Thread)    │
│  - Native method calls                 │
└─────────────────────────────────────────┘
```

### Method Area (Metaspace)

**Java 8+**: Metaspace (replaces PermGen)
- **Location**: Native memory (not heap)
- **Contents**:
  - Class metadata (class name, methods, fields)
  - Static variables
  - Method bytecode
  - Runtime constant pool
  - String intern pool

**Key Points**:
- Shared across all threads
- Grows dynamically
- Garbage collected (unlike old PermGen)
- Can cause `OutOfMemoryError: Metaspace`

```kotlin
// Static variables stored in Method Area
class MyClass {
    companion object {
        val staticVar = "stored in metaspace"
    }
}

// Class metadata stored in Method Area
// - Class name: "MyClass"
// - Method signatures
// - Field information
```

### Heap Memory

**Purpose**: Stores all object instances

**Characteristics**:
- Shared by all threads
- Managed by garbage collector
- Can be divided into generations (Young/Old)

**Heap Structure**:
```
Heap
├── Young Generation
│   ├── Eden Space (new objects)
│   ├── Survivor Space 0 (S0)
│   └── Survivor Space 1 (S1)
└── Old Generation (Tenured)
    └── Long-lived objects
```

### Stack Memory

**Purpose**: Stores method execution frames

**Characteristics**:
- **Per thread**: Each thread has its own stack
- **LIFO**: Last In, First Out
- **Fast**: Faster than heap allocation
- **Limited size**: Can cause `StackOverflowError`

**Stack Frame Structure**:
```
┌─────────────────────────┐
│   Local Variables        │  ← Method parameters, local vars
├─────────────────────────┤
│   Operand Stack          │  ← Intermediate calculations
├─────────────────────────┤
│   Frame Data             │  ← Return address, references
└─────────────────────────┘
```

**Example**:
```kotlin
fun calculate(a: Int, b: Int): Int {
    val result = a + b  // Local variable on stack
    return result        // Return value
}

// Stack frame for calculate():
// Local Variables: [a=5, b=3, result=8]
// Operand Stack: [8]
// Frame Data: [return address]
```

### PC Register (Program Counter)

**Purpose**: Tracks current instruction being executed

**Characteristics**:
- **Per thread**: Each thread has its own PC register
- **Points to**: Current bytecode instruction
- **Native methods**: Undefined (native code handles it)

## Heap vs Stack Memory

### Key Differences

| Aspect | Heap | Stack |
|--------|------|-------|
| **Size** | Large, dynamic | Small, fixed (typically 1-2MB) |
| **Speed** | Slower (GC overhead) | Faster (direct access) |
| **Lifetime** | Until GC'd | Method scope |
| **Thread Safety** | Shared, needs synchronization | Thread-local, safe |
| **Allocation** | Dynamic | Automatic (method entry/exit) |
| **Memory Management** | Garbage collected | Automatic (stack unwinding) |

### What Goes Where?

#### Stack Memory Stores:
```kotlin
fun example() {
    val localVar = 10           // Primitive → Stack
    val localString = "hello"   // String reference → Stack
                                 // String object → Heap
    
    val localObject = MyObject() // Reference → Stack
                                 // Object → Heap
}
```

**Stack contains**:
- Primitive values (int, boolean, etc.)
- Object references (pointers to heap)
- Method parameters
- Return addresses

#### Heap Memory Stores:
```kotlin
class MyClass {
    val instanceVar = "heap"    // Object → Heap
}

val obj = MyClass()              // Object instance → Heap
val array = IntArray(100)        // Array → Heap
```

**Heap contains**:
- All object instances
- Arrays
- String objects (not references)
- Instance variables

### Memory Allocation Example

```kotlin
class Person(val name: String, val age: Int)

fun createPerson() {
    // Stack: [nameRef, ageRef, personRef]
    // Heap: [Person object with name="John", age=30]
    val person = Person("John", 30)
    
    // Stack: [personRef, nameRef]
    // Heap: [String object "John"]
    val name = person.name
    
    // When method returns:
    // Stack frame destroyed
    // personRef removed from stack
    // Person object remains in heap (until GC'd)
}
```

### Memory Layout Example

```kotlin
class Example {
    // Instance variable → Heap (part of object)
    val instanceVar = "heap"
    
    fun method() {
        // Local variable → Stack
        val localVar = 10
        
        // Object → Heap
        // Reference → Stack
        val obj = MyObject()
        
        // Array → Heap
        // Reference → Stack
        val array = IntArray(100)
    }
}

// Memory layout:
// Stack (method frame):
//   - localVar: 10
//   - obj: reference → Heap address
//   - array: reference → Heap address
//
// Heap:
//   - Example object:
//     - instanceVar: "heap"
//   - MyObject instance
//   - IntArray[100]
```

## Class Loading Mechanism

### Class Loading Phases

#### Phase 1: Loading
```
1. Read .class file
2. Create Class object
3. Store in Method Area
```

**What happens**:
- JVM reads bytecode from `.class` file
- Creates `java.lang.Class` object
- Stores class metadata in Method Area

#### Phase 2: Linking

**2a. Verification**:
- Verify bytecode is valid
- Check security constraints
- Ensure class file format is correct

**2b. Preparation**:
- Allocate memory for static variables
- Set default values (0, null, false)
- Create method tables

**2c. Resolution**:
- Resolve symbolic references
- Replace symbolic names with direct references
- Link methods and fields

#### Phase 3: Initialization
```
1. Execute static initializers
2. Initialize static variables
3. Run <clinit> method
```

### Class Loader Hierarchy

```
Bootstrap Class Loader (Native)
    ↓
Extension Class Loader (Java)
    ↓
Application Class Loader (Your classes)
    ↓
Custom Class Loader (Optional)
```

**Bootstrap Class Loader**:
- Loads core Java classes (`java.lang.*`, `java.util.*`)
- Written in native code
- No parent

**Extension Class Loader**:
- Loads extension classes
- Child of Bootstrap
- Loads from `jre/lib/ext`

**Application Class Loader**:
- Loads application classes
- Child of Extension
- Loads from classpath

**Custom Class Loader**:
- Your own class loading logic
- Useful for plugins, dynamic loading

### Class Loading Example

```kotlin
// When you write:
val obj = MyClass()

// JVM does:
// 1. Loading: Read MyClass.class
// 2. Linking: Verify, prepare, resolve
// 3. Initialization: Execute static blocks
// 4. Create instance in heap
```

### Delegation Model

```
When loading a class:
1. Check if already loaded (cache)
2. Delegate to parent class loader
3. If parent can't load, try self
4. If can't load, throw ClassNotFoundException
```

**Example**:
```kotlin
// Application Class Loader loading MyClass:
// 1. Check cache → Not found
// 2. Ask Extension Class Loader
//    - Extension checks cache → Not found
//    - Extension asks Bootstrap
//      - Bootstrap checks → Not found
// 3. Extension tries to load → Not in ext directory
// 4. Application Class Loader loads from classpath
```

## JIT Compiler & AOT

### Execution Modes

#### 1. Interpretation
```
Bytecode → Interpreter → Machine Code (on-the-fly)
```

**Characteristics**:
- Slow (interprets every time)
- No compilation overhead
- Good for code executed once

#### 2. Just-In-Time (JIT) Compilation
```
Bytecode → JIT Compiler → Native Code (cached)
```

**Characteristics**:
- Compiles hot code (frequently executed)
- Caches compiled code
- Faster execution after compilation
- Compilation overhead

**JIT Process**:
```
1. Method executed (interpreted)
2. Execution count increases
3. Reaches threshold (hot method)
4. JIT compiler compiles to native code
5. Future calls use native code
```

#### 3. Ahead-of-Time (AOT) Compilation
```
Bytecode → AOT Compiler → Native Code (before execution)
```

**Characteristics**:
- Compiles before execution
- No runtime compilation overhead
- Larger app size (native code)
- Faster startup (no interpretation)

### JIT Compilation Details

#### Hot Spot Detection

```kotlin
// Method called once → Interpreted
fun method1() { }

// Method called 1000+ times → JIT compiled
fun method2() {
    // Hot code → Compiled to native
    for (i in 0 until 1000000) {
        // This loop gets compiled
    }
}
```

**Compilation Thresholds**:
- **Client mode**: ~1,500 invocations
- **Server mode**: ~10,000 invocations
- **Tiered compilation**: Multiple compilation levels

#### JIT Optimization Techniques

**1. Inlining**:
```kotlin
// BEFORE: Method call overhead
fun calculate(a: Int, b: Int): Int = a + b
fun main() {
    val result = calculate(5, 3) // Method call
}

// AFTER JIT: Inlined
fun main() {
    val result = 5 + 3 // Direct calculation
}
```

**2. Loop Optimization**:
```kotlin
// JIT optimizes loops
for (i in 0 until 1000) {
    // Loop unrolling, vectorization
}
```

**3. Dead Code Elimination**:
```kotlin
if (false) {
    // This code removed by JIT
    expensiveOperation()
}
```

### AOT Compilation (Android ART)

**Android Runtime (ART)**:
- Uses AOT compilation (since Android 5.0)
- Compiles apps during installation
- Stores compiled code in `.oat` files

**ART Compilation Process**:
```
1. Install app
2. dex2oat compiles .dex → .oat
3. Native code stored on device
4. App runs native code directly
```

**Advantages**:
- Faster execution (no interpretation)
- Better battery life (no JIT overhead)
- Predictable performance

**Disadvantages**:
- Longer installation time
- More storage space
- Slower app updates

### Hybrid Approach (Android 7.0+)

**Profile-Guided Optimization**:
```
1. App runs with JIT initially
2. Profile collects hot methods
3. Background compilation of hot methods
4. Next launch uses compiled code
```

**Benefits**:
- Fast installation (no AOT)
- Optimized hot code (AOT for hot methods)
- Best of both worlds

## Memory Organization Deep Dive

### Object Memory Layout

```kotlin
class Person(val name: String, val age: Int)

// Memory layout in heap:
┌─────────────────────────┐
│   Object Header         │  ← Mark word, class pointer
├─────────────────────────┤
│   name: String ref      │  ← Reference to String object
├─────────────────────────┤
│   age: Int (4 bytes)    │  ← Primitive value
└─────────────────────────┘
```

**Object Header Contains**:
- **Mark Word**: GC info, lock info, identity hash
- **Class Pointer**: Reference to Class object
- **Array Length**: (if array)

### Array Memory Layout

```kotlin
val array = IntArray(5)

// Memory layout:
┌─────────────────────────┐
│   Array Header          │
│   - Mark word           │
│   - Class pointer       │
│   - Length: 5           │
├─────────────────────────┤
│   [0] = 0               │
│   [1] = 0               │
│   [2] = 0               │
│   [3] = 0               │
│   [4] = 0               │
└─────────────────────────┘
```

### String Memory Layout

```kotlin
val str = "Hello"

// Memory layout:
┌─────────────────────────┐
│   String Object         │
│   - value: char[] ref   │  → Points to char array
│   - hash: int           │
│   - coder: byte         │
└─────────────────────────┘
         ↓
┌─────────────────────────┐
│   char[] Array          │
│   ['H','e','l','l','o'] │
└─────────────────────────┘
```

### Memory Alignment

**Purpose**: Optimize memory access
**Rule**: Objects aligned to 8-byte boundaries (on 64-bit JVM)

```kotlin
class Example {
    val byte: Byte    // 1 byte + 7 padding = 8 bytes
    val int: Int      // 4 bytes
    val long: Long    // 8 bytes
}

// Total: 24 bytes (aligned)
```

## Real Code Examples

### Example 1: Understanding Memory Allocation

```kotlin
class MemoryExample {
    // Instance variable → Heap (part of object)
    val instanceVar = "heap"
    
    fun demonstrate() {
        // Local variable → Stack
        val localInt = 10
        
        // Object → Heap
        // Reference → Stack
        val person = Person("John", 30)
        
        // Array → Heap
        // Reference → Stack
        val numbers = IntArray(1000)
        
        // When method returns:
        // - Stack frame destroyed
        // - localInt removed
        // - person reference removed
        // - numbers reference removed
        // - Objects remain in heap until GC
    }
}
```

### Example 2: Class Loading in Action

```kotlin
// First access to MyClass
val obj = MyClass()

// JVM does:
// 1. Loading: Read MyClass.class
// 2. Verification: Check bytecode validity
// 3. Preparation: Allocate static variables
// 4. Resolution: Resolve method references
// 5. Initialization: Execute static blocks
// 6. Create instance

class MyClass {
    companion object {
        init {
            println("Static initializer") // Runs during initialization
        }
        
        val staticVar = "initialized" // Prepared, then initialized
    }
    
    init {
        println("Instance initializer") // Runs when creating instance
    }
}
```

## Common Pitfalls

### Problem: Stack Overflow

```kotlin
// BAD: Infinite recursion
fun recursive(n: Int): Int {
    return recursive(n + 1) // Stack grows infinitely
}

// Each call creates new stack frame
// Stack limited (~1-2MB)
// Results in StackOverflowError
```

### Problem: Heap Memory Leak

```kotlin
// BAD: Objects not garbage collected
class Leaky {
    companion object {
        val cache = mutableListOf<LargeObject>() // Static reference
    }
    
    fun add(obj: LargeObject) {
        cache.add(obj) // Never removed, keeps growing
    }
}

// Objects referenced by static cache
// Never eligible for GC
// Heap keeps growing → OutOfMemoryError
```

## Quiz

1. Where are static variables stored?
   - **A)** Heap
   - **B)** Stack
   - **C)** Method Area (Metaspace)
   - **D)** PC Register

2. What is the main difference between heap and stack?
   - **A)** Heap is faster
   - **B)** Stack stores objects, heap stores primitives
   - **C)** Heap is shared, stack is per-thread
   - **D)** No difference

3. When does JIT compilation occur?
   - **A)** During app installation
   - **B)** When method becomes "hot"
   - **C)** Never
   - **D)** Only for native methods

**Answers:**
1. **C** - Static variables stored in Method Area (Metaspace)
2. **C** - Heap is shared across threads, stack is per-thread
3. **B** - JIT compiles methods that are frequently executed (hot methods)

## Next Steps

- [Java Threads & Concurrency Basics](./07.%20Java%20Threads%20%26%20Concurrency%20Basics.md) - Threading model
- [Garbage Collection Fundamentals](./08.%20Garbage%20Collection%20Fundamentals.md) - Memory management

