---
number: 7
title: "Java Threads & Concurrency Basics"
slug: "java-threads-concurrency-basics"
level: "beginner"
tags: ["java", "threads", "concurrency", "multithreading", "synchronization"]
prerequisites: ["jvm-architecture-java-memory-model"]
estimated_minutes: 75
contributors: []
diagrams: []
examples: []
canonical_id: "android-beginner-07"
---




# Java Threads & Concurrency Basics

## Overview

Understanding Java's threading model and concurrency primitives is essential for building responsive Android applications. This comprehensive guide covers thread creation, synchronization, thread lifecycle, and the Java Memory Model's guarantees for concurrent execution.

## Table of Contents

1. [Thread Fundamentals](#thread-fundamentals)
2. [Thread Lifecycle](#thread-lifecycle)
3. [Thread Creation](#thread-creation)
4. [Synchronization](#synchronization)
5. [Java Memory Model](#java-memory-model)
6. [Common Concurrency Patterns](#concurrency-patterns)

## Thread Fundamentals

### What is a Thread?

A thread is:
- **Lightweight process**: Shares memory space with other threads
- **Independent execution**: Has its own call stack
- **Concurrent execution**: Multiple threads run simultaneously

### Thread vs Process

| Aspect | Process | Thread |
|--------|---------|--------|
| **Memory** | Isolated | Shared |
| **Creation** | Expensive | Lightweight |
| **Communication** | IPC (slow) | Shared memory (fast) |
| **Context Switch** | Slow | Fast |

### Why Multiple Threads?

**Benefits**:
- **Responsiveness**: UI thread stays responsive
- **Performance**: Utilize multiple CPU cores
- **Efficiency**: Overlap I/O with computation

**Android Example**:
```kotlin
// Main thread: UI updates
// Background thread: Network requests
// Result: UI doesn't freeze during network call
```

## Thread Lifecycle

### Thread States

```
NEW
  ↓ (start())
RUNNABLE
  ↓ (scheduled)
RUNNING
  ↓ (wait/block)
BLOCKED / WAITING / TIMED_WAITING
  ↓ (notify/resume)
RUNNABLE
  ↓ (terminate)
TERMINATED
```

### State Details

**1. NEW**:
- Thread created but not started
- `Thread thread = Thread { }` → NEW

**2. RUNNABLE**:
- Thread is eligible to run
- Waiting for CPU time slice
- `thread.start()` → RUNNABLE

**3. RUNNING**:
- Thread is executing
- Actually running on CPU
- Part of RUNNABLE state

**4. BLOCKED**:
- Waiting for monitor lock
- `synchronized` block
- Waiting to enter synchronized section

**5. WAITING**:
- Indefinitely waiting
- `object.wait()`
- `thread.join()` (no timeout)

**6. TIMED_WAITING**:
- Waiting with timeout
- `Thread.sleep(1000)`
- `object.wait(1000)`
- `thread.join(1000)`

**7. TERMINATED**:
- Thread finished execution
- `run()` method completed
- Cannot be restarted

### State Transitions Example

```kotlin
val thread = Thread {
    println("Running") // RUNNING state
    
    synchronized(lock) {
        // If lock held by another thread → BLOCKED
        // Otherwise → RUNNING
    }
    
    Thread.sleep(1000) // TIMED_WAITING
    
    lock.wait() // WAITING
    
    println("Done") // TERMINATED
}

thread.start() // NEW → RUNNABLE
```

## Thread Creation

### Method 1: Extending Thread

```kotlin
class MyThread : Thread() {
    override fun run() {
        println("Thread running: ${Thread.currentThread().name}")
    }
}

// Usage
val thread = MyThread()
thread.start() // Starts new thread
```

### Method 2: Implementing Runnable

```kotlin
class MyRunnable : Runnable {
    override fun run() {
        println("Runnable running")
    }
}

// Usage
val runnable = MyRunnable()
val thread = Thread(runnable)
thread.start()
```

### Method 3: Lambda (Kotlin)

```kotlin
val thread = Thread {
    println("Lambda thread")
}
thread.start()
```

### Method 4: Thread Pool (Recommended)

```kotlin
// Use ExecutorService instead of creating threads directly
val executor = Executors.newFixedThreadPool(4)

executor.execute {
    println("Task 1")
}

executor.execute {
    println("Task 2")
}

executor.shutdown()
```

## Synchronization

### The Problem: Race Conditions

```kotlin
var counter = 0

// Thread 1
counter++ // Read: 0, Add: 1, Write: 1

// Thread 2 (concurrent)
counter++ // Read: 0, Add: 1, Write: 1

// Result: 2 (expected), but might be 1 (wrong!)
```

**Why it happens**:
1. Thread 1 reads counter (0)
2. Thread 2 reads counter (0) - before Thread 1 writes
3. Thread 1 writes (1)
4. Thread 2 writes (1) - overwrites Thread 1's value

### Solution: Synchronization

#### Synchronized Methods

```kotlin
class Counter {
    private var count = 0
    
    @Synchronized
    fun increment() {
        count++ // Atomic operation
    }
    
    @Synchronized
    fun getCount(): Int {
        return count
    }
}

// Only one thread can execute synchronized methods at a time
```

#### Synchronized Blocks

```kotlin
class Counter {
    private var count = 0
    private val lock = Any()
    
    fun increment() {
        synchronized(lock) {
            count++ // Protected by lock
        }
    }
}
```

#### Intrinsic Locks (Monitor)

```kotlin
// Every object has an intrinsic lock (monitor)
val obj = Any()

synchronized(obj) {
    // Only one thread can enter this block
    // Other threads wait here
    // Lock released when block exits
}
```

### Lock Mechanism

```
Thread 1: synchronized(lock) {
    // Thread 1 acquires lock
    // Thread 2 tries to enter → BLOCKED
    // Thread 1 releases lock
}

Thread 2: synchronized(lock) {
    // Thread 2 can now acquire lock
    // Enters block
}
```

### Volatile Keyword

```kotlin
@Volatile
var flag = false

// Volatile guarantees:
// 1. Visibility: Changes visible to all threads immediately
// 2. No reordering: Prevents compiler optimizations
```

**When to use volatile**:
- Simple flags (boolean)
- Single writer, multiple readers
- Not for compound operations (use synchronized)

**Example**:
```kotlin
@Volatile
var running = true

// Thread 1
fun stop() {
    running = false // Immediately visible to Thread 2
}

// Thread 2
while (running) {
    // Sees updated value immediately
}
```

## Java Memory Model

### What is the Java Memory Model?

The Java Memory Model (JMM) defines:
- **How threads interact through memory**
- **When writes are visible to other threads**
- **What optimizations are allowed**

### Happens-Before Relationship

**Rule**: If action A happens-before action B, then:
- All memory effects of A are visible to B
- A appears to execute before B

### Happens-Before Rules

**1. Program Order**:
```kotlin
// Within same thread:
val x = 1  // Happens-before
val y = 2  // y sees x = 1
```

**2. Monitor Lock**:
```kotlin
// Unlock happens-before subsequent lock
synchronized(lock) {
    x = 1
} // Unlock
// Happens-before
synchronized(lock) {
    val y = x // y sees x = 1
}
```

**3. Volatile**:
```kotlin
@Volatile
var x = 0

// Thread 1
x = 1 // Write to volatile

// Thread 2
val y = x // Read from volatile
// y guaranteed to see x = 1
```

**4. Thread Start**:
```kotlin
val x = 1
thread.start() // Happens-before thread execution
// Thread sees x = 1
```

**5. Thread Join**:
```kotlin
thread.start()
thread.join() // Thread execution happens-before join returns
// All thread's writes visible here
```

### Memory Visibility

**Problem**: Without synchronization, changes might not be visible

```kotlin
// Thread 1
var flag = false
// ... do work ...
flag = true

// Thread 2
while (!flag) {
    // Might never see flag = true!
    // Due to CPU cache, compiler optimizations
}
```

**Solution**: Use synchronization or volatile

```kotlin
@Volatile
var flag = false // Now visible across threads
```

## Common Concurrency Patterns

### Pattern 1: Producer-Consumer

```kotlin
class ProducerConsumer {
    private val queue = LinkedBlockingQueue<Item>()
    
    fun producer() {
        while (true) {
            val item = produceItem()
            queue.put(item) // Blocks if queue full
        }
    }
    
    fun consumer() {
        while (true) {
            val item = queue.take() // Blocks if queue empty
            processItem(item)
        }
    }
}
```

### Pattern 2: Reader-Writer Lock

```kotlin
class ReadWriteLock {
    private var readers = 0
    private var writer = false
    private val lock = Any()
    
    fun acquireReadLock() {
        synchronized(lock) {
            while (writer) {
                lock.wait() // Wait for writer
            }
            readers++
        }
    }
    
    fun releaseReadLock() {
        synchronized(lock) {
            readers--
            if (readers == 0) {
                lock.notifyAll() // Notify waiting writers
            }
        }
    }
    
    fun acquireWriteLock() {
        synchronized(lock) {
            while (writer || readers > 0) {
                lock.wait()
            }
            writer = true
        }
    }
    
    fun releaseWriteLock() {
        synchronized(lock) {
            writer = false
            lock.notifyAll()
        }
    }
}
```

### Pattern 3: CountDownLatch

```kotlin
val latch = CountDownLatch(3) // Wait for 3 tasks

// Task 1
thread1.execute {
    doWork()
    latch.countDown() // Decrement count
}

// Task 2
thread2.execute {
    doWork()
    latch.countDown()
}

// Task 3
thread3.execute {
    doWork()
    latch.countDown()
}

// Main thread waits for all
latch.await() // Blocks until count reaches 0
println("All tasks completed")
```

## Common Pitfalls

### Problem: Deadlock

```kotlin
// Thread 1
synchronized(lockA) {
    synchronized(lockB) {
        // ...
    }
}

// Thread 2
synchronized(lockB) {
    synchronized(lockA) {
        // ...
    }
}

// Deadlock: Each thread holds one lock, waits for other
```

**Solution**: Always acquire locks in same order

```kotlin
// Both threads acquire lockA, then lockB
synchronized(lockA) {
    synchronized(lockB) {
        // ...
    }
}
```

### Problem: Liveness Issues

```kotlin
// Thread waits forever
synchronized(lock) {
    while (condition) {
        // Forgot to call wait()!
        // Spins forever, wastes CPU
    }
}

// Solution: Use wait/notify
synchronized(lock) {
    while (condition) {
        lock.wait() // Releases lock, waits for notify
    }
}
```

## Quiz

1. What state is a thread in when waiting for a lock?
   - **A)** RUNNABLE
   - **B)** BLOCKED
   - **C)** WAITING
   - **D)** TERMINATED

2. What does synchronized guarantee?
   - **A)** Faster execution
   - **B)** Mutual exclusion and visibility
   - **C)** No deadlocks
   - **D)** Thread safety automatically

3. When should you use volatile?
   - **A)** For all shared variables
   - **B)** For simple flags, single writer
   - **C)** Never, use synchronized instead
   - **D)** Only for primitives

**Answers:**
1. **B** - Thread waiting for lock is in BLOCKED state
2. **B** - Synchronized provides mutual exclusion (one thread at a time) and visibility (happens-before)
3. **B** - Volatile is for simple cases like flags with single writer, multiple readers

## Next Steps

- [Kotlin Coroutines Basics](./03.%20Kotlin%20Coroutines%20Basics.md) - Modern concurrency
- [Advanced Coroutines & Cancellation](../03_advanced/20.%20Advanced%20Coroutines%20%26%20Cancellation.md) - Advanced patterns

