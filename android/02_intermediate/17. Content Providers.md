---
number: 17
title: "Content Providers"
slug: "content-providers"
level: "intermediate"
tags: ["content-provider", "content-resolver", "data-sharing", "uri"]
prerequisites: ["room-database-data-persistence"]
estimated_minutes: 80
contributors: []
diagrams: []
examples: []
canonical_id: "android-intermediate-17"
---



# Content Providers

## Overview

Content Providers manage access to structured data and enable data sharing between applications. This comprehensive guide covers creating Content Providers, Content URIs, Content Resolver, querying data, inserting/updating/deleting data, permissions, and best practices for implementing Content Providers in Android applications.

## Table of Contents

1. [What are Content Providers?](#what-are-content-providers)
2. [Creating Content Providers](#creating-providers)
3. [Content URIs](#content-uris)
4. [Content Resolver](#content-resolver)
5. [CRUD Operations](#crud-operations)
6. [Permissions](#permissions)
7. [Best Practices](#best-practices)

## What are Content Providers?

### Definition

**Content Provider**: Component that manages access to structured data

**Purpose**: Share data between apps

**Characteristics**:
- **Data Access**: Centralized data access
- **Security**: Permission-based access
- **Standardized**: Standard interface
- **Cross-App**: Share data between apps

### When to Use Content Providers

**Use Content Providers For**:
- **Data Sharing**: Share data with other apps
- **System Integration**: Integrate with system providers
- **FileProvider**: Share files securely
- **Custom Data**: Expose custom data sources

**Don't Use Content Providers For**:
- **Internal Data**: App-internal data (use Room/SharedPreferences)
- **Simple Data**: Simple key-value data (use SharedPreferences)

## Creating Content Providers

### Basic Content Provider

```kotlin
class MyContentProvider : ContentProvider() {
    private lateinit var database: AppDatabase
    
    override fun onCreate(): Boolean {
        database = AppDatabase.getDatabase(context!!)
        return true
    }
    
    override fun query(
        uri: Uri,
        projection: Array<String>?,
        selection: String?,
        selectionArgs: Array<String>?,
        sortOrder: String?
    ): Cursor? {
        val code = uriMatcher.match(uri)
        return when (code) {
            USERS_CODE -> {
                database.userDao().getUsersCursor()
            }
            USER_ID_CODE -> {
                val id = uri.lastPathSegment
                database.userDao().getUserCursor(id)
            }
            else -> null
        }
    }
    
    override fun insert(uri: Uri, values: ContentValues?): Uri? {
        val code = uriMatcher.match(uri)
        return when (code) {
            USERS_CODE -> {
                val user = values?.toUser()
                val id = database.userDao().insert(user)
                Uri.parse("content://${AUTHORITY}/users/$id")
            }
            else -> null
        }
    }
    
    override fun update(
        uri: Uri,
        values: ContentValues?,
        selection: String?,
        selectionArgs: Array<String>?
    ): Int {
        val code = uriMatcher.match(uri)
        return when (code) {
            USER_ID_CODE -> {
                val id = uri.lastPathSegment
                val user = values?.toUser()
                database.userDao().update(user)
            }
            else -> 0
        }
    }
    
    override fun delete(
        uri: Uri,
        selection: String?,
        selectionArgs: Array<String>?
    ): Int {
        val code = uriMatcher.match(uri)
        return when (code) {
            USER_ID_CODE -> {
                val id = uri.lastPathSegment
                database.userDao().delete(id)
            }
            else -> 0
        }
    }
    
    override fun getType(uri: Uri): String? {
        return when (uriMatcher.match(uri)) {
            USERS_CODE -> "vnd.android.cursor.dir/user"
            USER_ID_CODE -> "vnd.android.cursor.item/user"
            else -> null
        }
    }
    
    companion object {
        const val AUTHORITY = "com.example.provider"
        const val USERS_PATH = "users"
        const val USERS_CODE = 1
        const val USER_ID_CODE = 2
        
        val CONTENT_URI = Uri.parse("content://$AUTHORITY/$USERS_PATH")
        
        private val uriMatcher = UriMatcher(UriMatcher.NO_MATCH).apply {
            addURI(AUTHORITY, USERS_PATH, USERS_CODE)
            addURI(AUTHORITY, "$USERS_PATH/#", USER_ID_CODE)
        }
    }
}
```

### Register in Manifest

```xml
<provider
    android:name=".MyContentProvider"
    android:authorities="com.example.provider"
    android:exported="true"
    android:permission="com.example.READ_PERMISSION" />
```

## Content URIs

### URI Structure

**Format**: `content://authority/path/id`

**Example**: `content://com.example.provider/users/123`

**Components**:
- **Scheme**: `content://`
- **Authority**: `com.example.provider`
- **Path**: `users`
- **ID**: `123` (optional)

### URI Matcher

```kotlin
private val uriMatcher = UriMatcher(UriMatcher.NO_MATCH).apply {
    addURI(AUTHORITY, "users", USERS_CODE)
    addURI(AUTHORITY, "users/#", USER_ID_CODE)
    addURI(AUTHORITY, "posts", POSTS_CODE)
    addURI(AUTHORITY, "posts/#", POST_ID_CODE)
}
```

## Content Resolver

### Querying Data

```kotlin
fun queryUsers(context: Context): List<User> {
    val cursor = context.contentResolver.query(
        Uri.parse("content://com.example.provider/users"),
        null, // projection
        null, // selection
        null, // selectionArgs
        null  // sortOrder
    )
    
    return cursor?.use {
        val users = mutableListOf<User>()
        while (it.moveToNext()) {
            val user = User(
                id = it.getLong(it.getColumnIndex("id")),
                name = it.getString(it.getColumnIndex("name")),
                email = it.getString(it.getColumnIndex("email"))
            )
            users.add(user)
        }
        users
    } ?: emptyList()
}
```

### Inserting Data

```kotlin
fun insertUser(context: Context, user: User) {
    val values = ContentValues().apply {
        put("name", user.name)
        put("email", user.email)
    }
    
    val uri = context.contentResolver.insert(
        Uri.parse("content://com.example.provider/users"),
        values
    )
}
```

### Updating Data

```kotlin
fun updateUser(context: Context, userId: String, user: User) {
    val values = ContentValues().apply {
        put("name", user.name)
        put("email", user.email)
    }
    
    val uri = Uri.parse("content://com.example.provider/users/$userId")
    context.contentResolver.update(uri, values, null, null)
}
```

### Deleting Data

```kotlin
fun deleteUser(context: Context, userId: String) {
    val uri = Uri.parse("content://com.example.provider/users/$userId")
    context.contentResolver.delete(uri, null, null)
}
```

## CRUD Operations

### Query

```kotlin
override fun query(
    uri: Uri,
    projection: Array<String>?,
    selection: String?,
    selectionArgs: Array<String>?,
    sortOrder: String?
): Cursor? {
    val code = uriMatcher.match(uri)
    val queryBuilder = SQLiteQueryBuilder()
    
    when (code) {
        USERS_CODE -> {
            queryBuilder.tables = "users"
        }
        USER_ID_CODE -> {
            queryBuilder.tables = "users"
            queryBuilder.appendWhere("_id = ${uri.lastPathSegment}")
        }
        else -> return null
    }
    
    val cursor = queryBuilder.query(
        database.readableDatabase,
        projection,
        selection,
        selectionArgs,
        null,
        null,
        sortOrder
    )
    
    cursor.setNotificationUri(context.contentResolver, uri)
    return cursor
}
```

### Insert

```kotlin
override fun insert(uri: Uri, values: ContentValues?): Uri? {
    val code = uriMatcher.match(uri)
    val db = database.writableDatabase
    
    val id = when (code) {
        USERS_CODE -> {
            db.insert("users", null, values)
        }
        else -> return null
    }
    
    if (id != null) {
        context.contentResolver.notifyChange(uri, null)
        return Uri.parse("$uri/$id")
    }
    return null
}
```

### Update

```kotlin
override fun update(
    uri: Uri,
    values: ContentValues?,
    selection: String?,
    selectionArgs: Array<String>?
): Int {
    val code = uriMatcher.match(uri)
    val db = database.writableDatabase
    
    val count = when (code) {
        USER_ID_CODE -> {
            val id = uri.lastPathSegment
            db.update("users", values, "_id = ?", arrayOf(id))
        }
        USERS_CODE -> {
            db.update("users", values, selection, selectionArgs)
        }
        else -> 0
    }
    
    if (count > 0) {
        context.contentResolver.notifyChange(uri, null)
    }
    return count
}
```

### Delete

```kotlin
override fun delete(
    uri: Uri,
    selection: String?,
    selectionArgs: Array<String>?
): Int {
    val code = uriMatcher.match(uri)
    val db = database.writableDatabase
    
    val count = when (code) {
        USER_ID_CODE -> {
            val id = uri.lastPathSegment
            db.delete("users", "_id = ?", arrayOf(id))
        }
        USERS_CODE -> {
            db.delete("users", selection, selectionArgs)
        }
        else -> 0
    }
    
    if (count > 0) {
        context.contentResolver.notifyChange(uri, null)
    }
    return count
}
```

## Permissions

### Read Permission

```xml
<provider
    android:name=".MyContentProvider"
    android:authorities="com.example.provider"
    android:readPermission="com.example.READ_PERMISSION" />
```

### Write Permission

```xml
<provider
    android:name=".MyContentProvider"
    android:authorities="com.example.provider"
    android:writePermission="com.example.WRITE_PERMISSION" />
```

### Checking Permissions

```kotlin
fun queryWithPermission(context: Context): Cursor? {
    return if (ContextCompat.checkSelfPermission(
            context,
            "com.example.READ_PERMISSION"
        ) == PackageManager.PERMISSION_GRANTED
    ) {
        context.contentResolver.query(
            Uri.parse("content://com.example.provider/users"),
            null, null, null, null
        )
    } else {
        null
    }
}
```

## Best Practices

### Practice 1: Use FileProvider for Files

```kotlin
// GOOD: FileProvider for file sharing
val file = File(context.filesDir, "image.jpg")
val uri = FileProvider.getUriForFile(
    context,
    "com.example.fileprovider",
    file
)

// BAD: File URI
val uri = Uri.fromFile(file) // Not secure
```

### Practice 2: Notify Changes

```kotlin
// GOOD: Notify content resolver
override fun insert(uri: Uri, values: ContentValues?): Uri? {
    val newUri = // Insert logic
    context.contentResolver.notifyChange(uri, null)
    return newUri
}

// BAD: Don't notify
// Observers won't be notified
```

### Practice 3: Use Cursor Loaders (Legacy)

```kotlin
// For View-based UIs (legacy)
class UserLoader(context: Context) : CursorLoader(context) {
    init {
        uri = Uri.parse("content://com.example.provider/users")
    }
}
```

## Real-World Examples

### FileProvider Setup

```kotlin
// FileProvider for secure file sharing
class MyFileProvider : FileProvider()

// AndroidManifest.xml
<provider
    android:name="androidx.core.content.FileProvider"
    android:authorities="com.example.fileprovider"
    android:exported="false"
    android:grantUriPermissions="true">
    <meta-data
        android:name="android.support.FILE_PROVIDER_PATHS"
        android:resource="@xml/file_paths" />
</provider>

// res/xml/file_paths.xml
<paths>
    <files-path name="files" path="." />
    <cache-path name="cache" path="." />
    <external-files-path name="external_files" path="." />
</paths>
```

## Common Pitfalls

### Problem: Not Notifying Changes

```kotlin
// BAD: Don't notify
override fun insert(uri: Uri, values: ContentValues?): Uri? {
    // Insert but don't notify
    return newUri
}

// GOOD: Notify changes
override fun insert(uri: Uri, values: ContentValues?): Uri? {
    val newUri = // Insert
    context.contentResolver.notifyChange(uri, null)
    return newUri
}
```

## Quiz

1. What are Content Providers used for?
   - **A)** UI components
   - **B)** Sharing data between apps
   - **C)** Network requests
   - **D)** Nothing

2. What is FileProvider used for?
   - **A)** Database access
   - **B)** Secure file sharing
   - **C)** Network files
   - **D)** Nothing

3. When should you notify content resolver?
   - **A)** Never
   - **B)** After data changes
   - **C)** Before changes
   - **D)** Always

**Answers:**
1. **B** - Content Providers manage access to structured data and enable data sharing between applications
2. **B** - FileProvider provides secure file sharing using content:// URIs instead of file:// URIs
3. **B** - Notify content resolver after data changes so observers can update their UI

## Next Steps

- [Room Database & Data Persistence](../01_beginners/04.%20Room%20Database%20%26%20Data%20Persistence.md) - Database setup
- [File & Storage Management](./12.%20File%20%26%20Storage%20Management.md) - File handling
- [Android Permissions](./20.%20Android%20Permissions.md) - Provider permissions

