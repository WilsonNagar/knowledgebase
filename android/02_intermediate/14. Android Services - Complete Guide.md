---
number: 14
title: "Android Services - Complete Guide"
slug: "android-services-complete-guide"
level: "intermediate"
tags: ["services", "foreground-service", "background-service", "bound-service"]
prerequisites: ["android-lifecycle-components"]
estimated_minutes: 100
contributors: []
diagrams: []
examples: []
canonical_id: "android-intermediate-14"
---



# Android Services - Complete Guide

## Overview

Android Services are components that run in the background to perform long-running operations without a user interface. This comprehensive guide covers foreground services, background services, bound services, service lifecycle, service types, best practices, and when to use services vs other alternatives like WorkManager.

## Table of Contents

1. [What are Services?](#what-are-services)
2. [Service Types](#service-types)
3. [Foreground Services](#foreground-services)
4. [Background Services](#background-services)
5. [Bound Services](#bound-services)
6. [Service Lifecycle](#lifecycle)
7. [Service vs WorkManager](#service-vs-workmanager)
8. [Best Practices](#best-practices)

## What are Services?

### Definition

**Service**: Component that runs in background without UI

**Purpose**: Perform long-running operations

**Characteristics**:
- **No UI**: No user interface
- **Background**: Runs in background
- **Long-running**: Can run for extended periods
- **Independent**: Can run independently of activities

### When to Use Services

**Use Services For**:
- **Foreground Services**: User-visible long-running tasks
- **Music Playback**: Play music in background
- **File Downloads**: Download files
- **Location Tracking**: Track location continuously

**Don't Use Services For**:
- **Short Tasks**: Use coroutines
- **Deferrable Work**: Use WorkManager
- **UI Updates**: Use ViewModel/Compose

## Service Types

### 1. Foreground Service

**Foreground Service**: Service with persistent notification

**Characteristics**:
- **Visible**: User is aware of it
- **Notification**: Must show notification
- **High Priority**: Less likely to be killed
- **Use Case**: Music, downloads, location tracking

### 2. Background Service

**Background Service**: Service without notification

**Characteristics**:
- **Hidden**: User not aware
- **Low Priority**: More likely to be killed
- **Restrictions**: Android 8.0+ restrictions
- **Use Case**: Limited use cases

### 3. Bound Service

**Bound Service**: Service bound to components

**Characteristics**:
- **Client-Server**: Client-server communication
- **IPC**: Inter-process communication
- **Lifecycle**: Tied to bound components
- **Use Case**: Provide API to other components

## Foreground Services

### What are Foreground Services?

**Foreground Service**: Service with persistent notification

**Requirement**: Must show notification within 5 seconds

**Use Cases**:
- Music playback
- File downloads
- Location tracking
- Ongoing operations user cares about

### Creating Foreground Service

```kotlin
class MyForegroundService : Service() {
    companion object {
        private const val NOTIFICATION_ID = 1
        private const val CHANNEL_ID = "foreground_service_channel"
    }
    
    override fun onCreate() {
        super.onCreate()
        createNotificationChannel()
    }
    
    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
        val notification = createNotification()
        startForeground(NOTIFICATION_ID, notification)
        
        // Do work
        doWork()
        
        return START_STICKY
    }
    
    private fun createNotificationChannel() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            val channel = NotificationChannel(
                CHANNEL_ID,
                "Foreground Service",
                NotificationManager.IMPORTANCE_LOW
            ).apply {
                description = "Foreground service channel"
            }
            
            val notificationManager = getSystemService(NotificationManager::class.java)
            notificationManager.createNotificationChannel(channel)
        }
    }
    
    private fun createNotification(): Notification {
        val intent = Intent(this, MainActivity::class.java)
        val pendingIntent = PendingIntent.getActivity(
            this,
            0,
            intent,
            PendingIntent.FLAG_IMMUTABLE
        )
        
        return NotificationCompat.Builder(this, CHANNEL_ID)
            .setContentTitle("Service Running")
            .setContentText("Doing work...")
            .setSmallIcon(R.drawable.ic_notification)
            .setContentIntent(pendingIntent)
            .build()
    }
    
    private fun doWork() {
        // Long-running work
    }
    
    override fun onBind(intent: Intent?): IBinder? = null
}
```

### Starting Foreground Service

```kotlin
fun startForegroundService(context: Context) {
    val intent = Intent(context, MyForegroundService::class.java)
    
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
        context.startForegroundService(intent)
    } else {
        context.startService(intent)
    }
}
```

### Foreground Service Types

**1. Media Playback**:
```kotlin
val serviceIntent = Intent(context, MediaService::class.java)
ContextCompat.startForegroundService(context, serviceIntent)
```

**2. Location**:
```kotlin
val serviceIntent = Intent(context, LocationService::class.java)
ContextCompat.startForegroundService(context, serviceIntent)
```

**3. Data Sync**:
```kotlin
val serviceIntent = Intent(context, SyncService::class.java)
ContextCompat.startForegroundService(context, serviceIntent)
```

### Updating Foreground Service Notification

```kotlin
fun updateNotification(progress: Int) {
    val notification = NotificationCompat.Builder(this, CHANNEL_ID)
        .setContentTitle("Downloading")
        .setContentText("$progress%")
        .setProgress(100, progress, false)
        .setSmallIcon(R.drawable.ic_notification)
        .build()
    
    val notificationManager = getSystemService(NotificationManager::class.java)
    notificationManager.notify(NOTIFICATION_ID, notification)
}
```

## Background Services

### What are Background Services?

**Background Service**: Service without persistent notification

**Restrictions** (Android 8.0+):
- **Limited**: Cannot start from background
- **Killed**: More likely to be killed
- **Use WorkManager**: Prefer WorkManager instead

### Creating Background Service

```kotlin
class MyBackgroundService : Service() {
    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
        // Do work
        doWork()
        
        return START_NOT_STICKY
    }
    
    private fun doWork() {
        // Background work
    }
    
    override fun onBind(intent: Intent?): IBinder? = null
}
```

**Note**: Background services are restricted on Android 8.0+. Use WorkManager instead.

## Bound Services

### What are Bound Services?

**Bound Service**: Service bound to components

**Purpose**: Provide API to bound components

**Lifecycle**: Lives as long as bound components

### Creating Bound Service

```kotlin
class MyBoundService : Service() {
    private val binder = LocalBinder()
    
    inner class LocalBinder : Binder() {
        fun getService(): MyBoundService = this@MyBoundService
    }
    
    override fun onBind(intent: Intent): IBinder {
        return binder
    }
    
    fun getData(): String {
        return "Data from service"
    }
}
```

### Binding to Service

```kotlin
class MainActivity : AppCompatActivity() {
    private var boundService: MyBoundService? = null
    private var isBound = false
    
    private val serviceConnection = object : ServiceConnection {
        override fun onServiceConnected(name: ComponentName?, service: IBinder?) {
            val binder = service as MyBoundService.LocalBinder
            boundService = binder.getService()
            isBound = true
        }
        
        override fun onServiceDisconnected(name: ComponentName?) {
            isBound = false
            boundService = null
        }
    }
    
    override fun onStart() {
        super.onStart()
        val intent = Intent(this, MyBoundService::class.java)
        bindService(intent, serviceConnection, Context.BIND_AUTO_CREATE)
    }
    
    override fun onStop() {
        super.onStop()
        if (isBound) {
            unbindService(serviceConnection)
            isBound = false
        }
    }
    
    fun useService() {
        boundService?.getData()
    }
}
```

### Messenger-Based Bound Service

```kotlin
class MessengerService : Service() {
    companion object {
        const val MSG_GET_DATA = 1
    }
    
    private val messenger = Messenger(IncomingHandler())
    
    inner class IncomingHandler : Handler(Looper.getMainLooper()) {
        override fun handleMessage(msg: Message) {
            when (msg.what) {
                MSG_GET_DATA -> {
                    val replyTo = msg.replyTo
                    val reply = Message.obtain(null, MSG_GET_DATA)
                    reply.obj = "Data from service"
                    replyTo.send(reply)
                }
                else -> super.handleMessage(msg)
            }
        }
    }
    
    override fun onBind(intent: Intent): IBinder {
        return messenger.binder
    }
}
```

## Service Lifecycle

### Service Lifecycle Methods

**onCreate()**: Called when service is created
**onStartCommand()**: Called when service is started
**onBind()**: Called when service is bound
**onDestroy()**: Called when service is destroyed

### Lifecycle Flow

**Started Service**:
```
onCreate() → onStartCommand() → Running → onDestroy()
```

**Bound Service**:
```
onCreate() → onBind() → Running → onUnbind() → onDestroy()
```

### Return Values

**START_STICKY**: Service restarted if killed
**START_NOT_STICKY**: Service not restarted
**START_REDELIVER_INTENT**: Service restarted with last intent

```kotlin
override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
    // Do work
    return START_STICKY // Restart if killed
}
```

## Service vs WorkManager

### When to Use Service

**Use Service For**:
- **Foreground Operations**: User-visible tasks
- **Music Playback**: Continuous playback
- **Location Tracking**: Continuous tracking
- **Real-time Operations**: Immediate execution needed

### When to Use WorkManager

**Use WorkManager For**:
- **Deferrable Work**: Can be delayed
- **Periodic Tasks**: Recurring work
- **Constraints**: Network, charging, etc.
- **Guaranteed Execution**: Must run eventually

### Comparison

**Service**:
- Immediate execution
- User-visible (foreground)
- Higher priority
- More battery usage

**WorkManager**:
- Deferred execution
- Background only
- Lower priority
- Battery efficient

## Best Practices

### Practice 1: Use Foreground Services for User-Visible Work

```kotlin
// GOOD: Foreground service for downloads
class DownloadService : Service() {
    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
        startForeground(1, createNotification())
        downloadFile()
        return START_STICKY
    }
}

// BAD: Background service for user-visible work
class DownloadService : Service() {
    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
        downloadFile() // User doesn't know it's running
        return START_STICKY
    }
}
```

### Practice 2: Use WorkManager for Deferrable Work

```kotlin
// GOOD: WorkManager for background sync
WorkManager.getInstance(context)
    .enqueue(OneTimeWorkRequestBuilder<SyncWorker>().build())

// BAD: Background service for deferrable work
startService(Intent(context, SyncService::class.java))
```

### Practice 3: Handle Service Death

```kotlin
// GOOD: Handle service death
override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
    // Save state
    saveState()
    
    // Do work
    doWork()
    
    return START_STICKY // Restart if killed
}

// BAD: Assume service always runs
override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
    doWork() // Might be killed
    return START_NOT_STICKY
}
```

### Practice 4: Use Coroutines in Services

```kotlin
// GOOD: Use coroutines
class MyService : Service() {
    private val serviceScope = CoroutineScope(Dispatchers.Default + SupervisorJob())
    
    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
        serviceScope.launch {
            doWork()
        }
        return START_STICKY
    }
    
    override fun onDestroy() {
        super.onDestroy()
        serviceScope.cancel()
    }
}

// BAD: Block main thread
override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
    Thread.sleep(10000) // Blocks main thread!
    return START_STICKY
}
```

## Real-World Examples

### Music Playback Service

```kotlin
class MusicService : Service() {
    private var mediaPlayer: MediaPlayer? = null
    private var isPlaying = false
    
    override fun onCreate() {
        super.onCreate()
        createNotificationChannel()
    }
    
    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
        when (intent?.action) {
            "PLAY" -> playMusic()
            "PAUSE" -> pauseMusic()
            "STOP" -> stopMusic()
        }
        return START_STICKY
    }
    
    private fun playMusic() {
        if (mediaPlayer == null) {
            mediaPlayer = MediaPlayer.create(this, R.raw.music)
        }
        mediaPlayer?.start()
        isPlaying = true
        updateNotification("Playing")
    }
    
    private fun pauseMusic() {
        mediaPlayer?.pause()
        isPlaying = false
        updateNotification("Paused")
    }
    
    private fun stopMusic() {
        mediaPlayer?.stop()
        mediaPlayer?.release()
        mediaPlayer = null
        isPlaying = false
        stopForeground(true)
        stopSelf()
    }
    
    private fun updateNotification(status: String) {
        val notification = NotificationCompat.Builder(this, "music_channel")
            .setContentTitle("Music Player")
            .setContentText(status)
            .setSmallIcon(R.drawable.ic_music)
            .addAction(R.drawable.ic_play, "Play", createActionIntent("PLAY"))
            .addAction(R.drawable.ic_pause, "Pause", createActionIntent("PAUSE"))
            .addAction(R.drawable.ic_stop, "Stop", createActionIntent("STOP"))
            .build()
        
        startForeground(1, notification)
    }
    
    private fun createActionIntent(action: String): PendingIntent {
        val intent = Intent(this, MusicService::class.java).apply {
            this.action = action
        }
        return PendingIntent.getService(
            this,
            0,
            intent,
            PendingIntent.FLAG_IMMUTABLE
        )
    }
    
    override fun onBind(intent: Intent?): IBinder? = null
}
```

## Common Pitfalls

### Problem: Not Showing Notification for Foreground Service

```kotlin
// BAD: No notification
override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
    doWork() // Service will be killed!
    return START_STICKY
}

// GOOD: Show notification
override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
    startForeground(1, createNotification())
    doWork()
    return START_STICKY
}
```

### Problem: Using Background Service When WorkManager Would Work

```kotlin
// BAD: Background service for deferrable work
startService(Intent(context, SyncService::class.java))

// GOOD: WorkManager
WorkManager.getInstance(context)
    .enqueue(OneTimeWorkRequestBuilder<SyncWorker>().build())
```

## Quiz

1. What must foreground services show?
   - **A)** Dialog
   - **B)** Persistent notification
   - **C)** Toast
   - **D)** Nothing

2. When should you use WorkManager instead of Service?
   - **A)** Always
   - **B)** For deferrable background work
   - **C)** Never
   - **D)** For foreground work

3. What is a bound service?
   - **A)** Service that must be bound
   - **B)** Service bound to components for IPC
   - **C)** Service that cannot be unbound
   - **D)** Nothing

**Answers:**
1. **B** - Foreground services must show a persistent notification within 5 seconds of starting
2. **B** - Use WorkManager for deferrable background work that can be delayed, use Services for immediate user-visible tasks
3. **B** - Bound services provide IPC communication to bound components through Binder or Messenger

## Next Steps

- [WorkManager & Background Tasks](./13.%20WorkManager%20%26%20Background%20Tasks.md) - Deferrable work
- [Notifications & FCM](./22.%20Notifications%20%26%20FCM.md) - Service notifications
- [Android Lifecycle Components](../01_beginners/05.%20Android%20Lifecycle%20Components.md) - Lifecycle awareness

