---
number: 24
title: "Dependency Injection with Hilt"
slug: "dependency-injection-hilt"
level: "intermediate"
tags: ["hilt", "dagger", "dependency-injection", "di", "architecture"]
prerequisites: ["introduction-to-android-architecture", "solid-principles"]
estimated_minutes: 90
contributors: []
diagrams: []
examples: []
canonical_id: "android-intermediate-24"
---





# Dependency Injection with Hilt

## Overview

Dependency Injection (DI) is a design pattern that implements Inversion of Control for resolving dependencies. Hilt is Google's recommended DI solution for Android, built on top of Dagger. This comprehensive guide covers Hilt setup, modules, scopes, ViewModel injection, testing with Hilt, and best practices for building maintainable Android applications.

## Table of Contents

1. [What is Dependency Injection?](#what-is-di)
2. [Why Use Dependency Injection?](#why-di)
3. [Hilt vs Dagger](#hilt-vs-dagger)
4. [Setting Up Hilt](#setup)
5. [Hilt Modules](#modules)
6. [Scopes](#scopes)
7. [ViewModel Injection](#viewmodel-injection)
8. [Field Injection](#field-injection)
9. [Constructor Injection](#constructor-injection)
10. [Multi-Module Setup](#multi-module)
11. [Testing with Hilt](#testing)
12. [Best Practices](#best-practices)

## What is Dependency Injection?

### Definition

**Dependency Injection**: A design pattern where objects receive their dependencies from external sources rather than creating them internally

**Key Principle**: Inversion of Control (IoC) - dependencies are provided rather than created

### Without Dependency Injection

```kotlin
// BAD: Hard dependencies
class UserRepository {
    private val apiService = RetrofitApiService() // Hard dependency
    private val database = AppDatabase.getInstance() // Hard dependency
    
    fun getUser(id: Int): User {
        // Use apiService and database
    }
}

class UserViewModel {
    private val repository = UserRepository() // Hard dependency
    
    fun loadUser(id: Int) {
        val user = repository.getUser(id)
    }
}
```

**Problems**:
- Hard to test (can't mock dependencies)
- Tight coupling
- Difficult to change implementations
- Violates SOLID principles

### With Dependency Injection

```kotlin
// GOOD: Dependencies injected
class UserRepository(
    private val apiService: ApiService, // Injected
    private val database: AppDatabase    // Injected
) {
    fun getUser(id: Int): User {
        // Use apiService and database
    }
}

class UserViewModel(
    private val repository: UserRepository // Injected
) : ViewModel() {
    fun loadUser(id: Int) {
        val user = repository.getUser(id)
    }
}
```

**Benefits**:
- Easy to test (can inject mocks)
- Loose coupling
- Easy to change implementations
- Follows SOLID principles

## Why Use Dependency Injection?

### Benefits

**1. Testability**:
```kotlin
// Easy to test with mocks
class UserViewModelTest {
    @Test
    fun testLoadUser() {
        val mockRepository = mock<UserRepository>()
        val viewModel = UserViewModel(mockRepository)
        // Test viewModel
    }
}
```

**2. Flexibility**:
```kotlin
// Can swap implementations easily
// Development: MockApiService
// Production: RetrofitApiService
```

**3. Maintainability**:
```kotlin
// Dependencies are explicit
// Easy to understand and modify
```

**4. Reusability**:
```kotlin
// Share dependencies across components
// Single source of truth
```

## Hilt vs Dagger

### What is Hilt?

**Hilt**: Google's opinionated DI framework built on Dagger

**Built on**: Dagger 2 (industry-standard DI framework)

**Purpose**: Simplify Dagger usage for Android

### Hilt vs Dagger

**Dagger**:
- More flexible
- More boilerplate
- Steeper learning curve
- Manual setup

**Hilt**:
- Less boilerplate
- Easier to learn
- Automatic setup
- Android-specific optimizations

**Recommendation**: Use Hilt for new Android projects

## Setting Up Hilt

### Step 1: Add Dependencies

**Project-level `build.gradle.kts`**:
```kotlin
buildscript {
    dependencies {
        classpath("com.google.dagger:hilt-android-gradle-plugin:2.48")
    }
}
```

**App-level `build.gradle.kts`**:
```kotlin
plugins {
    id("com.android.application")
    id("org.jetbrains.kotlin.android")
    id("dagger.hilt.android.plugin")
    id("kotlin-kapt")
}

dependencies {
    // Hilt
    implementation("com.google.dagger:hilt-android:2.48")
    kapt("com.google.dagger:hilt-compiler:2.48")
    
    // Hilt for ViewModel
    implementation("androidx.hilt:hilt-lifecycle-viewmodel:1.0.0-alpha03")
    kapt("androidx.hilt:hilt-compiler:1.1.0")
}
```

### Step 2: Application Class

```kotlin
@HiltAndroidApp
class MyApplication : Application() {
    override fun onCreate() {
        super.onCreate()
    }
}
```

**AndroidManifest.xml**:
```xml
<application
    android:name=".MyApplication"
    ...>
</application>
```

### Step 3: Install Hilt in Activities/Fragments

**Activity**:
```kotlin
@AndroidEntryPoint
class MainActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
    }
}
```

**Fragment**:
```kotlin
@AndroidEntryPoint
class UserFragment : Fragment() {
    // Hilt automatically injects dependencies
}
```

## Hilt Modules

### What are Modules?

**Module**: Provides dependencies to Hilt

**Purpose**: Tell Hilt how to create dependencies

### @Module Annotation

```kotlin
@Module
@InstallIn(SingletonComponent::class)
object NetworkModule {
    @Provides
    @Singleton
    fun provideOkHttpClient(): OkHttpClient {
        return OkHttpClient.Builder()
            .connectTimeout(30, TimeUnit.SECONDS)
            .readTimeout(30, TimeUnit.SECONDS)
            .build()
    }
    
    @Provides
    @Singleton
    fun provideRetrofit(okHttpClient: OkHttpClient): Retrofit {
        return Retrofit.Builder()
            .baseUrl("https://api.example.com/")
            .client(okHttpClient)
            .addConverterFactory(GsonConverterFactory.create())
            .build()
    }
    
    @Provides
    @Singleton
    fun provideApiService(retrofit: Retrofit): ApiService {
        return retrofit.create(ApiService::class.java)
    }
}
```

### @Provides vs @Binds

**@Provides**: For concrete classes or complex creation logic

```kotlin
@Provides
@Singleton
fun provideApiService(retrofit: Retrofit): ApiService {
    return retrofit.create(ApiService::class.java)
}
```

**@Binds**: For interfaces (more efficient)

```kotlin
@Module
@InstallIn(SingletonComponent::class)
abstract class RepositoryModule {
    @Binds
    abstract fun bindUserRepository(
        userRepositoryImpl: UserRepositoryImpl
    ): UserRepository
}
```

### Database Module

```kotlin
@Module
@InstallIn(SingletonComponent::class)
object DatabaseModule {
    @Provides
    @Singleton
    fun provideDatabase(@ApplicationContext context: Context): AppDatabase {
        return Room.databaseBuilder(
            context,
            AppDatabase::class.java,
            "app_database"
        ).build()
    }
    
    @Provides
    fun provideUserDao(database: AppDatabase): UserDao {
        return database.userDao()
    }
}
```

### Repository Module

```kotlin
@Module
@InstallIn(SingletonComponent::class)
abstract class RepositoryModule {
    @Binds
    abstract fun bindUserRepository(
        userRepositoryImpl: UserRepositoryImpl
    ): UserRepository
}
```

## Scopes

### What are Scopes?

**Scope**: Defines the lifetime of a dependency

**Purpose**: Control when dependencies are created and destroyed

### Hilt Scopes

**1. @Singleton**: Application lifetime
```kotlin
@Provides
@Singleton
fun provideApiService(): ApiService {
    // Created once, lives for app lifetime
}
```

**2. @ActivityScoped**: Activity lifetime
```kotlin
@Provides
@ActivityScoped
fun provideActivityScopedDependency(): SomeClass {
    // Created per activity instance
}
```

**3. @ViewModelScoped**: ViewModel lifetime
```kotlin
@Provides
@ViewModelScoped
fun provideViewModelScopedDependency(): SomeClass {
    // Created per ViewModel instance
}
```

**4. @FragmentScoped**: Fragment lifetime
```kotlin
@Provides
@FragmentScoped
fun provideFragmentScopedDependency(): SomeClass {
    // Created per fragment instance
}
```

### Scope Hierarchy

```
@Singleton (Application)
    └─ @ActivityScoped (Activity)
        └─ @FragmentScoped (Fragment)
            └─ @ViewModelScoped (ViewModel)
```

**Rule**: Can inject scoped dependency into same or higher scope

## ViewModel Injection

### Using @HiltViewModel

```kotlin
@HiltViewModel
class UserViewModel @Inject constructor(
    private val repository: UserRepository
) : ViewModel() {
    fun loadUser(id: Int) {
        viewModelScope.launch {
            val user = repository.getUser(id)
            // Update UI state
        }
    }
}
```

### Using in Activity/Fragment

```kotlin
@AndroidEntryPoint
class UserActivity : AppCompatActivity() {
    private val viewModel: UserViewModel by viewModels()
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        // viewModel is automatically injected
    }
}
```

**Compose**:
```kotlin
@Composable
fun UserScreen(
    viewModel: UserViewModel = hiltViewModel()
) {
    // viewModel is automatically injected
}
```

## Field Injection

### @Inject Annotation

```kotlin
@AndroidEntryPoint
class MainActivity : AppCompatActivity() {
    @Inject
    lateinit var apiService: ApiService
    
    @Inject
    lateinit var repository: UserRepository
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        // Dependencies are injected automatically
        // Can use apiService and repository
    }
}
```

**Note**: Field injection is less preferred than constructor injection

## Constructor Injection

### Preferred Method

```kotlin
class UserRepository @Inject constructor(
    private val apiService: ApiService,
    private val database: AppDatabase
) {
    fun getUser(id: Int): User {
        // Use dependencies
    }
}
```

**Benefits**:
- Dependencies are explicit
- Immutable (val)
- Easy to test
- Compile-time safety

## Multi-Module Setup

### Project Structure

```
app/
  └─ build.gradle.kts
core/
  ├─ data/
  │   └─ build.gradle.kts
  └─ domain/
      └─ build.gradle.kts
feature/
  └─ auth/
      └─ build.gradle.kts
```

### Core Module Setup

**core/data/build.gradle.kts**:
```kotlin
plugins {
    id("dagger.hilt.android.plugin")
    id("kotlin-kapt")
}

dependencies {
    implementation("com.google.dagger:hilt-android:2.48")
    kapt("com.google.dagger:hilt-compiler:2.48")
}
```

**core/data/src/main/java/.../di/DataModule.kt**:
```kotlin
@Module
@InstallIn(SingletonComponent::class)
object DataModule {
    @Provides
    @Singleton
    fun provideApiService(): ApiService {
        // Implementation
    }
}
```

### Feature Module Setup

**feature/auth/build.gradle.kts**:
```kotlin
plugins {
    id("dagger.hilt.android.plugin")
    id("kotlin-kapt")
}

dependencies {
    implementation(project(":core:data"))
    implementation("com.google.dagger:hilt-android:2.48")
    kapt("com.google.dagger:hilt-compiler:2.48")
}
```

**feature/auth/src/main/java/.../di/AuthModule.kt**:
```kotlin
@Module
@InstallIn(ViewModelComponent::class)
abstract class AuthModule {
    @Binds
    abstract fun bindAuthRepository(
        authRepositoryImpl: AuthRepositoryImpl
    ): AuthRepository
}
```

### App Module Setup

**app/build.gradle.kts**:
```kotlin
dependencies {
    implementation(project(":core:data"))
    implementation(project(":core:domain"))
    implementation(project(":feature:auth"))
    
    implementation("com.google.dagger:hilt-android:2.48")
    kapt("com.google.dagger:hilt-compiler:2.48")
}
```

## Testing with Hilt

### Setup

**build.gradle.kts**:
```kotlin
dependencies {
    androidTestImplementation("com.google.dagger:hilt-android-testing:2.48")
    kaptAndroidTest("com.google.dagger:hilt-compiler:2.48")
}
```

### Test Application

```kotlin
@HiltAndroidApp
class TestApplication : Application()
```

### Test Module

```kotlin
@Module
@TestInstallIn(
    components = [SingletonComponent::class],
    replaces = [NetworkModule::class]
)
object FakeNetworkModule {
    @Provides
    @Singleton
    fun provideFakeApiService(): ApiService {
        return FakeApiService()
    }
}
```

### Test Class

```kotlin
@HiltAndroidTest
class UserViewModelTest {
    @get:Rule
    var hiltRule = HiltAndroidRule(this)
    
    @Inject
    lateinit var fakeRepository: FakeUserRepository
    
    @Before
    fun init() {
        hiltRule.inject()
    }
    
    @Test
    fun testLoadUser() {
        val viewModel = UserViewModel(fakeRepository)
        // Test
    }
}
```

## Best Practices

### Practice 1: Use Constructor Injection

```kotlin
// GOOD: Constructor injection
class UserRepository @Inject constructor(
    private val apiService: ApiService
)

// BAD: Field injection
class UserRepository {
    @Inject
    lateinit var apiService: ApiService
}
```

### Practice 2: Use Appropriate Scopes

```kotlin
// GOOD: Singleton for shared resources
@Provides
@Singleton
fun provideApiService(): ApiService

// GOOD: ViewModelScoped for ViewModel-specific
@Provides
@ViewModelScoped
fun provideViewModelHelper(): Helper
```

### Practice 3: Organize Modules

```kotlin
// GOOD: Separate modules by concern
@Module
@InstallIn(SingletonComponent::class)
object NetworkModule { }

@Module
@InstallIn(SingletonComponent::class)
object DatabaseModule { }

@Module
@InstallIn(SingletonComponent::class)
abstract class RepositoryModule { }
```

### Practice 4: Use @Binds for Interfaces

```kotlin
// GOOD: @Binds for interfaces
@Binds
abstract fun bindRepository(impl: RepositoryImpl): Repository

// OK: @Provides for concrete classes
@Provides
fun provideRepository(): RepositoryImpl
```

### Practice 5: Provide Context Properly

```kotlin
// GOOD: Use @ApplicationContext
@Provides
fun provideDatabase(@ApplicationContext context: Context): AppDatabase

// BAD: Don't use Activity context for singletons
@Provides
@Singleton
fun provideDatabase(context: Context): AppDatabase // Wrong!
```

## Real-World Examples

### Example 1: Complete Setup

```kotlin
// Application
@HiltAndroidApp
class MyApplication : Application()

// Network Module
@Module
@InstallIn(SingletonComponent::class)
object NetworkModule {
    @Provides
    @Singleton
    fun provideOkHttpClient(): OkHttpClient {
        return OkHttpClient.Builder()
            .addInterceptor(HttpLoggingInterceptor().apply {
                level = HttpLoggingInterceptor.Level.BODY
            })
            .build()
    }
    
    @Provides
    @Singleton
    fun provideRetrofit(okHttpClient: OkHttpClient): Retrofit {
        return Retrofit.Builder()
            .baseUrl("https://api.example.com/")
            .client(okHttpClient)
            .addConverterFactory(GsonConverterFactory.create())
            .build()
    }
    
    @Provides
    @Singleton
    fun provideApiService(retrofit: Retrofit): ApiService {
        return retrofit.create(ApiService::class.java)
    }
}

// Database Module
@Module
@InstallIn(SingletonComponent::class)
object DatabaseModule {
    @Provides
    @Singleton
    fun provideDatabase(@ApplicationContext context: Context): AppDatabase {
        return Room.databaseBuilder(
            context,
            AppDatabase::class.java,
            "app_database"
        ).build()
    }
    
    @Provides
    fun provideUserDao(database: AppDatabase): UserDao {
        return database.userDao()
    }
}

// Repository
class UserRepository @Inject constructor(
    private val apiService: ApiService,
    private val userDao: UserDao
) {
    suspend fun getUser(id: Int): User {
        // Implementation
    }
}

// ViewModel
@HiltViewModel
class UserViewModel @Inject constructor(
    private val repository: UserRepository
) : ViewModel() {
    fun loadUser(id: Int) {
        viewModelScope.launch {
            val user = repository.getUser(id)
        }
    }
}

// Activity
@AndroidEntryPoint
class MainActivity : AppCompatActivity() {
    private val viewModel: UserViewModel by viewModels()
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        // Use viewModel
    }
}
```

## Common Pitfalls

### Problem: Missing @HiltAndroidApp

```kotlin
// BAD: Missing annotation
class MyApplication : Application()

// GOOD: Add annotation
@HiltAndroidApp
class MyApplication : Application()
```

### Problem: Wrong Scope

```kotlin
// BAD: Activity-scoped dependency in singleton
@Provides
@Singleton
fun provideSomething(activity: Activity): Something

// GOOD: Use @ApplicationContext
@Provides
@Singleton
fun provideSomething(@ApplicationContext context: Context): Something
```

### Problem: Circular Dependencies

```kotlin
// BAD: Circular dependency
class A @Inject constructor(b: B)
class B @Inject constructor(a: A)

// GOOD: Refactor to remove cycle
class A @Inject constructor(b: B)
class B @Inject constructor(c: C)
```

## Quiz

1. What is the purpose of @HiltAndroidApp?
   - **A)** Marks Application class for Hilt
   - **B)** Marks Activity class
   - **C)** Marks ViewModel class
   - **D)** Nothing

2. What scope should be used for API service?
   - **A)** @ActivityScoped
   - **B)** @Singleton
   - **C)** @FragmentScoped
   - **D)** @ViewModelScoped

3. What is the difference between @Provides and @Binds?
   - **A)** @Provides for interfaces, @Binds for concrete classes
   - **B)** @Binds for interfaces, @Provides for concrete classes
   - **C)** They're the same
   - **D)** @Provides is deprecated

**Answers:**
1. **A** - @HiltAndroidApp marks the Application class, enabling Hilt dependency injection throughout the app
2. **B** - API services should be @Singleton since they're shared resources used across the app
3. **B** - @Binds is more efficient for interfaces, @Provides is for concrete classes or complex creation logic

## Next Steps

- [Introduction to Android Architecture](../beginners/01.%20Introduction%20to%20Android%20Architecture.md) - Architecture patterns
- [SOLID Principles](../beginners/02.%20SOLID%20Principles.md) - Design principles
- [Networking & API Integration](./25.%20Networking%20%26%20API%20Integration.md) - Using DI with networking

