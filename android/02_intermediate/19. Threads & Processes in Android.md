---
number: 19
title: "Threads & Processes in Android"
slug: "threads-processes-android"
level: "intermediate"
tags: ["threads", "processes", "multithreading", "android", "concurrency"]
prerequisites: ["java-threads-concurrency-basics", "android-lifecycle-components"]
estimated_minutes: 90
contributors: []
diagrams: []
examples: []
canonical_id: "android-intermediate-19"
---



# Threads & Processes in Android

## Overview

Understanding how threads and processes work in Android is crucial for building responsive, efficient applications. This comprehensive guide covers Android's process model, thread creation and management, the relationship between processes and threads, Android-specific threading considerations, thread scheduling, and best practices for multithreaded Android applications.

## Table of Contents

1. [Process vs Thread in Android](#process-vs-thread)
2. [Android Process Model](#android-process-model)
3. [Thread Creation in Android](#thread-creation)
4. [Main Thread (UI Thread)](#main-thread)
5. [Background Threads](#background-threads)
6. [Thread Communication](#thread-communication)
7. [Process Communication (IPC)](#process-communication)
8. [Thread Scheduling](#thread-scheduling)
9. [Best Practices](#best-practices)

## Process vs Thread in Android

### What is a Process?

**Process**: Isolated execution environment

**Characteristics**:
- **Memory Space**: Has its own memory space
- **Isolation**: Cannot directly access other processes' memory
- **Components**: Can contain multiple threads
- **Lifecycle**: Managed by Android system

### What is a Thread?

**Thread**: Lightweight execution unit within a process

**Characteristics**:
- **Shared Memory**: Shares memory with other threads in same process
- **Call Stack**: Has its own call stack
- **Execution**: Runs concurrently with other threads
- **Lightweight**: Cheaper to create than processes

### Comparison

| Aspect | Process | Thread |
|--------|---------|--------|
| **Memory** | Isolated | Shared |
| **Creation Cost** | Expensive | Lightweight |
| **Communication** | IPC (Binder, Intents) | Shared memory |
| **Context Switch** | Slow | Fast |
| **Crash Impact** | Only that process | Can affect process |
| **Android Example** | Each app = process | Main thread + worker threads |

### Android Context

**Process**:
- Each Android app runs in its own process
- Process name: `com.example.app`
- Process ID (PID): Unique system-wide
- Isolated from other apps

**Thread**:
- Each process has at least one thread (main thread)
- Can create multiple threads
- Threads share process memory
- Thread ID (TID): Unique within process

## Android Process Model

### Process Creation

**How Android Creates Processes**:

```
1. User launches app
2. Zygote process forks
3. New process created (copy of Zygote)
4. Process loads app's DEX files
5. Main thread created
6. Application.onCreate() called
7. Process ready
```

### Process Isolation

**Each App Process**:
- **Separate Memory**: Cannot access other apps' memory
- **Unique UID**: Each app has unique user ID
- **File Permissions**: Can only access own files
- **Security**: Isolated by Linux + SELinux

**Example**:
```kotlin
// App A (Process 1)
val data = "App A data" // In Process 1 memory

// App B (Process 2)
// Cannot directly access Process 1 memory
// Must use IPC (Binder, Intents, etc.)
```

### Process States

**1. Foreground Process**:
- User interacting with app
- Highest priority
- Contains foreground activity

**2. Visible Process**:
- App visible but not foreground
- High priority
- Contains visible activity

**3. Service Process**:
- Running background service
- Medium priority
- Service running

**4. Background Process**:
- App not visible
- Low priority
- No active components

**5. Empty Process**:
- No active components
- Lowest priority
- Cached for faster restart

### Process Priority Example

```kotlin
// Foreground process
class MainActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        // Process is FOREGROUND (highest priority)
    }
}

// Background process
class BackgroundService : Service() {
    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
        // Process is SERVICE (medium priority)
        return START_STICKY
    }
}
```

## Thread Creation in Android

### Main Thread (UI Thread)

**Automatic Creation**:
- Created automatically when process starts
- One per process
- Handles all UI operations

```kotlin
// Main thread is created automatically
class MainActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        // Running on main thread
        Log.d("Thread", "Main thread: ${Thread.currentThread().name}")
    }
}
```

### Creating Background Threads

**Method 1: Thread Class**:
```kotlin
val thread = Thread {
    // Runs on background thread
    doWork()
    // Update UI on main thread
    runOnUiThread {
        updateUI()
    }
}
thread.start()
```

**Method 2: Coroutines (Recommended)**:
```kotlin
lifecycleScope.launch {
    val result = withContext(Dispatchers.IO) {
        // Runs on background thread
        doWork()
    }
    // Back on main thread
    updateUI(result)
}
```

**Method 3: ExecutorService**:
```kotlin
val executor = Executors.newFixedThreadPool(4)
executor.execute {
    // Runs on background thread
    doWork()
}
```

**Method 4: HandlerThread**:
```kotlin
val handlerThread = HandlerThread("WorkerThread")
handlerThread.start()
val handler = Handler(handlerThread.looper)
handler.post {
    // Runs on HandlerThread
    doWork()
}
```

## Main Thread (UI Thread)

### What is the Main Thread?

**Main Thread**: Primary thread in Android process

**Responsibilities**:
- **UI Updates**: All UI operations
- **Event Handling**: Touch events, key events
- **Lifecycle**: Activity/Fragment lifecycle
- **View Drawing**: View.onDraw(), measure, layout

### Why Single UI Thread?

**Thread Safety**:
- UI components are not thread-safe
- Multiple threads updating UI = crashes
- Single thread = no synchronization needed

**Performance**:
- Avoids synchronization overhead
- Predictable execution order
- Simpler programming model

### Main Thread Operations

**Must Run on Main Thread**:
```kotlin
// UI updates
textView.text = "Hello"

// View operations
view.visibility = View.VISIBLE

// Activity operations
startActivity(intent)

// Fragment operations
supportFragmentManager.beginTransaction()
```

**Must NOT Run on Main Thread**:
```kotlin
// Network requests
val response = api.getData() // BAD: Blocks UI

// File I/O
val file = File("data.txt").readText() // BAD: Blocks UI

// Heavy computation
val result = heavyComputation() // BAD: Blocks UI
```

### Checking Current Thread

```kotlin
fun isMainThread(): Boolean {
    return Looper.getMainLooper().thread == Thread.currentThread()
}

// Usage
if (isMainThread()) {
    // On main thread
} else {
    // On background thread
    runOnUiThread {
        // Switch to main thread
    }
}
```

## Background Threads

### When to Use Background Threads

**Use Background Threads For**:
- **Network Requests**: API calls, downloads
- **File I/O**: Reading/writing files
- **Database Operations**: Room queries (Room handles this)
- **Heavy Computation**: Image processing, calculations
- **Parsing**: JSON, XML parsing

### Creating Background Threads

**Coroutines (Recommended)**:
```kotlin
// Background work
lifecycleScope.launch(Dispatchers.IO) {
    val data = fetchData()
    withContext(Dispatchers.Main) {
        updateUI(data)
    }
}
```

**Thread Pool**:
```kotlin
val executor = Executors.newFixedThreadPool(4)
executor.execute {
    val data = fetchData()
    runOnUiThread {
        updateUI(data)
    }
}
```

**HandlerThread**:
```kotlin
val handlerThread = HandlerThread("Worker")
handlerThread.start()
val handler = Handler(handlerThread.looper)
handler.post {
    val data = fetchData()
    Handler(Looper.getMainLooper()).post {
        updateUI(data)
    }
}
```

### Thread Lifecycle in Android

**Thread States**:
```
NEW → RUNNABLE → RUNNING → BLOCKED/WAITING → TERMINATED
```

**Android Considerations**:
- **Process Death**: Threads die when process dies
- **Configuration Changes**: Threads survive (if process survives)
- **Background Limits**: Background threads restricted on Android 8.0+

## Thread Communication

### Within Same Process

**Shared Memory**:
```kotlin
// Shared variable
var counter = 0

// Thread 1
thread {
    counter++
}

// Thread 2
thread {
    counter++ // Can access same variable
}
```

**Synchronization**:
```kotlin
val lock = Any()

// Thread 1
synchronized(lock) {
    sharedData = "Updated"
}

// Thread 2
synchronized(lock) {
    val data = sharedData // Safe access
}
```

**Handler Communication**:
```kotlin
// Main thread handler
val mainHandler = Handler(Looper.getMainLooper())

// Background thread
thread {
    val result = doWork()
    mainHandler.post {
        // Runs on main thread
        updateUI(result)
    }
}
```

**Coroutines**:
```kotlin
// Background thread
lifecycleScope.launch(Dispatchers.IO) {
    val result = doWork()
    // Switch to main thread
    withContext(Dispatchers.Main) {
        updateUI(result)
    }
}
```

## Process Communication (IPC)

### Why IPC?

**Process Isolation**:
- Processes cannot directly access each other's memory
- Need IPC for inter-process communication

### IPC Mechanisms

**1. Binder (Most Common)**:
```kotlin
// Service in Process A
class MyService : Service() {
    private val binder = object : IMyService.Stub() {
        override fun getData(): String {
            return "Data from Process A"
        }
    }
    
    override fun onBind(intent: Intent): IBinder {
        return binder
    }
}

// Client in Process B
val serviceConnection = object : ServiceConnection {
    override fun onServiceConnected(name: ComponentName?, service: IBinder?) {
        val myService = IMyService.Stub.asInterface(service)
        val data = myService.getData() // IPC call
    }
    
    override fun onServiceDisconnected(name: ComponentName?) {}
}
```

**2. Intents**:
```kotlin
// Process A: Send intent
val intent = Intent().apply {
    action = "com.example.ACTION"
    putExtra("data", "Data")
}
sendBroadcast(intent)

// Process B: Receive intent
class MyReceiver : BroadcastReceiver() {
    override fun onReceive(context: Context, intent: Intent) {
        val data = intent.getStringExtra("data")
    }
}
```

**3. ContentProvider**:
```kotlin
// Process A: Provide data
class MyProvider : ContentProvider() {
    override fun query(uri: Uri, ...): Cursor? {
        // Return data
    }
}

// Process B: Query data
val cursor = contentResolver.query(
    Uri.parse("content://com.example.provider/data"),
    null, null, null, null
)
```

**4. AIDL (Advanced)**:
```kotlin
// Define interface
interface IMyService : IInterface {
    fun getData(): String
}

// Implement in service
// Use in client
```

## Thread Scheduling

### How Android Schedules Threads

**Linux Kernel Scheduler**:
- Android uses Linux kernel's CFS (Completely Fair Scheduler)
- Threads scheduled based on priority
- Time slices allocated fairly

**Thread Priority**:
```kotlin
// Set thread priority
thread.priority = Thread.MAX_PRIORITY // 10
thread.priority = Thread.NORM_PRIORITY // 5 (default)
thread.priority = Thread.MIN_PRIORITY // 1
```

**Process Priority**:
- Determined by Android system
- Based on process state (foreground, background, etc.)
- Cannot be set directly by app

### Thread Priority in Android

**Main Thread**:
- Normal priority
- Gets CPU time for UI responsiveness

**Background Threads**:
- Lower priority (by default)
- Can be adjusted if needed

**Example**:
```kotlin
val thread = Thread {
    // Set higher priority for important work
    Thread.currentThread().priority = Thread.MAX_PRIORITY
    doImportantWork()
}
thread.start()
```

### Thread Scheduling Considerations

**Don't Rely on Priority**:
- Priority is a hint, not guarantee
- System can adjust priorities
- Focus on correct design instead

**Use Appropriate Mechanisms**:
- Coroutines for async work
- WorkManager for background tasks
- Foreground services for long-running work

## Best Practices

### Practice 1: Keep Main Thread Responsive

```kotlin
// BAD: Block main thread
override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    val data = fetchDataFromNetwork() // Blocks UI!
    updateUI(data)
}

// GOOD: Use background thread
override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    lifecycleScope.launch(Dispatchers.IO) {
        val data = fetchDataFromNetwork()
        withContext(Dispatchers.Main) {
            updateUI(data)
        }
    }
}
```

### Practice 2: Use Coroutines for Async Work

```kotlin
// GOOD: Coroutines
lifecycleScope.launch {
    val result = withContext(Dispatchers.IO) {
        doWork()
    }
    updateUI(result)
}

// BAD: Manual thread management
val thread = Thread {
    val result = doWork()
    runOnUiThread {
        updateUI(result)
    }
}
thread.start()
```

### Practice 3: Avoid Process Creation When Possible

```kotlin
// BAD: Separate process (unless needed)
<service
    android:name=".MyService"
    android:process=":remote" />

// GOOD: Same process (default)
<service
    android:name=".MyService" />
```

### Practice 4: Handle Thread Lifecycle

```kotlin
// GOOD: Cancel threads on lifecycle end
class MyActivity : AppCompatActivity() {
    private val executor = Executors.newFixedThreadPool(4)
    
    override fun onDestroy() {
        super.onDestroy()
        executor.shutdown() // Clean up
    }
}

// BAD: Threads continue after activity destroyed
val thread = Thread { doWork() }
thread.start() // May continue after activity destroyed
```

### Practice 5: Use Thread-Safe Data Structures

```kotlin
// GOOD: Thread-safe collections
val list = Collections.synchronizedList(mutableListOf<String>())
val map = ConcurrentHashMap<String, String>()

// BAD: Non-thread-safe collections
val list = mutableListOf<String>() // Not thread-safe
```

## Real-World Examples

### Example 1: Network Request with Threading

```kotlin
class MainActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        
        // Background thread: Network request
        lifecycleScope.launch(Dispatchers.IO) {
            try {
                val response = apiService.getData()
                
                // Main thread: Update UI
                withContext(Dispatchers.Main) {
                    textView.text = response.data
                }
            } catch (e: Exception) {
                withContext(Dispatchers.Main) {
                    showError(e.message)
                }
            }
        }
    }
}
```

### Example 2: Image Processing

```kotlin
fun processImage(bitmap: Bitmap) {
    // Background thread: Process image
    lifecycleScope.launch(Dispatchers.Default) {
        val processed = bitmap.let {
            // Heavy image processing
            processBitmap(it)
        }
        
        // Main thread: Update UI
        withContext(Dispatchers.Main) {
            imageView.setImageBitmap(processed)
        }
    }
}
```

### Example 3: Multiple Background Tasks

```kotlin
fun loadData() {
    lifecycleScope.launch {
        // Run multiple tasks concurrently
        val deferred1 = async(Dispatchers.IO) { loadData1() }
        val deferred2 = async(Dispatchers.IO) { loadData2() }
        val deferred3 = async(Dispatchers.IO) { loadData3() }
        
        // Wait for all
        val results = awaitAll(deferred1, deferred2, deferred3)
        
        // Main thread: Update UI
        withContext(Dispatchers.Main) {
            updateUI(results)
        }
    }
}
```

## Common Pitfalls

### Problem: Updating UI from Background Thread

```kotlin
// BAD: UI update from background thread
thread {
    textView.text = "Updated" // Crashes!
}

// GOOD: Switch to main thread
thread {
    val data = fetchData()
    runOnUiThread {
        textView.text = data
    }
}
```

### Problem: Process Death Not Handled

```kotlin
// BAD: Assume process always alive
class MyService : Service() {
    private var data: String? = null
    
    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
        // Process might be killed
        data = fetchData() // Lost if process killed
        return START_STICKY
    }
}

// GOOD: Handle process death
override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
    // Save state
    saveState()
    
    // Restore if needed
    restoreState()
    
    return START_STICKY
}
```

### Problem: Thread Leaks

```kotlin
// BAD: Threads not cleaned up
class MyActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        Thread {
            while (true) {
                doWork() // Continues after activity destroyed
            }
        }.start()
    }
}

// GOOD: Clean up threads
class MyActivity : AppCompatActivity() {
    private var thread: Thread? = null
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        thread = Thread {
            while (!Thread.currentThread().isInterrupted) {
                doWork()
            }
        }
        thread?.start()
    }
    
    override fun onDestroy() {
        super.onDestroy()
        thread?.interrupt()
    }
}
```

## Quiz

1. What is the main difference between a process and a thread in Android?
   - **A)** No difference
   - **B)** Process has isolated memory, thread shares memory
   - **C)** Thread is heavier than process
   - **D)** Process is lighter than thread

2. Why must UI updates happen on the main thread?
   - **A)** It's faster
   - **B)** UI components are not thread-safe
   - **C)** It's optional
   - **D)** Android requires it for security

3. How do threads in different processes communicate?
   - **A)** Shared memory
   - **B)** IPC mechanisms (Binder, Intents)
   - **C)** Direct method calls
   - **D)** They cannot communicate

**Answers:**
1. **B** - Processes have isolated memory spaces and cannot directly access each other's memory, while threads within the same process share memory
2. **B** - UI components are not thread-safe, so all UI operations must happen on a single thread (the main thread) to avoid crashes and race conditions
3. **B** - Threads in different processes communicate using IPC mechanisms like Binder, Intents, ContentProviders, or AIDL, since they cannot share memory

## Next Steps

- [Java Threads & Concurrency Basics](../beginners/07.%20Java%20Threads%20%26%20Concurrency%20Basics.md) - Java threading fundamentals
- [Kotlin Coroutines Basics](../beginners/03.%20Kotlin%20Coroutines%20Basics.md) - Modern concurrency
- [Android OS Internals - Looper, Handler & MessageQueue](../advanced/35.%20Android%20OS%20Internals%20-%20Looper%2C%20Handler%20%26%20MessageQueue.md) - Android threading internals
- [Android OS Internals - Architecture & Process Management](../advanced/29.%20Android%20OS%20Internals%20-%20Architecture%20%26%20Process%20Management.md) - Process management

