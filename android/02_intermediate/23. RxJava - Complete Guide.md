---
number: 23
title: "RxJava - Complete Guide"
slug: "rxjava-complete-guide"
level: "intermediate"
tags: ["rxjava", "reactive", "observable", "observer", "rxandroid"]
prerequisites: ["kotlin-coroutines-basics"]
estimated_minutes: 150
contributors: []
diagrams: []
examples: []
canonical_id: "android-23"
---

# RxJava - Complete Guide

## Overview

RxJava is a reactive programming library for composing asynchronous and event-based programs using observable sequences. While Kotlin Coroutines and Flow are now preferred for new Android projects, understanding RxJava is important for maintaining legacy codebases and understanding reactive programming concepts. This comprehensive guide covers Observables, Observers, operators, threading, error handling, and best practices.

## Table of Contents

1. [What is RxJava?](#what-is-rxjava)
2. [Observable](#observable)
3. [Observer](#observer)
4. [Operators](#operators)
5. [Schedulers](#schedulers)
6. [Subjects](#subjects)
7. [Error Handling](#error-handling)
8. [RxJava in Android](#rxjava-in-android)
9. [Migration to Coroutines/Flow](#migration)
10. [Best Practices](#best-practices)

## What is RxJava?

### Definition

**RxJava**: Reactive Extensions for Java - library for composing asynchronous and event-based programs

**Core Concepts**:
- **Observable**: Source of data/events
- **Observer**: Consumer of data/events
- **Operators**: Transformations and compositions
- **Schedulers**: Thread management

### RxJava vs Coroutines/Flow

**RxJava**:
- **Mature**: Well-established, many operators
- **Java-Compatible**: Works with Java
- **Complex**: Steeper learning curve
- **Legacy**: Being replaced by Coroutines/Flow

**Coroutines/Flow**:
- **Kotlin-Native**: Built for Kotlin
- **Simpler**: Easier to learn
- **Modern**: Recommended for new projects
- **Better Integration**: Better Android integration

### When to Use RxJava

**Use RxJava When**:
- **Legacy Codebase**: Maintaining existing RxJava code
- **Complex Transformations**: Need advanced operators
- **Java Codebase**: Working with Java code
- **Team Familiarity**: Team already knows RxJava

**Prefer Coroutines/Flow When**:
- **New Projects**: Starting new Android projects
- **Kotlin Codebase**: Pure Kotlin codebase
- **Simplicity**: Want simpler code

## Observable

### What is Observable?

**Observable**: Source that emits items over time

**Types**:
- **Observable**: Emits 0..N items, may complete or error
- **Single**: Emits exactly 1 item or error
- **Completable**: Emits completion or error (no items)
- **Maybe**: Emits 0 or 1 item, may complete or error

### Creating Observables

**1. Observable.create()**:
```kotlin
val observable = Observable.create<Int> { emitter ->
    emitter.onNext(1)
    emitter.onNext(2)
    emitter.onNext(3)
    emitter.onComplete()
}
```

**2. Observable.just()**:
```kotlin
val observable = Observable.just(1, 2, 3)
```

**3. Observable.fromIterable()**:
```kotlin
val observable = Observable.fromIterable(listOf(1, 2, 3))
```

**4. Observable.range()**:
```kotlin
val observable = Observable.range(1, 5) // 1, 2, 3, 4, 5
```

**5. Observable.interval()**:
```kotlin
val observable = Observable.interval(1, TimeUnit.SECONDS)
    .take(5) // Emit 5 values
```

**6. Observable.fromCallable()**:
```kotlin
val observable = Observable.fromCallable {
    fetchData() // Lazy execution
}
```

### Observable Types

**1. Observable<T>**:
```kotlin
val observable: Observable<String> = Observable.just("Hello")
```

**2. Single<T>**:
```kotlin
val single: Single<User> = Single.just(User("John"))
```

**3. Completable**:
```kotlin
val completable: Completable = Completable.fromAction {
    saveData()
}
```

**4. Maybe<T>**:
```kotlin
val maybe: Maybe<User> = Maybe.just(User("John"))
// or
val maybeEmpty: Maybe<User> = Maybe.empty()
```

## Observer

### What is Observer?

**Observer**: Consumer that receives items from Observable

**Methods**:
- **onNext()**: Receives next item
- **onError()**: Receives error
- **onComplete()**: Receives completion signal

### Subscribing to Observable

**1. Basic Subscription**:
```kotlin
observable.subscribe(
    { value -> println(value) }, // onNext
    { error -> println("Error: $error") }, // onError
    { println("Complete") } // onComplete
)
```

**2. Observer Interface**:
```kotlin
val observer = object : Observer<Int> {
    override fun onSubscribe(d: Disposable) {
        // Called on subscription
    }
    
    override fun onNext(value: Int) {
        println(value)
    }
    
    override fun onError(e: Throwable) {
        println("Error: $e")
    }
    
    override fun onComplete() {
        println("Complete")
    }
}

observable.subscribe(observer)
```

**3. Consumer (Simplified)**:
```kotlin
observable.subscribe(
    { value -> println(value) } // onNext only
)
```

### Disposable

**Disposable**: Represents subscription, used for cancellation

```kotlin
val disposable = observable.subscribe { value ->
    println(value)
}

// Cancel subscription
disposable.dispose()
```

**CompositeDisposable**: Manage multiple disposables

```kotlin
val compositeDisposable = CompositeDisposable()

compositeDisposable.add(observable1.subscribe { })
compositeDisposable.add(observable2.subscribe { })

// Dispose all
compositeDisposable.clear()
```

## Operators

### Transformation Operators

**1. map**:
```kotlin
Observable.just(1, 2, 3)
    .map { it * 2 }
    .subscribe { println(it) } // 2, 4, 6
```

**2. flatMap**:
```kotlin
Observable.just(1, 2, 3)
    .flatMap { value ->
        Observable.just(value, value * 2)
    }
    .subscribe { println(it) } // 1, 2, 2, 4, 3, 6
```

**3. concatMap**:
```kotlin
Observable.just(1, 2, 3)
    .concatMap { value ->
        Observable.just(value, value * 2)
    }
    .subscribe { println(it) } // Sequential: 1, 2, 2, 4, 3, 6
```

**4. switchMap**:
```kotlin
Observable.just(1, 2, 3)
    .switchMap { value ->
        Observable.just(value, value * 2)
    }
    .subscribe { println(it) } // Only latest
```

**5. scan**:
```kotlin
Observable.just(1, 2, 3, 4, 5)
    .scan { acc, value -> acc + value }
    .subscribe { println(it) } // 1, 3, 6, 10, 15
```

### Filtering Operators

**1. filter**:
```kotlin
Observable.just(1, 2, 3, 4, 5)
    .filter { it % 2 == 0 }
    .subscribe { println(it) } // 2, 4
```

**2. take**:
```kotlin
Observable.just(1, 2, 3, 4, 5)
    .take(3)
    .subscribe { println(it) } // 1, 2, 3
```

**3. skip**:
```kotlin
Observable.just(1, 2, 3, 4, 5)
    .skip(2)
    .subscribe { println(it) } // 3, 4, 5
```

**4. distinct**:
```kotlin
Observable.just(1, 1, 2, 2, 3)
    .distinct()
    .subscribe { println(it) } // 1, 2, 3
```

**5. debounce**:
```kotlin
Observable.create<Int> { emitter ->
    emitter.onNext(1)
    Thread.sleep(100)
    emitter.onNext(2)
    Thread.sleep(500)
    emitter.onNext(3)
    emitter.onComplete()
}
    .debounce(200, TimeUnit.MILLISECONDS)
    .subscribe { println(it) } // 2, 3
```

### Combining Operators

**1. merge**:
```kotlin
val observable1 = Observable.just(1, 2, 3)
val observable2 = Observable.just(4, 5, 6)

Observable.merge(observable1, observable2)
    .subscribe { println(it) } // Interleaved: 1, 4, 2, 5, 3, 6
```

**2. concat**:
```kotlin
val observable1 = Observable.just(1, 2, 3)
val observable2 = Observable.just(4, 5, 6)

Observable.concat(observable1, observable2)
    .subscribe { println(it) } // Sequential: 1, 2, 3, 4, 5, 6
```

**3. zip**:
```kotlin
val observable1 = Observable.just(1, 2, 3)
val observable2 = Observable.just("a", "b", "c")

Observable.zip(observable1, observable2) { a, b ->
    "$a$b"
}.subscribe { println(it) } // 1a, 2b, 3c
```

**4. combineLatest**:
```kotlin
val observable1 = Observable.just(1, 2, 3)
val observable2 = Observable.just("a", "b", "c")

Observable.combineLatest(observable1, observable2) { a, b ->
    "$a$b"
}.subscribe { println(it) } // Combines latest values
```

## Schedulers

### What are Schedulers?

**Scheduler**: Determines thread for Observable operations

**Types**:
- **Schedulers.io()**: For I/O operations
- **Schedulers.computation()**: For CPU-intensive work
- **Schedulers.mainThread()**: Main/UI thread (RxAndroid)
- **Schedulers.newThread()**: New thread for each operation
- **Schedulers.trampoline()**: Current thread, sequential

### Using Schedulers

**1. subscribeOn**:
```kotlin
Observable.just(1, 2, 3)
    .subscribeOn(Schedulers.io()) // Where Observable runs
    .subscribe { println(it) }
```

**2. observeOn**:
```kotlin
Observable.just(1, 2, 3)
    .observeOn(AndroidSchedulers.mainThread()) // Where Observer runs
    .subscribe { updateUI(it) }
```

**3. Both**:
```kotlin
Observable.fromCallable { fetchData() }
    .subscribeOn(Schedulers.io()) // Background thread
    .observeOn(AndroidSchedulers.mainThread()) // Main thread
    .subscribe { updateUI(it) }
```

## Subjects

### What are Subjects?

**Subject**: Observable + Observer (can emit and subscribe)

**Types**:
- **PublishSubject**: Emits items to current subscribers
- **BehaviorSubject**: Emits last item + new items
- **ReplaySubject**: Replays all items to new subscribers
- **AsyncSubject**: Emits only last item on completion

### PublishSubject

```kotlin
val subject = PublishSubject.create<Int>()

subject.subscribe { println("Observer 1: $it") }
subject.onNext(1) // Observer 1: 1

subject.subscribe { println("Observer 2: $it") }
subject.onNext(2) // Observer 1: 2, Observer 2: 2
```

### BehaviorSubject

```kotlin
val subject = BehaviorSubject.create<Int>()

subject.onNext(0) // Initial value

subject.subscribe { println("Observer 1: $it") } // Observer 1: 0

subject.onNext(1) // Observer 1: 1

subject.subscribe { println("Observer 2: $it") } // Observer 2: 1 (gets last value)
```

### ReplaySubject

```kotlin
val subject = ReplaySubject.create<Int>()

subject.onNext(1)
subject.onNext(2)
subject.onNext(3)

subject.subscribe { println(it) } // 1, 2, 3 (replays all)
```

## Error Handling

### onErrorReturn

```kotlin
Observable.just(1, 2, 3)
    .map { if (it == 2) throw RuntimeException() else it }
    .onErrorReturn { -1 }
    .subscribe { println(it) } // 1, -1
```

### onErrorResumeNext

```kotlin
Observable.just(1, 2, 3)
    .map { if (it == 2) throw RuntimeException() else it }
    .onErrorResumeNext(Observable.just(10, 20))
    .subscribe { println(it) } // 1, 10, 20
```

### retry

```kotlin
Observable.fromCallable { fetchData() }
    .retry(3) // Retry 3 times
    .subscribe { println(it) }
```

### retryWhen

```kotlin
Observable.fromCallable { fetchData() }
    .retryWhen { errors ->
        errors.zipWith(Observable.range(1, 3)) { error, retryCount ->
            if (retryCount < 3) {
                Observable.timer(retryCount.toLong(), TimeUnit.SECONDS)
            } else {
                Observable.error(error)
            }
        }.flatMap { it }
    }
    .subscribe { println(it) }
```

## RxJava in Android

### RxAndroid

**RxAndroid**: Android-specific bindings for RxJava

**Dependency**:
```kotlin
implementation("io.reactivex.rxjava3:rxandroid:3.0.0")
```

**MainThread Scheduler**:
```kotlin
Observable.just(1, 2, 3)
    .observeOn(AndroidSchedulers.mainThread())
    .subscribe { updateUI(it) }
```

### RxJava in ViewModel

```kotlin
class UserViewModel(
    private val repository: UserRepository
) : ViewModel() {
    
    private val compositeDisposable = CompositeDisposable()
    
    private val _users = MutableLiveData<List<User>>()
    val users: LiveData<List<User>> = _users
    
    fun loadUsers() {
        repository.getUsersObservable()
            .subscribeOn(Schedulers.io())
            .observeOn(AndroidSchedulers.mainThread())
            .subscribe(
                { users -> _users.value = users },
                { error -> handleError(error) }
            )
            .let { compositeDisposable.add(it) }
    }
    
    override fun onCleared() {
        super.onCleared()
        compositeDisposable.clear()
    }
}
```

### RxJava with Retrofit

```kotlin
interface ApiService {
    @GET("users")
    fun getUsers(): Observable<List<User>>
}

class UserRepository(
    private val apiService: ApiService
) {
    fun getUsersObservable(): Observable<List<User>> {
        return apiService.getUsers()
            .subscribeOn(Schedulers.io())
            .observeOn(AndroidSchedulers.mainThread())
    }
}
```

### RxBinding

**RxBinding**: RxJava bindings for Android views

**Dependency**:
```kotlin
implementation("com.jakewharton.rxbinding4:rxbinding:4.0.0")
```

**Usage**:
```kotlin
RxTextView.textChanges(searchView)
    .debounce(300, TimeUnit.MILLISECONDS)
    .filter { it.isNotEmpty() }
    .switchMap { query ->
        repository.searchObservable(query.toString())
    }
    .observeOn(AndroidSchedulers.mainThread())
    .subscribe { results ->
        updateResults(results)
    }
```

## Migration to Coroutines/Flow

### Observable → Flow

**Before (RxJava)**:
```kotlin
fun getUsersObservable(): Observable<List<User>> {
    return apiService.getUsers()
        .subscribeOn(Schedulers.io())
        .observeOn(AndroidSchedulers.mainThread())
}
```

**After (Flow)**:
```kotlin
fun getUsersFlow(): Flow<List<User>> = flow {
    emit(apiService.getUsers())
}
    .flowOn(Dispatchers.IO)
```

### Single → Flow

**Before (RxJava)**:
```kotlin
fun getUserSingle(id: Int): Single<User> {
    return apiService.getUser(id)
        .subscribeOn(Schedulers.io())
}
```

**After (Flow)**:
```kotlin
fun getUserFlow(id: Int): Flow<User> = flow {
    emit(apiService.getUser(id))
}
    .flowOn(Dispatchers.IO)
```

### Subject → StateFlow/SharedFlow

**Before (RxJava)**:
```kotlin
val subject = BehaviorSubject.create<User>()
subject.subscribe { user -> updateUI(user) }
subject.onNext(user)
```

**After (Flow)**:
```kotlin
private val _user = MutableStateFlow<User?>(null)
val user: StateFlow<User?> = _user.asStateFlow()

user.collect { user -> updateUI(user) }
_user.value = user
```

## Best Practices

### Practice 1: Dispose Subscriptions

```kotlin
// GOOD: Dispose in onCleared
class MyViewModel : ViewModel() {
    private val compositeDisposable = CompositeDisposable()
    
    fun loadData() {
        observable.subscribe { }
            .let { compositeDisposable.add(it) }
    }
    
    override fun onCleared() {
        compositeDisposable.clear()
    }
}
```

### Practice 2: Use Appropriate Schedulers

```kotlin
// GOOD: Use appropriate schedulers
Observable.fromCallable { fetchData() }
    .subscribeOn(Schedulers.io()) // I/O operation
    .observeOn(AndroidSchedulers.mainThread()) // UI update
    .subscribe { updateUI(it) }
```

### Practice 3: Handle Errors

```kotlin
// GOOD: Handle errors
observable
    .onErrorReturn { fallbackValue }
    .subscribe { value ->
        process(value)
    }
```

### Practice 4: Avoid Memory Leaks

```kotlin
// BAD: No disposal
observable.subscribe { }

// GOOD: Dispose properly
val disposable = observable.subscribe { }
// Dispose when done
disposable.dispose()
```

## Common Pitfalls

### Problem: Not Disposing Subscriptions

```kotlin
// BAD: Memory leak
fun loadData() {
    observable.subscribe { }
    // Subscription never disposed
}

// GOOD: Dispose properly
private val compositeDisposable = CompositeDisposable()

fun loadData() {
    observable.subscribe { }
        .let { compositeDisposable.add(it) }
}
```

### Problem: Wrong Thread

```kotlin
// BAD: UI update on background thread
Observable.just(data)
    .subscribeOn(Schedulers.io())
    .subscribe { updateUI(it) } // Crashes!

// GOOD: Observe on main thread
Observable.just(data)
    .subscribeOn(Schedulers.io())
    .observeOn(AndroidSchedulers.mainThread())
    .subscribe { updateUI(it) }
```

## Quiz

1. What is Observable in RxJava?
   - **A)** Observer
   - **B)** Source that emits items over time
   - **C)** Operator
   - **D)** Scheduler

2. What is the difference between subscribeOn and observeOn?
   - **A)** They're the same
   - **B)** subscribeOn determines where Observable runs, observeOn determines where Observer runs
   - **C)** observeOn determines where Observable runs
   - **D)** No difference

3. When should you use RxJava vs Coroutines/Flow?
   - **A)** Always use RxJava
   - **B)** Use RxJava for legacy code, prefer Coroutines/Flow for new projects
   - **C)** Always use Coroutines/Flow
   - **D)** They're the same

**Answers:**
1. **B** - Observable is the source that emits items over time to observers
2. **B** - subscribeOn sets the thread for Observable operations, observeOn sets the thread for Observer callbacks
3. **B** - Use RxJava for maintaining legacy codebases, but prefer Coroutines/Flow for new Android projects

## Next Steps

- [Kotlin Flow - Complete Guide](./22.%20Kotlin%20Flow%20-%20Complete%20Guide.md) - Modern alternative
- [Kotlin Coroutines Basics](../beginners/03.%20Kotlin%20Coroutines%20Basics.md) - Coroutines foundation
- [Advanced Coroutines & Cancellation](../advanced/20.%20Advanced%20Coroutines%20%26%20Cancellation.md) - Advanced coroutines

