---
number: 8
title: "Socket Connections & Network Communication"
slug: "socket-connections-network-communication"
level: "intermediate"
tags: ["sockets", "networking", "tcp", "udp", "websockets"]
prerequisites: ["kotlin-coroutines-basics"]
estimated_minutes: 50
contributors: []
diagrams: []
examples: []
canonical_id: "android-intermediate-08"
---



# Socket Connections & Network Communication

## Overview

Socket programming enables direct network communication between Android apps and servers. This guide covers TCP/UDP sockets, WebSockets, and implementing real-time communication for chat apps, gaming, IoT, and other applications requiring persistent connections.

## Deep Explanation

### Socket Types

- **TCP Sockets**: Reliable, ordered, connection-oriented
- **UDP Sockets**: Fast, unreliable, connectionless
- **WebSockets**: Full-duplex communication over HTTP

### When to Use Sockets

- Real-time chat applications
- Gaming with low latency requirements
- IoT device communication
- Live data streaming
- When REST APIs aren't sufficient

## Real Code Examples

### TCP Socket Client

```kotlin
class TCPSocketClient(private val host: String, private val port: Int) {
    private var socket: Socket? = null
    private var inputStream: BufferedReader? = null
    private var outputStream: PrintWriter? = null
    
    suspend fun connect() = withContext(Dispatchers.IO) {
        try {
            socket = Socket(host, port)
            inputStream = BufferedReader(
                InputStreamReader(socket!!.getInputStream())
            )
            outputStream = PrintWriter(socket!!.getOutputStream(), true)
            true
        } catch (e: IOException) {
            false
        }
    }
    
    suspend fun sendMessage(message: String) = withContext(Dispatchers.IO) {
        outputStream?.println(message)
    }
    
    suspend fun receiveMessage(): String? = withContext(Dispatchers.IO) {
        inputStream?.readLine()
    }
    
    fun disconnect() {
        socket?.close()
        inputStream?.close()
        outputStream?.close()
    }
}

// Usage
class ChatViewModel : ViewModel() {
    private val socketClient = TCPSocketClient("192.168.1.100", 8080)
    
    fun connect() {
        viewModelScope.launch {
            if (socketClient.connect()) {
                startReceivingMessages()
            }
        }
    }
    
    private fun startReceivingMessages() {
        viewModelScope.launch {
            while (true) {
                val message = socketClient.receiveMessage()
                message?.let { 
                    // Update UI with message
                }
            }
        }
    }
}
```

### UDP Socket

```kotlin
class UDPSocketClient(private val port: Int) {
    private var socket: DatagramSocket? = null
    
    suspend fun sendData(data: ByteArray, host: String, port: Int) = withContext(Dispatchers.IO) {
        try {
            socket = DatagramSocket()
            val address = InetAddress.getByName(host)
            val packet = DatagramPacket(data, data.size, address, port)
            socket?.send(packet)
        } catch (e: IOException) {
            e.printStackTrace()
        } finally {
            socket?.close()
        }
    }
    
    suspend fun receiveData(): ByteArray? = withContext(Dispatchers.IO) {
        try {
            socket = DatagramSocket(port)
            val buffer = ByteArray(1024)
            val packet = DatagramPacket(buffer, buffer.size)
            socket?.receive(packet)
            buffer.copyOf(packet.length)
        } catch (e: IOException) {
            null
        }
    }
}
```

### WebSocket with OkHttp

```kotlin
class WebSocketManager(private val url: String) {
    private var webSocket: WebSocket? = null
    private val client = OkHttpClient()
    
    fun connect(listener: WebSocketListener) {
        val request = Request.Builder().url(url).build()
        webSocket = client.newWebSocket(request, listener)
    }
    
    fun sendMessage(message: String) {
        webSocket?.send(message)
    }
    
    fun close() {
        webSocket?.close(1000, "Closing")
    }
}

// Usage
class ChatViewModel : ViewModel() {
    private val webSocketManager = WebSocketManager("ws://example.com/chat")
    
    init {
        webSocketManager.connect(object : WebSocketListener() {
            override fun onMessage(webSocket: WebSocket, text: String) {
                // Handle received message
            }
            
            override fun onFailure(webSocket: WebSocket, t: Throwable, response: Response?) {
                // Handle failure
            }
        })
    }
    
    fun sendMessage(message: String) {
        webSocketManager.sendMessage(message)
    }
}
```

## Common Pitfalls

### Problem: Blocking main thread with socket operations

**BAD:**
```kotlin
// Blocks UI thread!
val message = socket.receiveMessage()
```

**GOOD:**
```kotlin
// Use coroutines with Dispatchers.IO
viewModelScope.launch(Dispatchers.IO) {
    val message = socket.receiveMessage()
}
```

## Quiz

1. What is TCP best suited for?
   - **A)** Fast, unreliable communication
   - **B)** Reliable, ordered communication
   - **C)** Broadcasting
   - **D)** One-way communication

2. Where should socket operations run?
   - **A)** Main thread
   - **B)** Background thread (Dispatchers.IO)
   - **C)** UI thread
   - **D)** Any thread

**Answers:**
1. **B** - TCP provides reliable, ordered data delivery
2. **B** - Socket operations should run on background threads to avoid blocking UI

## Next Steps

- [Kotlin Coroutines Basics](../01_beginners/03.%20Kotlin%20Coroutines%20Basics.md) - Understanding coroutines
- [Building Offline-First Apps](../03_advanced/22.%20Building%20Offline-First%20Apps.md) - Network strategies

