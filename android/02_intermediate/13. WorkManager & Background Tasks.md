---
number: 13
title: "WorkManager & Background Tasks"
slug: "workmanager-background-tasks"
level: "intermediate"
tags: ["workmanager", "background", "tasks", "scheduling", "android"]
prerequisites: ["kotlin-coroutines-basics"]
estimated_minutes: 50
contributors: []
diagrams: []
examples: []
canonical_id: "android-intermediate-13"
---





# WorkManager & Background Tasks

## Overview

WorkManager is Android's recommended solution for deferrable background work that must execute reliably. It provides a flexible API for scheduling tasks that should run even if the app exits or the device restarts. WorkManager is perfect for tasks like syncing data, uploading logs, or processing images that don't need to run immediately.

## Deep Explanation

### When to Use WorkManager

WorkManager is ideal for:
- **Deferrable tasks**: Work that doesn't need to run immediately
- **Guaranteed execution**: Tasks that must run even if the app is closed
- **Constraints**: Tasks that should run only under certain conditions (network, charging, etc.)
- **Periodic work**: Tasks that need to run repeatedly

**Don't use WorkManager for:**
- Immediate tasks (use coroutines)
- Tasks tied to UI lifecycle (use ViewModel)
- Tasks that need precise timing (use AlarmManager)

### WorkManager vs Alternatives

- **Coroutines**: For immediate, app-scoped tasks
- **JobScheduler**: WorkManager uses JobScheduler internally (API 23+)
- **AlarmManager**: For precise timing (not recommended for most cases)
- **Foreground Service**: For user-visible, long-running tasks

## Real Code Examples

### Basic One-Time Work

```kotlin
// 1. Define your work
class UploadWorker(
    context: Context,
    params: WorkerParameters
) : CoroutineWorker(context, params) {
    
    override suspend fun doWork(): Result {
        return try {
            // Your work here
            uploadData()
            Result.success()
        } catch (e: Exception) {
            Result.retry() // or Result.failure()
        }
    }
    
    private suspend fun uploadData() {
        // Upload logic
    }
}

// 2. Schedule the work
val uploadWorkRequest = OneTimeWorkRequestBuilder<UploadWorker>()
    .build()

WorkManager.getInstance(context).enqueue(uploadWorkRequest)
```

### Work with Constraints

```kotlin
val constraints = Constraints.Builder()
    .setRequiredNetworkType(NetworkType.CONNECTED)
    .setRequiresCharging(true)
    .setRequiresBatteryNotLow(true)
    .build()

val uploadWorkRequest = OneTimeWorkRequestBuilder<UploadWorker>()
    .setConstraints(constraints)
    .build()

WorkManager.getInstance(context).enqueue(uploadWorkRequest)
```

### Periodic Work

```kotlin
val syncWorkRequest = PeriodicWorkRequestBuilder<SyncWorker>(
    15, TimeUnit.MINUTES // Minimum interval
).build()

WorkManager.getInstance(context).enqueuePeriodicWork(syncWorkRequest)
```

### Passing Data to Workers

```kotlin
// Create input data
val inputData = workDataOf(
    "userId" to userId,
    "data" to dataToUpload
)

val uploadWorkRequest = OneTimeWorkRequestBuilder<UploadWorker>()
    .setInputData(inputData)
    .build()

// In worker
class UploadWorker(context: Context, params: WorkerParameters) 
    : CoroutineWorker(context, params) {
    
    override suspend fun doWork(): Result {
        val userId = inputData.getString("userId")
        val data = inputData.getString("data")
        // Use the data...
        return Result.success()
    }
}
```

### Chaining Work

```kotlin
val compressWork = OneTimeWorkRequestBuilder<CompressImageWorker>()
    .build()

val uploadWork = OneTimeWorkRequestBuilder<UploadImageWorker>()
    .build()

WorkManager.getInstance(context)
    .beginWith(compressWork)
    .then(uploadWork)
    .enqueue()
```

### Observing Work Status

```kotlin
WorkManager.getInstance(context)
    .getWorkInfoByIdLiveData(uploadWorkRequest.id)
    .observe(this) { workInfo ->
        when (workInfo?.state) {
            WorkInfo.State.ENQUEUED -> { /* Work is queued */ }
            WorkInfo.State.RUNNING -> { /* Work is running */ }
            WorkInfo.State.SUCCEEDED -> { /* Work completed successfully */ }
            WorkInfo.State.FAILED -> { /* Work failed */ }
            WorkInfo.State.CANCELLED -> { /* Work was cancelled */ }
            else -> { }
        }
    }
```

### Unique Work (Prevent Duplicates)

```kotlin
val syncWorkRequest = OneTimeWorkRequestBuilder<SyncWorker>()
    .build()

WorkManager.getInstance(context)
    .enqueueUniqueWork(
        "sync_work",
        ExistingWorkPolicy.REPLACE, // or KEEP, APPEND
        syncWorkRequest
    )
```

## Common Pitfalls

### Problem: Using WorkManager for immediate tasks

**BAD:**
```kotlin
// User clicks button, needs immediate response
WorkManager.getInstance(context).enqueue(uploadWorkRequest)
// User waits... work might not run immediately
```

**GOOD:**
```kotlin
// Use coroutines for immediate tasks
viewModelScope.launch {
    uploadData() // Runs immediately
}
```

### Problem: Not handling work cancellation

**BAD:**
```kotlin
class UploadWorker(context: Context, params: WorkerParameters)
    : CoroutineWorker(context, params) {
    
    override suspend fun doWork(): Result {
        // Long operation without checking cancellation
        for (i in 1..1000000) {
            processItem(i) // Never checks if cancelled
        }
        return Result.success()
    }
}
```

**GOOD:**
```kotlin
class UploadWorker(context: Context, params: WorkerParameters)
    : CoroutineWorker(context, params) {
    
    override suspend fun doWork(): Result {
        return withContext(Dispatchers.IO) {
            for (i in 1..1000000) {
                if (isStopped) return@withContext Result.failure()
                processItem(i)
            }
            Result.success()
        }
    }
}
```

## Quiz

1. When should you use WorkManager?
   - **A)** For immediate UI updates
   - **B)** For deferrable background tasks that must execute reliably
   - **C)** For tasks tied to Activity lifecycle
   - **D)** For precise timing requirements

2. What is the minimum interval for periodic work?
   - **A)** 1 minute
   - **B)** 5 minutes
   - **C)** 15 minutes
   - **D)** 1 hour

3. How do you prevent duplicate work requests?
   - **A)** Check if work exists before enqueueing
   - **B)** Use `enqueueUniqueWork`
   - **C)** Cancel existing work first
   - **D)** Use constraints

**Answers:**
1. **B** - WorkManager is for deferrable tasks that need guaranteed execution
2. **C** - 15 minutes is the minimum interval for periodic work
3. **B** - `enqueueUniqueWork` ensures only one instance of a work runs at a time

## Next Steps

- [Kotlin Coroutines Basics](../01_beginners/03.%20Kotlin%20Coroutines%20Basics.md) - Understanding coroutines
- [Building Offline-First Apps](../03_advanced/04.%20Building%20Offline-First%20Apps.md) - Using WorkManager for sync

