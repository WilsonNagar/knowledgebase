---
number: 28
title: "Unit Testing in Android"
slug: "unit-testing-android"
level: "intermediate"
tags: ["testing", "unit-tests", "junit", "mockito", "test-driven"]
prerequisites: ["introduction-to-android-architecture", "solid-principles"]
estimated_minutes: 60
contributors: []
diagrams: []
examples: []
canonical_id: "android-intermediate-28"
---




# Unit Testing in Android

## Overview

Unit testing is essential for building reliable Android applications. This guide covers writing unit tests for ViewModels, Repositories, Use Cases, and other business logic components. You'll learn to use JUnit, Mockito, and Kotlin testing best practices to ensure your code works correctly.

## Deep Explanation

### Why Unit Testing?

- **Catch bugs early**: Find issues before they reach production
- **Refactor safely**: Make changes with confidence
- **Documentation**: Tests serve as executable documentation
- **Design feedback**: Hard-to-test code often indicates design problems

### Testing Pyramid

- **Unit Tests** (70%): Fast, many, test individual components
- **Integration Tests** (20%): Medium speed, test component interactions
- **UI Tests** (10%): Slow, few, test user flows

## Real Code Examples

### Testing ViewModel

```kotlin
// ViewModel to test
class UserViewModel(
    private val repository: UserRepository
) : ViewModel() {
    private val _users = MutableLiveData<List<User>>()
    val users: LiveData<List<User>> = _users
    
    fun loadUsers() {
        viewModelScope.launch {
            _users.value = repository.getUsers()
        }
    }
}

// Unit test
@RunWith(MockitoJUnitRunner::class)
class UserViewModelTest {
    @Mock
    private lateinit var repository: UserRepository
    
    private lateinit var viewModel: UserViewModel
    
    @get:Rule
    val instantExecutorRule = InstantTaskExecutorRule()
    
    @Before
    fun setup() {
        viewModel = UserViewModel(repository)
    }
    
    @Test
    fun `loadUsers should update users LiveData`() = runTest {
        // Given
        val expectedUsers = listOf(User(1, "John"), User(2, "Jane"))
        whenever(repository.getUsers()).thenReturn(expectedUsers)
        
        // When
        viewModel.loadUsers()
        
        // Then
        assertEquals(expectedUsers, viewModel.users.value)
    }
}
```

### Testing Repository

```kotlin
// Repository to test
class UserRepository(
    private val localDataSource: UserLocalDataSource,
    private val remoteDataSource: UserRemoteDataSource
) {
    suspend fun getUsers(): List<User> {
        return try {
            val users = remoteDataSource.getUsers()
            localDataSource.saveUsers(users)
            users
        } catch (e: Exception) {
            localDataSource.getUsers()
        }
    }
}

// Unit test
class UserRepositoryTest {
    @Mock
    private lateinit var localDataSource: UserLocalDataSource
    
    @Mock
    private lateinit var remoteDataSource: UserRemoteDataSource
    
    private lateinit var repository: UserRepository
    
    @Before
    fun setup() {
        repository = UserRepository(localDataSource, remoteDataSource)
    }
    
    @Test
    fun `getUsers should return remote data and save locally`() = runTest {
        // Given
        val remoteUsers = listOf(User(1, "John"))
        whenever(remoteDataSource.getUsers()).thenReturn(remoteUsers)
        
        // When
        val result = repository.getUsers()
        
        // Then
        assertEquals(remoteUsers, result)
        verify(localDataSource).saveUsers(remoteUsers)
    }
    
    @Test
    fun `getUsers should return local data when remote fails`() = runTest {
        // Given
        val localUsers = listOf(User(1, "John"))
        whenever(remoteDataSource.getUsers()).thenThrow(IOException())
        whenever(localDataSource.getUsers()).thenReturn(localUsers)
        
        // When
        val result = repository.getUsers()
        
        // Then
        assertEquals(localUsers, result)
    }
}
```

### Testing Coroutines

```kotlin
class CoroutineTest {
    @get:Rule
    val mainDispatcherRule = MainDispatcherRule()
    
    @Test
    fun `test coroutine`() = runTest {
        val result = suspendFunction()
        assertEquals(expected, result)
    }
}

// Custom rule for testing coroutines
class MainDispatcherRule(
    private val testDispatcher: TestDispatcher = StandardTestDispatcher()
) : TestWatcher() {
    override fun starting(description: Description) {
        Dispatchers.setMain(testDispatcher)
    }
    
    override fun finished(description: Description) {
        Dispatchers.resetMain()
    }
}
```

### Testing with MockK (Kotlin-friendly mocking)

```kotlin
class UserViewModelTest {
    private val repository = mockk<UserRepository>()
    private lateinit var viewModel: UserViewModel
    
    @Before
    fun setup() {
        viewModel = UserViewModel(repository)
    }
    
    @Test
    fun `loadUsers should update users`() = runTest {
        // Given
        val users = listOf(User(1, "John"))
        coEvery { repository.getUsers() } returns users
        
        // When
        viewModel.loadUsers()
        
        // Then
        assertEquals(users, viewModel.users.value)
        coVerify { repository.getUsers() }
    }
}
```

## Common Pitfalls

### Problem: Testing implementation details instead of behavior

**BAD:**
```kotlin
@Test
fun `test internal method call`() {
    // Testing private implementation details
    verify(viewModel).privateMethod() // Don't do this!
}
```

**GOOD:**
```kotlin
@Test
fun `test public behavior`() {
    viewModel.loadUsers()
    assertEquals(expectedUsers, viewModel.users.value) // Test observable behavior
}
```

### Problem: Not testing edge cases

**BAD:**
```kotlin
@Test
fun `test happy path only`() {
    // Only tests when everything works
    viewModel.loadUsers()
    assertNotNull(viewModel.users.value)
}
```

**GOOD:**
```kotlin
@Test
fun `test error handling`() {
    whenever(repository.getUsers()).thenThrow(IOException())
    viewModel.loadUsers()
    assertTrue(viewModel.error.value != null) // Test error case
}
```

## Quiz

1. What percentage of tests should be unit tests?
   - **A)** 30%
   - **B)** 50%
   - **C)** 70%
   - **D)** 90%

2. What should you test in unit tests?
   - **A)** Implementation details
   - **B)** Observable behavior
   - **C)** Private methods
   - **D)** UI components

3. How do you test coroutines?
   - **A)** Use Thread.sleep()
   - **B)** Use runTest with TestDispatcher
   - **C)** Don't test coroutines
   - **D)** Use real Dispatchers

**Answers:**
1. **C** - Unit tests should be the majority (70%) of your test suite
2. **B** - Test observable behavior, not implementation details
3. **B** - Use runTest with TestDispatcher for predictable coroutine testing

## Next Steps

- [Testing Compose UIs](./05.%20Testing%20Compose%20UIs.md) - UI testing
- [SOLID Principles](../01_beginners/02.%20SOLID%20Principles.md) - Writing testable code

