---
number: 22
title: "Notifications & FCM"
slug: "notifications-fcm"
level: "intermediate"
tags: ["notifications", "fcm", "firebase", "push-notifications"]
prerequisites: ["android-permissions"]
estimated_minutes: 100
contributors: []
diagrams: []
examples: []
canonical_id: "android-intermediate-22"
---



# Notifications & FCM

## Overview

Notifications keep users engaged with your app. This comprehensive guide covers creating notifications, notification channels, notification actions, foreground services, Firebase Cloud Messaging (FCM), push notifications, notification best practices, and handling notification interactions.

## Table of Contents

1. [Notifications Overview](#overview)
2. [Notification Channels](#channels)
3. [Creating Notifications](#creating-notifications)
4. [Notification Actions](#actions)
5. [Foreground Services](#foreground-services)
6. [Firebase Cloud Messaging](#fcm)
7. [Push Notifications](#push-notifications)
8. [Notification Best Practices](#best-practices)

## Notifications Overview

### What are Notifications?

**Notification**: Alert shown outside app UI

**Purpose**: Inform users about events, updates, messages

**Types**:
- **Standard**: Basic notifications
- **Expanded**: Rich notifications with images/actions
- **Heads-up**: Appear on top of screen
- **Foreground**: For ongoing operations

### Notification Components

**Components**:
- **Icon**: Small icon shown in status bar
- **Title**: Notification title
- **Text**: Notification content
- **Actions**: Buttons for user actions
- **Style**: Expanded style (big text, inbox, etc.)

## Notification Channels

### What are Channels?

**Channel**: Category for notifications

**Purpose**: User control over notification types

**Android 8.0+**: Required for all notifications

### Creating Channels

```kotlin
fun createNotificationChannel(context: Context) {
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
        val channel = NotificationChannel(
            "channel_id",
            "Channel Name",
            NotificationManager.IMPORTANCE_HIGH
        ).apply {
            description = "Channel description"
            enableLights(true)
            lightColor = Color.BLUE
            enableVibration(true)
            vibrationPattern = longArrayOf(0, 1000, 500, 1000)
        }
        
        val notificationManager = context.getSystemService(
            Context.NOTIFICATION_SERVICE
        ) as NotificationManager
        
        notificationManager.createNotificationChannel(channel)
    }
}
```

### Channel Importance Levels

**IMPORTANCE_HIGH**: Makes sound and appears as heads-up
**IMPORTANCE_DEFAULT**: Makes sound
**IMPORTANCE_LOW**: No sound
**IMPORTANCE_MIN**: No sound, no visual interruption

```kotlin
val channel = NotificationChannel(
    "channel_id",
    "Channel Name",
    NotificationManager.IMPORTANCE_HIGH
)
```

## Creating Notifications

### Basic Notification

```kotlin
fun createBasicNotification(context: Context): Notification {
    val intent = Intent(context, MainActivity::class.java).apply {
        flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK
    }
    
    val pendingIntent = PendingIntent.getActivity(
        context,
        0,
        intent,
        PendingIntent.FLAG_IMMUTABLE
    )
    
    return NotificationCompat.Builder(context, "channel_id")
        .setSmallIcon(R.drawable.ic_notification)
        .setContentTitle("Notification Title")
        .setContentText("Notification content")
        .setContentIntent(pendingIntent)
        .setAutoCancel(true)
        .build()
}

fun showNotification(context: Context, notification: Notification) {
    val notificationManager = NotificationManagerCompat.from(context)
    notificationManager.notify(1, notification)
}
```

### Expanded Notifications

**Big Text Style**:
```kotlin
val bigTextStyle = NotificationCompat.BigTextStyle()
    .bigText("Long text content that expands when notification is expanded")

val notification = NotificationCompat.Builder(context, "channel_id")
    .setSmallIcon(R.drawable.ic_notification)
    .setContentTitle("Title")
    .setContentText("Short text")
    .setStyle(bigTextStyle)
    .build()
```

**Big Picture Style**:
```kotlin
val bigPictureStyle = NotificationCompat.BigPictureStyle()
    .bigPicture(BitmapFactory.decodeResource(resources, R.drawable.big_image))
    .bigLargeIcon(null)

val notification = NotificationCompat.Builder(context, "channel_id")
    .setSmallIcon(R.drawable.ic_notification)
    .setContentTitle("Title")
    .setContentText("Text")
    .setStyle(bigPictureStyle)
    .build()
```

**Inbox Style**:
```kotlin
val inboxStyle = NotificationCompat.InboxStyle()
    .addLine("Message 1")
    .addLine("Message 2")
    .addLine("Message 3")
    .setBigContentTitle("3 new messages")
    .setSummaryText("email@example.com")

val notification = NotificationCompat.Builder(context, "channel_id")
    .setSmallIcon(R.drawable.ic_notification)
    .setContentTitle("Title")
    .setContentText("Text")
    .setStyle(inboxStyle)
    .build()
```

## Notification Actions

### Adding Actions

```kotlin
fun createNotificationWithActions(context: Context): Notification {
    // Action 1: Reply
    val replyIntent = Intent(context, ReplyReceiver::class.java).apply {
        action = "REPLY_ACTION"
    }
    val replyPendingIntent = PendingIntent.getBroadcast(
        context,
        0,
        replyIntent,
        PendingIntent.FLAG_IMMUTABLE
    )
    val replyAction = NotificationCompat.Action(
        R.drawable.ic_reply,
        "Reply",
        replyPendingIntent
    )
    
    // Action 2: Dismiss
    val dismissIntent = Intent(context, DismissReceiver::class.java).apply {
        action = "DISMISS_ACTION"
    }
    val dismissPendingIntent = PendingIntent.getBroadcast(
        context,
        1,
        dismissIntent,
        PendingIntent.FLAG_IMMUTABLE
    )
    val dismissAction = NotificationCompat.Action(
        R.drawable.ic_dismiss,
        "Dismiss",
        dismissPendingIntent
    )
    
    return NotificationCompat.Builder(context, "channel_id")
        .setSmallIcon(R.drawable.ic_notification)
        .setContentTitle("Title")
        .setContentText("Text")
        .addAction(replyAction)
        .addAction(dismissAction)
        .build()
}
```

### Direct Reply

```kotlin
val remoteInput = RemoteInput.Builder("reply_key")
    .setLabel("Reply")
    .build()

val replyIntent = Intent(context, ReplyReceiver::class.java)
val replyPendingIntent = PendingIntent.getBroadcast(
    context,
    0,
    replyIntent,
    PendingIntent.FLAG_IMMUTABLE
)

val replyAction = NotificationCompat.Action.Builder(
    R.drawable.ic_reply,
    "Reply",
    replyPendingIntent
)
    .addRemoteInput(remoteInput)
    .build()

val notification = NotificationCompat.Builder(context, "channel_id")
    .setSmallIcon(R.drawable.ic_notification)
    .setContentTitle("Title")
    .setContentText("Text")
    .addAction(replyAction)
    .build()
```

### Handling Direct Reply

```kotlin
class ReplyReceiver : BroadcastReceiver() {
    override fun onReceive(context: Context, intent: Intent) {
        val remoteInput = RemoteInput.getResultsFromIntent(intent)
        val replyText = remoteInput?.getCharSequence("reply_key")
        
        // Handle reply
        handleReply(replyText.toString())
        
        // Update notification
        val notificationManager = NotificationManagerCompat.from(context)
        notificationManager.cancel(1)
    }
}
```

## Foreground Services

### What are Foreground Services?

**Foreground Service**: Service that shows persistent notification

**Purpose**: Long-running operations that user is aware of

**Requirement**: Must show notification

### Creating Foreground Service

```kotlin
class MyForegroundService : Service() {
    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
        val notification = createForegroundNotification()
        startForeground(1, notification)
        
        // Do work
        doWork()
        
        return START_STICKY
    }
    
    private fun createForegroundNotification(): Notification {
        val intent = Intent(this, MainActivity::class.java)
        val pendingIntent = PendingIntent.getActivity(
            this,
            0,
            intent,
            PendingIntent.FLAG_IMMUTABLE
        )
        
        return NotificationCompat.Builder(this, "foreground_channel")
            .setContentTitle("Service Running")
            .setContentText("Doing work...")
            .setSmallIcon(R.drawable.ic_notification)
            .setContentIntent(pendingIntent)
            .build()
    }
    
    override fun onBind(intent: Intent?): IBinder? = null
}
```

### Starting Foreground Service

```kotlin
fun startForegroundService(context: Context) {
    val intent = Intent(context, MyForegroundService::class.java)
    
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
        context.startForegroundService(intent)
    } else {
        context.startService(intent)
    }
}
```

## Firebase Cloud Messaging

### What is FCM?

**FCM**: Firebase Cloud Messaging

**Purpose**: Send push notifications from server

**Features**:
- **Free**: No cost
- **Reliable**: Google infrastructure
- **Cross-platform**: Android, iOS, Web

### FCM Setup

**1. Add Firebase to Project**:
- Add `google-services.json` to `app/` directory

**2. Add Dependencies**:
```kotlin
// Project-level build.gradle
classpath("com.google.gms:google-services:4.4.0")

// App-level build.gradle
plugins {
    id("com.google.gms.google-services")
}

dependencies {
    implementation("com.google.firebase:firebase-messaging:23.3.1")
    implementation("com.google.firebase:firebase-messaging-ktx:23.3.1")
}
```

**3. Create FCM Service**:
```kotlin
class MyFirebaseMessagingService : FirebaseMessagingService() {
    override fun onNewToken(token: String) {
        // Token refreshed, send to server
        sendTokenToServer(token)
    }
    
    override fun onMessageReceived(remoteMessage: RemoteMessage) {
        // Handle FCM message
        if (remoteMessage.notification != null) {
            showNotification(remoteMessage.notification!!)
        }
        
        // Handle data payload
        remoteMessage.data.isNotEmpty().let {
            handleDataPayload(remoteMessage.data)
        }
    }
    
    private fun showNotification(notification: RemoteMessage.Notification) {
        val notificationBuilder = NotificationCompat.Builder(this, "channel_id")
            .setSmallIcon(R.drawable.ic_notification)
            .setContentTitle(notification.title)
            .setContentText(notification.body)
            .setAutoCancel(true)
        
        val notificationManager = NotificationManagerCompat.from(this)
        notificationManager.notify(0, notificationBuilder.build())
    }
}
```

**4. Register Service in Manifest**:
```xml
<service
    android:name=".MyFirebaseMessagingService"
    android:exported="false">
    <intent-filter>
        <action android:name="com.google.firebase.MESSAGING_EVENT" />
    </intent-filter>
</service>
```

### Getting FCM Token

```kotlin
FirebaseMessaging.getInstance().token.addOnCompleteListener { task ->
    if (!task.isSuccessful) {
        return@addOnCompleteListener
    }
    
    val token = task.result
    // Send token to server
    sendTokenToServer(token)
}
```

## Push Notifications

### Sending Push Notification

**From Server** (using FCM Admin SDK):
```kotlin
// Server-side code (example)
val message = Message.builder()
    .setToken(deviceToken)
    .setNotification(
        Notification.builder()
            .setTitle("Title")
            .setBody("Body")
            .build()
    )
    .putData("key", "value")
    .build()

FirebaseMessaging.getInstance().send(message)
```

**From Firebase Console**:
1. Go to Firebase Console
2. Select project
3. Go to Cloud Messaging
4. Send test message

### Handling Notification Clicks

```kotlin
override fun onMessageReceived(remoteMessage: RemoteMessage) {
    val intent = Intent(this, DetailActivity::class.java).apply {
        flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK
        putExtra("data", remoteMessage.data["key"])
    }
    
    val pendingIntent = PendingIntent.getActivity(
        this,
        0,
        intent,
        PendingIntent.FLAG_IMMUTABLE
    )
    
    val notification = NotificationCompat.Builder(this, "channel_id")
        .setSmallIcon(R.drawable.ic_notification)
        .setContentTitle(remoteMessage.notification?.title)
        .setContentText(remoteMessage.notification?.body)
        .setContentIntent(pendingIntent)
        .setAutoCancel(true)
        .build()
    
    NotificationManagerCompat.from(this).notify(0, notification)
}
```

## Notification Best Practices

### Practice 1: Use Appropriate Channels

```kotlin
// GOOD: Separate channels for different types
createChannel("messages", "Messages", IMPORTANCE_HIGH)
createChannel("updates", "Updates", IMPORTANCE_DEFAULT)
createChannel("promotions", "Promotions", IMPORTANCE_LOW)

// BAD: Single channel for everything
createChannel("notifications", "Notifications", IMPORTANCE_HIGH)
```

### Practice 2: Set Appropriate Importance

```kotlin
// GOOD: High importance for important notifications
val channel = NotificationChannel(
    "important",
    "Important",
    NotificationManager.IMPORTANCE_HIGH
)

// BAD: High importance for all notifications
val channel = NotificationChannel(
    "all",
    "All",
    NotificationManager.IMPORTANCE_HIGH // Too noisy
)
```

### Practice 3: Provide Actions

```kotlin
// GOOD: Provide useful actions
notification.addAction(replyAction)
notification.addAction(archiveAction)

// BAD: No actions
// User must open app to act
```

### Practice 4: Handle Notification Dismissal

```kotlin
// GOOD: Handle dismissal
notification.setAutoCancel(true)

// BAD: Notification stays forever
// notification.setAutoCancel(false)
```

### Practice 5: Update Notifications

```kotlin
// GOOD: Update existing notification
notificationManager.notify(1, updatedNotification)

// BAD: Create new notification for same event
notificationManager.notify(2, newNotification) // Creates duplicate
```

## Real-World Examples

### Complete Notification Manager

```kotlin
class NotificationManager(
    private val context: Context
) {
    private val notificationManager = NotificationManagerCompat.from(context)
    
    init {
        createChannels()
    }
    
    private fun createChannels() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            val manager = context.getSystemService(
                Context.NOTIFICATION_SERVICE
            ) as NotificationManager
            
            // Messages channel
            val messagesChannel = NotificationChannel(
                "messages",
                "Messages",
                NotificationManager.IMPORTANCE_HIGH
            ).apply {
                description = "Chat messages"
                enableVibration(true)
            }
            manager.createNotificationChannel(messagesChannel)
            
            // Updates channel
            val updatesChannel = NotificationChannel(
                "updates",
                "Updates",
                NotificationManager.IMPORTANCE_DEFAULT
            ).apply {
                description = "App updates"
            }
            manager.createNotificationChannel(updatesChannel)
        }
    }
    
    fun showMessageNotification(
        title: String,
        message: String,
        senderId: String
    ) {
        val intent = Intent(context, ChatActivity::class.java).apply {
            putExtra("sender_id", senderId)
            flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK
        }
        
        val pendingIntent = PendingIntent.getActivity(
            context,
            0,
            intent,
            PendingIntent.FLAG_IMMUTABLE
        )
        
        val notification = NotificationCompat.Builder(context, "messages")
            .setSmallIcon(R.drawable.ic_message)
            .setContentTitle(title)
            .setContentText(message)
            .setContentIntent(pendingIntent)
            .setAutoCancel(true)
            .setPriority(NotificationCompat.PRIORITY_HIGH)
            .build()
        
        notificationManager.notify(senderId.hashCode(), notification)
    }
}
```

## Common Pitfalls

### Problem: Not Creating Channels

```kotlin
// BAD: No channel (Android 8.0+)
val notification = NotificationCompat.Builder(context)
    .setContentTitle("Title")
    .build()

// GOOD: Create channel first
createNotificationChannel(context)
val notification = NotificationCompat.Builder(context, "channel_id")
    .setContentTitle("Title")
    .build()
```

### Problem: Not Handling Token Refresh

```kotlin
// BAD: Don't handle token refresh
// Token may become invalid

// GOOD: Handle token refresh
override fun onNewToken(token: String) {
    sendTokenToServer(token)
}
```

## Quiz

1. What is required for notifications on Android 8.0+?
   - **A)** Nothing
   - **B)** Notification channels
   - **C)** FCM
   - **D)** Permissions

2. What is FCM used for?
   - **A)** Local notifications
   - **B)** Push notifications from server
   - **C)** In-app notifications
   - **D)** Nothing

3. What must foreground services show?
   - **A)** Dialog
   - **B)** Toast
   - **C)** Persistent notification
   - **D)** Nothing

**Answers:**
1. **B** - Notification channels are required for all notifications on Android 8.0 (API 26) and above
2. **B** - FCM (Firebase Cloud Messaging) is used to send push notifications from server to devices
3. **C** - Foreground services must show a persistent notification to inform users about ongoing work

## Next Steps

- [Android Permissions](./27.%20Android%20Permissions.md) - Notification permissions
- [Security & Authentication](./28.%20Security%20%26%20Authentication.md) - Secure notifications
- [WorkManager & Background Tasks](./13.%20WorkManager%20%26%20Background%20Tasks.md) - Background work

