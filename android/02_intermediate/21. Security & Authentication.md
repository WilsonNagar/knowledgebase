---
number: 21
title: "Security & Authentication"
slug: "security-authentication"
level: "intermediate"
tags: ["security", "authentication", "biometric", "encryption", "keystore"]
prerequisites: ["android-permissions"]
estimated_minutes: 120
contributors: []
diagrams: []
examples: []
canonical_id: "android-intermediate-21"
---



# Security & Authentication

## Overview

Security is critical for Android applications handling sensitive data. This comprehensive guide covers biometric authentication, encryption (data at rest and in transit), secure storage (EncryptedSharedPreferences, Keystore), certificate pinning, OAuth 2.0/OpenID Connect, token management, and security best practices.

## Table of Contents

1. [Security Overview](#security-overview)
2. [Biometric Authentication](#biometric-authentication)
3. [Encryption](#encryption)
4. [Secure Storage](#secure-storage)
5. [Android Keystore](#keystore)
6. [Certificate Pinning](#certificate-pinning)
7. [OAuth 2.0 & OpenID Connect](#oauth)
8. [Token Management](#token-management)
9. [Security Best Practices](#best-practices)

## Security Overview

### Why Security Matters

**Threats**:
- **Data Theft**: Unauthorized access to user data
- **Man-in-the-Middle**: Intercepting network traffic
- **Reverse Engineering**: App tampering
- **Credential Theft**: Stolen passwords/tokens

**Protection**:
- **Encryption**: Protect data at rest and in transit
- **Authentication**: Verify user identity
- **Secure Storage**: Protect sensitive data
- **Certificate Pinning**: Prevent MITM attacks

## Biometric Authentication

### What is Biometric Authentication?

**Biometric**: Authentication using biological characteristics

**Types**:
- **Fingerprint**: Fingerprint scanning
- **Face**: Face recognition
- **Iris**: Iris scanning

### Biometric Setup

**Dependency**:
```kotlin
implementation("androidx.biometric:biometric:1.1.0")
```

**Check Availability**:
```kotlin
fun isBiometricAvailable(context: Context): Boolean {
    val biometricManager = BiometricManager.from(context)
    return when (biometricManager.canAuthenticate(BiometricManager.Authenticators.BIOMETRIC_STRONG)) {
        BiometricManager.BIOMETRIC_SUCCESS -> true
        else -> false
    }
}
```

### Biometric Authentication

```kotlin
class BiometricAuthHelper(
    private val activity: ComponentActivity
) {
    private val biometricPrompt: BiometricPrompt
    
    init {
        val executor = ContextCompat.getMainExecutor(activity)
        val callback = object : BiometricPrompt.AuthenticationCallback() {
            override fun onAuthenticationSucceeded(
                result: BiometricPrompt.AuthenticationResult
            ) {
                super.onAuthenticationSucceeded(result)
                onSuccess()
            }
            
            override fun onAuthenticationError(
                errorCode: Int,
                errString: CharSequence
            ) {
                super.onAuthenticationError(errorCode, errString)
                onError(errString.toString())
            }
            
            override fun onAuthenticationFailed() {
                super.onAuthenticationFailed()
                onFailed()
            }
        }
        
        biometricPrompt = BiometricPrompt(activity, executor, callback)
    }
    
    fun authenticate(
        title: String = "Biometric Authentication",
        subtitle: String = "Use your fingerprint to authenticate",
        onSuccess: () -> Unit,
        onError: (String) -> Unit,
        onFailed: () -> Unit
    ) {
        val promptInfo = BiometricPrompt.PromptInfo.Builder()
            .setTitle(title)
            .setSubtitle(subtitle)
            .setNegativeButtonText("Cancel")
            .build()
        
        biometricPrompt.authenticate(promptInfo)
    }
}
```

### Using Biometric Auth

```kotlin
class LoginActivity : AppCompatActivity() {
    private val biometricHelper = BiometricAuthHelper(this)
    
    fun loginWithBiometric() {
        biometricHelper.authenticate(
            title = "Login",
            subtitle = "Use your fingerprint to login",
            onSuccess = {
                // Authentication successful
                proceedToMainScreen()
            },
            onError = { error ->
                // Handle error
                showError(error)
            },
            onFailed = {
                // Authentication failed
                showError("Authentication failed")
            }
        )
    }
}
```

## Encryption

### Data at Rest Encryption

**EncryptedSharedPreferences**:
```kotlin
fun getEncryptedSharedPreferences(context: Context): SharedPreferences {
    val masterKey = MasterKey.Builder(context)
        .setKeyScheme(MasterKey.KeyScheme.AES256_GCM)
        .build()
    
    return EncryptedSharedPreferences.create(
        context,
        "encrypted_prefs",
        masterKey,
        EncryptedSharedPreferences.PrefKeyEncryptionScheme.AES256_SIV,
        EncryptedSharedPreferences.PrefValueEncryptionScheme.AES256_GCM
    )
}

// Usage
val encryptedPrefs = getEncryptedSharedPreferences(context)
encryptedPrefs.edit()
    .putString("sensitive_data", "value")
    .apply()
```

### Data in Transit Encryption

**TLS/SSL**: Use HTTPS for all network communication

```kotlin
val okHttpClient = OkHttpClient.Builder()
    .sslSocketFactory(sslSocketFactory, trustManager)
    .build()
```

### AES Encryption

```kotlin
class EncryptionHelper {
    private val secretKey: SecretKey
    
    init {
        val keyGenerator = KeyGenerator.getInstance("AES")
        keyGenerator.init(256)
        secretKey = keyGenerator.generateKey()
    }
    
    fun encrypt(data: String): String {
        val cipher = Cipher.getInstance("AES/GCM/NoPadding")
        cipher.init(Cipher.ENCRYPT_MODE, secretKey)
        val encryptedBytes = cipher.doFinal(data.toByteArray())
        return Base64.encodeToString(encryptedBytes, Base64.DEFAULT)
    }
    
    fun decrypt(encryptedData: String): String {
        val cipher = Cipher.getInstance("AES/GCM/NoPadding")
        cipher.init(Cipher.DECRYPT_MODE, secretKey)
        val decryptedBytes = cipher.doFinal(
            Base64.decode(encryptedData, Base64.DEFAULT)
        )
        return String(decryptedBytes)
    }
}
```

## Secure Storage

### Android Keystore

**Keystore**: Hardware-backed secure storage

**Benefits**:
- **Hardware-backed**: Uses secure hardware when available
- **Key Protection**: Keys never leave device
- **Isolation**: Keys isolated per app

### Creating Keys

```kotlin
fun createKey(keyName: String) {
    val keyGenerator = KeyGenerator.getInstance(
        KeyProperties.KEY_ALGORITHM_AES,
        "AndroidKeyStore"
    )
    
    val keyGenParameterSpec = KeyGenParameterSpec.Builder(
        keyName,
        KeyProperties.PURPOSE_ENCRYPT or KeyProperties.PURPOSE_DECRYPT
    )
        .setBlockModes(KeyProperties.BLOCK_MODE_GCM)
        .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_NONE)
        .setUserAuthenticationRequired(true)
        .build()
    
    keyGenerator.init(keyGenParameterSpec)
    keyGenerator.generateKey()
}
```

### Encrypting with Keystore

```kotlin
class KeystoreEncryptionHelper(
    private val keyName: String
) {
    private val keyStore = KeyStore.getInstance("AndroidKeyStore").apply {
        load(null)
    }
    
    fun encrypt(data: String): String {
        val key = keyStore.getKey(keyName, null) as SecretKey
        val cipher = Cipher.getInstance("AES/GCM/NoPadding")
        cipher.init(Cipher.ENCRYPT_MODE, key)
        
        val encryptedBytes = cipher.doFinal(data.toByteArray())
        val iv = cipher.iv
        
        return Base64.encodeToString(
            iv + encryptedBytes,
            Base64.DEFAULT
        )
    }
    
    fun decrypt(encryptedData: String): String {
        val encryptedBytes = Base64.decode(encryptedData, Base64.DEFAULT)
        val iv = encryptedBytes.sliceArray(0..11)
        val ciphertext = encryptedBytes.sliceArray(12 until encryptedBytes.size)
        
        val key = keyStore.getKey(keyName, null) as SecretKey
        val cipher = Cipher.getInstance("AES/GCM/NoPadding")
        val spec = GCMParameterSpec(128, iv)
        cipher.init(Cipher.DECRYPT_MODE, key, spec)
        
        val decryptedBytes = cipher.doFinal(ciphertext)
        return String(decryptedBytes)
    }
}
```

## Android Keystore

### Key Types

**1. AES Keys**: Symmetric encryption
```kotlin
KeyProperties.KEY_ALGORITHM_AES
```

**2. RSA Keys**: Asymmetric encryption
```kotlin
KeyProperties.KEY_ALGORITHM_RSA
```

**3. EC Keys**: Elliptic curve cryptography
```kotlin
KeyProperties.KEY_ALGORITHM_EC
```

### Key Properties

```kotlin
val keyGenParameterSpec = KeyGenParameterSpec.Builder(
    keyName,
    KeyProperties.PURPOSE_ENCRYPT or KeyProperties.PURPOSE_DECRYPT
)
    .setBlockModes(KeyProperties.BLOCK_MODE_GCM)
    .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_NONE)
    .setUserAuthenticationRequired(true)
    .setUserAuthenticationValidityDurationSeconds(30)
    .setInvalidatedByBiometricEnrollment(true)
    .build()
```

## Certificate Pinning

### What is Certificate Pinning?

**Certificate Pinning**: Trust only specific certificates

**Purpose**: Prevent MITM attacks

### OkHttp Certificate Pinning

```kotlin
val certificatePinner = CertificatePinner.Builder()
    .add("api.example.com", "sha256/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=")
    .add("api.example.com", "sha256/BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB=")
    .build()

val okHttpClient = OkHttpClient.Builder()
    .certificatePinner(certificatePinner)
    .build()
```

### Getting Certificate Hash

```bash
openssl s_client -connect api.example.com:443 | \
openssl x509 -pubkey -noout | \
openssl pkey -pubin -outform der | \
openssl dgst -sha256 -binary | \
openssl enc -base64
```

## OAuth 2.0 & OpenID Connect

### OAuth 2.0 Flow

**Authorization Code Flow**:
1. User authorizes app
2. App receives authorization code
3. App exchanges code for access token
4. App uses access token for API calls

### OAuth Implementation

```kotlin
class OAuthManager(
    private val context: Context
) {
    private val authState = AuthState()
    
    fun authorize() {
        val authRequest = AuthorizationRequest.Builder(
            AuthorizationServiceConfiguration(
                Uri.parse("https://auth.example.com/authorize"),
                Uri.parse("https://auth.example.com/token")
            ),
            "client_id",
            ResponseTypeValues.CODE,
            Uri.parse("myapp://callback")
        )
            .setScopes("openid", "profile", "email")
            .build()
        
        val authService = AuthorizationService(context)
        val intent = authService.getAuthorizationRequestIntent(authRequest)
        context.startActivity(intent)
    }
    
    fun handleCallback(uri: Uri) {
        val authResponse = AuthorizationResponse.fromIntent(uri)
        val authException = AuthorizationException.fromIntent(uri)
        
        authState.update(authResponse, authException)
        
        if (authResponse != null) {
            exchangeCodeForToken(authResponse)
        }
    }
    
    private fun exchangeCodeForToken(authResponse: AuthorizationResponse) {
        val tokenRequest = authResponse.createTokenExchangeRequest()
        val authService = AuthorizationService(context)
        
        authService.performTokenRequest(tokenRequest) { response, exception ->
            authState.update(response, exception)
            if (response != null) {
                saveTokens(response)
            }
        }
    }
}
```

## Token Management

### Secure Token Storage

```kotlin
class TokenManager(
    private val context: Context
) {
    private val encryptedPrefs = getEncryptedSharedPreferences(context)
    
    fun saveAccessToken(token: String) {
        encryptedPrefs.edit()
            .putString("access_token", token)
            .apply()
    }
    
    fun getAccessToken(): String? {
        return encryptedPrefs.getString("access_token", null)
    }
    
    fun saveRefreshToken(token: String) {
        encryptedPrefs.edit()
            .putString("refresh_token", token)
            .apply()
    }
    
    fun getRefreshToken(): String? {
        return encryptedPrefs.getString("refresh_token", null)
    }
    
    fun clearTokens() {
        encryptedPrefs.edit()
            .remove("access_token")
            .remove("refresh_token")
            .apply()
    }
}
```

### Token Refresh

```kotlin
class TokenRefreshInterceptor(
    private val tokenManager: TokenManager,
    private val authApi: AuthApiService
) : Interceptor {
    override fun intercept(chain: Interceptor.Chain): Response {
        var request = chain.request()
        var response = chain.proceed(request)
        
        if (response.code == 401) {
            // Token expired, refresh it
            val refreshToken = tokenManager.getRefreshToken()
            if (refreshToken != null) {
                val newToken = refreshAccessToken(refreshToken)
                if (newToken != null) {
                    // Retry with new token
                    request = request.newBuilder()
                        .header("Authorization", "Bearer $newToken")
                        .build()
                    response.close()
                    response = chain.proceed(request)
                }
            }
        }
        
        return response
    }
    
    private suspend fun refreshAccessToken(refreshToken: String): String? {
        return try {
            val response = authApi.refreshToken(refreshToken)
            tokenManager.saveAccessToken(response.accessToken)
            response.accessToken
        } catch (e: Exception) {
            null
        }
    }
}
```

## Security Best Practices

### Practice 1: Use HTTPS Always

```kotlin
// GOOD: Always use HTTPS
val retrofit = Retrofit.Builder()
    .baseUrl("https://api.example.com/") // HTTPS
    .build()

// BAD: Never use HTTP
val retrofit = Retrofit.Builder()
    .baseUrl("http://api.example.com/") // HTTP - insecure!
    .build()
```

### Practice 2: Encrypt Sensitive Data

```kotlin
// GOOD: Encrypt sensitive data
val encryptedPrefs = getEncryptedSharedPreferences(context)
encryptedPrefs.edit()
    .putString("password", encryptedPassword)
    .apply()

// BAD: Store plain text
val prefs = getSharedPreferences("prefs", Context.MODE_PRIVATE)
prefs.edit()
    .putString("password", plainPassword) // Insecure!
    .apply()
```

### Practice 3: Use Keystore for Keys

```kotlin
// GOOD: Use Android Keystore
val keyStore = KeyStore.getInstance("AndroidKeyStore")
keyStore.load(null)
val key = keyStore.getKey("my_key", null)

// BAD: Store keys in code
val key = "my_secret_key" // Insecure!
```

### Practice 4: Implement Certificate Pinning

```kotlin
// GOOD: Pin certificates
val certificatePinner = CertificatePinner.Builder()
    .add("api.example.com", "sha256/...")
    .build()

// BAD: Trust all certificates
// No pinning - vulnerable to MITM
```

### Practice 5: Clear Sensitive Data

```kotlin
// GOOD: Clear sensitive data
fun clearSensitiveData() {
    password = null
    token = null
    // Let GC collect
}

// BAD: Keep sensitive data in memory
var password: String? = null // Never cleared
```

## Real-World Examples

### Complete Security Manager

```kotlin
class SecurityManager(
    private val context: Context
) {
    private val tokenManager = TokenManager(context)
    private val encryptionHelper = KeystoreEncryptionHelper("app_key")
    private val biometricHelper = BiometricAuthHelper(context as ComponentActivity)
    
    fun saveSecureData(key: String, value: String) {
        val encrypted = encryptionHelper.encrypt(value)
        val encryptedPrefs = getEncryptedSharedPreferences(context)
        encryptedPrefs.edit()
            .putString(key, encrypted)
            .apply()
    }
    
    fun getSecureData(key: String): String? {
        val encryptedPrefs = getEncryptedSharedPreferences(context)
        val encrypted = encryptedPrefs.getString(key, null) ?: return null
        return encryptionHelper.decrypt(encrypted)
    }
    
    fun authenticateWithBiometric(
        onSuccess: () -> Unit,
        onError: (String) -> Unit
    ) {
        biometricHelper.authenticate(
            title = "Authentication Required",
            subtitle = "Use biometric to authenticate",
            onSuccess = onSuccess,
            onError = onError,
            onFailed = { onError("Authentication failed") }
        )
    }
}
```

## Common Pitfalls

### Problem: Storing Passwords in Plain Text

```kotlin
// BAD: Plain text storage
prefs.edit().putString("password", password).apply()

// GOOD: Encrypted storage
val encrypted = encryptionHelper.encrypt(password)
encryptedPrefs.edit().putString("password", encrypted).apply()
```

### Problem: Not Using HTTPS

```kotlin
// BAD: HTTP
.baseUrl("http://api.example.com/")

// GOOD: HTTPS
.baseUrl("https://api.example.com/")
```

## Quiz

1. What is the purpose of Android Keystore?
   - **A)** Store app data
   - **B)** Hardware-backed secure key storage
   - **C)** Network storage
   - **D)** Nothing

2. What is certificate pinning?
   - **A)** Trust all certificates
   - **B)** Trust only specific certificates
   - **C)** No certificates
   - **D)** Automatic certificates

3. How should you store sensitive data?
   - **A)** Plain text
   - **B)** Encrypted storage
   - **C)** SharedPreferences
   - **D)** Public storage

**Answers:**
1. **B** - Android Keystore provides hardware-backed secure storage for cryptographic keys
2. **B** - Certificate pinning trusts only specific certificates to prevent MITM attacks
3. **B** - Sensitive data should always be stored encrypted using EncryptedSharedPreferences or Keystore

## Next Steps

- [Android Permissions](./27.%20Android%20Permissions.md) - Permission handling
- [Networking & API Integration](./25.%20Networking%20%26%20API%20Integration.md) - Secure networking
- [Notifications & FCM](./29.%20Notifications%20%26%20FCM.md) - Secure notifications

