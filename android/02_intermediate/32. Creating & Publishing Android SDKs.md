---
number: 32
title: "Creating & Publishing Android SDKs"
slug: "creating-publishing-android-sdks"
level: "intermediate"
tags: ["sdk", "library", "aar", "maven", "publishing", "distribution"]
prerequisites: ["build-systems-advanced-gradle", "dependency-injection-hilt"]
estimated_minutes: 90
contributors: []
diagrams: []
examples: []
canonical_id: "android-intermediate-32"
---

# Creating & Publishing Android SDKs

## Overview

Creating reusable Android SDKs allows you to share code across projects, build libraries for third-party developers, and modularize your codebase. This comprehensive guide covers creating Android library modules, building AAR files, publishing to Maven repositories (Maven Central, JitPack), versioning strategies, and best practices for SDK distribution.

## Table of Contents

1. [SDK Overview](#sdk-overview)
2. [Creating Android Library Module](#creating-library-module)
3. [Building AAR Files](#building-aar-files)
4. [Publishing to JitPack](#publishing-jitpack)
5. [Publishing to Maven Central](#publishing-maven-central)
6. [Local Maven Repository](#local-maven)
7. [Versioning Strategies](#versioning)
8. [SDK Configuration](#sdk-configuration)
9. [Best Practices](#best-practices)

## SDK Overview

### What is an Android SDK?

**SDK (Software Development Kit)**: A collection of tools, libraries, and documentation that allows developers to build applications for a specific platform or framework.

**Android SDK**: A library module packaged as an AAR (Android Archive) file that can be distributed and integrated into other Android projects.

### Types of Android Libraries

**1. Android Library Module**:
- Contains Android resources (layouts, drawables, strings)
- Can include Activities, Fragments, Services
- Packaged as `.aar` file

**2. Java/Kotlin Library Module**:
- Pure Java/Kotlin code without Android dependencies
- Packaged as `.jar` file
- Can be used in non-Android projects

**3. Multi-Platform Library**:
- Supports multiple platforms (Android, iOS, JVM)
- Uses Kotlin Multiplatform

### AAR vs JAR

**AAR (Android Archive)**:
- Contains compiled code, resources, and manifest
- Includes Android-specific files
- Used for Android libraries

**JAR (Java Archive)**:
- Contains only compiled Java/Kotlin classes
- No Android resources
- Used for pure Java/Kotlin libraries

## Creating Android Library Module

### Step 1: Create Library Module

**In Android Studio**:
1. File → New → New Module
2. Select "Android Library"
3. Configure module name and package

**Manually**:

```kotlin
// settings.gradle.kts
include(":mylibrary")
```

```kotlin
// mylibrary/build.gradle.kts
plugins {
    id("com.android.library")
    id("org.jetbrains.kotlin.android")
}

android {
    namespace = "com.example.mylibrary"
    compileSdk = 34

    defaultConfig {
        minSdk = 24
        targetSdk = 34
        versionCode = 1
        versionName = "1.0.0"
    }

    buildTypes {
        release {
            isMinifyEnabled = false
            proguardFiles(
                getDefaultProguardFile("proguard-android-optimize.txt"),
                "proguard-rules.pro"
            )
        }
    }

    compileOptions {
        sourceCompatibility = JavaVersion.VERSION_17
        targetCompatibility = JavaVersion.VERSION_17
    }

    kotlinOptions {
        jvmTarget = "17"
    }
}

dependencies {
    // SDK dependencies
    implementation("androidx.core:core-ktx:1.12.0")
    implementation("org.jetbrains.kotlinx:kotlinx-coroutines-android:1.7.3")
}
```

### Step 2: Define Public API

**Create Public Interface**:

```kotlin
// mylibrary/src/main/java/com/example/mylibrary/MySDK.kt
package com.example.mylibrary

class MySDK private constructor() {
    private var isInitialized = false

    companion object {
        @Volatile
        private var instance: MySDK? = null

        fun getInstance(): MySDK {
            return instance ?: synchronized(this) {
                instance ?: MySDK().also { instance = it }
            }
        }
    }

    fun initialize(context: android.content.Context) {
        if (!isInitialized) {
            // Initialize SDK
            isInitialized = true
        }
    }

    fun doSomething() {
        require(isInitialized) { "SDK not initialized. Call initialize() first." }
        // SDK functionality
    }
}
```

**Builder Pattern**:

```kotlin
// mylibrary/src/main/java/com/example/mylibrary/MySDKBuilder.kt
package com.example.mylibrary

class MySDKBuilder {
    private var apiKey: String? = null
    private var environment: Environment = Environment.PRODUCTION

    fun setApiKey(apiKey: String): MySDKBuilder {
        this.apiKey = apiKey
        return this
    }

    fun setEnvironment(environment: Environment): MySDKBuilder {
        this.environment = environment
        return this
    }

    fun build(context: android.content.Context): MySDK {
        requireNotNull(apiKey) { "API key is required" }
        val sdk = MySDK.getInstance()
        sdk.initialize(context, apiKey!!, environment)
        return sdk
    }
}

enum class Environment {
    DEVELOPMENT,
    STAGING,
    PRODUCTION
}
```

### Step 3: Configure ProGuard Rules

**proguard-rules.pro**:

```proguard
# Keep SDK public API
-keep public class com.example.mylibrary.** { *; }

# Keep data classes
-keep class com.example.mylibrary.model.** { *; }

# Keep annotations
-keepattributes *Annotation*
-keepattributes Signature
-keepattributes Exceptions

# Keep native methods
-keepclasseswithmembernames class * {
    native <methods>;
}

# Keep Parcelable implementations
-keep class * implements android.os.Parcelable {
    public static final android.os.Parcelable$Creator *;
}
```

## Building AAR Files

### Build AAR Locally

**Command Line**:

```bash
# Build release AAR
./gradlew :mylibrary:assembleRelease

# Output location
# mylibrary/build/outputs/aar/mylibrary-release.aar
```

**Gradle Task**:

```kotlin
// mylibrary/build.gradle.kts
tasks.register("generateAAR") {
    dependsOn("assembleRelease")
    doLast {
        val aarFile = file("build/outputs/aar/mylibrary-release.aar")
        val outputDir = file("dist")
        outputDir.mkdirs()
        copy {
            from(aarFile)
            into(outputDir)
            rename { "mylibrary-${project.version}.aar" }
        }
        println("AAR generated: ${outputDir}/mylibrary-${project.version}.aar")
    }
}
```

### AAR Structure

```
mylibrary-release.aar
├── AndroidManifest.xml
├── classes.jar
├── R.txt
├── res/
│   ├── layout/
│   ├── drawable/
│   └── values/
└── proguard.txt
```

## Publishing to JitPack

### What is JitPack?

**JitPack**: A repository that automatically builds and publishes GitHub projects as Maven dependencies.

**Benefits**:
- No manual configuration
- Automatic builds from Git tags
- Free for public repositories

### Step 1: Setup Repository

**GitHub Repository**:

```bash
# Initialize git repository
git init
git add .
git commit -m "Initial commit"
git remote add origin https://github.com/username/mylibrary.git
git push -u origin main
```

### Step 2: Create Release Tag

```bash
# Create version tag
git tag -a v1.0.0 -m "Release version 1.0.0"
git push origin v1.0.0
```

### Step 3: Configure build.gradle.kts

```kotlin
// mylibrary/build.gradle.kts
plugins {
    id("com.android.library")
    id("org.jetbrains.kotlin.android")
    id("maven-publish")
}

android {
    // ... existing configuration

    publishing {
        singleVariant("release") {
            withSourcesJar()
            withJavadocJar()
        }
    }
}

afterEvaluate {
    publishing {
        publications {
            create<MavenPublication>("release") {
                from(components["release"])

                groupId = "com.github.YourUsername"
                artifactId = "mylibrary"
                version = "1.0.0"
            }
        }
    }
}
```

### Step 4: Use in Projects

**build.gradle.kts**:

```kotlin
// Add JitPack repository
repositories {
    maven { url = uri("https://jitpack.io") }
}

dependencies {
    implementation("com.github.YourUsername:mylibrary:1.0.0")
}
```

## Publishing to Maven Central

### Prerequisites

1. **Sonatype Account**: Create account at https://issues.sonatype.org
2. **GPG Key**: Generate GPG key for signing
3. **Repository Access**: Request access to group ID

### Step 1: Generate GPG Key

```bash
# Generate GPG key
gpg --gen-key

# List keys
gpg --list-secret-keys

# Export public key
gpg --keyserver hkp://keyserver.ubuntu.com --send-keys YOUR_KEY_ID
```

### Step 2: Configure Gradle

**gradle.properties** (in `~/.gradle/gradle.properties`):

```properties
signing.keyId=YOUR_KEY_ID
signing.password=YOUR_KEY_PASSWORD
signing.secretKeyRingFile=/path/to/.gnupg/secring.gpg

ossrhUsername=YOUR_SONATYPE_USERNAME
ossrhPassword=YOUR_SONATYPE_PASSWORD
```

**build.gradle.kts**:

```kotlin
// mylibrary/build.gradle.kts
plugins {
    id("com.android.library")
    id("org.jetbrains.kotlin.android")
    id("maven-publish")
    id("signing")
}

android {
    // ... existing configuration

    publishing {
        singleVariant("release") {
            withSourcesJar()
            withJavadocJar()
        }
    }
}

publishing {
    publications {
        create<MavenPublication>("release") {
            afterEvaluate {
                from(components["release"])
            }

            groupId = "com.example"
            artifactId = "mylibrary"
            version = "1.0.0"

            pom {
                name.set("My Library")
                description.set("A sample Android SDK")
                url.set("https://github.com/username/mylibrary")

                licenses {
                    license {
                        name.set("The Apache License, Version 2.0")
                        url.set("http://www.apache.org/licenses/LICENSE-2.0.txt")
                    }
                }

                developers {
                    developer {
                        id.set("developer")
                        name.set("Developer Name")
                        email.set("developer@example.com")
                    }
                }

                scm {
                    connection.set("scm:git:git://github.com/username/mylibrary.git")
                    developerConnection.set("scm:git:ssh://github.com:username/mylibrary.git")
                    url.set("https://github.com/username/mylibrary")
                }
            }
        }
    }

    repositories {
        maven {
            name = "sonatype"
            url = uri("https://s01.oss.sonatype.org/service/local/staging/deploy/maven2/")
            credentials {
                username = project.findProperty("ossrhUsername") as String?
                password = project.findProperty("ossrhPassword") as String?
            }
        }
    }
}

signing {
    sign(publishing.publications["release"])
}

tasks.register("publishToMavenCentral") {
    dependsOn("publishReleasePublicationToSonatypeRepository")
    doLast {
        println("Published to Maven Central staging repository")
        println("Visit https://s01.oss.sonatype.org to release")
    }
}
```

### Step 3: Publish

```bash
# Publish to staging repository
./gradlew publishToMavenCentral

# After verification, release from Sonatype Nexus UI
# Or use closeAndReleaseRepository task
```

## Local Maven Repository

### Publishing Locally

```kotlin
// mylibrary/build.gradle.kts
publishing {
    publications {
        create<MavenPublication>("release") {
            afterEvaluate {
                from(components["release"])
            }

            groupId = "com.example"
            artifactId = "mylibrary"
            version = "1.0.0"
        }
    }

    repositories {
        maven {
            url = uri("${project.rootDir}/repo")
        }
    }
}
```

**Publish**:

```bash
./gradlew publishReleasePublicationToMavenRepository
```

**Use Local Repository**:

```kotlin
// app/build.gradle.kts
repositories {
    maven { url = uri("${project.rootDir}/../repo") }
}

dependencies {
    implementation("com.example:mylibrary:1.0.0")
}
```

## Versioning Strategies

### Semantic Versioning

**Format**: `MAJOR.MINOR.PATCH`

- **MAJOR**: Breaking changes
- **MINOR**: New features (backward compatible)
- **PATCH**: Bug fixes (backward compatible)

**Examples**:
- `1.0.0` - Initial release
- `1.0.1` - Bug fix
- `1.1.0` - New feature
- `2.0.0` - Breaking changes

### Version Configuration

```kotlin
// gradle.properties
VERSION_NAME=1.0.0
VERSION_CODE=1

// mylibrary/build.gradle.kts
android {
    defaultConfig {
        versionCode = project.findProperty("VERSION_CODE")?.toString()?.toInt() ?: 1
        versionName = project.findProperty("VERSION_NAME")?.toString() ?: "1.0.0"
    }
}
```

### Version Catalog

```toml
# gradle/libs.versions.toml
[versions]
mylibrary = "1.0.0"

[libraries]
mylibrary = { module = "com.example:mylibrary", version.ref = "mylibrary" }
```

## SDK Configuration

### Build Variants for SDK

```kotlin
android {
    flavorDimensions += "environment"

    productFlavors {
        create("dev") {
            dimension = "environment"
            buildConfigField("String", "API_URL", "\"https://dev.api.com\"")
        }

        create("prod") {
            dimension = "environment"
            buildConfigField("String", "API_URL", "\"https://api.com\"")
        }
    }
}
```

### API Level Configuration

```kotlin
android {
    defaultConfig {
        minSdk = 24
        compileSdk = 34
        targetSdk = 34
    }
}
```

### Resource Shrinking

```kotlin
android {
    buildTypes {
        release {
            isMinifyEnabled = true
            isShrinkResources = true
            proguardFiles(
                getDefaultProguardFile("proguard-android-optimize.txt"),
                "proguard-rules.pro"
            )
        }
    }
}
```

## Best Practices

### 1. Clear Public API

**Design**:
- Expose only necessary classes/methods
- Use `internal` visibility for implementation details
- Document public API with KDoc

```kotlin
/**
 * Main entry point for MySDK.
 *
 * @param context Application context
 * @param apiKey API key for authentication
 */
class MySDK {
    // ...
}
```

### 2. Error Handling

```kotlin
sealed class SDKResult<out T> {
    data class Success<T>(val data: T) : SDKResult<T>()
    data class Error(val exception: Throwable) : SDKResult<Nothing>()
}

fun doSomething(): SDKResult<String> {
    return try {
        SDKResult.Success("Success")
    } catch (e: Exception) {
        SDKResult.Error(e)
    }
}
```

### 3. Initialization

```kotlin
class MySDK private constructor() {
    companion object {
        @Volatile
        private var instance: MySDK? = null

        fun initialize(context: Context, config: SDKConfig): MySDK {
            return instance ?: synchronized(this) {
                instance ?: MySDK().apply {
                    init(context, config)
                    instance = this
                }
            }
        }

        fun getInstance(): MySDK {
            return instance ?: throw IllegalStateException(
                "SDK not initialized. Call initialize() first."
            )
        }
    }
}
```

### 4. Dependency Management

**Minimize Dependencies**:
- Only include essential dependencies
- Use `api` for transitive dependencies
- Use `implementation` for internal dependencies

```kotlin
dependencies {
    // Exposed to SDK users
    api("com.squareup.retrofit2:retrofit:2.9.0")

    // Internal to SDK
    implementation("com.google.code.gson:gson:2.10.1")
}
```

### 5. Testing

```kotlin
// mylibrary/src/test/java/com/example/mylibrary/MySDKTest.kt
class MySDKTest {
    @Test
    fun testInitialization() {
        val context = mock(Context::class.java)
        val sdk = MySDK.initialize(context, SDKConfig())
        assertNotNull(sdk)
    }
}
```

### 6. Documentation

**README.md**:

```markdown
# MySDK

Android SDK for [purpose].

## Installation

```kotlin
dependencies {
    implementation("com.example:mylibrary:1.0.0")
}
```

## Usage

```kotlin
MySDK.initialize(context, SDKConfig.builder()
    .setApiKey("your-api-key")
    .build())

MySDK.getInstance().doSomething()
```

## License

Apache 2.0
```

## Quiz

### Question 1
What is the difference between AAR and JAR files?

**A)** AAR contains Android resources, JAR doesn't  
**B)** AAR is larger than JAR  
**C)** JAR is for Android, AAR is for Java  
**D)** No difference

**Answer: A** - AAR (Android Archive) files contain Android resources like layouts and drawables, while JAR files contain only compiled Java/Kotlin classes.

### Question 2
What is the recommended versioning strategy for SDKs?

**A)** Random version numbers  
**B)** Semantic versioning (MAJOR.MINOR.PATCH)  
**C)** Date-based versioning  
**D)** No versioning needed

**Answer: B** - Semantic versioning (MAJOR.MINOR.PATCH) is the industry standard for SDK versioning, making it clear when breaking changes occur.

### Question 3
Which repository is easiest for publishing Android SDKs?

**A)** Maven Central  
**B)** JitPack  
**C)** Local repository  
**D)** All are equally easy

**Answer: B** - JitPack automatically builds and publishes GitHub projects without manual configuration, making it the easiest option for quick publishing.

### Question 4
What should you use for SDK dependencies that users need?

**A)** `implementation`  
**B)** `api`  
**C)** `compileOnly`  
**D)** `testImplementation`

**Answer: B** - Use `api` for dependencies that SDK users need access to, as it exposes them transitively.

### Question 5
What is the purpose of ProGuard rules in SDKs?

**A)** To make code faster  
**B)** To keep public API classes from being obfuscated  
**C)** To reduce APK size  
**D)** To improve security

**Answer: B** - ProGuard rules ensure that public API classes and methods are not obfuscated, maintaining compatibility for SDK users.

## Related Topics

- [Build Systems & Advanced Gradle](../04_overachiever/02.%20Build%20Systems%20%26%20Advanced%20Gradle.md) - Gradle configuration
- [Dependency Injection with Hilt](./24.%20Dependency%20Injection%20with%20Hilt.md) - Dependency management
- [Advanced SDK Design & Architecture](../03_advanced/17.%20Advanced%20SDK%20Design%20%26%20Architecture.md) - Advanced SDK topics

