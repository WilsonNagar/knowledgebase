---
number: 31
title: "Firebase Integration"
slug: "firebase-integration"
level: "intermediate"
tags: ["firebase", "firestore", "authentication", "analytics", "crashlytics"]
prerequisites: ["networking-api-integration"]
estimated_minutes: 120
contributors: []
diagrams: []
examples: []
canonical_id: "android-31"
---

# Firebase Integration

## Overview

Firebase is Google's platform for building mobile and web applications. This comprehensive guide covers Firebase setup, Authentication, Firestore database, Analytics, Crashlytics, Remote Config, Storage, Cloud Functions, and best practices for integrating Firebase services into Android applications.

## Table of Contents

1. [Firebase Overview](#overview)
2. [Firebase Setup](#setup)
3. [Firebase Authentication](#authentication)
4. [Cloud Firestore](#firestore)
5. [Firebase Analytics](#analytics)
6. [Firebase Crashlytics](#crashlytics)
7. [Firebase Remote Config](#remote-config)
8. [Firebase Storage](#storage)
9. [Cloud Functions](#cloud-functions)
10. [Best Practices](#best-practices)

## Firebase Overview

### What is Firebase?

**Firebase**: Google's Backend-as-a-Service (BaaS) platform

**Services**:
- **Authentication**: User authentication
- **Firestore**: NoSQL database
- **Analytics**: User analytics
- **Crashlytics**: Crash reporting
- **Remote Config**: Remote configuration
- **Storage**: File storage
- **Cloud Functions**: Serverless functions

### Benefits

**Benefits**:
- **Backend**: No backend server needed
- **Real-time**: Real-time synchronization
- **Scalable**: Automatic scaling
- **Free Tier**: Generous free tier

## Firebase Setup

### Step 1: Create Firebase Project

1. Go to [Firebase Console](https://console.firebase.google.com/)
2. Create new project
3. Add Android app
4. Download `google-services.json`
5. Place in `app/` directory

### Step 2: Add Dependencies

**Project-level `build.gradle.kts`**:
```kotlin
buildscript {
    dependencies {
        classpath("com.google.gms:google-services:4.4.0")
    }
}
```

**App-level `build.gradle.kts`**:
```kotlin
plugins {
    id("com.android.application")
    id("org.jetbrains.kotlin.android")
    id("com.google.gms.google-services")
}

dependencies {
    // Firebase BOM
    implementation(platform("com.google.firebase:firebase-bom:32.7.0"))
    
    // Firebase services
    implementation("com.google.firebase:firebase-auth-ktx")
    implementation("com.google.firebase:firebase-firestore-ktx")
    implementation("com.google.firebase:firebase-analytics-ktx")
    implementation("com.google.firebase:firebase-crashlytics-ktx")
    implementation("com.google.firebase:firebase-config-ktx")
    implementation("com.google.firebase:firebase-storage-ktx")
    implementation("com.google.firebase:firebase-messaging-ktx")
}
```

### Step 3: Initialize Firebase

```kotlin
class MyApplication : Application() {
    override fun onCreate() {
        super.onCreate()
        // Firebase automatically initialized
        // No manual initialization needed
    }
}
```

## Firebase Authentication

### Email/Password Authentication

**Sign Up**:
```kotlin
FirebaseAuth.getInstance().createUserWithEmailAndPassword(
    email,
    password
).addOnCompleteListener { task ->
    if (task.isSuccessful) {
        val user = task.result?.user
        // User created
    } else {
        val error = task.exception
        // Handle error
    }
}
```

**Sign In**:
```kotlin
FirebaseAuth.getInstance().signInWithEmailAndPassword(
    email,
    password
).addOnCompleteListener { task ->
    if (task.isSuccessful) {
        val user = task.result?.user
        // User signed in
    } else {
        // Handle error
    }
}
```

**Sign Out**:
```kotlin
FirebaseAuth.getInstance().signOut()
```

### Google Sign-In

**Setup**:
```kotlin
val gso = GoogleSignInOptions.Builder(GoogleSignInOptions.DEFAULT_SIGN_IN)
    .requestIdToken(getString(R.string.default_web_client_id))
    .requestEmail()
    .build()

val googleSignInClient = GoogleSignIn.getClient(this, gso)
```

**Sign In**:
```kotlin
val signInIntent = googleSignInClient.signInIntent
startActivityForResult(signInIntent, RC_SIGN_IN)

override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {
    super.onActivityResult(requestCode, resultCode, data)
    
    if (requestCode == RC_SIGN_IN) {
        val task = GoogleSignIn.getSignedInAccountFromIntent(data)
        val account = task.getResult(ApiException::class.java)
        
        val credential = GoogleAuthProvider.getCredential(account.idToken, null)
        FirebaseAuth.getInstance().signInWithCredential(credential)
            .addOnCompleteListener { task ->
                if (task.isSuccessful) {
                    // Signed in
                }
            }
    }
}
```

### Anonymous Authentication

```kotlin
FirebaseAuth.getInstance().signInAnonymously()
    .addOnCompleteListener { task ->
        if (task.isSuccessful) {
            val user = task.result?.user
            // Anonymous user signed in
        }
    }
```

### Auth State Listener

```kotlin
val authStateListener = FirebaseAuth.AuthStateListener { auth ->
    val user = auth.currentUser
    if (user != null) {
        // User signed in
    } else {
        // User signed out
    }
}

FirebaseAuth.getInstance().addAuthStateListener(authStateListener)
```

## Cloud Firestore

### What is Firestore?

**Firestore**: NoSQL document database

**Features**:
- **Real-time**: Real-time synchronization
- **Offline**: Offline support
- **Scalable**: Automatic scaling
- **Queries**: Powerful querying

### Writing Data

```kotlin
val db = FirebaseFirestore.getInstance()

// Add document
val user = hashMapOf(
    "name" to "John",
    "email" to "john@example.com",
    "age" to 30
)

db.collection("users")
    .add(user)
    .addOnSuccessListener { documentReference ->
        // Document added
    }
    .addOnFailureListener { e ->
        // Handle error
    }

// Set document with ID
db.collection("users")
    .document("user123")
    .set(user)

// Update document
db.collection("users")
    .document("user123")
    .update("age", 31)
```

### Reading Data

```kotlin
// Read single document
db.collection("users")
    .document("user123")
    .get()
    .addOnSuccessListener { document ->
        if (document != null) {
            val name = document.getString("name")
            val email = document.getString("email")
        }
    }

// Read collection
db.collection("users")
    .get()
    .addOnSuccessListener { documents ->
        for (document in documents) {
            // Process document
        }
    }

// Query
db.collection("users")
    .whereEqualTo("age", 30)
    .get()
    .addOnSuccessListener { documents ->
        // Process results
    }
```

### Real-time Listeners

```kotlin
// Listen to document
db.collection("users")
    .document("user123")
    .addSnapshotListener { snapshot, error ->
        if (error != null) {
            // Handle error
            return@addSnapshotListener
        }
        
        if (snapshot != null && snapshot.exists()) {
            val user = snapshot.toObject(User::class.java)
            // Update UI
        }
    }

// Listen to collection
db.collection("users")
    .addSnapshotListener { snapshot, error ->
        if (error != null) {
            return@addSnapshotListener
        }
        
        snapshot?.documents?.forEach { document ->
            val user = document.toObject(User::class.java)
            // Process user
        }
    }
```

### Firestore with Coroutines

```kotlin
suspend fun getUser(userId: String): User? {
    return try {
        val document = db.collection("users")
            .document(userId)
            .get()
            .await()
        
        document.toObject(User::class.java)
    } catch (e: Exception) {
        null
    }
}

suspend fun getUsers(): List<User> {
    return try {
        val snapshot = db.collection("users")
            .get()
            .await()
        
        snapshot.documents.mapNotNull { it.toObject(User::class.java) }
    } catch (e: Exception) {
        emptyList()
    }
}
```

## Firebase Analytics

### Setup

```kotlin
// Automatically initialized
// No setup needed
```

### Log Events

```kotlin
val firebaseAnalytics = FirebaseAnalytics.getInstance(this)

// Log event
firebaseAnalytics.logEvent(FirebaseAnalytics.Event.SELECT_ITEM) {
    param(FirebaseAnalytics.Param.ITEM_ID, "item123")
    param(FirebaseAnalytics.Param.ITEM_NAME, "Product Name")
    param(FirebaseAnalytics.Param.CONTENT_TYPE, "product")
}

// Custom event
firebaseAnalytics.logEvent("custom_event") {
    param("custom_param", "value")
}
```

### Set User Properties

```kotlin
firebaseAnalytics.setUserProperty("user_type", "premium")
firebaseAnalytics.setUserId("user123")
```

## Firebase Crashlytics

### Setup

**build.gradle.kts**:
```kotlin
android {
    buildTypes {
        release {
            isMinifyEnabled = true
            // Crashlytics requires minification
        }
    }
}
```

**Application**:
```kotlin
class MyApplication : Application() {
    override fun onCreate() {
        super.onCreate()
        FirebaseCrashlytics.getInstance().setCrashlyticsCollectionEnabled(true)
    }
}
```

### Log Crashes

```kotlin
// Automatic crash reporting
// Crashes are automatically reported

// Log non-fatal exception
FirebaseCrashlytics.getInstance().recordException(exception)

// Set custom keys
FirebaseCrashlytics.getInstance().setCustomKey("user_id", userId)
FirebaseCrashlytics.getInstance().setCustomKey("screen", "LoginScreen")

// Log messages
FirebaseCrashlytics.getInstance().log("User clicked login button")
```

## Firebase Remote Config

### Setup

```kotlin
val remoteConfig = FirebaseRemoteConfig.getInstance()

val configSettings = remoteConfigSettings {
    minimumFetchIntervalInSeconds = 3600
}

remoteConfig.setConfigSettingsAsync(configSettings)

// Set default values
remoteConfig.setDefaultsAsync(mapOf(
    "welcome_message" to "Welcome",
    "feature_enabled" to false
))
```

### Fetch and Activate

```kotlin
remoteConfig.fetchAndActivate()
    .addOnCompleteListener { task ->
        if (task.isSuccessful) {
            val updated = task.result
            // Config updated
        }
    }
```

### Get Values

```kotlin
val welcomeMessage = remoteConfig.getString("welcome_message")
val featureEnabled = remoteConfig.getBoolean("feature_enabled")
val count = remoteConfig.getLong("count")
```

## Firebase Storage

### Upload Files

```kotlin
val storage = FirebaseStorage.getInstance()
val storageRef = storage.reference

// Upload file
val file = Uri.fromFile(File("path/to/file.jpg"))
val imageRef = storageRef.child("images/image.jpg")

imageRef.putFile(file)
    .addOnSuccessListener { taskSnapshot ->
        // Upload successful
        val downloadUrl = taskSnapshot.metadata?.reference?.downloadUrl
    }
    .addOnFailureListener { exception ->
        // Handle error
    }
```

### Download Files

```kotlin
val storageRef = FirebaseStorage.getInstance().reference
val imageRef = storageRef.child("images/image.jpg")

imageRef.downloadUrl.addOnSuccessListener { uri ->
    // Use URI to load image
    loadImage(uri.toString())
}.addOnFailureListener {
    // Handle error
}
```

### Delete Files

```kotlin
val storageRef = FirebaseStorage.getInstance().reference
val imageRef = storageRef.child("images/image.jpg")

imageRef.delete()
    .addOnSuccessListener {
        // File deleted
    }
    .addOnFailureListener {
        // Handle error
    }
```

## Cloud Functions

### What are Cloud Functions?

**Cloud Functions**: Serverless functions

**Purpose**: Run backend code without managing servers

### Calling Cloud Functions

```kotlin
val functions = FirebaseFunctions.getInstance()

val data = hashMapOf(
    "text" to "Hello",
    "uppercase" to true
)

functions.getHttpsCallable("uppercase")
    .call(data)
    .continueWith { task ->
        val result = task.result?.data as? Map<*, *>
        result?.get("message") as? String
    }
```

## Best Practices

### Practice 1: Use Offline Persistence

```kotlin
// Enable offline persistence
val settings = FirebaseFirestoreSettings.Builder()
    .setPersistenceEnabled(true)
    .build()

db.firestoreSettings = settings
```

### Practice 2: Handle Errors

```kotlin
// GOOD: Handle errors
db.collection("users")
    .get()
    .addOnSuccessListener { documents ->
        // Process documents
    }
    .addOnFailureListener { exception ->
        // Handle error
        Log.e("Firestore", "Error getting documents", exception)
    }
```

### Practice 3: Use Security Rules

```javascript
// Firestore Security Rules
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    match /users/{userId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }
  }
}
```

### Practice 4: Optimize Queries

```kotlin
// GOOD: Use indexes for complex queries
db.collection("users")
    .whereEqualTo("age", 30)
    .whereEqualTo("city", "New York")
    .get()

// BAD: Too many queries
// Make multiple separate queries
```

## Real-World Examples

### Complete Firebase Setup

```kotlin
class FirebaseManager {
    private val auth = FirebaseAuth.getInstance()
    private val db = FirebaseFirestore.getInstance()
    private val analytics = FirebaseAnalytics.getInstance(context)
    
    // Authentication
    suspend fun signIn(email: String, password: String): Result<User> {
        return try {
            val result = auth.signInWithEmailAndPassword(email, password).await()
            Result.success(result.user!!)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
    
    // Firestore
    suspend fun getUser(userId: String): User? {
        return try {
            val document = db.collection("users")
                .document(userId)
                .get()
                .await()
            
            document.toObject(User::class.java)
        } catch (e: Exception) {
            null
        }
    }
    
    // Analytics
    fun logEvent(eventName: String, params: Map<String, Any>) {
        analytics.logEvent(eventName, Bundle().apply {
            params.forEach { (key, value) ->
                putString(key, value.toString())
            }
        })
    }
}
```

## Common Pitfalls

### Problem: Not Handling Offline

```kotlin
// BAD: No offline handling
db.collection("users").get()

// GOOD: Enable offline persistence
val settings = FirebaseFirestoreSettings.Builder()
    .setPersistenceEnabled(true)
    .build()
db.firestoreSettings = settings
```

### Problem: Not Using Security Rules

```kotlin
// BAD: No security rules
// Anyone can read/write

// GOOD: Use security rules
// Enforce authentication and authorization
```

## Quiz

1. What is Firestore?
   - **A)** SQL database
   - **B)** NoSQL document database
   - **C)** File storage
   - **D)** Nothing

2. What is Firebase Authentication used for?
   - **A)** Database access
   - **B)** User authentication
   - **C)** File storage
   - **D)** Analytics

3. What is Remote Config used for?
   - **A)** Remote database
   - **B)** Remote configuration without app update
   - **C)** Remote storage
   - **D)** Nothing

**Answers:**
1. **B** - Firestore is a NoSQL document database with real-time synchronization
2. **B** - Firebase Authentication provides user authentication services (email/password, Google, etc.)
3. **B** - Remote Config allows you to change app behavior remotely without publishing an update

## Next Steps

- [Networking & API Integration](./25.%20Networking%20%26%20API%20Integration.md) - API integration
- [Notifications & FCM](./29.%20Notifications%20%26%20FCM.md) - Push notifications
- [NoSQL Databases in Android](../advanced/23.%20NoSQL%20Databases%20in%20Android.md) - Database patterns

