---
number: 39
title: "File & Storage Management"
slug: "file-storage-management"
level: "intermediate"
tags: ["files", "storage", "scoped-storage", "mediastore", "file-picker"]
prerequisites: ["android-permissions"]
estimated_minutes: 90
contributors: []
diagrams: []
examples: []
canonical_id: "android-39"
---

# File & Storage Management

## Overview

Android provides multiple storage options for apps. This comprehensive guide covers internal storage, external storage, scoped storage (Android 10+), MediaStore API, file picker, document provider, file operations, and best practices for managing files in Android applications.

## Table of Contents

1. [Storage Overview](#storage-overview)
2. [Internal Storage](#internal-storage)
3. [External Storage](#external-storage)
4. [Scoped Storage](#scoped-storage)
5. [MediaStore API](#mediastore)
6. [File Picker](#file-picker)
7. [Document Provider](#document-provider)
8. [Best Practices](#best-practices)

## Storage Overview

### Storage Types

**1. Internal Storage**:
- **Private**: App-private files
- **Secure**: Not accessible by other apps
- **Cleared**: Cleared when app uninstalled

**2. External Storage**:
- **Public**: Accessible by other apps
- **Media**: Media files (photos, videos)
- **Persistent**: Persists after app uninstall

**3. Scoped Storage** (Android 10+):
- **Restricted**: Limited access to external storage
- **MediaStore**: Use MediaStore API
- **Permissions**: Runtime permissions required

## Internal Storage

### Writing to Internal Storage

```kotlin
fun writeToInternalStorage(context: Context, filename: String, content: String) {
    try {
        context.openFileOutput(filename, Context.MODE_PRIVATE).use { output ->
            output.write(content.toByteArray())
        }
    } catch (e: Exception) {
        e.printStackTrace()
    }
}
```

### Reading from Internal Storage

```kotlin
fun readFromInternalStorage(context: Context, filename: String): String? {
    return try {
        context.openFileInput(filename).use { input ->
            input.bufferedReader().use { reader ->
                reader.readText()
            }
        }
    } catch (e: FileNotFoundException) {
        null
    }
}
```

### File Operations

```kotlin
// Get internal files directory
val filesDir = context.filesDir

// Create file
val file = File(filesDir, "myfile.txt")
file.writeText("Content")

// Read file
val content = file.readText()

// Delete file
file.delete()

// List files
val files = filesDir.listFiles()
```

### Cache Directory

```kotlin
// Get cache directory
val cacheDir = context.cacheDir

// Write to cache
val cacheFile = File(cacheDir, "cache.txt")
cacheFile.writeText("Cache content")

// Clear cache
cacheDir.listFiles()?.forEach { it.delete() }
```

## External Storage

### Checking Availability

```kotlin
fun isExternalStorageAvailable(): Boolean {
    return Environment.getExternalStorageState() == Environment.MEDIA_MOUNTED
}

fun isExternalStorageWritable(): Boolean {
    val state = Environment.getExternalStorageState()
    return Environment.MEDIA_MOUNTED == state || 
           Environment.MEDIA_MOUNTED_READ_ONLY == state
}
```

### Writing to External Storage

```kotlin
fun writeToExternalStorage(context: Context, filename: String, content: String) {
    if (!isExternalStorageWritable()) {
        return
    }
    
    val file = File(context.getExternalFilesDir(null), filename)
    file.writeText(content)
}
```

### Reading from External Storage

```kotlin
fun readFromExternalStorage(context: Context, filename: String): String? {
    if (!isExternalStorageAvailable()) {
        return null
    }
    
    val file = File(context.getExternalFilesDir(null), filename)
    return if (file.exists()) {
        file.readText()
    } else {
        null
    }
}
```

## Scoped Storage

### What is Scoped Storage?

**Scoped Storage**: Restricted access to external storage (Android 10+)

**Purpose**: Improve privacy and security

**Changes**:
- **No Direct Access**: Cannot access external storage directly
- **MediaStore**: Use MediaStore API
- **Permissions**: Runtime permissions required

### Requesting Storage Permission

```kotlin
fun requestStoragePermission(activity: Activity) {
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) {
        // Android 11+ - No permission needed for scoped storage
        // But need MANAGE_EXTERNAL_STORAGE for full access
    } else if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
        // Android 10 - Scoped storage, use MediaStore
    } else {
        // Android 9 and below - Request WRITE_EXTERNAL_STORAGE
        ActivityCompat.requestPermissions(
            activity,
            arrayOf(Manifest.permission.WRITE_EXTERNAL_STORAGE),
            REQUEST_CODE
        )
    }
}
```

## MediaStore API

### What is MediaStore?

**MediaStore**: System database for media files

**Purpose**: Access media files (images, videos, audio)

**Benefits**:
- **Scoped Storage**: Works with scoped storage
- **System Integration**: Integrated with system
- **Metadata**: Rich metadata access

### Querying Images

```kotlin
fun queryImages(context: Context): List<Image> {
    val images = mutableListOf<Image>()
    val projection = arrayOf(
        MediaStore.Images.Media._ID,
        MediaStore.Images.Media.DISPLAY_NAME,
        MediaStore.Images.Media.DATE_ADDED
    )
    
    val sortOrder = "${MediaStore.Images.Media.DATE_ADDED} DESC"
    
    context.contentResolver.query(
        MediaStore.Images.Media.EXTERNAL_CONTENT_URI,
        projection,
        null,
        null,
        sortOrder
    )?.use { cursor ->
        val idColumn = cursor.getColumnIndexOrThrow(MediaStore.Images.Media._ID)
        val nameColumn = cursor.getColumnIndexOrThrow(MediaStore.Images.Media.DISPLAY_NAME)
        val dateColumn = cursor.getColumnIndexOrThrow(MediaStore.Images.Media.DATE_ADDED)
        
        while (cursor.moveToNext()) {
            val id = cursor.getLong(idColumn)
            val name = cursor.getString(nameColumn)
            val dateAdded = cursor.getLong(dateColumn)
            
            val contentUri = ContentUris.withAppendedId(
                MediaStore.Images.Media.EXTERNAL_CONTENT_URI,
                id
            )
            
            images.add(Image(id, name, contentUri, dateAdded))
        }
    }
    
    return images
}
```

### Saving Image to MediaStore

```kotlin
@RequiresApi(Build.VERSION_CODES.Q)
fun saveImageToMediaStore(context: Context, bitmap: Bitmap, displayName: String): Uri? {
    val contentValues = ContentValues().apply {
        put(MediaStore.Images.Media.DISPLAY_NAME, displayName)
        put(MediaStore.Images.Media.MIME_TYPE, "image/jpeg")
        put(MediaStore.Images.Media.RELATIVE_PATH, Environment.DIRECTORY_PICTURES)
    }
    
    val uri = context.contentResolver.insert(
        MediaStore.Images.Media.EXTERNAL_CONTENT_URI,
        contentValues
    )
    
    uri?.let {
        context.contentResolver.openOutputStream(it)?.use { outputStream ->
            bitmap.compress(Bitmap.CompressFormat.JPEG, 90, outputStream)
        }
    }
    
    return uri
}
```

### Querying Videos

```kotlin
fun queryVideos(context: Context): List<Video> {
    val videos = mutableListOf<Video>()
    val projection = arrayOf(
        MediaStore.Video.Media._ID,
        MediaStore.Video.Media.DISPLAY_NAME,
        MediaStore.Video.Media.DURATION
    )
    
    context.contentResolver.query(
        MediaStore.Video.Media.EXTERNAL_CONTENT_URI,
        projection,
        null,
        null,
        null
    )?.use { cursor ->
        val idColumn = cursor.getColumnIndexOrThrow(MediaStore.Video.Media._ID)
        val nameColumn = cursor.getColumnIndexOrThrow(MediaStore.Video.Media.DISPLAY_NAME)
        val durationColumn = cursor.getColumnIndexOrThrow(MediaStore.Video.Media.DURATION)
        
        while (cursor.moveToNext()) {
            val id = cursor.getLong(idColumn)
            val name = cursor.getString(nameColumn)
            val duration = cursor.getLong(durationColumn)
            
            val contentUri = ContentUris.withAppendedId(
                MediaStore.Video.Media.EXTERNAL_CONTENT_URI,
                id
            )
            
            videos.add(Video(id, name, contentUri, duration))
        }
    }
    
    return videos
}
```

## File Picker

### Using Storage Access Framework

```kotlin
fun pickFile(activity: Activity) {
    val intent = Intent(Intent.ACTION_OPEN_DOCUMENT).apply {
        addCategory(Intent.CATEGORY_OPENABLE)
        type = "*/*"
    }
    activity.startActivityForResult(intent, REQUEST_CODE_PICK_FILE)
}

override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {
    if (requestCode == REQUEST_CODE_PICK_FILE && resultCode == Activity.RESULT_OK) {
        data?.data?.let { uri ->
            readFileFromUri(uri)
        }
    }
}

fun readFileFromUri(uri: Uri): String? {
    return try {
        contentResolver.openInputStream(uri)?.use { input ->
            input.bufferedReader().use { reader ->
                reader.readText()
            }
        }
    } catch (e: Exception) {
        null
    }
}
```

### Picking Images

```kotlin
fun pickImage(activity: Activity) {
    val intent = Intent(Intent.ACTION_PICK).apply {
        type = "image/*"
    }
    activity.startActivityForResult(intent, REQUEST_CODE_PICK_IMAGE)
}
```

### Creating File

```kotlin
fun createFile(activity: Activity) {
    val intent = Intent(Intent.ACTION_CREATE_DOCUMENT).apply {
        addCategory(Intent.CATEGORY_OPENABLE)
        type = "text/plain"
        putExtra(Intent.EXTRA_TITLE, "document.txt")
    }
    activity.startActivityForResult(intent, REQUEST_CODE_CREATE_FILE)
}

override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {
    if (requestCode == REQUEST_CODE_CREATE_FILE && resultCode == Activity.RESULT_OK) {
        data?.data?.let { uri ->
            writeFileToUri(uri, "Content")
        }
    }
}

fun writeFileToUri(uri: Uri, content: String) {
    contentResolver.openOutputStream(uri)?.use { output ->
        output.write(content.toByteArray())
    }
}
```

## Document Provider

### Using DocumentProvider

```kotlin
fun openDocument(activity: Activity) {
    val intent = Intent(Intent.ACTION_OPEN_DOCUMENT).apply {
        addCategory(Intent.CATEGORY_OPENABLE)
        type = "*/*"
        putExtra(Intent.EXTRA_MIME_TYPES, arrayOf("image/*", "video/*"))
    }
    activity.startActivityForResult(intent, REQUEST_CODE)
}
```

### Take Persistent URI Permission

```kotlin
override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {
    if (resultCode == Activity.RESULT_OK) {
        data?.data?.let { uri ->
            // Take persistent permission
            val takeFlags = Intent.FLAG_GRANT_READ_URI_PERMISSION or
                          Intent.FLAG_GRANT_WRITE_URI_PERMISSION
            contentResolver.takePersistableUriPermission(uri, takeFlags)
            
            // Save URI for later use
            saveUri(uri)
        }
    }
}
```

## Best Practices

### Practice 1: Use Internal Storage for Private Data

```kotlin
// GOOD: Internal storage for private data
val file = File(context.filesDir, "private.txt")
file.writeText("Private content")

// BAD: External storage for private data
val file = File(Environment.getExternalStorageDirectory(), "private.txt")
```

### Practice 2: Use MediaStore for Media Files

```kotlin
// GOOD: MediaStore for images
val contentValues = ContentValues().apply {
    put(MediaStore.Images.Media.DISPLAY_NAME, "image.jpg")
    put(MediaStore.Images.Media.MIME_TYPE, "image/jpeg")
}
val uri = contentResolver.insert(
    MediaStore.Images.Media.EXTERNAL_CONTENT_URI,
    contentValues
)

// BAD: Direct file access (Android 10+)
val file = File(Environment.getExternalStorageDirectory(), "image.jpg")
```

### Practice 3: Handle Scoped Storage

```kotlin
// GOOD: Handle scoped storage
if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
    // Use MediaStore
    saveImageToMediaStore(context, bitmap, "image.jpg")
} else {
    // Use external storage
    saveImageToExternalStorage(context, bitmap, "image.jpg")
}
```

### Practice 4: Use FileProvider for File Sharing

```kotlin
// GOOD: FileProvider for sharing
val file = File(context.filesDir, "shared.txt")
val uri = FileProvider.getUriForFile(
    context,
    "com.example.fileprovider",
    file
)

// BAD: File URI
val uri = Uri.fromFile(file) // Not secure
```

## Real-World Examples

### Complete File Manager

```kotlin
class FileManager(private val context: Context) {
    // Internal storage
    fun saveToInternalStorage(filename: String, content: String) {
        context.openFileOutput(filename, Context.MODE_PRIVATE).use {
            it.write(content.toByteArray())
        }
    }
    
    fun readFromInternalStorage(filename: String): String? {
        return try {
            context.openFileInput(filename).use {
                it.bufferedReader().readText()
        } catch (e: FileNotFoundException) {
            null
        }
    }
    
    // MediaStore (Android 10+)
    @RequiresApi(Build.VERSION_CODES.Q)
    fun saveImageToMediaStore(bitmap: Bitmap, displayName: String): Uri? {
        val contentValues = ContentValues().apply {
            put(MediaStore.Images.Media.DISPLAY_NAME, displayName)
            put(MediaStore.Images.Media.MIME_TYPE, "image/jpeg")
            put(MediaStore.Images.Media.RELATIVE_PATH, Environment.DIRECTORY_PICTURES)
        }
        
        val uri = context.contentResolver.insert(
            MediaStore.Images.Media.EXTERNAL_CONTENT_URI,
            contentValues
        )
        
        uri?.let {
            context.contentResolver.openOutputStream(it)?.use { output ->
                bitmap.compress(Bitmap.CompressFormat.JPEG, 90, output)
            }
        }
        
        return uri
    }
    
    // File picker
    fun pickFile(activity: Activity) {
        val intent = Intent(Intent.ACTION_OPEN_DOCUMENT).apply {
            addCategory(Intent.CATEGORY_OPENABLE)
            type = "*/*"
        }
        activity.startActivityForResult(intent, REQUEST_CODE)
    }
}
```

## Common Pitfalls

### Problem: Not Handling Scoped Storage

```kotlin
// BAD: Direct file access (Android 10+)
val file = File(Environment.getExternalStorageDirectory(), "file.txt")

// GOOD: Use MediaStore or app-specific directory
if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
    // Use MediaStore
} else {
    // Use external storage
}
```

### Problem: Not Using FileProvider

```kotlin
// BAD: File URI
val uri = Uri.fromFile(file)

// GOOD: FileProvider
val uri = FileProvider.getUriForFile(context, authority, file)
```

## Quiz

1. What is scoped storage?
   - **A)** Unlimited storage access
   - **B)** Restricted access to external storage (Android 10+)
   - **C)** Internal storage only
   - **D)** Nothing

2. What API should you use for media files on Android 10+?
   - **A)** Direct file access
   - **B)** MediaStore API
   - **C)** SharedPreferences
   - **D)** Room

3. What is FileProvider used for?
   - **A)** Database access
   - **B)** Secure file sharing
   - **C)** Network files
   - **D)** Nothing

**Answers:**
1. **B** - Scoped storage restricts direct access to external storage on Android 10+, requiring use of MediaStore API or app-specific directories
2. **B** - Use MediaStore API for accessing media files (images, videos, audio) on Android 10+ with scoped storage
3. **B** - FileProvider provides secure file sharing using content:// URIs instead of file:// URIs

## Next Steps

- [Android Permissions](./27.%20Android%20Permissions.md) - Storage permissions
- [Content Providers](./38.%20Content%20Providers.md) - FileProvider
- [Room Database & Data Persistence](../beginners/04.%20Room%20Database%20%26%20Data%20Persistence.md) - Database storage

