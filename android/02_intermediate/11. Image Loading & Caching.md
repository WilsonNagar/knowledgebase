---
number: 11
title: "Image Loading & Caching"
slug: "image-loading-caching"
level: "intermediate"
tags: ["images", "glide", "coil", "caching", "performance"]
prerequisites: ["jetpack-compose-ui-components-theming"]
estimated_minutes: 80
contributors: []
diagrams: []
examples: []
canonical_id: "android-intermediate-11"
---



# Image Loading & Caching

## Overview

Efficient image loading is crucial for Android app performance. This comprehensive guide covers image loading libraries (Glide and Coil), caching strategies, image transformations, placeholders, error handling, memory management, and best practices for loading and displaying images in Android applications.

## Table of Contents

1. [Image Loading Overview](#overview)
2. [Coil Library](#coil)
3. [Glide Library](#glide)
4. [Caching Strategies](#caching)
5. [Image Transformations](#transformations)
6. [Placeholders & Error Handling](#placeholders)
7. [Memory Management](#memory)
8. [Best Practices](#best-practices)

## Image Loading Overview

### Why Use Image Loading Libraries?

**Challenges**:
- **Memory**: Large images consume memory
- **Performance**: Loading blocks UI thread
- **Network**: Network requests are slow
- **Caching**: Need efficient caching

**Solutions**: Image loading libraries handle these automatically

### Popular Libraries

**Coil**: Kotlin-first, Coroutines-based
**Glide**: Mature, feature-rich
**Picasso**: Simple, lightweight

**Recommendation**: Use Coil for new Kotlin projects, Glide for Java/mixed projects

## Coil Library

### What is Coil?

**Coil**: Kotlin Image Loading Library

**Features**:
- **Kotlin-first**: Built for Kotlin
- **Coroutines**: Coroutines-based
- **Compose**: Native Compose support
- **Performance**: Fast and efficient

### Coil Setup

**Dependencies**:
```kotlin
dependencies {
    // Coil
    implementation("io.coil-kt:coil:2.5.0")
    implementation("io.coil-kt:coil-compose:2.5.0")
}
```

### Basic Usage

**In Views**:
```kotlin
imageView.load("https://example.com/image.jpg")
```

**In Compose**:
```kotlin
AsyncImage(
    model = "https://example.com/image.jpg",
    contentDescription = "Image"
)
```

### Advanced Usage

```kotlin
AsyncImage(
    model = ImageRequest.Builder(context)
        .data("https://example.com/image.jpg")
        .crossfade(true)
        .build(),
    contentDescription = "Image",
    modifier = Modifier.size(200.dp),
    contentScale = ContentScale.Crop,
    placeholder = painterResource(R.drawable.placeholder),
    error = painterResource(R.drawable.error),
    onSuccess = { success ->
        // Image loaded successfully
    },
    onError = { error ->
        // Handle error
    }
)
```

### Coil with Transformations

```kotlin
AsyncImage(
    model = ImageRequest.Builder(context)
        .data("https://example.com/image.jpg")
        .transformations(
            CircleCropTransformation(),
            RoundedCornersTransformation(16f)
        )
        .build(),
    contentDescription = "Image"
)
```

## Glide Library

### What is Glide?

**Glide**: Fast and efficient image loading library

**Features**:
- **Mature**: Well-established
- **Feature-rich**: Many features
- **Java/Kotlin**: Works with both
- **Performance**: Optimized for performance

### Glide Setup

**Dependencies**:
```kotlin
dependencies {
    implementation("com.github.bumptech.glide:glide:4.16.0")
    kapt("com.github.bumptech.glide:compiler:4.16.0")
}
```

### Basic Usage

```kotlin
Glide.with(context)
    .load("https://example.com/image.jpg")
    .into(imageView)
```

### Advanced Usage

```kotlin
Glide.with(context)
    .load("https://example.com/image.jpg")
    .placeholder(R.drawable.placeholder)
    .error(R.drawable.error)
    .centerCrop()
    .circleCrop()
    .into(imageView)
```

### Glide with Transformations

```kotlin
Glide.with(context)
    .load("https://example.com/image.jpg")
    .transform(
        RoundedCorners(16),
        CircleCrop()
    )
    .into(imageView)
```

## Caching Strategies

### Coil Caching

**Automatic Caching**: Coil caches automatically

**Cache Types**:
- **Memory Cache**: Fast, limited size
- **Disk Cache**: Slower, larger size

**Configuration**:
```kotlin
val imageLoader = ImageLoader.Builder(context)
    .memoryCache {
        MemoryCache.Builder(context)
            .maxSizePercent(0.25)
            .build()
    }
    .diskCache {
        DiskCache.Builder()
            .directory(context.cacheDir.resolve("image_cache"))
            .maxSizePercent(0.02)
            .build()
    }
    .build()

// Use custom ImageLoader
AsyncImage(
    model = "https://example.com/image.jpg",
    imageLoader = imageLoader,
    contentDescription = "Image"
)
```

### Glide Caching

**Automatic Caching**: Glide caches automatically

**Skip Cache**:
```kotlin
Glide.with(context)
    .load("https://example.com/image.jpg")
    .skipMemoryCache(true) // Skip memory cache
    .diskCacheStrategy(DiskCacheStrategy.NONE) // Skip disk cache
    .into(imageView)
```

**Cache Only**:
```kotlin
Glide.with(context)
    .load("https://example.com/image.jpg")
    .onlyRetrieveFromCache(true) // Only from cache
    .into(imageView)
```

## Image Transformations

### Coil Transformations

**Circle Crop**:
```kotlin
AsyncImage(
    model = ImageRequest.Builder(context)
        .data(imageUrl)
        .transformations(CircleCropTransformation())
        .build(),
    contentDescription = "Image"
)
```

**Rounded Corners**:
```kotlin
AsyncImage(
    model = ImageRequest.Builder(context)
        .data(imageUrl)
        .transformations(RoundedCornersTransformation(16f))
        .build(),
    contentDescription = "Image"
)
```

**Blur**:
```kotlin
AsyncImage(
    model = ImageRequest.Builder(context)
        .data(imageUrl)
        .transformations(BlurTransformation(context, 10f))
        .build(),
    contentDescription = "Image"
)
```

### Glide Transformations

**Circle Crop**:
```kotlin
Glide.with(context)
    .load(imageUrl)
    .circleCrop()
    .into(imageView)
```

**Rounded Corners**:
```kotlin
Glide.with(context)
    .load(imageUrl)
    .transform(RoundedCorners(16))
    .into(imageView)
```

**Custom Transformation**:
```kotlin
class CustomTransformation : Transformation<Bitmap> {
    override fun transform(
        context: Context,
        resource: Resource<Bitmap>,
        outWidth: Int,
        outHeight: Int
    ): Resource<Bitmap> {
        // Custom transformation logic
        return resource
    }
    
    override fun updateDiskCacheKey(messageDigest: MessageDigest) {
        messageDigest.update("custom".toByteArray())
    }
}
```

## Placeholders & Error Handling

### Coil Placeholders

```kotlin
AsyncImage(
    model = imageUrl,
    contentDescription = "Image",
    placeholder = painterResource(R.drawable.placeholder),
    error = painterResource(R.drawable.error),
    onError = { error ->
        // Handle error
    }
)
```

### Glide Placeholders

```kotlin
Glide.with(context)
    .load(imageUrl)
    .placeholder(R.drawable.placeholder)
    .error(R.drawable.error)
    .fallback(R.drawable.fallback)
    .into(imageView)
```

### Loading States

```kotlin
@Composable
fun ImageWithLoadingState(imageUrl: String) {
    val imageLoader = rememberImageLoader()
    val imageState = rememberAsyncImagePainter(
        model = ImageRequest.Builder(LocalContext.current)
            .data(imageUrl)
            .build(),
        imageLoader = imageLoader
    ).state
    
    when {
        imageState is ImagePainter.State.Loading -> {
            CircularProgressIndicator()
        }
        imageState is ImagePainter.State.Error -> {
            Icon(
                imageVector = Icons.Default.Error,
                contentDescription = "Error"
            )
        }
        else -> {
            Image(
                painter = imageState.painter,
                contentDescription = "Image"
            )
        }
    }
}
```

## Memory Management

### Coil Memory Management

**Automatic**: Coil manages memory automatically

**Configuration**:
```kotlin
val imageLoader = ImageLoader.Builder(context)
    .memoryCache {
        MemoryCache.Builder(context)
            .maxSizePercent(0.25) // 25% of available memory
            .build()
    }
    .build()
```

### Glide Memory Management

**Automatic**: Glide manages memory automatically

**Clear Memory**:
```kotlin
Glide.get(context).clearMemory()
```

**Clear Disk Cache**:
```kotlin
Glide.get(context).clearDiskCache()
```

### Bitmap Optimization

```kotlin
// Coil automatically optimizes bitmaps
// No manual optimization needed

// Glide automatically optimizes bitmaps
// Configure if needed
Glide.with(context)
    .load(imageUrl)
    .override(800, 600) // Resize before loading
    .into(imageView)
```

## Best Practices

### Practice 1: Use Appropriate Library

```kotlin
// GOOD: Use Coil for Kotlin/Compose projects
AsyncImage(model = imageUrl, contentDescription = "Image")

// GOOD: Use Glide for Java/mixed projects
Glide.with(context).load(imageUrl).into(imageView)
```

### Practice 2: Provide Placeholders

```kotlin
// GOOD: Provide placeholder
AsyncImage(
    model = imageUrl,
    placeholder = painterResource(R.drawable.placeholder),
    contentDescription = "Image"
)

// BAD: No placeholder
AsyncImage(model = imageUrl, contentDescription = "Image")
```

### Practice 3: Handle Errors

```kotlin
// GOOD: Handle errors
AsyncImage(
    model = imageUrl,
    error = painterResource(R.drawable.error),
    onError = { error ->
        // Log error
    },
    contentDescription = "Image"
)

// BAD: No error handling
AsyncImage(model = imageUrl, contentDescription = "Image")
```

### Practice 4: Use Appropriate Size

```kotlin
// GOOD: Resize before loading
AsyncImage(
    model = ImageRequest.Builder(context)
        .data(imageUrl)
        .size(Size(800, 600)) // Resize
        .build(),
    contentDescription = "Image"
)

// BAD: Load full-size image
AsyncImage(model = imageUrl, contentDescription = "Image")
```

### Practice 5: Clear Cache When Needed

```kotlin
// GOOD: Clear cache when user logs out
fun clearImageCache() {
    Coil.imageLoader(context).memoryCache?.clear()
    Glide.get(context).clearMemory()
}
```

## Real-World Examples

### Complete Image Loading Manager

```kotlin
class ImageLoadingManager(
    private val context: Context
) {
    private val coilImageLoader = ImageLoader.Builder(context)
        .memoryCache {
            MemoryCache.Builder(context)
                .maxSizePercent(0.25)
                .build()
        }
        .diskCache {
            DiskCache.Builder()
                .directory(context.cacheDir.resolve("image_cache"))
                .maxSizePercent(0.02)
                .build()
        }
        .build()
    
    @Composable
    fun LoadImage(
        imageUrl: String,
        contentDescription: String,
        modifier: Modifier = Modifier,
        placeholder: Painter? = null,
        error: Painter? = null
    ) {
        AsyncImage(
            model = ImageRequest.Builder(context)
                .data(imageUrl)
                .crossfade(true)
                .build(),
            contentDescription = contentDescription,
            imageLoader = coilImageLoader,
            modifier = modifier,
            placeholder = placeholder ?: painterResource(R.drawable.placeholder),
            error = error ?: painterResource(R.drawable.error),
            contentScale = ContentScale.Crop
        )
    }
    
    @Composable
    fun LoadCircularImage(
        imageUrl: String,
        contentDescription: String,
        size: Dp = 64.dp
    ) {
        AsyncImage(
            model = ImageRequest.Builder(context)
                .data(imageUrl)
                .transformations(CircleCropTransformation())
                .build(),
            contentDescription = contentDescription,
            imageLoader = coilImageLoader,
            modifier = Modifier.size(size),
            placeholder = painterResource(R.drawable.placeholder_circle),
            error = painterResource(R.drawable.error_circle),
            contentScale = ContentScale.Crop
        )
    }
    
    fun clearCache() {
        coilImageLoader.memoryCache?.clear()
    }
}
```

## Common Pitfalls

### Problem: Not Providing Placeholders

```kotlin
// BAD: No placeholder
AsyncImage(model = imageUrl, contentDescription = "Image")

// GOOD: Provide placeholder
AsyncImage(
    model = imageUrl,
    placeholder = painterResource(R.drawable.placeholder),
    contentDescription = "Image"
)
```

### Problem: Loading Large Images

```kotlin
// BAD: Load full-size image
AsyncImage(model = imageUrl, contentDescription = "Image")

// GOOD: Resize before loading
AsyncImage(
    model = ImageRequest.Builder(context)
        .data(imageUrl)
        .size(Size(800, 600))
        .build(),
    contentDescription = "Image"
)
```

## Quiz

1. What is Coil?
   - **A)** Image loading library for Java
   - **B)** Kotlin-first image loading library
   - **C)** Database library
   - **D)** Nothing

2. What should you always provide for images?
   - **A)** Size
   - **B)** Placeholder
   - **C)** Transformations
   - **D)** Nothing

3. How do image loading libraries help?
   - **A)** Automatic caching and memory management
   - **B)** Manual caching
   - **C)** No caching
   - **D)** Nothing

**Answers:**
1. **B** - Coil is a Kotlin-first image loading library built with Coroutines and Compose support
2. **B** - Always provide placeholders to show while images are loading
3. **A** - Image loading libraries automatically handle caching, memory management, and network requests

## Next Steps

- [Jetpack Compose UI Components & Theming](./26.%20Jetpack%20Compose%20UI%20Components%20%26%20Theming.md) - UI components
- [Performance Profiling & Memory Leaks](../advanced/21.%20Performance%20Profiling%20%26%20Memory%20Leaks.md) - Memory optimization
- [Android GC & Memory Management](../advanced/28.%20Android%20GC%20%26%20Memory%20Management.md) - Memory management

