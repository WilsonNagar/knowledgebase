---
number: 25
title: "Networking & API Integration"
slug: "networking-api-integration"
level: "intermediate"
tags: ["networking", "retrofit", "okhttp", "api", "rest", "http"]
prerequisites: ["dependency-injection-hilt", "kotlin-coroutines-basics"]
estimated_minutes: 120
contributors: []
diagrams: []
examples: []
canonical_id: "android-25"
---

# Networking & API Integration

## Overview

Networking is fundamental to modern Android applications. This comprehensive guide covers Retrofit for REST API calls, OkHttp for HTTP client configuration, interceptors, error handling, authentication, request/response logging, and best practices for building robust networking layers in Android apps.

## Table of Contents

1. [Networking Overview](#overview)
2. [Retrofit Setup](#retrofit-setup)
3. [OkHttp Configuration](#okhttp-configuration)
4. [API Service Definition](#api-service)
5. [Request & Response Handling](#request-response)
6. [Interceptors](#interceptors)
7. [Error Handling](#error-handling)
8. [Authentication](#authentication)
9. [Request Logging](#logging)
10. [Testing](#testing)
11. [Best Practices](#best-practices)

## Networking Overview

### What is Retrofit?

**Retrofit**: Type-safe HTTP client for Android and Java

**Built on**: OkHttp

**Purpose**: Simplify REST API calls

### Why Retrofit?

**Benefits**:
- **Type-safe**: Compile-time safety
- **Simple**: Easy to use
- **Powerful**: Supports many features
- **Well-maintained**: Active development

### Architecture

```
App → Retrofit → OkHttp → Network
```

**Retrofit**: Converts Java/Kotlin interfaces to HTTP calls
**OkHttp**: Handles HTTP requests/responses

## Retrofit Setup

### Dependencies

**build.gradle.kts**:
```kotlin
dependencies {
    // Retrofit
    implementation("com.squareup.retrofit2:retrofit:2.9.0")
    implementation("com.squareup.retrofit2:converter-gson:2.9.0")
    
    // OkHttp
    implementation("com.squareup.okhttp3:okhttp:4.12.0")
    implementation("com.squareup.okhttp3:logging-interceptor:4.12.0")
    
    // Coroutines support
    implementation("org.jetbrains.kotlinx:kotlinx-coroutines-android:1.7.3")
}
```

### Basic Setup

```kotlin
val retrofit = Retrofit.Builder()
    .baseUrl("https://api.example.com/")
    .addConverterFactory(GsonConverterFactory.create())
    .build()

val apiService = retrofit.create(ApiService::class.java)
```

### With Hilt

```kotlin
@Module
@InstallIn(SingletonComponent::class)
object NetworkModule {
    @Provides
    @Singleton
    fun provideOkHttpClient(): OkHttpClient {
        return OkHttpClient.Builder()
            .connectTimeout(30, TimeUnit.SECONDS)
            .readTimeout(30, TimeUnit.SECONDS)
            .writeTimeout(30, TimeUnit.SECONDS)
            .build()
    }
    
    @Provides
    @Singleton
    fun provideRetrofit(okHttpClient: OkHttpClient): Retrofit {
        return Retrofit.Builder()
            .baseUrl("https://api.example.com/")
            .client(okHttpClient)
            .addConverterFactory(GsonConverterFactory.create())
            .build()
    }
    
    @Provides
    @Singleton
    fun provideApiService(retrofit: Retrofit): ApiService {
        return retrofit.create(ApiService::class.java)
    }
}
```

## OkHttp Configuration

### Basic Configuration

```kotlin
val okHttpClient = OkHttpClient.Builder()
    .connectTimeout(30, TimeUnit.SECONDS)
    .readTimeout(30, TimeUnit.SECONDS)
    .writeTimeout(30, TimeUnit.SECONDS)
    .build()
```

### Advanced Configuration

```kotlin
val okHttpClient = OkHttpClient.Builder()
    .connectTimeout(30, TimeUnit.SECONDS)
    .readTimeout(30, TimeUnit.SECONDS)
    .writeTimeout(30, TimeUnit.SECONDS)
    .retryOnConnectionFailure(true)
    .connectionPool(ConnectionPool(10, 5, TimeUnit.MINUTES))
    .addInterceptor(HttpLoggingInterceptor().apply {
        level = HttpLoggingInterceptor.Level.BODY
    })
    .build()
```

### Connection Pool

```kotlin
val connectionPool = ConnectionPool(
    maxIdleConnections = 10,      // Max idle connections
    keepAliveDuration = 5,        // Keep alive time
    timeUnit = TimeUnit.MINUTES
)

val okHttpClient = OkHttpClient.Builder()
    .connectionPool(connectionPool)
    .build()
```

## API Service Definition

### Basic GET Request

```kotlin
interface ApiService {
    @GET("users/{id}")
    suspend fun getUser(@Path("id") userId: Int): User
    
    @GET("users")
    suspend fun getUsers(): List<User>
}
```

### Query Parameters

```kotlin
interface ApiService {
    @GET("users")
    suspend fun getUsers(
        @Query("page") page: Int,
        @Query("limit") limit: Int = 20
    ): List<User>
    
    @GET("search")
    suspend fun search(
        @QueryMap queryMap: Map<String, String>
    ): SearchResults
}
```

### POST Request

```kotlin
interface ApiService {
    @POST("users")
    suspend fun createUser(@Body user: User): User
    
    @POST("users/{id}")
    suspend fun updateUser(
        @Path("id") userId: Int,
        @Body user: User
    ): User
}
```

### PUT/PATCH/DELETE

```kotlin
interface ApiService {
    @PUT("users/{id}")
    suspend fun updateUser(
        @Path("id") userId: Int,
        @Body user: User
    ): User
    
    @PATCH("users/{id}")
    suspend fun patchUser(
        @Path("id") userId: Int,
        @Body user: User
    ): User
    
    @DELETE("users/{id}")
    suspend fun deleteUser(@Path("id") userId: Int): Response<Unit>
}
```

### Headers

```kotlin
interface ApiService {
    @GET("users")
    @Headers("Accept: application/json")
    suspend fun getUsers(): List<User>
    
    @GET("users/{id}")
    suspend fun getUser(
        @Path("id") userId: Int,
        @Header("Authorization") token: String
    ): User
    
    @GET("users")
    suspend fun getUsers(
        @HeaderMap headers: Map<String, String>
    ): List<User>
}
```

### Multipart

```kotlin
interface ApiService {
    @Multipart
    @POST("upload")
    suspend fun uploadFile(
        @Part file: MultipartBody.Part,
        @Part("description") description: RequestBody
    ): UploadResponse
}
```

### Form Data

```kotlin
interface ApiService {
    @FormUrlEncoded
    @POST("login")
    suspend fun login(
        @Field("username") username: String,
        @Field("password") password: String
    ): LoginResponse
}
```

## Request & Response Handling

### Using Coroutines

```kotlin
class UserRepository(
    private val apiService: ApiService
) {
    suspend fun getUser(id: Int): Result<User> {
        return try {
            val user = apiService.getUser(id)
            Result.success(user)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
}
```

### Response Wrapper

```kotlin
data class ApiResponse<T>(
    val data: T?,
    val message: String?,
    val success: Boolean
)

interface ApiService {
    @GET("users/{id}")
    suspend fun getUser(@Path("id") userId: Int): ApiResponse<User>
}
```

### Custom Response Type

```kotlin
sealed class ApiResult<out T> {
    data class Success<T>(val data: T) : ApiResult<T>()
    data class Error(val exception: Throwable) : ApiResult<Nothing>()
    object Loading : ApiResult<Nothing>()
}
```

## Interceptors

### What are Interceptors?

**Interceptor**: Intercepts requests/responses

**Types**:
- **Application Interceptor**: Outside retry/redirect
- **Network Interceptor**: Between retry/redirect

### Logging Interceptor

```kotlin
val loggingInterceptor = HttpLoggingInterceptor().apply {
    level = if (BuildConfig.DEBUG) {
        HttpLoggingInterceptor.Level.BODY
    } else {
        HttpLoggingInterceptor.Level.NONE
    }
}

val okHttpClient = OkHttpClient.Builder()
    .addInterceptor(loggingInterceptor)
    .build()
```

### Auth Interceptor

```kotlin
class AuthInterceptor(
    private val tokenManager: TokenManager
) : Interceptor {
    override fun intercept(chain: Interceptor.Chain): Response {
        val request = chain.request()
        
        val token = tokenManager.getToken()
        val authenticatedRequest = request.newBuilder()
            .header("Authorization", "Bearer $token")
            .build()
        
        return chain.proceed(authenticatedRequest)
    }
}

val okHttpClient = OkHttpClient.Builder()
    .addInterceptor(AuthInterceptor(tokenManager))
    .build()
```

### Retry Interceptor

```kotlin
class RetryInterceptor(
    private val maxRetries: Int = 3
) : Interceptor {
    override fun intercept(chain: Interceptor.Chain): Response {
        var request = chain.request()
        var response = chain.proceed(request)
        var retryCount = 0
        
        while (!response.isSuccessful && retryCount < maxRetries) {
            retryCount++
            response.close()
            response = chain.proceed(request)
        }
        
        return response
    }
}
```

### Error Interceptor

```kotlin
class ErrorInterceptor : Interceptor {
    override fun intercept(chain: Interceptor.Chain): Response {
        val response = chain.proceed(chain.request())
        
        when (response.code) {
            401 -> {
                // Handle unauthorized
                throw UnauthorizedException()
            }
            403 -> {
                // Handle forbidden
                throw ForbiddenException()
            }
            404 -> {
                // Handle not found
                throw NotFoundException()
            }
            500 -> {
                // Handle server error
                throw ServerException()
            }
        }
        
        return response
    }
}
```

## Error Handling

### Exception Handling

```kotlin
sealed class NetworkException : Exception() {
    object NoInternetException : NetworkException()
    object TimeoutException : NetworkException()
    object ServerException : NetworkException()
    data class HttpException(val code: Int, val message: String) : NetworkException()
    data class UnknownException(val throwable: Throwable) : NetworkException()
}

class NetworkErrorHandler {
    fun handleError(throwable: Throwable): NetworkException {
        return when (throwable) {
            is SocketTimeoutException -> NetworkException.TimeoutException
            is UnknownHostException -> NetworkException.NoInternetException
            is HttpException -> NetworkException.HttpException(
                throwable.code(),
                throwable.message()
            )
            else -> NetworkException.UnknownException(throwable)
        }
    }
}
```

### Repository Pattern

```kotlin
class UserRepository(
    private val apiService: ApiService,
    private val errorHandler: NetworkErrorHandler
) {
    suspend fun getUser(id: Int): Result<User> {
        return try {
            val user = apiService.getUser(id)
            Result.success(user)
        } catch (e: Exception) {
            val networkException = errorHandler.handleError(e)
            Result.failure(networkException)
        }
    }
}
```

### ViewModel Error Handling

```kotlin
class UserViewModel(
    private val repository: UserRepository
) : ViewModel() {
    private val _uiState = MutableStateFlow(UserUiState())
    val uiState: StateFlow<UserUiState> = _uiState.asStateFlow()
    
    fun loadUser(id: Int) {
        viewModelScope.launch {
            _uiState.value = _uiState.value.copy(isLoading = true)
            
            repository.getUser(id)
                .onSuccess { user ->
                    _uiState.value = _uiState.value.copy(
                        user = user,
                        isLoading = false
                    )
                }
                .onFailure { exception ->
                    _uiState.value = _uiState.value.copy(
                        error = exception.message,
                        isLoading = false
                    )
                }
        }
    }
}
```

## Authentication

### Bearer Token

```kotlin
class AuthInterceptor(
    private val tokenManager: TokenManager
) : Interceptor {
    override fun intercept(chain: Interceptor.Chain): Response {
        val token = tokenManager.getToken()
        
        val request = chain.request().newBuilder()
            .header("Authorization", "Bearer $token")
            .build()
        
        return chain.proceed(request)
    }
}
```

### Token Refresh

```kotlin
class TokenRefreshInterceptor(
    private val tokenManager: TokenManager,
    private val authApi: AuthApiService
) : Interceptor {
    override fun intercept(chain: Interceptor.Chain): Response {
        val request = chain.request()
        var response = chain.proceed(request)
        
        if (response.code == 401) {
            // Token expired, refresh it
            val newToken = refreshToken()
            
            if (newToken != null) {
                // Retry with new token
                val newRequest = request.newBuilder()
                    .header("Authorization", "Bearer $newToken")
                    .build()
                response.close()
                response = chain.proceed(newRequest)
            }
        }
        
        return response
    }
    
    private suspend fun refreshToken(): String? {
        return try {
            val refreshToken = tokenManager.getRefreshToken()
            val response = authApi.refreshToken(refreshToken)
            tokenManager.saveToken(response.accessToken)
            response.accessToken
        } catch (e: Exception) {
            null
        }
    }
}
```

### OAuth 2.0

```kotlin
class OAuthInterceptor(
    private val tokenManager: TokenManager
) : Interceptor {
    override fun intercept(chain: Interceptor.Chain): Response {
        val request = chain.request()
        
        // Add OAuth token
        val token = tokenManager.getAccessToken()
        val authenticatedRequest = request.newBuilder()
            .header("Authorization", "Bearer $token")
            .build()
        
        var response = chain.proceed(authenticatedRequest)
        
        // Handle token refresh
        if (response.code == 401) {
            response.close()
            val newToken = refreshAccessToken()
            
            if (newToken != null) {
                val newRequest = request.newBuilder()
                    .header("Authorization", "Bearer $newToken")
                    .build()
                response = chain.proceed(newRequest)
            }
        }
        
        return response
    }
    
    private suspend fun refreshAccessToken(): String? {
        // Implement OAuth refresh flow
        return null
    }
}
```

## Request Logging

### Logging Interceptor

```kotlin
val loggingInterceptor = HttpLoggingInterceptor { message ->
    Log.d("Network", message)
}.apply {
    level = HttpLoggingInterceptor.Level.BODY
}
```

### Custom Logger

```kotlin
class CustomLoggingInterceptor : Interceptor {
    override fun intercept(chain: Interceptor.Chain): Response {
        val request = chain.request()
        
        val requestBody = request.body
        val requestLog = StringBuilder()
        requestLog.append("REQUEST: ${request.method} ${request.url}\n")
        
        if (requestBody != null) {
            val buffer = Buffer()
            requestBody.writeTo(buffer)
            requestLog.append("Body: ${buffer.readUtf8()}\n")
        }
        
        Log.d("Network", requestLog.toString())
        
        val response = chain.proceed(request)
        val responseLog = StringBuilder()
        responseLog.append("RESPONSE: ${response.code} ${response.message}\n")
        
        val responseBody = response.body
        if (responseBody != null) {
            val source = responseBody.source()
            source.request(Long.MAX_VALUE)
            val buffer = source.buffer
            responseLog.append("Body: ${buffer.clone().readUtf8()}\n")
        }
        
        Log.d("Network", responseLog.toString())
        
        return response
    }
}
```

## Testing

### Mock API Service

```kotlin
class MockApiService : ApiService {
    override suspend fun getUser(id: Int): User {
        return User(id = id, name = "Test User")
    }
    
    override suspend fun getUsers(): List<User> {
        return listOf(
            User(id = 1, name = "User 1"),
            User(id = 2, name = "User 2")
        )
    }
}
```

### MockWebServer

```kotlin
class ApiServiceTest {
    private lateinit var mockWebServer: MockWebServer
    private lateinit var apiService: ApiService
    
    @Before
    fun setup() {
        mockWebServer = MockWebServer()
        mockWebServer.start()
        
        val retrofit = Retrofit.Builder()
            .baseUrl(mockWebServer.url("/"))
            .addConverterFactory(GsonConverterFactory.create())
            .build()
        
        apiService = retrofit.create(ApiService::class.java)
    }
    
    @Test
    fun testGetUser() = runTest {
        // Mock response
        val mockResponse = MockResponse()
            .setResponseCode(200)
            .setBody("""{"id":1,"name":"John"}""")
        
        mockWebServer.enqueue(mockResponse)
        
        // Call API
        val user = apiService.getUser(1)
        
        // Verify
        assertEquals(1, user.id)
        assertEquals("John", user.name)
    }
    
    @After
    fun tearDown() {
        mockWebServer.shutdown()
    }
}
```

## Best Practices

### Practice 1: Use Repository Pattern

```kotlin
// GOOD: Repository abstracts API
class UserRepository(
    private val apiService: ApiService
) {
    suspend fun getUser(id: Int): Result<User>
}

// BAD: Direct API calls in ViewModel
class UserViewModel {
    fun loadUser() {
        apiService.getUser(1) // Don't do this
    }
}
```

### Practice 2: Handle Errors Properly

```kotlin
// GOOD: Proper error handling
suspend fun getUser(id: Int): Result<User> {
    return try {
        val user = apiService.getUser(id)
        Result.success(user)
    } catch (e: Exception) {
        Result.failure(handleError(e))
    }
}
```

### Practice 3: Use Timeouts

```kotlin
// GOOD: Set appropriate timeouts
val okHttpClient = OkHttpClient.Builder()
    .connectTimeout(30, TimeUnit.SECONDS)
    .readTimeout(30, TimeUnit.SECONDS)
    .build()
```

### Practice 4: Cache Responses

```kotlin
// GOOD: Cache responses
val cache = Cache(
    directory = File(context.cacheDir, "http_cache"),
    maxSize = 10 * 1024 * 1024 // 10 MB
)

val okHttpClient = OkHttpClient.Builder()
    .cache(cache)
    .build()
```

### Practice 5: Use Interceptors Wisely

```kotlin
// GOOD: Add interceptors in order
val okHttpClient = OkHttpClient.Builder()
    .addInterceptor(loggingInterceptor)      // First
    .addInterceptor(authInterceptor)         // Second
    .addNetworkInterceptor(cacheInterceptor) // Network layer
    .build()
```

## Real-World Examples

### Complete Setup Example

```kotlin
@Module
@InstallIn(SingletonComponent::class)
object NetworkModule {
    @Provides
    @Singleton
    fun provideOkHttpClient(
        @ApplicationContext context: Context,
        tokenManager: TokenManager
    ): OkHttpClient {
        val cache = Cache(
            directory = File(context.cacheDir, "http_cache"),
            maxSize = 10 * 1024 * 1024
        )
        
        return OkHttpClient.Builder()
            .cache(cache)
            .connectTimeout(30, TimeUnit.SECONDS)
            .readTimeout(30, TimeUnit.SECONDS)
            .addInterceptor(AuthInterceptor(tokenManager))
            .addInterceptor(HttpLoggingInterceptor().apply {
                level = if (BuildConfig.DEBUG) {
                    HttpLoggingInterceptor.Level.BODY
                } else {
                    HttpLoggingInterceptor.Level.NONE
                }
            })
            .build()
    }
    
    @Provides
    @Singleton
    fun provideRetrofit(okHttpClient: OkHttpClient): Retrofit {
        return Retrofit.Builder()
            .baseUrl("https://api.example.com/")
            .client(okHttpClient)
            .addConverterFactory(GsonConverterFactory.create())
            .build()
    }
    
    @Provides
    @Singleton
    fun provideApiService(retrofit: Retrofit): ApiService {
        return retrofit.create(ApiService::class.java)
    }
}
```

## Common Pitfalls

### Problem: Missing Base URL

```kotlin
// BAD: Missing base URL
val retrofit = Retrofit.Builder()
    .build()

// GOOD: Provide base URL
val retrofit = Retrofit.Builder()
    .baseUrl("https://api.example.com/")
    .build()
```

### Problem: Not Handling Errors

```kotlin
// BAD: No error handling
suspend fun getUser(id: Int): User {
    return apiService.getUser(id) // May throw
}

// GOOD: Handle errors
suspend fun getUser(id: Int): Result<User> {
    return try {
        Result.success(apiService.getUser(id))
    } catch (e: Exception) {
        Result.failure(e)
    }
}
```

## Quiz

1. What is Retrofit built on?
   - **A)** Volley
   - **B)** OkHttp
   - **C)** HttpURLConnection
   - **D)** Apache HttpClient

2. What annotation is used for GET requests?
   - **A)** @POST
   - **B)** @GET
   - **C)** @PUT
   - **D)** @DELETE

3. What is the purpose of interceptors?
   - **A)** To intercept and modify requests/responses
   - **B)** To handle errors
   - **C)** To cache responses
   - **D)** Nothing

**Answers:**
1. **B** - Retrofit is built on OkHttp, which handles the actual HTTP requests
2. **B** - @GET annotation is used for GET requests in Retrofit
3. **A** - Interceptors intercept and can modify requests and responses before they're sent/received

## Next Steps

- [Dependency Injection with Hilt](./24.%20Dependency%20Injection%20with%20Hilt.md) - DI setup
- [Kotlin Coroutines Basics](../beginners/03.%20Kotlin%20Coroutines%20Basics.md) - Async operations
- [Building Offline-First Apps](../advanced/22.%20Building%20Offline-First%20Apps.md) - Network + local storage

