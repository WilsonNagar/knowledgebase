---
number: 10
title: "Paging Library"
slug: "paging-library"
level: "intermediate"
tags: ["paging", "recyclerview", "lazy-loading", "data-loading"]
prerequisites: ["room-database-data-persistence", "kotlin-flow-complete-guide"]
estimated_minutes: 90
contributors: []
diagrams: []
examples: []
canonical_id: "android-intermediate-10"
---



# Paging Library

## Overview

The Paging Library helps you load and display large datasets efficiently. This comprehensive guide covers Paging 3 setup, loading data from different sources (network, database, both), using Paging with Room, Flow/StateFlow integration, error handling, loading states, and best practices for implementing pagination in Android apps.

## Table of Contents

1. [What is Paging?](#what-is-paging)
2. [Paging 3 Setup](#setup)
3. [PagingSource](#pagingsource)
4. [RemoteMediator](#remotemediator)
5. [Paging with Room](#paging-room)
6. [Paging with Flow](#paging-flow)
7. [UI Integration](#ui-integration)
8. [Error Handling](#error-handling)
9. [Loading States](#loading-states)
10. [Best Practices](#best-practices)

## What is Paging?

### Definition

**Paging**: Load and display data in chunks (pages)

**Benefits**:
- **Performance**: Load only what's needed
- **Memory**: Efficient memory usage
- **Network**: Reduce network requests
- **UX**: Smooth scrolling experience

### Why Paging?

**Without Paging**:
- Load all data at once
- High memory usage
- Slow initial load
- Poor performance

**With Paging**:
- Load data in pages
- Low memory usage
- Fast initial load
- Smooth performance

## Paging 3 Setup

### Dependencies

```kotlin
dependencies {
    // Paging
    implementation("androidx.paging:paging-runtime:3.2.1")
    implementation("androidx.paging:paging-compose:3.2.1")
    
    // Room with Paging
    implementation("androidx.room:room-paging:2.6.1")
    
    // Retrofit (for network)
    implementation("com.squareup.retrofit2:retrofit:2.9.0")
}
```

### Basic Concepts

**PagingSource**: Defines how to load data
**Pager**: Configures paging behavior
**PagingData**: Observable stream of paged data
**PagingDataAdapter**: Adapter for RecyclerView

## PagingSource

### Creating PagingSource

```kotlin
class UserPagingSource(
    private val apiService: ApiService
) : PagingSource<Int, User>() {
    override suspend fun load(params: LoadParams<Int>): LoadResult<Int, User> {
        return try {
            val page = params.key ?: 1
            val pageSize = params.loadSize
            
            val response = apiService.getUsers(page, pageSize)
            
            LoadResult.Page(
                data = response.users,
                prevKey = if (page == 1) null else page - 1,
                nextKey = if (response.users.size < pageSize) null else page + 1
            )
        } catch (e: Exception) {
            LoadResult.Error(e)
        }
    }
    
    override fun getRefreshKey(state: PagingState<Int, User>): Int? {
        return state.anchorPosition?.let { anchorPosition ->
            val anchorPage = state.closestPageToPosition(anchorPosition)
            anchorPage?.prevKey?.plus(1) ?: anchorPage?.nextKey?.minus(1)
        }
    }
}
```

### Using PagingSource

```kotlin
val pagingFlow = Pager(
    config = PagingConfig(pageSize = 20),
    pagingSourceFactory = { UserPagingSource(apiService) }
).flow
```

## RemoteMediator

### What is RemoteMediator?

**RemoteMediator**: Load from network and database

**Purpose**: Combine remote and local data sources

**Use Case**: Offline-first apps with network sync

### Creating RemoteMediator

```kotlin
@OptIn(ExperimentalPagingApi::class)
class UserRemoteMediator(
    private val apiService: ApiService,
    private val database: AppDatabase
) : RemoteMediator<Int, UserEntity>() {
    
    override suspend fun load(
        loadType: LoadType,
        state: PagingState<Int, UserEntity>
    ): MediatorResult {
        return try {
            val page = when (loadType) {
                LoadType.REFRESH -> 1
                LoadType.PREPEND -> return MediatorResult.Success(endOfPaginationReached = true)
                LoadType.APPEND -> {
                    val lastItem = state.lastItemOrNull()
                    if (lastItem == null) {
                        1
                    } else {
                        (lastItem.id / state.config.pageSize) + 1
                    }
                }
            }
            
            val response = apiService.getUsers(page, state.config.pageSize)
            
            database.withTransaction {
                if (loadType == LoadType.REFRESH) {
                    database.userDao().clearAll()
                }
                database.userDao().insertAll(response.users.map { it.toEntity() })
            }
            
            MediatorResult.Success(
                endOfPaginationReached = response.users.isEmpty()
            )
        } catch (e: Exception) {
            MediatorResult.Error(e)
        }
    }
    
    override suspend fun initialize(): InitializeAction {
        return InitializeAction.LAUNCH_INITIAL_REFRESH
    }
}
```

### Using RemoteMediator

```kotlin
val pagingFlow = Pager(
    config = PagingConfig(pageSize = 20),
    remoteMediator = UserRemoteMediator(apiService, database),
    pagingSourceFactory = { database.userDao().getUsersPaged() }
).flow
```

## Paging with Room

### Room Paging Setup

**Dao**:
```kotlin
@Dao
interface UserDao {
    @Query("SELECT * FROM users ORDER BY id ASC")
    fun getUsersPaged(): PagingSource<Int, UserEntity>
    
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertAll(users: List<UserEntity>)
    
    @Query("DELETE FROM users")
    suspend fun clearAll()
}
```

### Using Room Paging

```kotlin
val pagingFlow = Pager(
    config = PagingConfig(pageSize = 20),
    pagingSourceFactory = { database.userDao().getUsersPaged() }
).flow
```

## Paging with Flow

### Collecting PagingData

```kotlin
class UserViewModel(
    private val repository: UserRepository
) : ViewModel() {
    val users: Flow<PagingData<User>> = Pager(
        config = PagingConfig(pageSize = 20),
        pagingSourceFactory = { repository.getUsersPagingSource() }
    ).flow
        .cachedIn(viewModelScope)
}
```

### Using in Compose

```kotlin
@Composable
fun UserListScreen(viewModel: UserViewModel = viewModel()) {
    val users = viewModel.users.collectAsLazyPagingItems()
    
    LazyColumn {
        items(
            count = users.itemCount,
            key = { index -> users[index]?.id ?: index }
        ) { index ->
            val user = users[index]
            if (user != null) {
                UserItem(user = user)
            } else {
                // Loading placeholder
                LoadingItem()
            }
        }
        
        // Loading indicator
        if (users.loadState.append is LoadState.Loading) {
            item {
                CircularProgressIndicator(
                    modifier = Modifier.fillMaxWidth()
                )
            }
        }
        
        // Error state
        if (users.loadState.append is LoadState.Error) {
            item {
                ErrorItem(
                    message = "Error loading users",
                    onRetry = { users.retry() }
                )
            }
        }
    }
}
```

## UI Integration

### RecyclerView Integration

```kotlin
class UserAdapter : PagingDataAdapter<User, UserViewHolder>(UserDiffCallback()) {
    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): UserViewHolder {
        return UserViewHolder(
            LayoutInflater.from(parent.context)
                .inflate(R.layout.item_user, parent, false)
        )
    }
    
    override fun onBindViewHolder(holder: UserViewHolder, position: Int) {
        val user = getItem(position)
        user?.let { holder.bind(it) }
    }
}

class UserDiffCallback : DiffUtil.ItemCallback<User>() {
    override fun areItemsTheSame(oldItem: User, newItem: User): Boolean {
        return oldItem.id == newItem.id
    }
    
    override fun areContentsTheSame(oldItem: User, newItem: User): Boolean {
        return oldItem == newItem
    }
}

// Usage
lifecycleScope.launch {
    viewModel.users.collectLatest { pagingData ->
        adapter.submitData(pagingData)
    }
}
```

### Compose Integration

```kotlin
@Composable
fun UserListScreen(viewModel: UserViewModel = viewModel()) {
    val users = viewModel.users.collectAsLazyPagingItems()
    
    LazyColumn(
        modifier = Modifier.fillMaxSize(),
        contentPadding = PaddingValues(16.dp),
        verticalArrangement = Arrangement.spacedBy(8.dp)
    ) {
        items(
            count = users.itemCount,
            key = { index -> users[index]?.id ?: index }
        ) { index ->
            val user = users[index]
            if (user != null) {
                UserItem(user = user)
            } else {
                UserItemPlaceholder()
            }
        }
        
        // Loading footer
        item {
            if (users.loadState.append is LoadState.Loading) {
                CircularProgressIndicator(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(16.dp)
                )
            }
        }
        
        // Error footer
        item {
            if (users.loadState.append is LoadState.Error) {
                ErrorItem(
                    message = "Failed to load",
                    onRetry = { users.retry() }
                )
            }
        }
    }
}
```

## Error Handling

### Handling Load Errors

```kotlin
@Composable
fun UserListScreen(viewModel: UserViewModel = viewModel()) {
    val users = viewModel.users.collectAsLazyPagingItems()
    
    // Handle initial load error
    when (val loadState = users.loadState.refresh) {
        is LoadState.Error -> {
            ErrorScreen(
                message = loadState.error.message ?: "Error loading users",
                onRetry = { users.retry() }
            )
        }
        is LoadState.Loading -> {
            LoadingScreen()
        }
        else -> {
            UserListContent(users = users)
        }
    }
}
```

### Retry Logic

```kotlin
fun retryLoad() {
    users.retry()
}

fun refresh() {
    users.refresh()
}
```

## Loading States

### Load State Types

**Refresh**: Initial load
**Append**: Loading more items
**Prepend**: Loading previous items

### Handling Load States

```kotlin
@Composable
fun UserListContent(users: LazyPagingItems<User>) {
    LazyColumn {
        items(users.itemCount) { index ->
            val user = users[index]
            if (user != null) {
                UserItem(user = user)
            }
        }
        
        // Append loading
        if (users.loadState.append is LoadState.Loading) {
            item {
                LoadingFooter()
            }
        }
        
        // Append error
        if (users.loadState.append is LoadState.Error) {
            item {
                ErrorFooter(
                    onRetry = { users.retry() }
                )
            }
        }
    }
}
```

## Best Practices

### Practice 1: Use Appropriate Page Size

```kotlin
// GOOD: Reasonable page size
PagingConfig(pageSize = 20)

// BAD: Too small or too large
PagingConfig(pageSize = 1) // Too many requests
PagingConfig(pageSize = 1000) // Too much data
```

### Practice 2: Cache PagingData

```kotlin
// GOOD: Cache in ViewModel scope
val users: Flow<PagingData<User>> = Pager(...)
    .flow
    .cachedIn(viewModelScope)

// BAD: Don't cache
val users: Flow<PagingData<User>> = Pager(...).flow
```

### Practice 3: Handle Errors

```kotlin
// GOOD: Handle errors
when (users.loadState.refresh) {
    is LoadState.Error -> {
        ErrorScreen(onRetry = { users.retry() })
    }
    else -> ContentScreen()
}

// BAD: Ignore errors
// No error handling
```

### Practice 4: Use DiffUtil

```kotlin
// GOOD: Implement DiffUtil
class UserDiffCallback : DiffUtil.ItemCallback<User>() {
    override fun areItemsTheSame(oldItem: User, newItem: User) =
        oldItem.id == newItem.id
    
    override fun areContentsTheSame(oldItem: User, newItem: User) =
        oldItem == newItem
}

// BAD: No DiffUtil
// Inefficient updates
```

## Real-World Examples

### Complete Paging Setup

```kotlin
// Repository
class UserRepository(
    private val apiService: ApiService,
    private val database: AppDatabase
) {
    fun getUsersPagingFlow(): Flow<PagingData<User>> {
        return Pager(
            config = PagingConfig(
                pageSize = 20,
                enablePlaceholders = false
            ),
            remoteMediator = UserRemoteMediator(apiService, database),
            pagingSourceFactory = { database.userDao().getUsersPaged() }
        ).flow.map { pagingData ->
            pagingData.map { it.toUser() }
        }
    }
}

// ViewModel
class UserViewModel(
    private val repository: UserRepository
) : ViewModel() {
    val users: Flow<PagingData<User>> = repository
        .getUsersPagingFlow()
        .cachedIn(viewModelScope)
}

// Compose Screen
@Composable
fun UserListScreen(viewModel: UserViewModel = viewModel()) {
    val users = viewModel.users.collectAsLazyPagingItems()
    
    when (val refreshState = users.loadState.refresh) {
        is LoadState.Loading -> {
            LoadingScreen()
        }
        is LoadState.Error -> {
            ErrorScreen(
                message = refreshState.error.message ?: "Error",
                onRetry = { users.retry() }
            )
        }
        else -> {
            LazyColumn {
                items(
                    count = users.itemCount,
                    key = { index -> users[index]?.id ?: index }
                ) { index ->
                    val user = users[index]
                    if (user != null) {
                        UserItem(user = user)
                    }
                }
                
                if (users.loadState.append is LoadState.Loading) {
                    item { LoadingFooter() }
                }
            }
        }
    }
}
```

## Common Pitfalls

### Problem: Not Caching PagingData

```kotlin
// BAD: Not cached
val users = Pager(...).flow

// GOOD: Cached
val users = Pager(...).flow.cachedIn(viewModelScope)
```

### Problem: Wrong Page Size

```kotlin
// BAD: Too small
PagingConfig(pageSize = 1)

// GOOD: Reasonable size
PagingConfig(pageSize = 20)
```

## Quiz

1. What is the purpose of Paging Library?
   - **A)** Load all data at once
   - **B)** Load data in chunks (pages)
   - **C)** Store data
   - **D)** Nothing

2. What is RemoteMediator used for?
   - **A)** Local data only
   - **B)** Network data only
   - **C)** Combine network and local data
   - **D)** Nothing

3. How do you cache PagingData?
   - **A)** Don't cache
   - **B)** Use cachedIn()
   - **C)** Store in variable
   - **D)** Nothing

**Answers:**
1. **B** - Paging Library loads data in chunks (pages) for efficient memory usage and performance
2. **C** - RemoteMediator combines network and local data sources for offline-first apps
3. **B** - Use `cachedIn(viewModelScope)` to cache PagingData in the ViewModel scope

## Next Steps

- [Room Database & Data Persistence](../beginners/04.%20Room%20Database%20%26%20Data%20Persistence.md) - Database setup
- [Kotlin Flow - Complete Guide](./22.%20Kotlin%20Flow%20-%20Complete%20Guide.md) - Flow integration
- [Building Offline-First Apps](../advanced/22.%20Building%20Offline-First%20Apps.md) - Offline-first patterns

