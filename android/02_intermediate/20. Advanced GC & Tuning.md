---
number: 20
title: "Advanced GC & Tuning"
slug: "advanced-gc-tuning"
level: "intermediate"
tags: ["gc", "tuning", "performance", "algorithms", "optimization"]
prerequisites: ["garbage-collection-fundamentals"]
estimated_minutes: 90
contributors: []
diagrams: []
examples: []
canonical_id: "android-20"
---

# Advanced GC & Tuning

## Overview

This advanced guide dives deep into garbage collection algorithms, tuning strategies, and performance optimization. You'll learn about different GC algorithms (Serial, Parallel, G1, ZGC), how to tune them for your application, and advanced techniques for minimizing GC impact on application performance.

## Table of Contents

1. [GC Algorithm Types](#gc-algorithms)
2. [Serial GC](#serial-gc)
3. [Parallel GC](#parallel-gc)
4. [Concurrent Mark Sweep (CMS)](#cms-gc)
5. [G1 Garbage Collector](#g1-gc)
6. [ZGC & Shenandoah](#modern-gc)
7. [GC Tuning Deep Dive](#gc-tuning)
8. [Performance Metrics](#performance-metrics)
9. [Advanced Optimization](#advanced-optimization)

## GC Algorithm Types

### Classification

**By Threading**:
- **Serial**: Single-threaded
- **Parallel**: Multi-threaded

**By Concurrency**:
- **Stop-the-World**: Pauses application
- **Concurrent**: Runs alongside application

**By Collection Strategy**:
- **Copying**: Copy live objects
- **Mark-Sweep**: Mark and free
- **Mark-Compact**: Mark, move, compact
- **Generational**: Different strategies per generation

## Serial GC

### How It Works

**Single-threaded, Stop-the-World**

```
1. Stop all application threads
2. Single GC thread marks live objects
3. Single GC thread sweeps garbage
4. Resume application threads
```

### Characteristics

- **Simple**: Easy to understand
- **Low overhead**: Minimal GC overhead
- **Long pauses**: Blocks application
- **Single core**: Uses one CPU core

### When to Use

- **Small applications**: <100MB heap
- **Single-core devices**: Embedded systems
- **Client applications**: Desktop apps with small heaps
- **Not for Android**: Too slow for mobile

### Tuning

```bash
# Enable Serial GC
-XX:+UseSerialGC

# Heap size
-Xms512m -Xmx1g

# GC logging
-XX:+PrintGC
-XX:+PrintGCDetails
```

## Parallel GC

### How It Works

**Multi-threaded, Stop-the-World**

```
1. Stop all application threads
2. Multiple GC threads mark live objects (parallel)
3. Multiple GC threads sweep garbage (parallel)
4. Resume application threads
```

### Characteristics

- **Faster**: Uses multiple CPU cores
- **Throughput-focused**: Maximizes application throughput
- **Longer pauses**: Still stop-the-world
- **Multi-core**: Utilizes multiple cores

### When to Use

- **Server applications**: Throughput is priority
- **Batch processing**: Can tolerate pauses
- **Multi-core systems**: Has multiple cores available
- **Not ideal for Android**: Pauses too long for UI

### Tuning

```bash
# Enable Parallel GC
-XX:+UseParallelGC

# Number of GC threads
-XX:ParallelGCThreads=4

# Adaptive sizing
-XX:+UseAdaptiveSizePolicy

# Target pause time (hint, not guarantee)
-XX:MaxGCPauseMillis=200
```

### Parallel GC Variants

**Parallel Old GC**:
- Uses parallel algorithm for Old Generation
- Better for large Old Generation
- `-XX:+UseParallelOldGC`

## Concurrent Mark Sweep (CMS)

### How It Works

**Concurrent Marking, Stop-the-World Sweeping**

```
Phase 1: Initial Mark (STW, short)
  ↓
Phase 2: Concurrent Mark (concurrent)
  ↓
Phase 3: Remark (STW, short)
  ↓
Phase 4: Concurrent Sweep (concurrent)
```

### Characteristics

- **Low pause times**: Most work is concurrent
- **CPU overhead**: Uses CPU during concurrent phases
- **Fragmentation**: Can cause heap fragmentation
- **Deprecated**: Removed in Java 14+

### When CMS Was Used

- **Low-latency requirements**: Needed short pauses
- **Large heaps**: Could handle fragmentation
- **Replaced by**: G1 GC (better alternative)

## G1 Garbage Collector

### How It Works

**Generational, Incremental, Low-Latency**

```
Heap divided into regions (typically 1-32MB each)

Young Collection:
1. Collect Young regions (Eden + Survivors)
2. Concurrent marking of Old regions
3. Incremental evacuation

Mixed Collection:
1. Collect Young + some Old regions
2. Based on marking information
3. Evacuate live objects
```

### Key Features

**1. Region-based**:
```
Heap = Collection of equal-sized regions
Each region can be Eden, Survivor, or Old
```

**2. Incremental Collection**:
```
Collects regions incrementally
Shorter, more predictable pauses
```

**3. Concurrent Marking**:
```
Marks live objects concurrently
Reduces pause times
```

**4. Evacuation**:
```
Moves live objects to other regions
Compacts heap incrementally
```

### When to Use

- **Large heaps**: >4GB recommended
- **Low pause requirements**: <200ms target
- **Modern applications**: Default in Java 9+
- **Android**: Not available (uses ART GC)

### Tuning

```bash
# Enable G1 GC
-XX:+UseG1GC

# Target pause time
-XX:MaxGCPauseMillis=200

# Heap region size
-XX:G1HeapRegionSize=16m

# Concurrent marking threads
-XX:ConcGCThreads=2

# Initiating heap occupancy
-XX:InitiatingHeapOccupancyPercent=45
```

## ZGC & Shenandoah

### ZGC (Z Garbage Collector)

**Ultra-low latency GC**

**Characteristics**:
- **Pause times**: <10ms (even with large heaps)
- **Concurrent**: Most work concurrent
- **Scalable**: Handles multi-terabyte heaps
- **Java 11+**: Available in newer Java versions

**How It Works**:
```
1. Concurrent marking
2. Concurrent relocation
3. Load barriers (colored pointers)
4. Reference processing concurrent
```

**When to Use**:
- **Very large heaps**: >32GB
- **Ultra-low latency**: <10ms requirements
- **Not for Android**: Not available in ART

### Shenandoah GC

**Similar to ZGC, different implementation**

**Characteristics**:
- **Low pause times**: <10ms
- **Concurrent evacuation**: Moves objects concurrently
- **Brooks pointers**: Forwarding pointers technique
- **OpenJDK**: Available in OpenJDK

## GC Tuning Deep Dive

### Understanding Your Application

**1. Object Allocation Rate**:
```
How many objects created per second?
High rate → More frequent GC
```

**2. Object Lifetime**:
```
How long do objects live?
Short-lived → Young Gen focus
Long-lived → Old Gen focus
```

**3. Heap Usage Pattern**:
```
How does heap usage grow?
Steady growth → Normal
Spikes → Need larger heap
```

### Tuning Strategy

#### Step 1: Measure Baseline

```bash
# Enable GC logging
-XX:+PrintGC
-XX:+PrintGCDetails
-XX:+PrintGCTimeStamps
-Xlog:gc*:file=gc.log

# Run application
# Analyze GC log
```

#### Step 2: Identify Issues

**High GC Frequency**:
```
Problem: GC happens too often
Solution: Increase heap size or Young Gen size
```

**Long Pause Times**:
```
Problem: GC pauses too long
Solution: Use concurrent GC (G1) or reduce heap
```

**High Memory Usage**:
```
Problem: Heap usage stays high
Solution: Check for memory leaks, reduce allocations
```

#### Step 3: Apply Tuning

```bash
# Example: Tune for low latency
-XX:+UseG1GC
-XX:MaxGCPauseMillis=100
-XX:G1HeapRegionSize=16m
-XX:InitiatingHeapOccupancyPercent=40

# Example: Tune for throughput
-XX:+UseParallelGC
-XX:ParallelGCThreads=8
-XX:+UseAdaptiveSizePolicy
```

### Heap Size Tuning

**Initial Heap (-Xms)**:
```bash
-Xms2g  # Start with 2GB
# Should match -Xmx to avoid resizing
```

**Maximum Heap (-Xmx)**:
```bash
-Xmx4g  # Maximum 4GB
# Too small → Frequent GC, OOM
# Too large → Long GC pauses
```

**Guidelines**:
- **Start with**: 25% of available RAM
- **Monitor**: Adjust based on GC frequency
- **Match**: Set -Xms = -Xmx (avoid resizing)

### Generation Sizing

**Young Generation**:
```bash
# Ratio-based
-XX:NewRatio=2  # Old:Young = 2:1

# Fixed size
-XX:NewSize=512m
-XX:MaxNewSize=1g
```

**Survivor Spaces**:
```bash
# Survivor ratio
-XX:SurvivorRatio=8  # Eden:Survivor = 8:1
```

**Tuning Guidelines**:
- **Larger Young Gen**: Fewer promotions, more Minor GCs
- **Smaller Young Gen**: More promotions, fewer Minor GCs
- **Balance**: Find sweet spot for your workload

## Performance Metrics

### Key Metrics

**1. Throughput**:
```
Throughput = (Total Time - GC Time) / Total Time
Target: > 95%
```

**2. Pause Time**:
```
Average Pause: Average GC pause duration
P99 Pause: 99th percentile pause time
Target: < 100ms average, < 200ms P99
```

**3. GC Frequency**:
```
Minor GC: Every few seconds (normal)
Major GC: Every few minutes (normal)
Full GC: Rare (problem if frequent)
```

**4. Heap Usage**:
```
Used Heap: Currently allocated
Free Heap: Available memory
Target: 70-80% usage (headroom for spikes)
```

### GC Log Analysis

**Understanding GC Logs**:
```
[GC (Allocation Failure) [PSYoungGen: 512K->64K(1024K)] 
 512K->200K(2048K), 0.0012345 secs]

Breakdown:
- GC: Minor GC
- Allocation Failure: Triggered by allocation
- PSYoungGen: Parallel Scavenge Young Gen
- 512K->64K: Used before -> Used after
- (1024K): Total size
- 512K->200K: Heap before -> Heap after
- 0.0012345 secs: Pause time
```

**What to Look For**:
- **Frequent GC**: Increase heap or reduce allocations
- **Long pauses**: Use concurrent GC or reduce heap
- **High promotion rate**: Increase Young Gen size
- **Full GC**: Problem! Check for memory leaks

## Advanced Optimization

### Reducing Allocations

**1. Object Pooling**:
```kotlin
class StringBuilderPool {
    private val pool = mutableListOf<StringBuilder>()
    
    fun acquire(): StringBuilder {
        return if (pool.isNotEmpty()) {
            pool.removeAt(pool.size - 1).clear()
        } else {
            StringBuilder()
        }
    }
    
    fun release(sb: StringBuilder) {
        if (pool.size < 10) { // Limit pool size
            pool.add(sb)
        }
    }
}
```

**2. Primitive Collections**:
```kotlin
// BAD: Boxed primitives
val list = mutableListOf<Int>() // Integer objects

// GOOD: Primitive arrays
val array = IntArray(1000) // Primitive ints, no boxing
```

**3. String Optimization**:
```kotlin
// BAD: Many string allocations
val result = str1 + str2 + str3 // Creates intermediate strings

// GOOD: StringBuilder
val result = buildString {
    append(str1)
    append(str2)
    append(str3)
}
```

### Memory Layout Optimization

**Object Field Ordering**:
```kotlin
// BAD: Wastes memory due to alignment
class BadLayout {
    val byte: Byte    // 1 byte + 7 padding
    val long: Long    // 8 bytes
    val int: Int      // 4 bytes + 4 padding
} // Total: 24 bytes

// GOOD: Better packing
class GoodLayout {
    val long: Long    // 8 bytes
    val int: Int      // 4 bytes
    val byte: Byte    // 1 byte + 3 padding
} // Total: 16 bytes
```

## Real-World Tuning Examples

### Example 1: Web Server Tuning

```bash
# High throughput, can tolerate pauses
-XX:+UseParallelGC
-XX:ParallelGCThreads=8
-Xms4g -Xmx4g
-XX:NewRatio=2
-XX:+UseAdaptiveSizePolicy
```

### Example 2: Real-Time Application Tuning

```bash
# Low latency, short pauses critical
-XX:+UseG1GC
-XX:MaxGCPauseMillis=50
-Xms2g -Xmx2g
-XX:G1HeapRegionSize=16m
-XX:InitiatingHeapOccupancyPercent=35
```

### Example 3: Memory-Constrained Tuning

```bash
# Limited memory, minimize footprint
-Xms512m -Xmx1g
-XX:NewRatio=3  # Smaller Young Gen
-XX:SurvivorRatio=8
-XX:+UseSerialGC  # Lower overhead
```

## Common Pitfalls

### Problem: Heap Too Small

**Symptoms**:
- Frequent Full GC
- OutOfMemoryError
- High GC overhead

**Solution**:
```bash
# Increase heap size
-Xmx4g  # Was 2g
```

### Problem: Heap Too Large

**Symptoms**:
- Long GC pauses
- High memory usage
- Slower overall performance

**Solution**:
```bash
# Reduce heap size
-Xmx2g  # Was 4g
# Or use G1 GC for better pause times
```

### Problem: Wrong GC Algorithm

**Symptoms**:
- Pauses too long for requirements
- Low throughput

**Solution**:
```bash
# Switch to appropriate GC
-XX:+UseG1GC  # For low latency
# Or
-XX:+UseParallelGC  # For throughput
```

## Quiz

1. What is the main advantage of G1 GC?
   - **A)** Highest throughput
   - **B)** Low pause times with large heaps
   - **C)** Lowest memory overhead
   - **D)** No pauses

2. When should you use Parallel GC?
   - **A)** Low latency requirements
   - **B)** Throughput-focused applications
   - **C)** Small heaps
   - **D)** Always

3. What does -XX:MaxGCPauseMillis control?
   - **A)** Maximum heap size
   - **B)** Target pause time (hint to GC)
   - **C)** GC frequency
   - **D)** Number of GC threads

**Answers:**
1. **B** - G1 GC provides low pause times even with large heaps through incremental collection
2. **B** - Parallel GC maximizes throughput, good for batch processing and servers
3. **B** - MaxGCPauseMillis is a target/hint to GC, not a hard guarantee

## Next Steps

- [Android GC & Memory Management](../03_advanced/28.%20Android%20GC%20%26%20Memory%20Management.md) - ART GC specifics
- [Performance Profiling & Memory Leaks](../03_advanced/21.%20Performance%20Profiling%20%26%20Memory%20Leaks.md) - Profiling techniques

