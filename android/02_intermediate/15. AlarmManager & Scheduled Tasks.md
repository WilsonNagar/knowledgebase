---
number: 15
title: "AlarmManager & Scheduled Tasks"
slug: "alarmmanager-scheduled-tasks"
level: "intermediate"
tags: ["alarmmanager", "scheduling", "alarms", "tasks"]
prerequisites: ["workmanager-background-tasks"]
estimated_minutes: 70
contributors: []
diagrams: []
examples: []
canonical_id: "android-intermediate-15"
---



# AlarmManager & Scheduled Tasks

## Overview

AlarmManager allows you to schedule tasks to run at specific times, even when your app is not running. This guide covers AlarmManager types, scheduling alarms, handling alarms, Doze mode considerations, and when to use AlarmManager vs WorkManager for scheduled tasks.

## Table of Contents

1. [What is AlarmManager?](#what-is-alarmmanager)
2. [Alarm Types](#alarm-types)
3. [Scheduling Alarms](#scheduling-alarms)
4. [Handling Alarms](#handling-alarms)
5. [Doze Mode Considerations](#doze-mode)
6. [AlarmManager vs WorkManager](#alarmmanager-vs-workmanager)
7. [Best Practices](#best-practices)

## What is AlarmManager?

### Definition

**AlarmManager**: System service for scheduling tasks

**Purpose**: Schedule tasks to run at specific times

**Characteristics**:
- **Precise**: Can schedule precise times
- **Wake Device**: Can wake device from sleep
- **System-Level**: System manages alarms
- **Persistent**: Survives app restart

### When to Use AlarmManager

**Use AlarmManager For**:
- **Precise Timing**: Exact time requirements
- **Wake Device**: Need to wake device
- **System Alarms**: System-level alarms
- **Legacy Code**: Maintaining existing code

**Prefer WorkManager For**:
- **Deferrable Work**: Can be delayed
- **Constraints**: Network, charging, etc.
- **Modern Apps**: New development

## Alarm Types

### 1. RTC (Real-Time Clock)

**RTC**: Uses wall clock time

**Characteristics**:
- **Wall Clock**: Uses device's wall clock
- **Time Zone**: Affected by time zone changes
- **Use Case**: Calendar events, reminders

### 2. RTC_WAKEUP

**RTC_WAKEUP**: Uses wall clock, wakes device

**Characteristics**:
- **Wake Device**: Wakes device from sleep
- **Wall Clock**: Uses device's wall clock
- **Use Case**: Alarms, reminders

### 3. ELAPSED_REALTIME

**ELAPSED_REALTIME**: Uses elapsed time since boot

**Characteristics**:
- **Elapsed Time**: Time since device boot
- **Not Wake**: Doesn't wake device
- **Use Case**: Relative time intervals

### 4. ELAPSED_REALTIME_WAKEUP

**ELAPSED_REALTIME_WAKEUP**: Uses elapsed time, wakes device

**Characteristics**:
- **Elapsed Time**: Time since device boot
- **Wake Device**: Wakes device from sleep
- **Use Case**: Relative alarms

## Scheduling Alarms

### Basic Alarm

```kotlin
fun scheduleAlarm(context: Context, triggerTime: Long) {
    val alarmManager = context.getSystemService(Context.ALARM_SERVICE) as AlarmManager
    val intent = Intent(context, AlarmReceiver::class.java)
    val pendingIntent = PendingIntent.getBroadcast(
        context,
        0,
        intent,
        PendingIntent.FLAG_IMMUTABLE
    )
    
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
        alarmManager.setExactAndAllowWhileIdle(
            AlarmManager.RTC_WAKEUP,
            triggerTime,
            pendingIntent
        )
    } else {
        alarmManager.setExact(
            AlarmManager.RTC_WAKEUP,
            triggerTime,
            pendingIntent
        )
    }
}
```

### Repeating Alarm

```kotlin
fun scheduleRepeatingAlarm(context: Context, intervalMillis: Long) {
    val alarmManager = context.getSystemService(Context.ALARM_SERVICE) as AlarmManager
    val intent = Intent(context, AlarmReceiver::class.java)
    val pendingIntent = PendingIntent.getBroadcast(
        context,
        0,
        intent,
        PendingIntent.FLAG_IMMUTABLE
    )
    
    alarmManager.setRepeating(
        AlarmManager.RTC_WAKEUP,
        System.currentTimeMillis(),
        intervalMillis,
        pendingIntent
    )
}
```

### Exact Alarm (Android 12+)

```kotlin
fun scheduleExactAlarm(context: Context, triggerTime: Long) {
    val alarmManager = context.getSystemService(Context.ALARM_SERVICE) as AlarmManager
    
    // Check if exact alarms allowed
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
        if (!alarmManager.canScheduleExactAlarms()) {
            // Request permission
            val intent = Intent(Settings.ACTION_REQUEST_SCHEDULE_EXACT_ALARM)
            context.startActivity(intent)
            return
        }
    }
    
    val intent = Intent(context, AlarmReceiver::class.java)
    val pendingIntent = PendingIntent.getBroadcast(
        context,
        0,
        intent,
        PendingIntent.FLAG_IMMUTABLE
    )
    
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
        alarmManager.setExactAndAllowWhileIdle(
            AlarmManager.RTC_WAKEUP,
            triggerTime,
            pendingIntent
        )
    } else {
        alarmManager.setExact(
            AlarmManager.RTC_WAKEUP,
            triggerTime,
            pendingIntent
        )
    }
}
```

## Handling Alarms

### BroadcastReceiver for Alarms

```kotlin
class AlarmReceiver : BroadcastReceiver() {
    override fun onReceive(context: Context, intent: Intent) {
        when (intent.action) {
            "ALARM_ACTION" -> {
                handleAlarm(context)
            }
        }
    }
    
    private fun handleAlarm(context: Context) {
        // Show notification
        showNotification(context)
        
        // Start service if needed
        val serviceIntent = Intent(context, AlarmService::class.java)
        ContextCompat.startForegroundService(context, serviceIntent)
    }
    
    private fun showNotification(context: Context) {
        val notification = NotificationCompat.Builder(context, "alarm_channel")
            .setContentTitle("Alarm")
            .setContentText("Alarm triggered")
            .setSmallIcon(R.drawable.ic_alarm)
            .build()
        
        val notificationManager = NotificationManagerCompat.from(context)
        notificationManager.notify(1, notification)
    }
}
```

### Register Receiver in Manifest

```xml
<receiver
    android:name=".AlarmReceiver"
    android:exported="false">
    <intent-filter>
        <action android:name="ALARM_ACTION" />
    </intent-filter>
</receiver>
```

### Canceling Alarms

```kotlin
fun cancelAlarm(context: Context) {
    val alarmManager = context.getSystemService(Context.ALARM_SERVICE) as AlarmManager
    val intent = Intent(context, AlarmReceiver::class.java)
    val pendingIntent = PendingIntent.getBroadcast(
        context,
        0,
        intent,
        PendingIntent.FLAG_IMMUTABLE
    )
    
    alarmManager.cancel(pendingIntent)
}
```

## Doze Mode Considerations

### Doze Mode Impact

**Doze Mode**: Restricts background activity

**Impact on Alarms**:
- **RTC_WAKEUP**: Still works (with restrictions)
- **ELAPSED_REALTIME_WAKEUP**: Still works (with restrictions)
- **Non-wakeup**: Deferred until maintenance window

### setExactAndAllowWhileIdle

```kotlin
// Allows alarm even in Doze mode (with restrictions)
if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
    alarmManager.setExactAndAllowWhileIdle(
        AlarmManager.RTC_WAKEUP,
        triggerTime,
        pendingIntent
    )
}
```

**Restrictions**:
- **Rate Limited**: Max one per app per 9 minutes
- **Batching**: May be batched with other alarms

## AlarmManager vs WorkManager

### When to Use AlarmManager

**Use AlarmManager For**:
- **Precise Timing**: Exact time requirements
- **Wake Device**: Need to wake device
- **System Alarms**: System-level functionality
- **Legacy Support**: Maintaining existing code

### When to Use WorkManager

**Use WorkManager For**:
- **Deferrable Work**: Can be delayed
- **Constraints**: Network, charging, etc.
- **Modern Apps**: New development
- **Battery Efficient**: Better battery usage

### Comparison

**AlarmManager**:
- Precise timing
- Can wake device
- System-level
- Less battery efficient

**WorkManager**:
- Flexible timing
- Constraint-based
- App-level
- Battery efficient

## Best Practices

### Practice 1: Use WorkManager When Possible

```kotlin
// GOOD: WorkManager for most cases
WorkManager.getInstance(context)
    .enqueue(OneTimeWorkRequestBuilder<MyWorker>()
        .setInitialDelay(5, TimeUnit.MINUTES)
        .build())

// BAD: AlarmManager when WorkManager would work
scheduleAlarm(context, System.currentTimeMillis() + 5 * 60 * 1000)
```

### Practice 2: Request Exact Alarm Permission

```kotlin
// GOOD: Check and request permission
if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
    val alarmManager = getSystemService(AlarmManager::class.java)
    if (!alarmManager.canScheduleExactAlarms()) {
        val intent = Intent(Settings.ACTION_REQUEST_SCHEDULE_EXACT_ALARM)
        startActivity(intent)
    }
}

// BAD: Assume permission granted
alarmManager.setExact(...) // May fail
```

### Practice 3: Use Appropriate Alarm Type

```kotlin
// GOOD: Use RTC_WAKEUP for user-facing alarms
alarmManager.setExactAndAllowWhileIdle(
    AlarmManager.RTC_WAKEUP,
    triggerTime,
    pendingIntent
)

// BAD: Use ELAPSED_REALTIME for user-facing alarms
alarmManager.setExact(
    AlarmManager.ELAPSED_REALTIME_WAKEUP,
    triggerTime,
    pendingIntent
)
```

## Real-World Examples

### Alarm Manager Helper

```kotlin
class AlarmManagerHelper(private val context: Context) {
    private val alarmManager = context.getSystemService(Context.ALARM_SERVICE) as AlarmManager
    
    fun scheduleAlarm(triggerTime: Long, alarmId: Int) {
        val intent = Intent(context, AlarmReceiver::class.java).apply {
            putExtra("alarm_id", alarmId)
        }
        val pendingIntent = PendingIntent.getBroadcast(
            context,
            alarmId,
            intent,
            PendingIntent.FLAG_IMMUTABLE
        )
        
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
            alarmManager.setExactAndAllowWhileIdle(
                AlarmManager.RTC_WAKEUP,
                triggerTime,
                pendingIntent
            )
        } else {
            alarmManager.setExact(
                AlarmManager.RTC_WAKEUP,
                triggerTime,
                pendingIntent
            )
        }
    }
    
    fun cancelAlarm(alarmId: Int) {
        val intent = Intent(context, AlarmReceiver::class.java)
        val pendingIntent = PendingIntent.getBroadcast(
            context,
            alarmId,
            intent,
            PendingIntent.FLAG_IMMUTABLE
        )
        alarmManager.cancel(pendingIntent)
    }
    
    fun scheduleRepeatingAlarm(intervalMillis: Long, alarmId: Int) {
        val intent = Intent(context, AlarmReceiver::class.java).apply {
            putExtra("alarm_id", alarmId)
        }
        val pendingIntent = PendingIntent.getBroadcast(
            context,
            alarmId,
            intent,
            PendingIntent.FLAG_IMMUTABLE
        )
        
        alarmManager.setRepeating(
            AlarmManager.RTC_WAKEUP,
            System.currentTimeMillis(),
            intervalMillis,
            pendingIntent
        )
    }
}
```

## Common Pitfalls

### Problem: Not Handling Doze Mode

```kotlin
// BAD: May not work in Doze mode
alarmManager.setExact(
    AlarmManager.RTC_WAKEUP,
    triggerTime,
    pendingIntent
)

// GOOD: Handle Doze mode
if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
    alarmManager.setExactAndAllowWhileIdle(
        AlarmManager.RTC_WAKEUP,
        triggerTime,
        pendingIntent
    )
}
```

### Problem: Using AlarmManager When WorkManager Would Work

```kotlin
// BAD: AlarmManager for deferrable work
scheduleAlarm(context, System.currentTimeMillis() + delay)

// GOOD: WorkManager
WorkManager.getInstance(context)
    .enqueue(OneTimeWorkRequestBuilder<MyWorker>()
        .setInitialDelay(delay, TimeUnit.MILLISECONDS)
        .build())
```

## Quiz

1. What is AlarmManager used for?
   - **A)** Database operations
   - **B)** Scheduling tasks at specific times
   - **C)** Network requests
   - **D)** UI updates

2. When should you use WorkManager instead of AlarmManager?
   - **A)** Always
   - **B)** For deferrable work with constraints
   - **C)** Never
   - **D)** For precise timing

3. What alarm type wakes the device?
   - **A)** RTC
   - **B)** RTC_WAKEUP
   - **C)** ELAPSED_REALTIME
   - **D)** None

**Answers:**
1. **B** - AlarmManager schedules tasks to run at specific times, even when the app is not running
2. **B** - Use WorkManager for deferrable work with constraints, use AlarmManager for precise timing requirements
3. **B** - RTC_WAKEUP and ELAPSED_REALTIME_WAKEUP wake the device from sleep

## Next Steps

- [WorkManager & Background Tasks](./13.%20WorkManager%20%26%20Background%20Tasks.md) - Modern scheduling
- [Android Services - Complete Guide](./35.%20Android%20Services%20-%20Complete%20Guide.md) - Service integration
- [Android OS Internals - Power Management](../advanced/33.%20Android%20OS%20Internals%20-%20Power%20Management.md) - Doze mode

