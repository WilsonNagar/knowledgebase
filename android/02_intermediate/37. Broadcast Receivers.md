---
number: 37
title: "Broadcast Receivers"
slug: "broadcast-receivers"
level: "intermediate"
tags: ["broadcast-receiver", "broadcasts", "system-events", "intents"]
prerequisites: ["android-lifecycle-components"]
estimated_minutes: 70
contributors: []
diagrams: []
examples: []
canonical_id: "android-37"
---

# Broadcast Receivers

## Overview

Broadcast Receivers allow your app to respond to system-wide broadcast announcements and custom intents. This comprehensive guide covers system broadcasts, local broadcasts, implicit vs explicit broadcasts, registering receivers, handling broadcasts, and best practices for using Broadcast Receivers in modern Android development.

## Table of Contents

1. [What are Broadcast Receivers?](#what-are-broadcast-receivers)
2. [System Broadcasts](#system-broadcasts)
3. [Local Broadcasts](#local-broadcasts)
4. [Registering Receivers](#registering-receivers)
5. [Handling Broadcasts](#handling-broadcasts)
6. [Implicit vs Explicit Broadcasts](#implicit-explicit)
7. [Best Practices](#best-practices)

## What are Broadcast Receivers?

### Definition

**Broadcast Receiver**: Component that responds to broadcast messages

**Purpose**: React to system events or custom broadcasts

**Characteristics**:
- **Event-Driven**: Responds to events
- **Lightweight**: Simple event handlers
- **System Events**: React to system changes
- **Custom Events**: React to app events

### When to Use Broadcast Receivers

**Use For**:
- **System Events**: Boot, network changes, battery
- **Custom Events**: App-wide events
- **Legacy Code**: Maintaining existing code

**Prefer Alternatives For**:
- **App Events**: Use Flow/StateFlow
- **Component Communication**: Use callbacks/events
- **Modern Apps**: Prefer modern patterns

## System Broadcasts

### Common System Broadcasts

**Boot Completed**:
```kotlin
class BootReceiver : BroadcastReceiver() {
    override fun onReceive(context: Context, intent: Intent) {
        if (intent.action == Intent.ACTION_BOOT_COMPLETED) {
            // Initialize app after boot
            initializeApp(context)
        }
    }
}
```

**Network State Changed**:
```kotlin
class NetworkReceiver : BroadcastReceiver() {
    override fun onReceive(context: Context, intent: Intent) {
        val connectivityManager = context.getSystemService(
            Context.CONNECTIVITY_SERVICE
        ) as ConnectivityManager
        
        val network = connectivityManager.activeNetwork
        val capabilities = connectivityManager.getNetworkCapabilities(network)
        
        val isConnected = capabilities?.hasCapability(
            NetworkCapabilities.NET_CAPABILITY_INTERNET
        ) ?: false
        
        // Handle network state change
        handleNetworkChange(isConnected)
    }
}
```

**Battery Changed**:
```kotlin
class BatteryReceiver : BroadcastReceiver() {
    override fun onReceive(context: Context, intent: Intent) {
        val level = intent.getIntExtra(BatteryManager.EXTRA_LEVEL, -1)
        val scale = intent.getIntExtra(BatteryManager.EXTRA_SCALE, -1)
        val batteryPct = level * 100 / scale.toFloat()
        
        // Handle battery level change
        handleBatteryChange(batteryPct)
    }
}
```

**Airplane Mode Changed**:
```kotlin
class AirplaneModeReceiver : BroadcastReceiver() {
    override fun onReceive(context: Context, intent: Intent) {
        val isAirplaneModeOn = Settings.Global.getInt(
            context.contentResolver,
            Settings.Global.AIRPLANE_MODE_ON,
            0
        ) != 0
        
        // Handle airplane mode change
        handleAirplaneModeChange(isAirplaneModeOn)
    }
}
```

## Local Broadcasts

### What are Local Broadcasts?

**Local Broadcast**: Broadcast within app only

**Purpose**: App-internal communication

**Benefits**:
- **Secure**: Only app can receive
- **Efficient**: No system overhead
- **Simple**: Easy to use

### Sending Local Broadcast

```kotlin
fun sendLocalBroadcast(context: Context, action: String, data: String) {
    val intent = Intent(action).apply {
        putExtra("data", data)
    }
    LocalBroadcastManager.getInstance(context).sendBroadcast(intent)
}
```

### Receiving Local Broadcast

```kotlin
class LocalReceiver : BroadcastReceiver() {
    override fun onReceive(context: Context, intent: Intent) {
        when (intent.action) {
            "CUSTOM_ACTION" -> {
                val data = intent.getStringExtra("data")
                // Handle broadcast
            }
        }
    }
}

// Register
val receiver = LocalReceiver()
LocalBroadcastManager.getInstance(context).registerReceiver(
    receiver,
    IntentFilter("CUSTOM_ACTION")
)

// Unregister
LocalBroadcastManager.getInstance(context).unregisterReceiver(receiver)
```

## Registering Receivers

### Manifest Registration

**Static Registration**: Registered in manifest

```xml
<receiver
    android:name=".BootReceiver"
    android:enabled="true"
    android:exported="true">
    <intent-filter>
        <action android:name="android.intent.action.BOOT_COMPLETED" />
    </intent-filter>
</receiver>
```

**Use Cases**:
- Boot completed
- Package replaced
- System events that need to be received even when app is closed

### Programmatic Registration

**Dynamic Registration**: Registered in code

```kotlin
class MainActivity : AppCompatActivity() {
    private val networkReceiver = NetworkReceiver()
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        
        val filter = IntentFilter().apply {
            addAction(ConnectivityManager.CONNECTIVITY_ACTION)
        }
        registerReceiver(networkReceiver, filter)
    }
    
    override fun onDestroy() {
        super.onDestroy()
        unregisterReceiver(networkReceiver)
    }
}
```

**Use Cases**:
- Network changes
- Battery changes
- Custom broadcasts
- Receivers needed only when app is running

## Handling Broadcasts

### Basic Receiver

```kotlin
class MyReceiver : BroadcastReceiver() {
    override fun onReceive(context: Context, intent: Intent) {
        when (intent.action) {
            Intent.ACTION_BOOT_COMPLETED -> {
                // Handle boot
            }
            ConnectivityManager.CONNECTIVITY_ACTION -> {
                // Handle network change
            }
            "CUSTOM_ACTION" -> {
                // Handle custom action
            }
        }
    }
}
```

### Starting Service from Receiver

```kotlin
class BootReceiver : BroadcastReceiver() {
    override fun onReceive(context: Context, intent: Intent) {
        if (intent.action == Intent.ACTION_BOOT_COMPLETED) {
            val serviceIntent = Intent(context, MyService::class.java)
            ContextCompat.startForegroundService(context, serviceIntent)
        }
    }
}
```

### Showing Notification from Receiver

```kotlin
class NotificationReceiver : BroadcastReceiver() {
    override fun onReceive(context: Context, intent: Intent) {
        val notification = NotificationCompat.Builder(context, "channel_id")
            .setContentTitle("Broadcast Received")
            .setContentText("Action: ${intent.action}")
            .setSmallIcon(R.drawable.ic_notification)
            .build()
        
        val notificationManager = NotificationManagerCompat.from(context)
        notificationManager.notify(1, notification)
    }
}
```

## Implicit vs Explicit Broadcasts

### Implicit Broadcasts

**Implicit Broadcast**: No specific target

**Restrictions** (Android 8.0+):
- **Limited**: Cannot register most implicit broadcasts in manifest
- **Exceptions**: Some system broadcasts still allowed

**Example**:
```kotlin
// Implicit broadcast (restricted)
val intent = Intent("CUSTOM_ACTION")
sendBroadcast(intent)
```

### Explicit Broadcasts

**Explicit Broadcast**: Specific target component

**Always Allowed**: No restrictions

**Example**:
```kotlin
// Explicit broadcast
val intent = Intent(this, MyReceiver::class.java)
intent.action = "CUSTOM_ACTION"
sendBroadcast(intent)
```

### Modern Approach

**Use LocalBroadcastManager or App Events**:
```kotlin
// GOOD: Local broadcast
LocalBroadcastManager.getInstance(context)
    .sendBroadcast(Intent("CUSTOM_ACTION"))

// GOOD: App events (Flow/StateFlow)
eventBus.emit(AppEvent.CustomEvent)
```

## Best Practices

### Practice 1: Use Modern Alternatives When Possible

```kotlin
// GOOD: Use Flow for app events
class EventBus {
    private val _events = MutableSharedFlow<AppEvent>()
    val events: SharedFlow<AppEvent> = _events.asSharedFlow()
    
    fun emit(event: AppEvent) {
        _events.emit(event)
    }
}

// BAD: Broadcast for app events
sendBroadcast(Intent("CUSTOM_ACTION"))
```

### Practice 2: Unregister Dynamic Receivers

```kotlin
// GOOD: Unregister in onDestroy
override fun onDestroy() {
    super.onDestroy()
    unregisterReceiver(receiver)
}

// BAD: Not unregistering
// Memory leak
```

### Practice 3: Use Local Broadcasts for App Events

```kotlin
// GOOD: Local broadcast
LocalBroadcastManager.getInstance(context)
    .sendBroadcast(intent)

// BAD: System broadcast for app events
sendBroadcast(intent) // May be received by other apps
```

### Practice 4: Handle Receivers Quickly

```kotlin
// GOOD: Quick handling, start service if needed
override fun onReceive(context: Context, intent: Intent) {
    val serviceIntent = Intent(context, MyService::class.java)
    ContextCompat.startForegroundService(context, serviceIntent)
}

// BAD: Long-running work in receiver
override fun onReceive(context: Context, intent: Intent) {
    Thread.sleep(10000) // Don't do this!
}
```

## Real-World Examples

### Network State Monitor

```kotlin
class NetworkStateReceiver : BroadcastReceiver() {
    override fun onReceive(context: Context, intent: Intent) {
        val connectivityManager = context.getSystemService(
            Context.CONNECTIVITY_SERVICE
        ) as ConnectivityManager
        
        val network = connectivityManager.activeNetwork
        val capabilities = connectivityManager.getNetworkCapabilities(network)
        
        val isConnected = capabilities?.hasCapability(
            NetworkCapabilities.NET_CAPABILITY_INTERNET
        ) ?: false
        
        val isWifi = capabilities?.hasTransport(
            NetworkCapabilities.TRANSPORT_WIFI
        ) ?: false
        
        val isCellular = capabilities?.hasTransport(
            NetworkCapabilities.TRANSPORT_CELLULAR
        ) ?: false
        
        // Notify app
        val eventIntent = Intent("NETWORK_STATE_CHANGED").apply {
            putExtra("is_connected", isConnected)
            putExtra("is_wifi", isWifi)
            putExtra("is_cellular", isCellular)
        }
        LocalBroadcastManager.getInstance(context).sendBroadcast(eventIntent)
    }
}
```

## Common Pitfalls

### Problem: Not Unregistering Receivers

```kotlin
// BAD: Not unregistering
registerReceiver(receiver, filter)
// Memory leak!

// GOOD: Unregister
override fun onDestroy() {
    super.onDestroy()
    unregisterReceiver(receiver)
}
```

### Problem: Long-Running Work in Receiver

```kotlin
// BAD: Long work in receiver
override fun onReceive(context: Context, intent: Intent) {
    doLongWork() // Receiver killed after 10 seconds
}

// GOOD: Start service
override fun onReceive(context: Context, intent: Intent) {
    val serviceIntent = Intent(context, MyService::class.java)
    ContextCompat.startForegroundService(context, serviceIntent)
}
```

## Quiz

1. What are Broadcast Receivers used for?
   - **A)** UI updates
   - **B)** Responding to system events and broadcasts
   - **C)** Database operations
   - **D)** Network requests

2. When should you unregister dynamic receivers?
   - **A)** Never
   - **B)** In onDestroy
   - **C)** In onCreate
   - **D)** Automatically

3. What is the difference between implicit and explicit broadcasts?
   - **A)** No difference
   - **B)** Implicit has no target, explicit has specific target
   - **C)** Explicit has no target
   - **D)** Both are the same

**Answers:**
1. **B** - Broadcast Receivers respond to system-wide broadcasts and custom intents
2. **B** - Always unregister dynamic receivers in onDestroy to prevent memory leaks
3. **B** - Implicit broadcasts have no specific target (restricted on Android 8.0+), explicit broadcasts target specific components

## Next Steps

- [Android Services - Complete Guide](./35.%20Android%20Services%20-%20Complete%20Guide.md) - Service integration
- [WorkManager & Background Tasks](./13.%20WorkManager%20%26%20Background%20Tasks.md) - Modern alternatives
- [Android Lifecycle Components](../beginners/05.%20Android%20Lifecycle%20Components.md) - Lifecycle awareness

