---
number: 25
title: "Kotlin Flow - Complete Guide"
slug: "kotlin-flow-complete-guide"
level: "intermediate"
tags: ["kotlin", "flow", "reactive", "streams", "stateflow", "sharedflow"]
prerequisites: ["kotlin-coroutines-basics"]
estimated_minutes: 120
contributors: []
diagrams: []
examples: []
canonical_id: "android-intermediate-25"
---



# Kotlin Flow - Complete Guide

## Overview

Kotlin Flow is a reactive streams library for handling asynchronous data streams in a sequential manner. Flow is built on top of coroutines and provides a powerful way to handle streams of data that can be emitted over time. This comprehensive guide covers cold flows, hot flows (StateFlow, SharedFlow), operators, error handling, and best practices.

## Table of Contents

1. [What is Flow?](#what-is-flow)
2. [Cold Flows](#cold-flows)
3. [Hot Flows](#hot-flows)
4. [StateFlow](#stateflow)
5. [SharedFlow](#sharedflow)
6. [Flow Operators](#flow-operators)
7. [Error Handling](#error-handling)
8. [Flow Collection](#flow-collection)
9. [Flow in ViewModels](#flow-in-viewmodels)
10. [Flow in Compose](#flow-in-compose)
11. [Best Practices](#best-practices)

## What is Flow?

### Definition

**Flow**: A cold asynchronous data stream that sequentially emits values

**Characteristics**:
- **Cold**: Starts emitting only when collected
- **Sequential**: Values emitted one at a time
- **Asynchronous**: Non-blocking, built on coroutines
- **Cancellable**: Can be cancelled

### Flow vs Other Solutions

**Flow vs LiveData**:
- **Flow**: More operators, better for complex transformations
- **LiveData**: Simpler, lifecycle-aware out of the box

**Flow vs RxJava**:
- **Flow**: Kotlin-native, coroutines-based, simpler
- **RxJava**: More mature, more operators, Java-compatible

**Flow vs Channels**:
- **Flow**: Cold, sequential, one-to-many
- **Channels**: Hot, concurrent, one-to-one

## Cold Flows

### What are Cold Flows?

**Cold Flow**: Starts emitting only when collected

**Characteristics**:
- **Lazy**: Doesn't start until collection begins
- **Independent**: Each collector gets its own stream
- **Sequential**: Values emitted one at a time

### Creating Cold Flows

**1. flow {} Builder**:
```kotlin
fun numbersFlow(): Flow<Int> = flow {
    for (i in 1..5) {
        delay(100)
        emit(i)
    }
}
```

**2. flowOf()**:
```kotlin
val flow = flowOf(1, 2, 3, 4, 5)
```

**3. asFlow()**:
```kotlin
val flow = listOf(1, 2, 3, 4, 5).asFlow()
```

**4. channelFlow {}**:
```kotlin
fun channelFlowExample(): Flow<Int> = channelFlow {
    for (i in 1..5) {
        send(i)
        delay(100)
    }
}
```

### Collecting Cold Flows

```kotlin
viewModelScope.launch {
    numbersFlow()
        .collect { value ->
            println(value)
        }
}
```

**Each Collection**: Starts a new stream

## Hot Flows

### What are Hot Flows?

**Hot Flow**: Emits values regardless of collectors

**Characteristics**:
- **Active**: Starts emitting immediately
- **Shared**: Multiple collectors share the same stream
- **Stateful**: Maintains state

**Types**:
- **StateFlow**: Holds current state, replays to new collectors
- **SharedFlow**: Configurable replay, no initial value

## StateFlow

### What is StateFlow?

**StateFlow**: Hot flow that holds current state

**Characteristics**:
- **Hot**: Active regardless of collectors
- **Stateful**: Holds current value
- **Replay**: New collectors get current value immediately
- **Conflation**: Only latest value kept

### Creating StateFlow

```kotlin
class CounterViewModel : ViewModel() {
    private val _count = MutableStateFlow(0)
    val count: StateFlow<Int> = _count.asStateFlow()
    
    fun increment() {
        _count.value++
    }
}
```

### StateFlow Properties

**1. Current Value**:
```kotlin
val currentValue = stateFlow.value // Always available
```

**2. Replay**:
```kotlin
// New collectors immediately get current value
stateFlow.collect { value ->
    println(value) // Gets current value immediately
}
```

**3. Conflation**:
```kotlin
// Only latest value kept
stateFlow.value = 1
stateFlow.value = 2
stateFlow.value = 3
// Collectors only see 3
```

### StateFlow Use Cases

**1. UI State**:
```kotlin
class LoginViewModel : ViewModel() {
    private val _uiState = MutableStateFlow(LoginUiState())
    val uiState: StateFlow<LoginUiState> = _uiState.asStateFlow()
    
    fun updateEmail(email: String) {
        _uiState.value = _uiState.value.copy(email = email)
    }
}
```

**2. Loading State**:
```kotlin
private val _isLoading = MutableStateFlow(false)
val isLoading: StateFlow<Boolean> = _uiState.asStateFlow()
```

## SharedFlow

### What is SharedFlow?

**SharedFlow**: Hot flow with configurable replay

**Characteristics**:
- **Hot**: Active regardless of collectors
- **Configurable Replay**: Can replay N values to new collectors
- **No Initial Value**: Unlike StateFlow
- **Buffer**: Can buffer emissions

### Creating SharedFlow

```kotlin
class EventBus {
    private val _events = MutableSharedFlow<Event>(
        replay = 0, // No replay
        extraBufferCapacity = 1 // Buffer capacity
    )
    val events: SharedFlow<Event> = _events.asSharedFlow()
    
    fun sendEvent(event: Event) {
        _events.emit(event)
    }
}
```

### SharedFlow Configuration

**1. Replay**:
```kotlin
// Replay last 3 values to new collectors
val sharedFlow = MutableSharedFlow<Int>(
    replay = 3
)
```

**2. Extra Buffer Capacity**:
```kotlin
// Buffer up to 10 values
val sharedFlow = MutableSharedFlow<Int>(
    extraBufferCapacity = 10
)
```

**3. onBufferOverflow**:
```kotlin
// Drop oldest when buffer full
val sharedFlow = MutableSharedFlow<Int>(
    extraBufferCapacity = 10,
    onBufferOverflow = BufferOverflow.DROP_OLDEST
)
```

### SharedFlow Use Cases

**1. Events**:
```kotlin
sealed class UiEvent {
    object NavigateBack : UiEvent()
    data class ShowError(val message: String) : UiEvent()
}

class MyViewModel : ViewModel() {
    private val _events = MutableSharedFlow<UiEvent>()
    val events: SharedFlow<UiEvent> = _events.asSharedFlow()
    
    fun showError(message: String) {
        _events.emit(UiEvent.ShowError(message))
    }
}
```

**2. One-Time Events**:
```kotlin
// No replay - events consumed once
val events = MutableSharedFlow<Event>(replay = 0)
```

## Flow Operators

### Transformation Operators

**1. map**:
```kotlin
flowOf(1, 2, 3)
    .map { it * 2 }
    .collect { println(it) } // 2, 4, 6
```

**2. transform**:
```kotlin
flowOf(1, 2, 3)
    .transform { value ->
        emit(value * 2)
        emit(value * 3)
    }
    .collect { println(it) } // 2, 3, 4, 6, 6, 9
```

**3. flatMapConcat**:
```kotlin
flowOf(1, 2, 3)
    .flatMapConcat { value ->
        flowOf(value, value * 2)
    }
    .collect { println(it) } // 1, 2, 2, 4, 3, 6
```

**4. flatMapMerge**:
```kotlin
flowOf(1, 2, 3)
    .flatMapMerge { value ->
        flowOf(value, value * 2)
    }
    .collect { println(it) } // May interleave
```

**5. flatMapLatest**:
```kotlin
flowOf(1, 2, 3)
    .flatMapLatest { value ->
        flowOf(value, value * 2)
    }
    .collect { println(it) } // Only latest
```

### Filtering Operators

**1. filter**:
```kotlin
flowOf(1, 2, 3, 4, 5)
    .filter { it % 2 == 0 }
    .collect { println(it) } // 2, 4
```

**2. take**:
```kotlin
flowOf(1, 2, 3, 4, 5)
    .take(3)
    .collect { println(it) } // 1, 2, 3
```

**3. drop**:
```kotlin
flowOf(1, 2, 3, 4, 5)
    .drop(2)
    .collect { println(it) } // 3, 4, 5
```

**4. distinctUntilChanged**:
```kotlin
flowOf(1, 1, 2, 2, 3)
    .distinctUntilChanged()
    .collect { println(it) } // 1, 2, 3
```

### Combining Operators

**1. combine**:
```kotlin
val flow1 = flowOf(1, 2, 3)
val flow2 = flowOf("a", "b", "c")

combine(flow1, flow2) { a, b ->
    "$a$b"
}.collect { println(it) } // 1a, 2b, 3c
```

**2. zip**:
```kotlin
val flow1 = flowOf(1, 2, 3)
val flow2 = flowOf("a", "b", "c")

flow1.zip(flow2) { a, b ->
    "$a$b"
}.collect { println(it) } // 1a, 2b, 3c
```

**3. merge**:
```kotlin
val flow1 = flowOf(1, 2, 3)
val flow2 = flowOf(4, 5, 6)

merge(flow1, flow2)
    .collect { println(it) } // Interleaved: 1, 4, 2, 5, 3, 6
```

### Terminal Operators

**1. collect**:
```kotlin
flow.collect { value ->
    println(value)
}
```

**2. first**:
```kotlin
val first = flow.first()
```

**3. toList**:
```kotlin
val list = flow.toList()
```

**4. reduce**:
```kotlin
val sum = flowOf(1, 2, 3, 4, 5)
    .reduce { acc, value -> acc + value } // 15
```

**5. fold**:
```kotlin
val sum = flowOf(1, 2, 3, 4, 5)
    .fold(0) { acc, value -> acc + value } // 15
```

### Context Operators

**1. flowOn**:
```kotlin
flow {
    // Runs on IO dispatcher
    emit(fetchData())
}
    .flowOn(Dispatchers.IO)
    .collect { // Runs on default dispatcher
        println(it)
    }
```

**2. buffer**:
```kotlin
flow {
    for (i in 1..5) {
        delay(100)
        emit(i)
    }
}
    .buffer() // Buffers emissions
    .collect { value ->
        delay(200)
        println(value)
    }
```

## Error Handling

### catch Operator

```kotlin
flow {
    emit(1)
    throw RuntimeException("Error")
    emit(2)
}
    .catch { e ->
        println("Caught: $e")
        emit(-1) // Fallback value
    }
    .collect { println(it) } // 1, -1
```

### retry Operator

```kotlin
flow {
    emit(fetchData())
}
    .retry(
        retries = 3,
        delay = 1.seconds
    ) { e ->
        e is IOException
    }
    .collect { println(it) }
```

### onEach with Error Handling

```kotlin
flow {
    emit(1)
    emit(2)
    throw RuntimeException("Error")
}
    .onEach { value ->
        println(value)
    }
    .catch { e ->
        println("Error: $e")
    }
    .collect()
```

## Flow Collection

### Basic Collection

```kotlin
viewModelScope.launch {
    flow.collect { value ->
        println(value)
    }
}
```

### Lifecycle-Aware Collection

```kotlin
@Composable
fun MyScreen(viewModel: MyViewModel) {
    val uiState by viewModel.uiState
        .collectAsStateWithLifecycle()
    
    // Use uiState
}
```

### Collecting in ViewModel

```kotlin
class MyViewModel : ViewModel() {
    init {
        viewModelScope.launch {
            repository.dataFlow
                .collect { data ->
                    _uiState.value = data
                }
        }
    }
}
```

## Flow in ViewModels

### StateFlow Pattern

```kotlin
class UserViewModel(
    private val repository: UserRepository
) : ViewModel() {
    private val _uiState = MutableStateFlow(UserUiState())
    val uiState: StateFlow<UserUiState> = _uiState.asStateFlow()
    
    init {
        loadUser()
    }
    
    private fun loadUser() {
        viewModelScope.launch {
            repository.getUserFlow()
                .catch { e ->
                    _uiState.value = _uiState.value.copy(
                        error = e.message
                    )
                }
                .collect { user ->
                    _uiState.value = _uiState.value.copy(
                        user = user,
                        isLoading = false
                    )
                }
        }
    }
}
```

### SharedFlow for Events

```kotlin
class LoginViewModel : ViewModel() {
    private val _events = MutableSharedFlow<LoginEvent>()
    val events: SharedFlow<LoginEvent> = _events.asSharedFlow()
    
    fun login(email: String, password: String) {
        viewModelScope.launch {
            try {
                val result = repository.login(email, password)
                _events.emit(LoginEvent.Success(result))
            } catch (e: Exception) {
                _events.emit(LoginEvent.Error(e.message ?: "Unknown error"))
            }
        }
    }
}
```

### Combining Multiple Flows

```kotlin
class DashboardViewModel : ViewModel() {
    val dashboardState: StateFlow<DashboardState> = combine(
        repository.userFlow,
        repository.postsFlow,
        repository.notificationsFlow
    ) { user, posts, notifications ->
        DashboardState(
            user = user,
            posts = posts,
            notifications = notifications
        )
    }.stateIn(
        scope = viewModelScope,
        started = SharingStarted.WhileSubscribed(5000),
        initialValue = DashboardState()
    )
}
```

## Flow in Compose

### Collecting StateFlow

```kotlin
@Composable
fun UserScreen(viewModel: UserViewModel = viewModel()) {
    val uiState by viewModel.uiState.collectAsStateWithLifecycle()
    
    when {
        uiState.isLoading -> LoadingIndicator()
        uiState.error != null -> ErrorMessage(uiState.error)
        else -> UserContent(uiState.user)
    }
}
```

### Collecting SharedFlow Events

```kotlin
@Composable
fun LoginScreen(viewModel: LoginViewModel = viewModel()) {
    val events by viewModel.events
        .collectAsStateWithLifecycle(initialValue = null)
    
    LaunchedEffect(events) {
        when (val event = events) {
            is LoginEvent.Success -> {
                // Navigate
            }
            is LoginEvent.Error -> {
                // Show error
            }
            null -> {}
        }
    }
    
    // UI
}
```

### Collecting Cold Flows

```kotlin
@Composable
fun SearchScreen(viewModel: SearchViewModel = viewModel()) {
    var query by remember { mutableStateOf("") }
    
    val results by remember(query) {
        viewModel.searchFlow(query)
    }.collectAsStateWithLifecycle(initialValue = emptyList())
    
    // UI
}
```

## Best Practices

### Practice 1: Use StateFlow for State

```kotlin
// GOOD: StateFlow for state
private val _uiState = MutableStateFlow(UiState())
val uiState: StateFlow<UiState> = _uiState.asStateFlow()

// BAD: SharedFlow for state
private val _uiState = MutableSharedFlow<UiState>()
```

### Practice 2: Use SharedFlow for Events

```kotlin
// GOOD: SharedFlow for events (no replay)
private val _events = MutableSharedFlow<Event>(replay = 0)
val events: SharedFlow<Event> = _events.asSharedFlow()

// BAD: StateFlow for events
private val _events = MutableStateFlow<Event?>(null)
```

### Practice 3: Handle Errors

```kotlin
flow {
    emit(data)
}
    .catch { e ->
        // Handle error
        emit(fallbackValue)
    }
    .collect { value ->
        // Use value
    }
```

### Practice 4: Use flowOn for Context Switching

```kotlin
flow {
    // I/O operation
    emit(fetchData())
}
    .flowOn(Dispatchers.IO)
    .collect { // Main thread
        updateUI(it)
    }
```

### Practice 5: Use shareIn for Sharing

```kotlin
val sharedFlow = repository.dataFlow
    .shareIn(
        scope = viewModelScope,
        started = SharingStarted.WhileSubscribed(5000),
        replay = 1
    )
```

## Real-World Examples

### Example 1: Search with Debounce

```kotlin
class SearchViewModel : ViewModel() {
    fun searchFlow(query: String): Flow<List<Result>> = flow {
        if (query.isEmpty()) {
            emit(emptyList())
            return@flow
        }
        
        delay(300) // Debounce
        emit(repository.search(query))
    }
        .flowOn(Dispatchers.IO)
        .catch { e ->
            emit(emptyList())
        }
}
```

### Example 2: Real-Time Updates

```kotlin
class ChatViewModel : ViewModel() {
    val messages: StateFlow<List<Message>> = repository.messagesFlow
        .stateIn(
            scope = viewModelScope,
            started = SharingStarted.WhileSubscribed(5000),
            initialValue = emptyList()
        )
}
```

### Example 3: Polling

```kotlin
fun pollData(): Flow<Data> = flow {
    while (true) {
        emit(fetchData())
        delay(5000)
    }
}
    .flowOn(Dispatchers.IO)
```

## Common Pitfalls

### Problem: Collecting in Wrong Scope

```kotlin
// BAD: GlobalScope
GlobalScope.launch {
    flow.collect { }
}

// GOOD: viewModelScope
viewModelScope.launch {
    flow.collect { }
}
```

### Problem: Not Handling Errors

```kotlin
// BAD: No error handling
flow.collect { value ->
    process(value) // May throw
}

// GOOD: Handle errors
flow
    .catch { e ->
        handleError(e)
    }
    .collect { value ->
        process(value)
    }
```

## Quiz

1. What is the difference between cold and hot flows?
   - **A)** Cold flows are faster
   - **B)** Cold flows start emitting only when collected, hot flows emit regardless
   - **C)** Hot flows are slower
   - **D)** No difference

2. What is StateFlow?
   - **A)** Cold flow
   - **B)** Hot flow that holds current state
   - **C)** Regular flow
   - **D)** Channel

3. When should you use SharedFlow vs StateFlow?
   - **A)** SharedFlow for state, StateFlow for events
   - **B)** StateFlow for state, SharedFlow for events
   - **C)** Always use StateFlow
   - **D)** Always use SharedFlow

**Answers:**
1. **B** - Cold flows are lazy and start emitting only when collected, while hot flows are active and emit regardless of collectors
2. **B** - StateFlow is a hot flow that holds and replays the current state value
3. **B** - Use StateFlow for state (always has a value), SharedFlow for events (one-time, no initial value)

## Next Steps

- [Kotlin Coroutines Basics](../beginners/03.%20Kotlin%20Coroutines%20Basics.md) - Coroutines foundation
- [Advanced Coroutines & Cancellation](../advanced/20.%20Advanced%20Coroutines%20%26%20Cancellation.md) - Advanced coroutines
- [Jetpack Compose State Management](./10.%20Jetpack%20Compose%20State%20Management.md) - Using Flow with Compose

