---
number: 33
title: "ViewBinding & DataBinding"
slug: "viewbinding-databinding"
level: "intermediate"
tags: ["viewbinding", "databinding", "views", "xml"]
prerequisites: ["introduction-to-android-architecture"]
estimated_minutes: 70
contributors: []
diagrams: []
examples: []
canonical_id: "android-33"
---

# ViewBinding & DataBinding

## Overview

ViewBinding and DataBinding provide type-safe ways to interact with views in Android. While Jetpack Compose is the modern approach, understanding ViewBinding and DataBinding is important for maintaining legacy codebases and working with XML layouts. This guide covers ViewBinding setup, DataBinding basics, two-way data binding, binding adapters, and migration strategies.

## Table of Contents

1. [ViewBinding vs DataBinding](#viewbinding-vs-databinding)
2. [ViewBinding Setup](#viewbinding-setup)
3. [Using ViewBinding](#using-viewbinding)
4. [DataBinding Setup](#databinding-setup)
5. [Using DataBinding](#using-databinding)
6. [Two-Way Data Binding](#two-way-binding)
7. [Binding Adapters](#binding-adapters)
8. [Migration from findViewById](#migration)
9. [Best Practices](#best-practices)

## ViewBinding vs DataBinding

### ViewBinding

**ViewBinding**: Type-safe view references

**Features**:
- **Type-safe**: Compile-time safety
- **Null-safe**: No null pointer exceptions
- **Simple**: Easy to use
- **Performance**: No reflection, faster

**Use Case**: Replace findViewById

### DataBinding

**DataBinding**: Bind data directly to views

**Features**:
- **Data Binding**: Bind data to views
- **Two-way**: Two-way data binding
- **Expressions**: Use expressions in XML
- **Performance**: Slight overhead

**Use Case**: Data-driven UIs

### Comparison

**ViewBinding**:
- Simpler
- Faster
- Type-safe view references only

**DataBinding**:
- More powerful
- Data binding capabilities
- Slight performance overhead

## ViewBinding Setup

### Enable ViewBinding

**build.gradle.kts**:
```kotlin
android {
    buildFeatures {
        viewBinding = true
    }
}
```

### Layout File

**activity_main.xml**:
```xml
<LinearLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical">
    
    <TextView
        android:id="@+id/textView"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content" />
    
    <Button
        android:id="@+id/button"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Click" />
</LinearLayout>
```

**Generated Binding Class**: `ActivityMainBinding`

## Using ViewBinding

### In Activity

```kotlin
class MainActivity : AppCompatActivity() {
    private lateinit var binding: ActivityMainBinding
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        binding = ActivityMainBinding.inflate(layoutInflater)
        setContentView(binding.root)
        
        // Use views
        binding.textView.text = "Hello"
        binding.button.setOnClickListener {
            // Handle click
        }
    }
    
    override fun onDestroy() {
        super.onDestroy()
        binding = null // Not needed, but good practice
    }
}
```

### In Fragment

```kotlin
class MyFragment : Fragment() {
    private var _binding: FragmentMyBinding? = null
    private val binding get() = _binding!!
    
    override fun onCreateView(
        inflater: LayoutInflater,
        container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View {
        _binding = FragmentMyBinding.inflate(inflater, container, false)
        return binding.root
    }
    
    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        
        // Use views
        binding.textView.text = "Hello"
    }
    
    override fun onDestroyView() {
        super.onDestroyView()
        _binding = null
    }
}
```

### In RecyclerView ViewHolder

```kotlin
class MyViewHolder(
    private val binding: ItemMyBinding
) : RecyclerView.ViewHolder(binding.root) {
    
    fun bind(item: MyItem) {
        binding.textView.text = item.text
        binding.button.setOnClickListener {
            // Handle click
        }
    }
}

class MyAdapter : RecyclerView.Adapter<MyViewHolder>() {
    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): MyViewHolder {
        val binding = ItemMyBinding.inflate(
            LayoutInflater.from(parent.context),
            parent,
            false
        )
        return MyViewHolder(binding)
    }
    
    override fun onBindViewHolder(holder: MyViewHolder, position: Int) {
        holder.bind(items[position])
    }
    
    override fun getItemCount() = items.size
}
```

## DataBinding Setup

### Enable DataBinding

**build.gradle.kts**:
```kotlin
android {
    buildFeatures {
        dataBinding = true
    }
}
```

### Layout File

**activity_main.xml**:
```xml
<layout xmlns:android="http://schemas.android.com/apk/res/android">
    <data>
        <variable
            name="user"
            type="com.example.User" />
    </data>
    
    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:orientation="vertical">
        
        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="@{user.name}" />
        
        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="@{user.email}" />
    </LinearLayout>
</layout>
```

## Using DataBinding

### In Activity

```kotlin
class MainActivity : AppCompatActivity() {
    private lateinit var binding: ActivityMainBinding
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        binding = DataBindingUtil.setContentView(this, R.layout.activity_main)
        
        val user = User("John", "john@example.com")
        binding.user = user
    }
}
```

### In Fragment

```kotlin
class MyFragment : Fragment() {
    private var _binding: FragmentMyBinding? = null
    private val binding get() = _binding!!
    
    override fun onCreateView(
        inflater: LayoutInflater,
        container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View {
        _binding = DataBindingUtil.inflate(
            inflater,
            R.layout.fragment_my,
            container,
            false
        )
        return binding.root
    }
    
    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        
        val user = User("John", "john@example.com")
        binding.user = user
    }
    
    override fun onDestroyView() {
        super.onDestroyView()
        _binding = null
    }
}
```

## Two-Way Data Binding

### Two-Way Binding Syntax

```xml
<EditText
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:text="@={user.name}" />
```

**`@={}`**: Two-way binding
**`@{}`**: One-way binding

### Using Two-Way Binding

```kotlin
class MainActivity : AppCompatActivity() {
    private lateinit var binding: ActivityMainBinding
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        binding = DataBindingUtil.setContentView(this, R.layout.activity_main)
        
        val user = User("John", "john@example.com")
        binding.user = user
        
        // Changes to EditText automatically update user.name
        // Changes to user.name automatically update EditText
    }
}
```

## Binding Adapters

### What are Binding Adapters?

**Binding Adapter**: Custom attribute binding

**Purpose**: Bind custom attributes or transform data

### Creating Binding Adapters

```kotlin
@BindingAdapter("app:imageUrl")
fun loadImage(view: ImageView, url: String?) {
    if (url != null) {
        Glide.with(view.context)
            .load(url)
            .into(view)
    }
}

@BindingAdapter("app:visible")
fun setVisibility(view: View, visible: Boolean) {
    view.visibility = if (visible) View.VISIBLE else View.GONE
}
```

### Using Binding Adapters

```xml
<ImageView
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    app:imageUrl="@{user.avatarUrl}" />

<TextView
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    app:visible="@{user.isVisible}" />
```

### Multiple Parameters

```kotlin
@BindingAdapter("app:imageUrl", "app:placeholder")
fun loadImageWithPlaceholder(
    view: ImageView,
    url: String?,
    placeholder: Drawable?
) {
    Glide.with(view.context)
        .load(url)
        .placeholder(placeholder)
        .into(view)
}
```

## Migration from findViewById

### Before (findViewById)

```kotlin
class MainActivity : AppCompatActivity() {
    private lateinit var textView: TextView
    private lateinit var button: Button
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        
        textView = findViewById(R.id.textView)
        button = findViewById(R.id.button)
        
        textView.text = "Hello"
        button.setOnClickListener { }
    }
}
```

### After (ViewBinding)

```kotlin
class MainActivity : AppCompatActivity() {
    private lateinit var binding: ActivityMainBinding
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        binding = ActivityMainBinding.inflate(layoutInflater)
        setContentView(binding.root)
        
        binding.textView.text = "Hello"
        binding.button.setOnClickListener { }
    }
}
```

**Benefits**:
- Type-safe
- Null-safe
- No findViewById calls
- Better performance

## Best Practices

### Practice 1: Use ViewBinding for Simple Cases

```kotlin
// GOOD: ViewBinding for simple view references
binding.textView.text = "Hello"

// BAD: DataBinding for simple cases
// Unnecessary overhead
```

### Practice 2: Use DataBinding for Data-Driven UIs

```kotlin
// GOOD: DataBinding for data-driven UIs
binding.user = user
// XML handles updates automatically

// BAD: ViewBinding for complex data binding
// Manual updates needed
```

### Practice 3: Null Safety in Fragments

```kotlin
// GOOD: Null safety
private var _binding: FragmentMyBinding? = null
private val binding get() = _binding!!

override fun onDestroyView() {
    super.onDestroyView()
    _binding = null
}

// BAD: Not nulling binding
// Memory leak risk
```

### Practice 4: Use Binding Adapters for Reusability

```kotlin
// GOOD: Reusable binding adapter
@BindingAdapter("app:imageUrl")
fun loadImage(view: ImageView, url: String?)

// BAD: Duplicate code
// Load image in multiple places
```

## Real-World Examples

### Complete ViewBinding Example

```kotlin
class LoginActivity : AppCompatActivity() {
    private lateinit var binding: ActivityLoginBinding
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        binding = ActivityLoginBinding.inflate(layoutInflater)
        setContentView(binding.root)
        
        binding.loginButton.setOnClickListener {
            val email = binding.emailEditText.text.toString()
            val password = binding.passwordEditText.text.toString()
            login(email, password)
        }
    }
    
    private fun login(email: String, password: String) {
        binding.progressBar.visibility = View.VISIBLE
        binding.loginButton.isEnabled = false
        
        // Login logic
    }
}
```

### Complete DataBinding Example

```kotlin
class UserProfileActivity : AppCompatActivity() {
    private lateinit var binding: ActivityUserProfileBinding
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        binding = DataBindingUtil.setContentView(this, R.layout.activity_user_profile)
        
        val user = User("John", "john@example.com", "https://example.com/avatar.jpg")
        binding.user = user
        binding.lifecycleOwner = this
    }
}
```

## Common Pitfalls

### Problem: Not Nulling Binding in Fragments

```kotlin
// BAD: Not nulling binding
private lateinit var binding: FragmentMyBinding

override fun onDestroyView() {
    super.onDestroyView()
    // binding still holds reference
}

// GOOD: Null binding
private var _binding: FragmentMyBinding? = null
private val binding get() = _binding!!

override fun onDestroyView() {
    super.onDestroyView()
    _binding = null
}
```

### Problem: Using DataBinding Unnecessarily

```kotlin
// BAD: DataBinding for simple case
binding.user = user
// When ViewBinding would suffice

// GOOD: ViewBinding for simple case
binding.textView.text = user.name
```

## Quiz

1. What is ViewBinding used for?
   - **A)** Data binding
   - **B)** Type-safe view references
   - **C)** Database
   - **D)** Nothing

2. When should you use DataBinding?
   - **A)** Always
   - **B)** For data-driven UIs
   - **C)** Never
   - **D)** For simple views

3. What is the difference between `@{}` and `@={}`?
   - **A)** No difference
   - **B)** `@{}` is one-way, `@={}` is two-way
   - **C)** `@{}` is two-way, `@={}` is one-way
   - **D)** Both are the same

**Answers:**
1. **B** - ViewBinding provides type-safe view references, replacing findViewById
2. **B** - Use DataBinding for data-driven UIs where you want automatic updates from data to views
3. **B** - `@{}` is one-way binding (data to view), `@={}` is two-way binding (data â†” view)

## Next Steps

- [Introduction to Android Architecture](../beginners/01.%20Introduction%20to%20Android%20Architecture.md) - Architecture patterns
- [Jetpack Compose UI Components & Theming](./26.%20Jetpack%20Compose%20UI%20Components%20%26%20Theming.md) - Modern UI approach
- [Unit Testing in Android](./14.%20Unit%20Testing%20in%20Android.md) - Testing with ViewBinding

