---
number: 30
title: "Object Lifecycle & References in Java"
slug: "object-lifecycle-references-java"
level: "intermediate"
tags: ["java", "memory", "references", "gc", "object-lifecycle", "finalization"]
prerequisites: ["jvm-architecture-java-memory-model"]
estimated_minutes: 80
contributors: []
diagrams: []
examples: []
canonical_id: "android-intermediate-30"
---




# Object Lifecycle & References in Java

## Overview

Understanding object lifecycle and reference types in Java is crucial for managing memory effectively and avoiding memory leaks. This comprehensive guide covers object creation, different reference types (strong, weak, soft, phantom), finalization, and how these concepts apply to Android development.

## Table of Contents

1. [Object Lifecycle](#object-lifecycle)
2. [Reference Types](#reference-types)
3. [Strong References](#strong-references)
4. [Weak References](#weak-references)
5. [Soft References](#soft-references)
6. [Phantom References](#phantom-references)
7. [Finalization & Cleaners](#finalization)
8. [Android-Specific Considerations](#android-considerations)

## Object Lifecycle

### Lifecycle Stages

```
Creation → Reachable → Unreachable → Finalization → GC → Deallocation
```

### Stage 1: Creation

```kotlin
val obj = MyObject() // Object created in heap

// What happens:
// 1. Allocate memory in heap
// 2. Initialize instance variables (default values)
// 3. Execute instance initializers
// 4. Execute constructor
// 5. Return reference
```

### Stage 2: Reachable

**Reachable Object**: Can be accessed through reference chain from GC roots

**GC Roots**:
- Static variables
- Local variables (active threads)
- Active threads
- JNI references
- Monitor locks

```kotlin
class Example {
    companion object {
        val staticRef = MyObject() // GC root → Object reachable
    }
    
    fun method() {
        val localRef = MyObject() // Local variable → Object reachable
        // When method returns, localRef removed
        // Object becomes unreachable (if no other references)
    }
}
```

### Stage 3: Unreachable

**Unreachable Object**: No path from GC roots to object

```kotlin
fun createObject() {
    val obj = MyObject() // Reachable
    // Method returns
    // obj reference removed from stack
    // Object becomes unreachable
    // Eligible for GC
}
```

### Stage 4: Finalization

**Finalization**: Cleanup before garbage collection

```kotlin
class MyClass {
    protected fun finalize() {
        // Cleanup code
        // Release native resources
        // Close files
    }
}

// Called by GC before object is collected
// Not guaranteed when (or if) it runs
```

### Stage 5: Garbage Collection

**GC Process**:
1. Mark unreachable objects
2. Finalize (if needed)
3. Collect memory
4. Compact heap (optional)

### Stage 6: Deallocation

**Memory returned to heap**: Available for new allocations

## Reference Types

### Reference Hierarchy

```
Reference (base class)
├── Strong Reference (default)
├── SoftReference
├── WeakReference
└── PhantomReference
```

### When Objects Are GC'd

| Reference Type | GC Behavior |
|---------------|-------------|
| **Strong** | Never GC'd while referenced |
| **Soft** | GC'd when memory pressure |
| **Weak** | GC'd in next GC cycle |
| **Phantom** | GC'd after finalization |

## Strong References

### What is a Strong Reference?

**Default reference type**: Normal object references

```kotlin
val obj = MyObject() // Strong reference

// Object cannot be GC'd while strong reference exists
// GC'd only when no strong references remain
```

### Characteristics

- **Default**: All references are strong by default
- **Prevents GC**: Object not collected while referenced
- **Memory Leaks**: Holding strong references prevents GC

### Strong Reference Example

```kotlin
class Cache {
    private val cache = mutableMapOf<String, LargeObject>()
    
    fun put(key: String, value: LargeObject) {
        cache[key] = value // Strong reference
    }
    
    fun get(key: String): LargeObject? {
        return cache[key]
    }
}

// Problem: Objects never GC'd
// Even if not used, cache holds strong references
// Solution: Use WeakReference or clear cache
```

### Memory Leak with Strong References

```kotlin
// BAD: Static strong reference
class Leaky {
    companion object {
        val listeners = mutableListOf<Listener>() // Strong references
    }
    
    fun addListener(listener: Listener) {
        listeners.add(listener) // Never removed
        // Listeners never GC'd
    }
}

// GOOD: Use WeakReference
class NonLeaky {
    companion object {
        val listeners = mutableListOf<WeakReference<Listener>>()
    }
    
    fun addListener(listener: Listener) {
        listeners.add(WeakReference(listener))
        // Listeners can be GC'd
    }
}
```

## Weak References

### What is a Weak Reference?

**Weak Reference**: Doesn't prevent garbage collection

```kotlin
val strongRef = MyObject() // Strong reference
val weakRef = WeakReference(strongRef) // Weak reference

strongRef = null // Remove strong reference
// Object now only weakly referenced
// GC can collect it in next cycle
```

### Characteristics

- **GC Behavior**: Collected in next GC cycle if no strong references
- **Use Case**: Caching, listeners, metadata
- **Access**: May return null if object was GC'd

### Weak Reference Example

```kotlin
class WeakCache {
    private val cache = mutableMapOf<String, WeakReference<LargeObject>>()
    
    fun put(key: String, value: LargeObject) {
        cache[key] = WeakReference(value)
    }
    
    fun get(key: String): LargeObject? {
        val weakRef = cache[key] ?: return null
        val obj = weakRef.get() // May return null if GC'd
        
        if (obj == null) {
            cache.remove(key) // Clean up null references
        }
        
        return obj
    }
}

// Benefits:
// - Objects can be GC'd when memory needed
// - Cache doesn't prevent GC
// - Automatic cleanup
```

### Common Use Case: Listeners

```kotlin
class EventManager {
    private val listeners = mutableListOf<WeakReference<Listener>>()
    
    fun addListener(listener: Listener) {
        listeners.add(WeakReference(listener))
    }
    
    fun notifyListeners() {
        listeners.removeAll { it.get() == null } // Remove GC'd listeners
        
        listeners.forEach { weakRef ->
            weakRef.get()?.onEvent() // Call if still alive
        }
    }
}

// Listener can be GC'd even if registered
// No memory leak if listener not removed
```

### WeakHashMap

```kotlin
// Special HashMap that uses weak references for keys
val cache = WeakHashMap<String, LargeObject>()

cache["key"] = LargeObject()

// If key becomes unreachable:
val key = "key"
// key reference removed
// Key-value pair can be GC'd automatically
```

## Soft References

### What is a Soft Reference?

**Soft Reference**: GC'd only when memory pressure

```kotlin
val softRef = SoftReference(largeObject)

// GC behavior:
// - Kept as long as memory available
// - GC'd when memory pressure
// - Useful for caching
```

### Characteristics

- **GC Behavior**: Collected when memory is low
- **Use Case**: Caching (kept until memory needed)
- **Lifetime**: Longer than WeakReference

### Soft Reference Example

```kotlin
class ImageCache {
    private val cache = mutableMapOf<String, SoftReference<Bitmap>>()
    
    fun getImage(url: String): Bitmap? {
        val softRef = cache[url]
        val bitmap = softRef?.get()
        
        if (bitmap != null) {
            return bitmap // Cache hit
        }
        
        // Cache miss or GC'd
        val newBitmap = loadImage(url)
        cache[url] = SoftReference(newBitmap)
        return newBitmap
    }
}

// Benefits:
// - Images cached while memory available
// - Automatically cleared when memory pressure
// - Better than strong references for cache
```

### When to Use Soft vs Weak

**Use SoftReference when**:
- Cache should persist while memory available
- Want to keep objects as long as possible
- Memory pressure is the only reason to clear

**Use WeakReference when**:
- Want objects GC'd immediately when not strongly referenced
- Don't want to keep objects longer than necessary
- Metadata, listeners, temporary data

## Phantom References

### What is a Phantom Reference?

**Phantom Reference**: Collected after finalization

```kotlin
val phantomRef = PhantomReference(obj, referenceQueue)

// GC behavior:
// 1. Object becomes unreachable
// 2. Object finalized
// 3. Phantom reference enqueued
// 4. Object collected
```

### Characteristics

- **Always null**: `get()` always returns null
- **Finalization tracking**: Know when object finalized
- **Use Case**: Cleanup after finalization

### Phantom Reference Example

```kotlin
class ResourceManager {
    private val referenceQueue = ReferenceQueue<Resource>()
    private val phantomRefs = mutableListOf<PhantomReference<Resource>>()
    
    init {
        // Cleanup thread
        Thread {
            while (true) {
                val ref = referenceQueue.remove() as? PhantomReference<*>
                ref?.let {
                    cleanupResource(it)
                    phantomRefs.remove(it)
                }
            }
        }.start()
    }
    
    fun createResource(): Resource {
        val resource = Resource()
        val phantomRef = PhantomReference(resource, referenceQueue)
        phantomRefs.add(phantomRef)
        return resource
    }
    
    private fun cleanupResource(ref: PhantomReference<*>) {
        // Cleanup after finalization
        // Release native resources, etc.
    }
}
```

## Finalization & Cleaners

### Finalization Process

```kotlin
class ResourceHolder {
    private val nativeHandle: Long = allocateNative()
    
    protected fun finalize() {
        // Called by GC before collection
        // NOT guaranteed when (or if) called
        // May be called after long delay
        releaseNative(nativeHandle)
    }
}

// Problems with finalization:
// 1. Not guaranteed to run
// 2. May run after long delay
// 3. Performance overhead
// 4. Can resurrect objects (bad practice)
```

### Problems with Finalization

**1. Not Guaranteed**:
- May never run
- Not suitable for critical cleanup

**2. Performance Overhead**:
- Slows down GC
- Objects survive extra GC cycles

**3. Timing Issues**:
- May run after long delay
- Resources held longer than needed

**4. Resurrection**:
```kotlin
class Resurrectable {
    companion object {
        var saved: Resurrectable? = null
    }
    
    protected fun finalize() {
        saved = this // Resurrect object!
        // Object not collected
        // finalize() called again later
    }
}
```

### Cleaners (Java 9+)

**Better alternative to finalization**:

```kotlin
import java.lang.ref.Cleaner

class ResourceHolder {
    private val nativeHandle: Long = allocateNative()
    
    companion object {
        private val cleaner = Cleaner.create()
    }
    
    private val cleanable: Cleaner.Cleanable
    
    init {
        cleanable = cleaner.register(this) {
            // Cleanup action
            releaseNative(nativeHandle)
        }
    }
    
    fun close() {
        cleanable.clean() // Explicit cleanup
    }
}

// Benefits:
// - More predictable
// - Better performance
// - Explicit control
```

### Best Practice: Try-With-Resources

```kotlin
// Use AutoCloseable instead of finalization
class Resource : AutoCloseable {
    private val nativeHandle: Long = allocateNative()
    
    override fun close() {
        releaseNative(nativeHandle)
    }
}

// Usage
Resource().use { resource ->
    // Use resource
    // Automatically closed when done
}

// Or manually
val resource = Resource()
try {
    // Use resource
} finally {
    resource.close() // Always closed
}
```

## Android-Specific Considerations

### Context References

```kotlin
// BAD: Static reference to Context
class Leaky {
    companion object {
        var context: Context? = null // Static reference!
    }
}

// Context holds reference to Activity
// Activity cannot be GC'd
// Memory leak!

// GOOD: Use Application context or WeakReference
class NonLeaky {
    companion object {
        var appContext: Context? = null // Application context OK
        // Or
        var contextRef: WeakReference<Context>? = null
    }
}
```

### View References

```kotlin
// BAD: Static reference to View
class Leaky {
    companion object {
        var view: View? = null // Holds reference to Activity!
    }
}

// View → Context → Activity
// Activity cannot be GC'd

// GOOD: Don't hold View references
// Or use WeakReference if needed
class NonLeaky {
    companion object {
        var viewRef: WeakReference<View>? = null
    }
}
```

### Handler References

```kotlin
// BAD: Handler with implicit reference
class LeakyActivity : AppCompatActivity() {
    private val handler = Handler { message ->
        // Handler holds implicit reference to Activity
        // Activity cannot be GC'd if messages pending
        true
    }
}

// GOOD: Use static Handler or WeakReference
class NonLeakyActivity : AppCompatActivity() {
    private class MyHandler(activity: NonLeakyActivity) : Handler() {
        private val activityRef = WeakReference(activity)
        
        override fun handleMessage(msg: Message) {
            activityRef.get()?.let { activity ->
                // Use activity
            }
        }
    }
}
```

## Real Code Examples

### Example 1: Memory-Efficient Cache

```kotlin
class MemoryEfficientCache<K, V> {
    private val cache = LinkedHashMap<K, SoftReference<V>>()
    private val maxSize = 100
    
    fun put(key: K, value: V) {
        // Remove null references
        cache.values.removeAll { it.get() == null }
        
        // Remove oldest if at capacity
        if (cache.size >= maxSize && !cache.containsKey(key)) {
            val firstKey = cache.keys.first()
            cache.remove(firstKey)
        }
        
        cache[key] = SoftReference(value)
    }
    
    fun get(key: K): V? {
        val softRef = cache[key] ?: return null
        val value = softRef.get()
        
        if (value == null) {
            cache.remove(key) // Clean up
        }
        
        return value
    }
}

// Benefits:
// - Objects kept while memory available
// - Automatically cleared when memory pressure
// - No manual cache management needed
```

### Example 2: Listener Management

```kotlin
class SafeListenerManager {
    private val listeners = mutableListOf<WeakReference<Listener>>()
    
    fun addListener(listener: Listener) {
        // Remove GC'd listeners
        listeners.removeAll { it.get() == null }
        
        // Add new listener
        listeners.add(WeakReference(listener))
    }
    
    fun removeListener(listener: Listener) {
        listeners.removeAll { it.get() == listener }
    }
    
    fun notifyListeners() {
        // Remove GC'd listeners
        listeners.removeAll { it.get() == null }
        
        // Notify active listeners
        listeners.forEach { weakRef ->
            weakRef.get()?.onEvent()
        }
    }
}

// Benefits:
// - Listeners can be GC'd
// - No memory leaks
// - Automatic cleanup
```

## Common Pitfalls

### Problem: Holding Strong References

```kotlin
// BAD: Static strong reference
object Cache {
    val data = mutableMapOf<String, LargeObject>()
}

// Objects never GC'd
// Memory leak

// GOOD: Use appropriate reference type
object Cache {
    val data = mutableMapOf<String, SoftReference<LargeObject>>()
}

// Objects can be GC'd when memory needed
```

### Problem: Finalization for Critical Cleanup

```kotlin
// BAD: Relying on finalization
class FileHandler {
    private val file: File
    
    protected fun finalize() {
        file.close() // May never run!
    }
}

// GOOD: Explicit cleanup
class FileHandler : AutoCloseable {
    private val file: File
    
    override fun close() {
        file.close() // Guaranteed to run
    }
}
```

## Quiz

1. When is an object with only weak references GC'd?
   - **A)** Never
   - **B)** In next GC cycle
   - **C)** Only when memory pressure
   - **D)** After finalization

2. What is the main problem with finalization?
   - **A)** Too fast
   - **B)** Not guaranteed to run
   - **C)** Too expensive
   - **D)** Not available

3. When should you use SoftReference?
   - **A)** For listeners
   - **B)** For caching (keep while memory available)
   - **C)** For critical resources
   - **D)** Never

**Answers:**
1. **B** - Weak references allow GC in next cycle if no strong references
2. **B** - Finalization is not guaranteed to run, making it unreliable
3. **B** - SoftReference is ideal for caching where you want to keep objects while memory is available

## Next Steps

- [Garbage Collection Fundamentals](./08.%20Garbage%20Collection%20Fundamentals.md) - How GC works
- [Android GC & Memory Management](../03_advanced/28.%20Android%20GC%20%26%20Memory%20Management.md) - Android-specific GC

