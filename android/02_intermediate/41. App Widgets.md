---
number: 41
title: "App Widgets"
slug: "app-widgets"
level: "intermediate"
tags: ["widgets", "app-widgets", "home-screen", "remote-views"]
prerequisites: ["android-lifecycle-components"]
estimated_minutes: 80
contributors: []
diagrams: []
examples: []
canonical_id: "android-41"
---

# App Widgets

## Overview

App Widgets allow users to view and interact with your app's content directly from the home screen. This comprehensive guide covers creating widgets, widget configuration, updating widgets, widget layouts, widget providers, and best practices for building effective home screen widgets.

## Table of Contents

1. [What are App Widgets?](#what-are-widgets)
2. [Widget Components](#widget-components)
3. [Creating a Widget](#creating-widget)
4. [Widget Layouts](#widget-layouts)
5. [Widget Provider](#widget-provider)
6. [Updating Widgets](#updating-widgets)
7. [Widget Configuration](#widget-configuration)
8. [Widget Interactions](#widget-interactions)
9. [Best Practices](#best-practices)

## What are App Widgets?

### Definition

**App Widget**: Mini application view embedded in home screen

**Purpose**: Display app content without opening app

**Characteristics**:
- **Home Screen**: Shown on home screen
- **Updates**: Can update periodically
- **Interactions**: Can handle clicks, touches
- **Limited UI**: Restricted set of views

### Widget Types

**1. Information Widgets**:
- Display information (weather, time, news)
- Read-only or minimal interaction

**2. Collection Widgets**:
- Display collections (list, grid)
- Scrollable content

**3. Control Widgets**:
- Control app functions (music player, settings)
- Buttons, toggles

**4. Hybrid Widgets**:
- Combination of above types

## Widget Components

### Required Components

**1. AppWidgetProvider**:
- BroadcastReceiver subclass
- Handles widget lifecycle events
- Updates widget content

**2. Widget Layout**:
- XML layout file
- Limited views supported
- RemoteViews compatible

**3. Widget Metadata**:
- XML configuration file
- Widget size, update frequency, etc.

**4. Widget Configuration Activity** (Optional):
- Setup screen for widget
- Runs when widget added

## Creating a Widget

### Step 1: Create Widget Layout

**res/layout/widget_layout.xml**:
```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical"
    android:padding="8dp"
    android:background="@drawable/widget_background">
    
    <TextView
        android:id="@+id/widget_title"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Widget Title"
        android:textSize="16sp"
        android:textStyle="bold" />
    
    <TextView
        android:id="@+id/widget_content"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Widget Content"
        android:textSize="14sp" />
    
    <Button
        android:id="@+id/widget_button"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Update" />
</LinearLayout>
```

### Step 2: Create Widget Metadata

**res/xml/widget_info.xml**:
```xml
<?xml version="1.0" encoding="utf-8"?>
<appwidget-provider xmlns:android="http://schemas.android.com/apk/res/android"
    android:minWidth="110dp"
    android:minHeight="110dp"
    android:updatePeriodMillis="1800000"
    android:previewImage="@drawable/widget_preview"
    android:initialLayout="@layout/widget_layout"
    android:resizeMode="horizontal|vertical"
    android:widgetCategory="home_screen"
    android:description="@string/widget_description" />
```

**Attributes**:
- **minWidth/minHeight**: Minimum widget size
- **updatePeriodMillis**: Update frequency (minimum 30 minutes)
- **previewImage**: Preview shown in widget picker
- **initialLayout**: Layout to show initially
- **resizeMode**: How widget can be resized
- **widgetCategory**: Where widget can be placed

### Step 3: Create Widget Provider

```kotlin
class MyWidgetProvider : AppWidgetProvider() {
    override fun onUpdate(
        context: Context,
        appWidgetManager: AppWidgetManager,
        appWidgetIds: IntArray
    ) {
        // Update all widget instances
        for (appWidgetId in appWidgetIds) {
            updateWidget(context, appWidgetManager, appWidgetId)
        }
    }
    
    private fun updateWidget(
        context: Context,
        appWidgetManager: AppWidgetManager,
        appWidgetId: Int
    ) {
        val views = RemoteViews(context.packageName, R.layout.widget_layout)
        
        // Update views
        views.setTextViewText(R.id.widget_title, "Updated Title")
        views.setTextViewText(R.id.widget_content, "Updated Content")
        
        // Set click intent
        val intent = Intent(context, MainActivity::class.java)
        val pendingIntent = PendingIntent.getActivity(
            context,
            0,
            intent,
            PendingIntent.FLAG_IMMUTABLE
        )
        views.setOnClickPendingIntent(R.id.widget_button, pendingIntent)
        
        // Update widget
        appWidgetManager.updateAppWidget(appWidgetId, views)
    }
    
    override fun onEnabled(context: Context) {
        // First widget instance added
    }
    
    override fun onDisabled(context: Context) {
        // Last widget instance removed
    }
    
    override fun onDeleted(context: Context, appWidgetIds: IntArray) {
        // Widget instance deleted
    }
    
    override fun onAppWidgetOptionsChanged(
        context: Context,
        appWidgetManager: AppWidgetManager,
        appWidgetId: Int,
        newOptions: Bundle?
    ) {
        // Widget resized
        updateWidget(context, appWidgetManager, appWidgetId)
    }
}
```

### Step 4: Register in Manifest

```xml
<receiver
    android:name=".MyWidgetProvider"
    android:exported="true">
    <intent-filter>
        <action android:name="android.appwidget.action.APPWIDGET_UPDATE" />
    </intent-filter>
    <meta-data
        android:name="android.appwidget.provider"
        android:resource="@xml/widget_info" />
</receiver>
```

## Widget Layouts

### Supported Views

**Supported Views**:
- **FrameLayout**
- **LinearLayout**
- **RelativeLayout**
- **GridLayout**
- **TextView**
- **ImageView**
- **Button**
- **ProgressBar**
- **AnalogClock**
- **DigitalClock**
- **Chronometer**

**Not Supported**:
- **RecyclerView** (use ListView for collections)
- **WebView**
- **VideoView**
- **Custom Views**

### Layout Best Practices

**1. Use dp for Sizes**:
```xml
<TextView
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:textSize="14sp"
    android:padding="8dp" />
```

**2. Support Multiple Sizes**:
```xml
<!-- Small widget -->
<LinearLayout
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical">
    <!-- Minimal content -->
</LinearLayout>

<!-- Large widget -->
<!-- Show more content -->
```

**3. Use RemoteViews Efficiently**:
```kotlin
// GOOD: Update only changed views
views.setTextViewText(R.id.widget_title, newTitle)

// BAD: Recreate entire layout
val views = RemoteViews(context.packageName, R.layout.widget_layout)
```

## Widget Provider

### AppWidgetProvider Lifecycle

**onUpdate()**: Called when widget needs update
**onEnabled()**: First widget instance added
**onDisabled()**: Last widget instance removed
**onDeleted()**: Widget instance deleted
**onAppWidgetOptionsChanged()**: Widget resized

### Update Widget

```kotlin
override fun onUpdate(
    context: Context,
    appWidgetManager: AppWidgetManager,
    appWidgetIds: IntArray
) {
    for (appWidgetId in appWidgetIds) {
        val views = RemoteViews(context.packageName, R.layout.widget_layout)
        
        // Update content
        updateWidgetContent(context, views)
        
        // Update widget
        appWidgetManager.updateAppWidget(appWidgetId, views)
    }
}

private fun updateWidgetContent(context: Context, views: RemoteViews) {
    // Fetch data
    val data = fetchData()
    
    // Update views
    views.setTextViewText(R.id.widget_title, data.title)
    views.setTextViewText(R.id.widget_content, data.content)
    
    // Update image
    val bitmap = loadImage(data.imageUrl)
    views.setImageViewBitmap(R.id.widget_image, bitmap)
}
```

## Updating Widgets

### Automatic Updates

**updatePeriodMillis**:
- Minimum: 30 minutes (1800000 ms)
- System may delay updates
- Battery impact

```xml
<appwidget-provider
    android:updatePeriodMillis="1800000" />
```

### Manual Updates

**Update Single Widget**:
```kotlin
val appWidgetManager = AppWidgetManager.getInstance(context)
val views = RemoteViews(context.packageName, R.layout.widget_layout)
// Update views
appWidgetManager.updateAppWidget(widgetId, views)
```

**Update All Widgets**:
```kotlin
val intent = Intent(context, MyWidgetProvider::class.java)
intent.action = AppWidgetManager.ACTION_APPWIDGET_UPDATE
intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_IDS, widgetIds)
context.sendBroadcast(intent)
```

### Background Updates

**Use WorkManager**:
```kotlin
class WidgetUpdateWorker(context: Context, params: WorkerParameters) :
    Worker(context, params) {
    
    override fun doWork(): Result {
        val appWidgetManager = AppWidgetManager.getInstance(context)
        val widgetIds = getWidgetIds()
        
        for (widgetId in widgetIds) {
            updateWidget(context, appWidgetManager, widgetId)
        }
        
        return Result.success()
    }
}

// Schedule updates
WorkManager.getInstance(context)
    .enqueuePeriodicWork(
        PeriodicWorkRequestBuilder<WidgetUpdateWorker>(30, TimeUnit.MINUTES)
            .build()
    )
```

## Widget Configuration

### Configuration Activity

**Create Configuration Activity**:
```kotlin
class WidgetConfigActivity : AppCompatActivity() {
    private var appWidgetId = AppWidgetManager.INVALID_APPWIDGET_ID
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        
        // Get widget ID
        appWidgetId = intent.getIntExtra(
            AppWidgetManager.EXTRA_APPWIDGET_ID,
            AppWidgetManager.INVALID_APPWIDGET_ID
        )
        
        // If no valid widget ID, finish
        if (appWidgetId == AppWidgetManager.INVALID_APPWIDGET_ID) {
            finish()
            return
        }
        
        setContentView(R.layout.activity_widget_config)
        
        // Setup configuration UI
        setupConfiguration()
    }
    
    private fun setupConfiguration() {
        buttonSave.setOnClickListener {
            // Save configuration
            saveConfiguration()
            
            // Update widget
            updateWidget()
            
            // Finish configuration
            val resultValue = Intent().apply {
                putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, appWidgetId)
            }
            setResult(RESULT_OK, resultValue)
            finish()
        }
    }
    
    private fun saveConfiguration() {
        val prefs = getSharedPreferences("widget_prefs", MODE_PRIVATE)
        prefs.edit().apply {
            putString("widget_$appWidgetId", "config_value")
            apply()
        }
    }
    
    private fun updateWidget() {
        val appWidgetManager = AppWidgetManager.getInstance(this)
        MyWidgetProvider.updateAppWidget(this, appWidgetManager, appWidgetId)
    }
}
```

**Register Configuration Activity**:
```xml
<activity
    android:name=".WidgetConfigActivity"
    android:exported="false">
    <intent-filter>
        <action android:name="android.appwidget.action.APPWIDGET_CONFIGURE" />
    </intent-filter>
</activity>
```

**Add to Widget Metadata**:
```xml
<appwidget-provider
    android:configure="com.example.app.WidgetConfigActivity" />
```

## Widget Interactions

### Click Events

**Single Click**:
```kotlin
val intent = Intent(context, MainActivity::class.java)
val pendingIntent = PendingIntent.getActivity(
    context,
    0,
    intent,
    PendingIntent.FLAG_IMMUTABLE
)
views.setOnClickPendingIntent(R.id.widget_button, pendingIntent)
```

**Different Clicks for Different Views**:
```kotlin
// Button click
val buttonIntent = Intent(context, MainActivity::class.java)
buttonIntent.putExtra("action", "button_click")
views.setOnClickPendingIntent(R.id.widget_button, 
    PendingIntent.getActivity(context, 0, buttonIntent, PendingIntent.FLAG_IMMUTABLE))

// Title click
val titleIntent = Intent(context, DetailActivity::class.java)
views.setOnClickPendingIntent(R.id.widget_title,
    PendingIntent.getActivity(context, 1, titleIntent, PendingIntent.FLAG_IMMUTABLE))
```

### Collection Widgets

**ListView Widget**:
```kotlin
class ListWidgetProvider : AppWidgetProvider() {
    override fun onUpdate(context: Context, appWidgetManager: AppWidgetManager, appWidgetIds: IntArray) {
        for (appWidgetId in appWidgetIds) {
            val views = RemoteViews(context.packageName, R.layout.list_widget_layout)
            
            // Set adapter
            val intent = Intent(context, ListWidgetService::class.java)
            intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, appWidgetId)
            intent.data = Uri.parse(intent.toUri(Intent.URI_INTENT_SCHEME))
            views.setRemoteAdapter(R.id.list_view, intent)
            
            // Set empty view
            views.setEmptyView(R.id.list_view, R.id.empty_view)
            
            // Set click template
            val clickIntent = Intent(context, MainActivity::class.java)
            val clickPendingIntent = PendingIntent.getActivity(
                context,
                0,
                clickIntent,
                PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
            )
            views.setPendingIntentTemplate(R.id.list_view, clickPendingIntent)
            
            appWidgetManager.updateAppWidget(appWidgetId, views)
        }
    }
}
```

**RemoteViewsService**:
```kotlin
class ListWidgetService : RemoteViewsService() {
    override fun onGetViewFactory(intent: Intent): RemoteViewsFactory {
        return ListRemoteViewsFactory(applicationContext, intent)
    }
}

class ListRemoteViewsFactory(
    private val context: Context,
    private val intent: Intent
) : RemoteViewsFactory {
    private val items = mutableListOf<Item>()
    
    override fun onCreate() {
        // Load data
        loadData()
    }
    
    override fun getViewAt(position: Int): RemoteViews {
        val views = RemoteViews(context.packageName, R.layout.list_item_widget)
        val item = items[position]
        
        views.setTextViewText(R.id.item_text, item.text)
        
        val fillInIntent = Intent().apply {
            putExtra("item_id", item.id)
        }
        views.setOnClickFillInIntent(R.id.item_text, fillInIntent)
        
        return views
    }
    
    override fun getCount(): Int = items.size
    
    // Other required methods...
}
```

## Best Practices

### Practice 1: Minimize Update Frequency

```kotlin
// GOOD: Update only when needed
fun updateWidgetWhenDataChanges() {
    val appWidgetManager = AppWidgetManager.getInstance(context)
    updateWidget(context, appWidgetManager, widgetId)
}

// BAD: Update too frequently
android:updatePeriodMillis="60000" // Every minute - battery drain
```

### Practice 2: Handle Widget Resizing

```kotlin
override fun onAppWidgetOptionsChanged(
    context: Context,
    appWidgetManager: AppWidgetManager,
    appWidgetId: Int,
    newOptions: Bundle?
) {
    val minWidth = newOptions?.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_WIDTH) ?: 0
    val minHeight = newOptions?.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_HEIGHT) ?: 0
    
    // Choose layout based on size
    val layoutId = when {
        minWidth > 200 -> R.layout.widget_large
        else -> R.layout.widget_small
    }
    
    val views = RemoteViews(context.packageName, layoutId)
    updateWidgetContent(context, views)
    appWidgetManager.updateAppWidget(appWidgetId, views)
}
```

### Practice 3: Use Background Tasks for Updates

```kotlin
// GOOD: Use WorkManager for updates
class WidgetUpdateWorker(context: Context, params: WorkerParameters) :
    Worker(context, params) {
    override fun doWork(): Result {
        updateAllWidgets(context)
        return Result.success()
    }
}

// BAD: Heavy work in onUpdate
override fun onUpdate(...) {
    val data = fetchDataFromNetwork() // Blocks!
    updateWidget(data)
}
```

### Practice 4: Cache Widget Data

```kotlin
// GOOD: Cache data
class WidgetDataCache {
    private var cachedData: WidgetData? = null
    private var lastUpdate: Long = 0
    
    fun getData(): WidgetData? {
        if (cachedData == null || System.currentTimeMillis() - lastUpdate > 60000) {
            cachedData = fetchData()
            lastUpdate = System.currentTimeMillis()
        }
        return cachedData
    }
}
```

## Real-World Examples

### Weather Widget

```kotlin
class WeatherWidgetProvider : AppWidgetProvider() {
    override fun onUpdate(context: Context, appWidgetManager: AppWidgetManager, appWidgetIds: IntArray) {
        for (appWidgetId in appWidgetIds) {
            val views = RemoteViews(context.packageName, R.layout.weather_widget)
            
            // Fetch weather data
            lifecycleScope.launch {
                val weather = weatherRepository.getCurrentWeather()
                
                // Update views
                views.setTextViewText(R.id.temperature, "${weather.temperature}Â°")
                views.setTextViewText(R.id.condition, weather.condition)
                views.setImageViewResource(R.id.weather_icon, weather.iconRes)
                
                // Update widget
                appWidgetManager.updateAppWidget(appWidgetId, views)
            }
        }
    }
}
```

## Common Pitfalls

### Problem: Widget Not Updating

```kotlin
// BAD: Not updating widget
override fun onUpdate(...) {
    // Empty - widget never updates
}

// GOOD: Update widget
override fun onUpdate(...) {
    updateWidget(context, appWidgetManager, appWidgetId)
}
```

### Problem: Heavy Work in onUpdate

```kotlin
// BAD: Network call in onUpdate
override fun onUpdate(...) {
    val data = api.getData() // Blocks!
    updateWidget(data)
}

// GOOD: Use background task
override fun onUpdate(...) {
    WorkManager.getInstance(context)
        .enqueue(OneTimeWorkRequestBuilder<UpdateWidgetWorker>().build())
}
```

## Quiz

1. What is the minimum update period for widgets?
   - **A)** 1 minute
   - **B)** 30 minutes
   - **C)** 1 hour
   - **D)** No minimum

2. What views are NOT supported in widgets?
   - **A)** TextView
   - **B)** RecyclerView
   - **C)** ImageView
   - **D)** Button

3. How do you handle widget clicks?
   - **A)** onClick listeners
   - **B)** PendingIntent with setOnClickPendingIntent
   - **C)** Touch events
   - **D)** Gesture detectors

**Answers:**
1. **B** - The minimum update period for widgets is 30 minutes (1800000 milliseconds) to prevent excessive battery drain
2. **B** - RecyclerView is not supported in widgets; use ListView with RemoteViewsService for collections
3. **B** - Widget clicks are handled using PendingIntent with setOnClickPendingIntent, as widgets use RemoteViews which don't support direct click listeners

## Next Steps

- [Android Services - Complete Guide](./35.%20Android%20Services%20-%20Complete%20Guide.md) - Background services
- [Broadcast Receivers](./37.%20Broadcast%20Receivers.md) - Widget provider extends BroadcastReceiver
- [WorkManager & Background Tasks](./13.%20WorkManager%20%26%20Background%20Tasks.md) - Widget updates

