---
number: 9
title: "Lock-Free Data Structures Implementation"
slug: "lock-free-data-structures-implementation"
level: "intermediate"
tags: ["concurrency", "lock-free", "wait-free", "data-structures", "atomic"]
prerequisites: ["lock-free-wait-free-algorithms"]
estimated_minutes: 125
contributors: []
diagrams: []
examples: []
canonical_id: "cs-conc-09"
---

# Lock-Free Data Structures Implementation

## Overview

Lock-free data structures provide concurrent access without traditional locks, using atomic operations and careful memory ordering. Understanding how to implement lock-free stacks, queues, and other data structures using CAS operations is essential for high-performance concurrent systems.

## Table of Contents

1. [Lock-Free Principles](#principles)
2. [Lock-Free Stack](#lock-free-stack)
3. [Lock-Free Queue](#lock-free-queue)
4. [ABA Problem](#aba-problem)
5. [Memory Reclamation](#memory-reclamation)
6. [Hazard Pointers](#hazard-pointers)
7. [Lock-Free Hash Table](#lock-free-hash)
8. [Real-World Examples](#examples)

## Lock-Free Principles

### What is Lock-Free?

**Lock-Free**: Progress guaranteed for some thread

**Property**: System makes progress even if some threads stall

**Method**: Atomic operations (CAS)

**Benefit**: No deadlocks, better performance

### Lock-Free vs Wait-Free

**Lock-Free**: At least one thread makes progress

**Wait-Free**: All threads make progress

**Wait-Free**: Stronger guarantee, harder to achieve

## Lock-Free Stack

### Stack Structure

**Stack**: LIFO (Last In First Out)

**Operations**: Push, Pop

**Challenge**: Concurrent push/pop without locks

### Lock-Free Stack Implementation

**Node Structure**:
```c
typedef struct Node {
    int data;
    struct Node* next;
} Node;

Node* top = NULL;  // Atomic pointer
```

**Push Operation**:
```c
void push(int value) {
    Node* new_node = malloc(sizeof(Node));
    new_node->data = value;
    
    do {
        new_node->next = atomic_load(&top);
    } while (!atomic_compare_exchange_weak(&top, &new_node->next, new_node));
}
```

**Pop Operation**:
```c
int pop() {
    Node* old_top;
    do {
        old_top = atomic_load(&top);
        if (old_top == NULL) {
            return -1;  // Empty
        }
    } while (!atomic_compare_exchange_weak(&top, &old_top, old_top->next));
    
    int value = old_top->data;
    free(old_top);  // Memory reclamation issue!
    return value;
}
```

## Lock-Free Queue

### Queue Structure

**Queue**: FIFO (First In First Out)

**Operations**: Enqueue, Dequeue

**Challenge**: Concurrent enqueue/dequeue

### Michael & Scott Queue

**Structure**: Two pointers (head, tail)

**Head**: Points to dummy node

**Tail**: Points to last node

**Implementation**:
```c
typedef struct Node {
    int data;
    struct Node* next;
} Node;

typedef struct Queue {
    Node* head;  // Atomic
    Node* tail;  // Atomic
} Queue;

void enqueue(Queue* q, int value) {
    Node* new_node = malloc(sizeof(Node));
    new_node->data = value;
    new_node->next = NULL;
    
    Node* prev_tail;
    do {
        prev_tail = atomic_load(&q->tail);
    } while (!atomic_compare_exchange_weak(&q->tail, &prev_tail, new_node));
    
    prev_tail->next = new_node;
}

int dequeue(Queue* q) {
    Node* head;
    Node* next;
    int value;
    
    do {
        head = atomic_load(&q->head);
        next = head->next;
        if (next == NULL) {
            return -1;  // Empty
        }
        value = next->data;
    } while (!atomic_compare_exchange_weak(&q->head, &head, next));
    
    free(head);  // Memory reclamation issue!
    return value;
}
```

## ABA Problem

### What is ABA Problem?

**ABA**: Value changes A → B → A

**Problem**: CAS sees same value, but structure changed

**Example**:
```
Thread 1: Read top = A
Thread 2: Pop A, push B, push A
Thread 1: CAS sees A, succeeds
But structure changed!
```

### Solutions

**1. Tagged Pointers**:
```
Add version number to pointer
Detect ABA
```

**2. Hazard Pointers**:
```
Protect nodes from reclamation
```

**3. RCU** (Read-Copy-Update):
```
Delay memory reclamation
```

## Memory Reclamation

### The Problem

**Problem**: When to free memory?

**Challenge**: Other threads may still reference node

**Solutions**: 
- **Hazard Pointers**: Protect nodes
- **Epoch-Based**: Delay reclamation
- **RCU**: Read-copy-update

### Hazard Pointers

**Method**: Thread declares which nodes it's accessing

**Process**:
```
1. Before accessing node: Set hazard pointer
2. Access node
3. Clear hazard pointer
4. Reclaimer checks hazard pointers before freeing
```

**Benefit**: Safe memory reclamation

## Lock-Free Hash Table

### Challenge

**Hash Table**: More complex than stack/queue

**Operations**: Insert, Delete, Lookup

**Challenge**: Resizing, concurrent operations

### Lock-Free Hash Table

**Approach**: 
- **Lock-Free Buckets**: Each bucket lock-free
- **Read-Copy-Update**: For resizing
- **Atomic Operations**: For updates

**Complexity**: Very complex

## Real-World Examples

### Example 1: Lock-Free Stack

**Use**: Task stealing, work queues

**Benefit**: High performance

### Example 2: Lock-Free Queue

**Use**: Producer-consumer, message queues

**Benefit**: Low latency

## Common Pitfalls

### Problem: Memory Reclamation

```c
// BAD: Free immediately
free(node);  // Other threads may access!

// GOOD: Use hazard pointers or RCU
// Delay reclamation until safe
```

### Problem: ABA Problem

```c
// BAD: Simple CAS
// May have ABA problem

// GOOD: Use tagged pointers
// Or hazard pointers
```

## Quiz

1. What is lock-free?
   - **A)** No locks used
   - **B)** Progress guaranteed for some thread using atomic operations
   - **C)** Faster than locked
   - **D)** Simpler than locked

2. What is the ABA problem?
   - **A)** Memory issue
   - **B)** Value changes A→B→A, CAS sees same value but structure changed
   - **C)** Lock issue
   - **D)** Thread issue

3. What are hazard pointers?
   - **A)** Dangerous pointers
   - **B)** Mechanism to protect nodes from reclamation during access
   - **C)** Invalid pointers
   - **D)** Null pointers

**Answers:**
1. **B** - Lock-free means at least one thread is guaranteed to make progress using atomic operations (like CAS), without traditional locks
2. **B** - The ABA problem occurs when a value changes from A to B and back to A, causing CAS to succeed even though the data structure has changed
3. **B** - Hazard pointers are a memory reclamation technique where threads declare which nodes they're accessing, preventing those nodes from being freed

## Next Steps

- [Parallel Algorithms](./10.%20Parallel%20Algorithms%20-%20Sort%20%26%20Search.md) - Parallel computation
- [GPU Parallel Programming](../03_advanced/01.%20GPU%20Parallel%20Programming.md) - GPU computing
