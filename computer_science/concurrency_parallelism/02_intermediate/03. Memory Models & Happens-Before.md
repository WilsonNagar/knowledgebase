---
number: 3
title: "Memory Models & Happens-Before"
slug: "memory-models-happens-before"
level: "intermediate"
tags: ["concurrency", "memory-models", "happens-before", "memory-ordering", "consistency"]
prerequisites: ["atomic-operations-cas"]
estimated_minutes: 110
contributors: []
diagrams: []
examples: []
canonical_id: "cs-conc-03"
---

# Memory Models & Happens-Before

## Overview

Memory models define how memory operations are ordered and visible across threads. Understanding memory models, happens-before relationships, and memory ordering guarantees is essential for writing correct concurrent code and understanding why some code works while similar code fails.

## Table of Contents

1. [The Memory Model Problem](#problem)
2. [What is a Memory Model?](#what-is-memory-model)
3. [Sequential Consistency](#sequential-consistency)
4. [Happens-Before Relationship](#happens-before)
5. [Memory Ordering](#memory-ordering)
6. [C11/C++11 Memory Model](#c11-memory-model)
7. [Java Memory Model](#java-memory-model)
8. [Common Pitfalls](#pitfalls)

## The Memory Model Problem

### The Challenge

**Multithreaded Programs**: Multiple threads access shared memory

**Problem**: What order do threads see memory operations?

**Example**:
```c
// Thread 1
x = 1;
y = 2;

// Thread 2
if (y == 2) {
    assert(x == 1); // May fail!
}
```

**Why**: CPU and compiler may reorder instructions

### Why Reordering Happens

**1. CPU Optimizations**:
- **Out-of-order execution**: Execute instructions out of order
- **Store buffers**: Write to buffer, commit later
- **Cache coherence**: May see stale values

**2. Compiler Optimizations**:
- **Instruction reordering**: Reorder for performance
- **Register allocation**: Keep values in registers
- **Dead code elimination**: Remove unused code

## What is a Memory Model?

### Definition

**Memory Model**: Defines allowed reorderings and visibility

**Purpose**: Specify what orderings are guaranteed

**Guarantees**: What threads can assume about memory

### Memory Model Components

**1. Ordering Guarantees**:
- **What orderings**: Are guaranteed
- **What reorderings**: Are allowed

**2. Visibility Guarantees**:
- **When writes**: Become visible
- **When reads**: See writes

**3. Atomicity Guarantees**:
- **What operations**: Are atomic
- **What guarantees**: Are provided

## Sequential Consistency

### What is Sequential Consistency?

**Sequential Consistency**: Strongest memory model

**Property**: All operations appear in program order

**Effect**: As if single global order

### Sequential Consistency Example

**Code**:
```c
// Thread 1
x = 1;
y = 2;

// Thread 2
a = y;
b = x;
```

**Possible Outcomes** (Sequential Consistency):
```
All threads see same order:
  x=1, y=2, a=y, b=x → a=2, b=1
  y=2, x=1, a=y, b=x → a=2, b=1
  x=1, a=y, y=2, b=x → a=0, b=1
  etc.
```

**Guarantee**: All threads see consistent order

### Sequential Consistency Cost

**Performance**: Expensive

**Why**: Limits optimizations

**Use**: Rarely used in practice (too slow)

## Happens-Before Relationship

### Definition

**Happens-Before (→)**: Partial ordering of operations

**Property**: If A → B, then A appears before B to all threads

### Happens-Before Rules

**1. Program Order**:
```
Operations in same thread: A → B if A before B
```

**2. Synchronization**:
```
Unlock → Lock (same mutex)
Release → Acquire (atomic)
```

**3. Transitivity**:
```
If A → B and B → C, then A → C
```

### Happens-Before Example

```c
// Thread 1
x = 1;           // (1)
mutex_unlock(m); // (2)

// Thread 2
mutex_lock(m);   // (3)
y = x;           // (4)

Happens-Before:
  (1) → (2) → (3) → (4)
  
Guarantee: y = 1 (always)
```

## Memory Ordering

### Memory Ordering Models

**1. Sequential Consistency**:
- **Strongest**: All operations in program order
- **Cost**: Expensive

**2. Acquire-Release**:
- **Acquire**: All reads after see writes before release
- **Release**: All writes before visible after acquire
- **Balance**: Good performance/guarantee balance

**3. Relaxed**:
- **Weakest**: No ordering guarantees
- **Use**: Counters, flags

### Acquire-Release Semantics

**Acquire**:
```
All memory operations after acquire
  see all memory operations before release
```

**Release**:
```
All memory operations before release
  visible to all operations after acquire
```

**Example**:
```c
// Thread 1
data = 42;                    // (1)
atomic_store(&flag, 1, release); // (2)

// Thread 2
if (atomic_load(&flag, acquire) == 1) { // (3)
    assert(data == 42);      // (4) Always true!
}
```

## C11/C++11 Memory Model

### Memory Ordering Options

**memory_order_seq_cst** (Sequential Consistency):
```c
atomic_store(&x, 1, memory_order_seq_cst);
```

**memory_order_acq_rel** (Acquire-Release):
```c
atomic_store(&x, 1, memory_order_release);
int val = atomic_load(&y, memory_order_acquire);
```

**memory_order_relaxed** (Relaxed):
```c
atomic_store(&x, 1, memory_order_relaxed);
```

### C11 Example

```c
atomic_int flag = ATOMIC_VAR_INIT(0);
int data = 0;

// Thread 1
data = 42;
atomic_store_explicit(&flag, 1, memory_order_release);

// Thread 2
if (atomic_load_explicit(&flag, memory_order_acquire) == 1) {
    // data is guaranteed to be 42
    printf("%d\n", data);
}
```

## Java Memory Model

### Java Happens-Before

**Rules**:
- **Program order**: Operations in same thread
- **Monitor lock**: Unlock → Lock
- **Volatile**: Volatile write → Volatile read
- **Thread start**: Thread.start() → First operation in thread
- **Thread join**: Last operation → Thread.join()

### Volatile in Java

**Volatile**: Provides happens-before

**Properties**:
- **Visibility**: Writes visible to all threads
- **Ordering**: Prevents reordering

**Example**:
```java
// Thread 1
data = 42;
volatileFlag = true; // Volatile write

// Thread 2
if (volatileFlag) { // Volatile read
    // data guaranteed to be 42
    System.out.println(data);
}
```

## Common Pitfalls

### Problem: Data Races

```c
// BAD: Data race
int x = 0;

// Thread 1
x = 1; // No synchronization

// Thread 2
int y = x; // May read 0 or 1 (undefined!)

// GOOD: Use synchronization
atomic_int x = ATOMIC_VAR_INIT(0);

// Thread 1
atomic_store(&x, 1, memory_order_release);

// Thread 2
int y = atomic_load(&x, memory_order_acquire);
```

### Problem: Assuming Sequential Consistency

```c
// BAD: Assume sequential consistency
x = 1;
y = 2;
// Compiler/CPU may reorder!

// GOOD: Use memory ordering
atomic_store(&x, 1, memory_order_release);
atomic_store(&y, 2, memory_order_release);
```

### Problem: Ignoring Visibility

```c
// BAD: Assume immediate visibility
x = 42;
// Other thread may not see immediately

// GOOD: Use synchronization
atomic_store(&x, 42, memory_order_release);
// Other thread uses acquire to see
```

## Real-World Examples

### Example 1: Double-Checked Locking

**Pattern**: Lazy initialization

**Wrong**:
```c
if (instance == NULL) {
    lock();
    if (instance == NULL) {
        instance = malloc(...);
    }
    unlock();
}
// Problem: instance may not be fully initialized
```

**Correct**:
```c
if (atomic_load(&instance, memory_order_acquire) == NULL) {
    lock();
    if (atomic_load(&instance, memory_order_acquire) == NULL) {
        void* new_instance = malloc(...);
        atomic_store(&instance, new_instance, memory_order_release);
    }
    unlock();
}
```

### Example 2: Producer-Consumer

**Pattern**: Producer writes, consumer reads

**Correct**:
```c
// Producer
data[i] = value;
atomic_store(&write_index, i + 1, memory_order_release);

// Consumer
int index = atomic_load(&write_index, memory_order_acquire);
if (index > read_index) {
    value = data[read_index]; // Guaranteed to see write
}
```

## Quiz

1. What is a memory model?
   - **A)** Physical memory layout
   - **B)** Defines allowed reorderings and visibility guarantees for memory operations
   - **C)** Memory allocation strategy
   - **D)** Cache organization

2. What is happens-before relationship?
   - **A)** Physical time ordering
   - **B)** Partial ordering ensuring if A happens-before B, A appears before B to all threads
   - **C)** Message ordering
   - **D)** Process ordering

3. What is the main advantage of acquire-release over sequential consistency?
   - **A)** Simpler
   - **B)** Better performance while still providing useful ordering guarantees
   - **C)** More secure
   - **D)** More memory

**Answers:**
1. **B** - A memory model defines what reorderings of memory operations are allowed and what visibility guarantees are provided to threads
2. **B** - Happens-before is a partial ordering: if operation A happens-before B, then A is guaranteed to appear before B to all threads
3. **B** - Acquire-release provides better performance than sequential consistency while still ensuring that operations before a release are visible to operations after an acquire

## Next Steps

- [Thread Pools & Executors](./04.%20Thread%20Pools%20%26%20Executors.md) - Thread management
- [Deadlocks, Livelocks & Starvation](./05.%20Deadlocks%2C%20Livelocks%20%26%20Starvation.md) - Concurrency problems

