---
number: 7
title: "Actors Model - Akka & Erlang"
slug: "actors-model-akka-erlang"
level: "intermediate"
tags: ["concurrency", "actors", "akka", "erlang", "message-passing"]
prerequisites: ["race-condition-detection"]
estimated_minutes: 120
contributors: []
diagrams: []
examples: []
canonical_id: "cs-conc-07"
---

# Actors Model - Akka & Erlang

## Overview

The Actors model is a concurrency paradigm based on message passing between independent actors. Understanding the actor model, how it avoids shared state, and implementations like Akka (Scala/Java) and Erlang is essential for building highly concurrent, fault-tolerant systems.

## Table of Contents

1. [What is the Actor Model?](#what-is-actor-model)
2. [Actor Model Principles](#principles)
3. [Message Passing](#message-passing)
4. [Actor Lifecycle](#lifecycle)
5. [Akka Framework](#akka)
6. [Erlang/OTP](#erlang)
7. [Supervision & Fault Tolerance](#supervision)
8. [Applications](#applications)

## What is the Actor Model?

### Definition

**Actor**: Independent computational entity

**Properties**:
- **Isolated**: No shared state
- **Asynchronous**: Messages sent asynchronously
- **Concurrent**: Many actors run concurrently

**Communication**: Message passing only

### Actor Model Benefits

**1. No Shared State**:
```
Actors don't share memory
Eliminates data races
```

**2. Location Transparency**:
```
Actors can be local or remote
Same programming model
```

**3. Fault Tolerance**:
```
Actor failures isolated
System continues operating
```

**4. Scalability**:
```
Easy to distribute actors
Scale horizontally
```

## Actor Model Principles

### Core Principles

**1. Encapsulation**:
```
Actor encapsulates state
Only actor can modify its state
```

**2. Message Passing**:
```
Actors communicate via messages
No direct method calls
```

**3. Asynchronous**:
```
Messages sent asynchronously
Non-blocking
```

**4. No Shared State**:
```
Actors don't share memory
Prevents races
```

### Actor Behavior

**State**: Private to actor

**Behavior**: Function processing messages

**Mailbox**: Queue of incoming messages

**Process**: 
```
1. Receive message from mailbox
2. Process message (update state)
3. Send messages to other actors
4. Repeat
```

## Message Passing

### Message Types

**1. Fire-and-Forget**:
```
Send message, don't wait for reply
```

**2. Request-Response**:
```
Send message, wait for reply
```

**3. Ask Pattern**:
```
Send message, get Future
```

### Message Delivery

**Guarantees**:
- **At-Most-Once**: Message delivered at most once
- **Ordering**: Messages from same sender ordered

**No Guarantee**:
- **Delivery**: Messages may be lost
- **Ordering**: Messages from different senders unordered

## Actor Lifecycle

### Lifecycle States

**1. Created**: Actor created

**2. Started**: Actor started, processing messages

**3. Stopped**: Actor stopped, no longer processing

**4. Restarted**: Actor restarted (on failure)

### Lifecycle Hooks

**PreStart**: Called before actor starts

**PostStop**: Called after actor stops

**PreRestart**: Called before restart

**PostRestart**: Called after restart

## Akka Framework

### What is Akka?

**Akka**: Actor framework for JVM

**Languages**: Scala, Java

**Features**: 
- **Actors**: Actor model implementation
- **Supervision**: Fault tolerance
- **Clustering**: Distributed actors
- **Streams**: Reactive streams

### Akka Actor Example

**Scala**:
```scala
import akka.actor.{Actor, ActorRef, ActorSystem, Props}

class CounterActor extends Actor {
  var count = 0
  
  def receive = {
    case "increment" => count += 1
    case "decrement" => count -= 1
    case "get" => sender() ! count
  }
}

// Usage
val system = ActorSystem("MySystem")
val counter = system.actorOf(Props[CounterActor], "counter")

counter ! "increment"  // Fire-and-forget
counter ! "get"         // Request
```

**Java**:
```java
public class CounterActor extends AbstractActor {
    private int count = 0;
    
    @Override
    public Receive createReceive() {
        return receiveBuilder()
            .matchEquals("increment", msg -> count++)
            .matchEquals("decrement", msg -> count--)
            .matchEquals("get", msg -> getSender().tell(count, getSelf()))
            .build();
    }
}
```

### Akka Supervision

**Supervisor**: Manages child actors

**Strategy**: What to do on failure

**Strategies**:
- **Restart**: Restart actor
- **Resume**: Continue processing
- **Stop**: Stop actor
- **Escalate**: Escalate to parent

## Erlang/OTP

### What is Erlang?

**Erlang**: Functional language with actors

**OTP**: Open Telecom Platform (framework)

**Features**:
- **Actors**: Processes (lightweight)
- **Message Passing**: Native support
- **Fault Tolerance**: "Let it crash" philosophy
- **Hot Code Swapping**: Update code without downtime

### Erlang Process Example

```erlang
-module(counter).
-export([start/0, increment/1, get/1]).

start() ->
    spawn(fun() -> loop(0) end).

loop(Count) ->
    receive
        {increment, Pid} ->
            Pid ! {ok, Count + 1},
            loop(Count + 1);
        {get, Pid} ->
            Pid ! {count, Count},
            loop(Count);
        stop ->
            ok
    end.

increment(Pid) ->
    Pid ! {increment, self()},
    receive
        {ok, NewCount} -> NewCount
    end.

get(Pid) ->
    Pid ! {get, self()},
    receive
        {count, Count} -> Count
    end.
```

### Erlang OTP Behaviors

**GenServer**: Generic server behavior

**Supervisor**: Supervision tree

**Application**: Application structure

**Use**: Build robust systems

## Supervision & Fault Tolerance

### Supervision Trees

**Structure**: Hierarchical supervision

**Parent**: Supervises children

**Children**: Worker actors

**Benefit**: Isolated failures

### Supervision Strategies

**1. One-for-One**:
```
Restart only failed child
```

**2. All-for-One**:
```
Restart all children if one fails
```

**3. One-for-All**:
```
Restart all siblings
```

### Fault Tolerance

**"Let it Crash"**:
```
Don't try to handle all errors
Let actor crash, supervisor handles
```

**Benefit**: Simpler error handling

**Recovery**: Supervisor restarts actor

## Applications

### Application 1: Chat Systems

**Use**: Real-time messaging

**Actors**: One per user

**Benefit**: Isolated user state

### Application 2: Game Servers

**Use**: Multiplayer games

**Actors**: One per game session

**Benefit**: Isolated game state

### Application 3: Distributed Systems

**Use**: Microservices

**Actors**: Service instances

**Benefit**: Location transparency

## Real-World Examples

### Example 1: WhatsApp

**Use**: Erlang for messaging

**Actors**: Handle millions of connections

**Benefit**: Fault tolerance, scalability

### Example 2: Akka Streams

**Use**: Reactive data processing

**Actors**: Process streams

**Benefit**: Backpressure handling

## Common Pitfalls

### Problem: Blocking Operations

```scala
// BAD: Blocking in actor
def receive = {
  case msg => 
    val result = blockingCall()  // Blocks thread!
}

// GOOD: Use Future or separate actor
def receive = {
  case msg =>
    val future = Future(blockingCall())
    future.pipeTo(sender())
}
```

### Problem: Shared Mutable State

```scala
// BAD: Share state between actors
var sharedState = 0  // Race condition!

// GOOD: Each actor has own state
class Actor extends AbstractActor {
  private var state = 0  // Private
}
```

## Quiz

1. What is the Actor Model?
   - **A)** Thread model
   - **B)** Concurrency model based on message passing between isolated actors
   - **C)** Process model
   - **D)** Shared memory model

2. What is the main advantage of actors?
   - **A)** Faster execution
   - **B)** No shared state eliminates data races and enables fault tolerance
   - **C)** Less memory
   - **D)** Simpler code

3. What is supervision in actor systems?
   - **A)** Monitoring
   - **B)** Hierarchical management where supervisors handle actor failures
   - **C)** Control
   - **D)** Scheduling

**Answers:**
1. **B** - The Actor Model is a concurrency paradigm where independent computational entities (actors) communicate only through asynchronous message passing, with no shared state
2. **B** - Actors eliminate data races by avoiding shared state, and their isolation enables fault tolerance where failures don't cascade
3. **B** - Supervision is a hierarchical fault-tolerance mechanism where supervisor actors manage child actors and decide how to handle failures (restart, stop, escalate)

## Next Steps

- [Multithreaded Debugging Techniques](./08.%20Multithreaded%20Debugging%20Techniques.md) - Debugging concurrency
- [Lock-Free Data Structures Implementation](./09.%20Lock-Free%20Data%20Structures%20Implementation.md) - Lock-free implementations

