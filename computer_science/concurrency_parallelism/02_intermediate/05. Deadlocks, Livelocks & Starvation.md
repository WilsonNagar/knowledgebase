---
number: 5
title: "Deadlocks, Livelocks & Starvation"
slug: "deadlocks-livelocks-starvation"
level: "intermediate"
tags: ["concurrency", "deadlocks", "livelocks", "starvation", "synchronization"]
prerequisites: ["thread-pools-executors"]
estimated_minutes: 110
contributors: []
diagrams: []
examples: []
canonical_id: "cs-conc-05"
---

# Deadlocks, Livelocks & Starvation

## Overview

Deadlocks, livelocks, and starvation are common concurrency problems that can cause systems to hang or perform poorly. Understanding how these problems occur, how to detect them, and how to prevent them is essential for building robust concurrent systems.

## Table of Contents

1. [What are Deadlocks?](#what-are-deadlocks)
2. [Deadlock Conditions](#deadlock-conditions)
3. [Deadlock Detection](#deadlock-detection)
4. [Deadlock Prevention](#deadlock-prevention)
5. [Deadlock Avoidance](#deadlock-avoidance)
6. [Livelocks](#livelocks)
7. [Starvation](#starvation)
8. [Real-World Examples](#examples)

## What are Deadlocks?

### Definition

**Deadlock**: Two or more threads blocked forever

**Cause**: Circular waiting for resources

**Result**: System hangs, no progress

### Classic Deadlock Example

**Scenario**: Two threads, two locks

```c
// Thread 1
lock(A);
lock(B);
// Use A and B
unlock(B);
unlock(A);

// Thread 2
lock(B);
lock(A);  // Deadlock! Thread 1 has A, Thread 2 has B
// Use A and B
unlock(A);
unlock(B);
```

**Deadlock**:
```
Thread 1: Has lock A, waiting for lock B
Thread 2: Has lock B, waiting for lock A
Both blocked forever!
```

## Deadlock Conditions

### Four Necessary Conditions

**1. Mutual Exclusion**:
```
Resources cannot be shared
Only one thread can hold resource
```

**2. Hold and Wait**:
```
Thread holds resource while waiting for another
```

**3. No Preemption**:
```
Resources cannot be forcibly taken
Must be voluntarily released
```

**4. Circular Wait**:
```
Circular chain of waiting
T1 waits for T2, T2 waits for T3, ..., Tn waits for T1
```

**All Required**: All four must be present for deadlock

## Deadlock Detection

### Detection Methods

**1. Timeout**:
```
Wait with timeout
If timeout: Assume deadlock
```

**2. Deadlock Detection Algorithm**:
```
Build wait-for graph
Detect cycles
If cycle: Deadlock detected
```

**3. Monitoring**:
```
Monitor lock acquisition
Detect circular waits
```

### Wait-For Graph

**Graph**: Nodes = threads, Edges = waiting

**Cycle**: Indicates deadlock

**Example**:
```
T1 → T2 (T1 waits for T2)
T2 → T1 (T2 waits for T1)
Cycle detected → Deadlock!
```

## Deadlock Prevention

### Breaking Conditions

**1. Break Mutual Exclusion**:
```
Use lock-free data structures
Avoid locks when possible
```

**2. Break Hold and Wait**:
```
Acquire all locks atomically
Or release before acquiring new
```

**3. Allow Preemption**:
```
Timeout on locks
Force release if timeout
```

**4. Break Circular Wait**:
```
Lock ordering: Always acquire in same order
```

### Lock Ordering

**Principle**: Always acquire locks in same order

**Example**:
```c
// GOOD: Consistent ordering
void function1() {
    lock(A);  // Always A first
    lock(B);  // Then B
}

void function2() {
    lock(A);  // Same order!
    lock(B);
}
```

**Prevents**: Circular wait

## Deadlock Avoidance

### Banker's Algorithm

**Idea**: Only grant request if safe state

**Safe State**: System can satisfy all requests

**Process**:
```
1. Check if granting request leads to safe state
2. If safe: Grant request
3. If unsafe: Deny request
```

**Complexity**: O(n²) per request

## Livelocks

### What are Livelocks?

**Livelock**: Threads keep changing state but make no progress

**Difference**: Threads are active (not blocked)

**Result**: No useful work done

### Livelock Example

**Scenario**: Two threads trying to pass through doorway

```c
// Thread 1
while (other_thread_in_way) {
    step_left();
    wait();
}

// Thread 2
while (other_thread_in_way) {
    step_left();
    wait();
}

// Both keep stepping aside, never pass!
```

**Solution**: Random backoff, or one thread yields

## Starvation

### What is Starvation?

**Starvation**: Thread never gets resource

**Cause**: Other threads always get resource first

**Result**: Thread makes no progress

### Starvation Example

**Scenario**: Priority scheduling

```c
// High priority threads always run
// Low priority thread never runs
// Low priority thread starves
```

**Solution**: Fair scheduling, aging (increase priority over time)

## Real-World Examples

### Example 1: Database Deadlock

**Scenario**: Two transactions

```
Transaction 1: Lock row A, then row B
Transaction 2: Lock row B, then row A
Deadlock!
```

**Solution**: Database detects, aborts one transaction

### Example 2: Dining Philosophers

**Problem**: Five philosophers, five forks

**Deadlock**: All pick up left fork, wait for right fork

**Solution**: 
- **Ordering**: Number forks, acquire in order
- **Timeout**: Timeout on acquiring fork
- **Asymmetric**: One philosopher picks up differently

## Common Pitfalls

### Problem: Inconsistent Lock Ordering

```c
// BAD: Different order in different functions
void func1() {
    lock(A);
    lock(B);
}

void func2() {
    lock(B);  // Different order!
    lock(A);
}
// Deadlock possible!

// GOOD: Consistent ordering
void func1() {
    lock(A);
    lock(B);
}

void func2() {
    lock(A);  // Same order
    lock(B);
}
```

### Problem: Not Using Timeouts

```c
// BAD: Block forever
lock(mutex);  // May deadlock

// GOOD: Use timeout
if (pthread_mutex_timedlock(&mutex, &timeout) == 0) {
    // Got lock
} else {
    // Timeout, handle deadlock
}
```

## Quiz

1. What are the four necessary conditions for deadlock?
   - **A)** Mutual exclusion, hold and wait, no preemption, circular wait
   - **B)** Locks, threads, resources, time
   - **C)** CPU, memory, disk, network
   - **D)** Read, write, execute, delete

2. How do you prevent deadlocks?
   - **A)** Use more locks
   - **B)** Consistent lock ordering, timeouts, avoid hold-and-wait
   - **C)** Use fewer threads
   - **D)** Increase memory

3. What is the difference between deadlock and livelock?
   - **A)** No difference
   - **B)** Deadlock: threads blocked; Livelock: threads active but make no progress
   - **C)** Deadlock is faster
   - **D)** Livelock is worse

**Answers:**
1. **A** - The four necessary conditions for deadlock are mutual exclusion (resources can't be shared), hold and wait (hold resource while waiting), no preemption (can't force release), and circular wait (circular chain of waiting)
2. **B** - Deadlocks can be prevented by consistent lock ordering (always acquire in same order), using timeouts, and avoiding hold-and-wait patterns (acquire all locks atomically)
3. **B** - In deadlock, threads are blocked waiting for resources; in livelock, threads are actively executing but keep changing state without making progress

## Next Steps

- [Race Condition Detection](../concurrency_parallelism/06.%20Race%20Condition%20Detection.md) - Debugging concurrency
- [Actors Model](../concurrency_parallelism/07.%20Actors%20Model.md) - Message-passing concurrency

