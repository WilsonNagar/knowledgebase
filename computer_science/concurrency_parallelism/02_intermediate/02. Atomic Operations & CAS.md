---
number: 2
title: "Atomic Operations & CAS"
slug: "atomic-operations-cas"
level: "intermediate"
tags: ["concurrency", "atomic", "cas", "compare-and-swap", "lock-free"]
prerequisites: ["lock-free-wait-free-algorithms"]
estimated_minutes: 105
contributors: []
diagrams: []
examples: []
canonical_id: "cs-conc-02"
---

# Atomic Operations & CAS

## Overview

Atomic operations are fundamental building blocks for lock-free programming and concurrent data structures. Understanding atomic operations, compare-and-swap (CAS), memory ordering, and how to use them effectively is essential for high-performance concurrent programming.

## Table of Contents

1. [What are Atomic Operations?](#what-are-atomic)
2. [Atomic Operations Types](#atomic-types)
3. [Compare-and-Swap (CAS)](#cas)
4. [CAS Loop Pattern](#cas-loop)
5. [Memory Ordering](#memory-ordering)
6. [Fetch-and-Add](#fetch-add)
7. [Load-Link/Store-Conditional](#ll-sc)
8. [Real-World Examples](#examples)

## What are Atomic Operations?

### Definition

**Atomic Operation**: Operation that completes entirely or not at all

**Properties**:
- **Indivisible**: Cannot be interrupted
- **Visible**: Changes visible to all threads
- **Hardware**: Supported by CPU

### Why Atomic Operations?

**Problem**: Race conditions

**Example**:
```c
// Non-atomic increment
int counter = 0;

// Thread 1
counter++; // Read, increment, write

// Thread 2
counter++; // Read, increment, write

// Problem: May lose updates
// Both threads read same value
```

**Solution**: Atomic operations

```c
// Atomic increment
atomic_int counter = 0;

// Thread 1
atomic_fetch_add(&counter, 1); // Atomic

// Thread 2
atomic_fetch_add(&counter, 1); // Atomic

// Result: Both updates applied correctly
```

## Atomic Operations Types

### Load and Store

**Atomic Load**:
```c
int value = atomic_load(&atomic_var);
// Read atomically
```

**Atomic Store**:
```c
atomic_store(&atomic_var, 42);
// Write atomically
```

**Use**: Simple reads/writes

### Exchange

**Atomic Exchange**:
```c
int old = atomic_exchange(&atomic_var, new_value);
// Swap atomically, return old value
```

**Use**: Swap values atomically

### Compare-and-Swap (CAS)

**CAS**: Compare and swap if equal

**Operation**:
```c
bool success = atomic_compare_exchange_strong(
    &atomic_var, &expected, desired);
// If atomic_var == expected:
//   atomic_var = desired, return true
// Else:
//   expected = atomic_var, return false
```

**Use**: Lock-free algorithms

### Fetch-and-Add

**Fetch-and-Add**:
```c
int old = atomic_fetch_add(&atomic_var, increment);
// atomic_var += increment, return old value
```

**Use**: Counters, accumulators

### Fetch-and-Subtract

**Fetch-and-Subtract**:
```c
int old = atomic_fetch_sub(&atomic_var, decrement);
// atomic_var -= decrement, return old value
```

## Compare-and-Swap (CAS)

### CAS Operation

**CAS**: Compare-and-Swap (or Compare-and-Exchange)

**Pseudocode**:
```
CAS(ptr, expected, new):
  if (*ptr == expected):
    *ptr = new
    return true
  else:
    return false
```

**Atomic**: Entire operation is atomic

### CAS Properties

**1. Atomicity**:
- **Entire operation**: Atomic
- **No interference**: Other threads cannot interfere

**2. Conditional**:
- **Only updates**: If value matches expected
- **Idempotent**: Safe to retry

**3. Foundation**: Basis for lock-free algorithms

### CAS Example: Lock-Free Counter

```c
typedef struct {
    atomic_int count;
} lock_free_counter;

void increment(lock_free_counter* c) {
    int expected = atomic_load(&c->count);
    int desired;
    
    do {
        desired = expected + 1;
    } while (!atomic_compare_exchange_weak(
        &c->count, &expected, desired));
}

int get(lock_free_counter* c) {
    return atomic_load(&c->count);
}
```

**How It Works**:
1. Read current value
2. Compute new value
3. Try to update with CAS
4. If failed (value changed), retry

## CAS Loop Pattern

### Standard Pattern

**Pattern**:
```c
int expected = atomic_load(ptr);

do {
    int desired = compute_new_value(expected);
} while (!atomic_compare_exchange_weak(ptr, &expected, desired));
```

**Steps**:
1. **Read**: Current value
2. **Compute**: New value based on current
3. **CAS**: Try to update
4. **Retry**: If failed (value changed)

### CAS Weak vs Strong

**CAS Weak**:
```c
atomic_compare_exchange_weak(ptr, &expected, desired);
// May fail spuriously (even if values match)
// Faster: May be implemented with LL/SC
```

**CAS Strong**:
```c
atomic_compare_exchange_strong(ptr, &expected, desired);
// Never fails spuriously
// Slower: May loop internally
```

**Use**: Weak in loops (will retry anyway), Strong when need guarantee

### CAS Loop Example: Stack Push

```c
typedef struct node {
    int data;
    struct node* next;
} node;

typedef struct {
    atomic_node_ptr top;
} lock_free_stack;

void push(lock_free_stack* s, int data) {
    node* new_node = malloc(sizeof(node));
    new_node->data = data;
    node* old_top;
    
    do {
        old_top = atomic_load(&s->top);
        new_node->next = old_top;
    } while (!atomic_compare_exchange_weak(
        &s->top, &old_top, new_node));
}
```

## Memory Ordering

### The Problem

**Out-of-Order Execution**: CPU may reorder instructions

**Example**:
```c
// Thread 1
x = 1;
y = 2;

// Thread 2
if (y == 2) {
    assert(x == 1); // May fail! (reordering)
}
```

### Memory Ordering Models

**1. Sequential Consistency**:
- **Strongest**: All operations appear in program order
- **Cost**: Expensive, limits optimizations

**2. Acquire-Release**:
- **Acquire**: All reads after acquire see writes before release
- **Release**: All writes before release visible after acquire
- **Common**: Good balance

**3. Relaxed**:
- **Weakest**: No ordering guarantees
- **Use**: Counters, flags

### C11 Memory Ordering

```c
// Sequential consistency (strongest)
atomic_store_explicit(&x, 1, memory_order_seq_cst);
int val = atomic_load_explicit(&y, memory_order_seq_cst);

// Acquire-Release
atomic_store_explicit(&x, 1, memory_order_release);
int val = atomic_load_explicit(&y, memory_order_acquire);

// Relaxed (weakest)
atomic_store_explicit(&x, 1, memory_order_relaxed);
int val = atomic_load_explicit(&y, memory_order_relaxed);
```

## Fetch-and-Add

### Fetch-and-Add Operation

**Operation**:
```c
int old = atomic_fetch_add(&counter, 1);
// counter += 1, return old value
```

**Use**: Counters, accumulators

### Fetch-and-Add Example

```c
atomic_int counter = ATOMIC_VAR_INIT(0);

// Thread 1
int old1 = atomic_fetch_add(&counter, 1);
// counter = 1, old1 = 0

// Thread 2
int old2 = atomic_fetch_add(&counter, 1);
// counter = 2, old2 = 1
```

**Benefits**: Simpler than CAS for increments

## Load-Link/Store-Conditional

### LL/SC Overview

**LL/SC**: Load-Link/Store-Conditional

**Architecture**: ARM, MIPS, PowerPC

**Alternative**: To CAS

### LL/SC Operations

**Load-Link**:
```c
value = load_link(ptr);
// Load value, mark for monitoring
```

**Store-Conditional**:
```c
bool success = store_conditional(ptr, new_value);
// Store only if ptr not modified since load_link
// Returns true if successful, false if failed
```

### LL/SC Example

```c
int increment(atomic_int* ptr) {
    int value;
    do {
        value = load_link(ptr);
        value++;
    } while (!store_conditional(ptr, value));
    return value;
}
```

**Equivalent**: To CAS loop

## Real-World Examples

### Example 1: Reference Counting

```c
typedef struct {
    atomic_int ref_count;
} ref_counted;

void retain(ref_counted* obj) {
    atomic_fetch_add(&obj->ref_count, 1);
}

void release(ref_counted* obj) {
    int count = atomic_fetch_sub(&obj->ref_count, 1);
    if (count == 1) {
        // Last reference
        free(obj);
    }
}
```

### Example 2: Lock-Free Queue

```c
typedef struct {
    atomic_node_ptr head;
    atomic_node_ptr tail;
} lock_free_queue;

void enqueue(lock_free_queue* q, void* data) {
    node* new_node = malloc(sizeof(node));
    new_node->data = data;
    new_node->next = NULL;
    
    node* tail;
    do {
        tail = atomic_load(&q->tail);
        node* next = atomic_load(&tail->next);
        if (next == NULL) {
            if (atomic_compare_exchange_weak(
                &tail->next, &next, new_node)) {
                break;
            }
        } else {
            atomic_compare_exchange_weak(
                &q->tail, &tail, next);
        }
    } while (true);
    
    atomic_compare_exchange_weak(&q->tail, &tail, new_node);
}
```

## Common Pitfalls

### Problem: ABA Problem

```c
// BAD: ABA problem
node* old_top = atomic_load(&stack->top);
node* new_top = old_top->next;
// Another thread: pop, push (reuses node)
atomic_compare_exchange_weak(&stack->top, &old_top, new_top);
// Succeeds incorrectly!

// GOOD: Use version numbers or hazard pointers
```

### Problem: Wrong Memory Ordering

```c
// BAD: Wrong ordering
atomic_store(&flag, 1); // May be reordered
data = compute();

// GOOD: Use acquire-release
atomic_store_explicit(&flag, 1, memory_order_release);
```

## Quiz

1. What is CAS (Compare-and-Swap)?
   - **A)** Compare two values
   - **B)** Atomically compare value and swap if equal
   - **C)** Swap two values
   - **D)** Compare and copy

2. What is the main use of atomic operations?
   - **A)** Encryption
   - **B)** Implementing lock-free algorithms and avoiding race conditions
   - **C)** Compression
   - **D)** Networking

3. What is the difference between CAS weak and strong?
   - **A)** No difference
   - **B)** Weak may fail spuriously, strong never fails spuriously
   - **C)** Strong is faster
   - **D)** Weak is more reliable

**Answers:**
1. **B** - CAS atomically compares a memory location's value with an expected value, and if they match, swaps it with a new value
2. **B** - Atomic operations are used to implement lock-free algorithms and prevent race conditions by ensuring operations complete atomically without interference
3. **B** - CAS weak may fail spuriously (even when values match) but is faster, while CAS strong never fails spuriously but may be slower

## Next Steps

- [Memory Models & Happens-Before](./03.%20Memory%20Models%20%26%20Happens-Before.md) - Memory consistency
- [Thread Pools & Executors](./04.%20Thread%20Pools%20%26%20Executors.md) - Thread management

