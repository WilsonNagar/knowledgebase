---
number: 4
title: "Thread Pools & Executors"
slug: "thread-pools-executors"
level: "intermediate"
tags: ["concurrency", "thread-pools", "executors", "parallelism", "task-scheduling"]
prerequisites: ["memory-models-happens-before"]
estimated_minutes: 105
contributors: []
diagrams: []
examples: []
canonical_id: "cs-conc-04"
---

# Thread Pools & Executors

## Overview

Thread pools manage a group of worker threads to execute tasks efficiently. Understanding thread pools, executors, work-stealing, and task scheduling is essential for building concurrent applications that efficiently utilize system resources and avoid thread creation overhead.

## Table of Contents

1. [Why Thread Pools?](#why-thread-pools)
2. [Thread Pool Basics](#basics)
3. [Thread Pool Parameters](#parameters)
4. [Task Queue](#task-queue)
5. [Work-Stealing](#work-stealing)
6. [Executor Patterns](#executor-patterns)
7. [Thread Pool Lifecycle](#lifecycle)
8. [Performance Considerations](#performance)

## Why Thread Pools?

### The Problem

**Thread Creation Overhead**:
```
Creating thread: ~1-10ms
Destroying thread: ~1-10ms
Context switching: ~1-10μs
```

**Problem**: Creating threads for each task is expensive

**Solution**: Reuse threads from pool

### Benefits

**1. Performance**:
- **Reuse**: Reuse existing threads
- **Lower overhead**: No creation/destruction per task

**2. Resource Management**:
- **Limit threads**: Control number of threads
- **Prevent overload**: Avoid too many threads

**3. Task Management**:
- **Queue tasks**: Handle more tasks than threads
- **Scheduling**: Control execution order

## Thread Pool Basics

### Basic Structure

**Components**:
- **Thread Pool**: Collection of worker threads
- **Task Queue**: Queue of pending tasks
- **Thread Manager**: Creates/destroys threads

**Process**:
```
1. Submit task to pool
2. Task added to queue
3. Worker thread picks task
4. Thread executes task
5. Thread returns to pool
```

### Simple Thread Pool

```c
typedef struct {
    pthread_t* threads;
    int num_threads;
    Queue* task_queue;
    bool shutdown;
} ThreadPool;

void* worker_thread(void* arg) {
    ThreadPool* pool = (ThreadPool*)arg;
    while (!pool->shutdown) {
        Task* task = dequeue(pool->task_queue);
        if (task != NULL) {
            task->function(task->arg);
            free(task);
        }
    }
    return NULL;
}
```

## Thread Pool Parameters

### Core Parameters

**1. Core Pool Size**:
```
Minimum number of threads
Always kept alive
```

**2. Maximum Pool Size**:
```
Maximum number of threads
Can grow beyond core size
```

**3. Keep-Alive Time**:
```
Time idle threads wait before termination
Applies to threads beyond core size
```

**4. Queue Capacity**:
```
Maximum tasks in queue
Reject if full (depending on policy)
```

### Thread Pool Policies

**1. Fixed Thread Pool**:
```
Core = Max = N
Fixed number of threads
```

**2. Cached Thread Pool**:
```
Core = 0, Max = ∞
Creates threads as needed
```

**3. Scheduled Thread Pool**:
```
Core = N, Max = ∞
Scheduled execution
```

## Task Queue

### Queue Types

**1. Unbounded Queue**:
```
Unlimited capacity
May grow large
Memory concern
```

**2. Bounded Queue**:
```
Fixed capacity
Reject when full
Backpressure
```

**3. Synchronous Queue**:
```
Capacity = 0
Handoff directly to thread
No buffering
```

### Queue Implementation

**LinkedBlockingQueue**:
```
Linked list implementation
Unbounded or bounded
Thread-safe
```

**ArrayBlockingQueue**:
```
Array implementation
Bounded
Thread-safe
```

## Work-Stealing

### What is Work-Stealing?

**Work-Stealing**: Idle threads steal work from busy threads

**Benefit**: Better load balancing

**Use**: ForkJoinPool (Java), TBB (C++)

### Work-Stealing Algorithm

**Process**:
```
1. Thread finishes own queue
2. Steal from other thread's queue
3. Steal from tail (other thread works from head)
4. Reduces contention
```

**Benefits**:
- **Load balancing**: Distributes work evenly
- **Efficiency**: Keeps threads busy

## Executor Patterns

### Executor Interface

**Submit Task**:
```java
Executor executor = Executors.newFixedThreadPool(10);
executor.execute(() -> {
    // Task code
});
```

**Future**:
```java
ExecutorService executor = Executors.newFixedThreadPool(10);
Future<Integer> future = executor.submit(() -> {
    return compute();
});
Integer result = future.get(); // Wait for result
```

### Executor Types

**1. FixedThreadPool**:
```java
ExecutorService executor = Executors.newFixedThreadPool(10);
// 10 threads, unbounded queue
```

**2. CachedThreadPool**:
```java
ExecutorService executor = Executors.newCachedThreadPool();
// Creates threads as needed, 60s timeout
```

**3. SingleThreadExecutor**:
```java
ExecutorService executor = Executors.newSingleThreadExecutor();
// Single thread, sequential execution
```

**4. ScheduledThreadPool**:
```java
ScheduledExecutorService executor = 
    Executors.newScheduledThreadPool(5);
executor.schedule(() -> task(), 10, TimeUnit.SECONDS);
```

## Thread Pool Lifecycle

### States

**1. Running**:
```
Accepting tasks
Executing tasks
```

**2. Shutting Down**:
```
Not accepting new tasks
Finishing existing tasks
```

**3. Terminated**:
```
All tasks finished
Threads terminated
```

### Shutdown Process

**Graceful Shutdown**:
```java
executor.shutdown(); // Stop accepting new tasks
executor.awaitTermination(60, TimeUnit.SECONDS); // Wait for completion
executor.shutdownNow(); // Force shutdown if timeout
```

**Force Shutdown**:
```java
executor.shutdownNow(); // Interrupt all threads
```

## Performance Considerations

### Thread Pool Sizing

**CPU-Bound Tasks**:
```
Threads ≈ Number of CPU cores
```

**I/O-Bound Tasks**:
```
Threads > Number of CPU cores
Can have many threads waiting on I/O
```

**Formula**:
```
Optimal threads = CPU cores × (1 + wait_time / compute_time)
```

### Common Issues

**1. Too Many Threads**:
```
Context switching overhead
Memory usage
Poor performance
```

**2. Too Few Threads**:
```
Underutilization
Slow processing
```

**3. Queue Overflow**:
```
Tasks rejected
Need backpressure handling
```

## Real-World Examples

### Example 1: Web Server

**Use**: Handle HTTP requests

**Thread Pool**: Fixed size (e.g., 100 threads)

**Queue**: Bounded queue

**Benefit**: Limits resource usage

### Example 2: Image Processing

**Use**: Process images in parallel

**Thread Pool**: Size = CPU cores

**Tasks**: Process each image

**Benefit**: Utilizes all cores

### Example 3: Database Connection Pool

**Use**: Manage database connections

**Pool**: Reuse connections

**Benefit**: Avoid connection overhead

## Common Pitfalls

### Problem: Thread Leak

```java
// BAD: Never shutdown executor
ExecutorService executor = Executors.newFixedThreadPool(10);
// Threads never terminated!

// GOOD: Shutdown executor
executor.shutdown();
executor.awaitTermination(60, TimeUnit.SECONDS);
```

### Problem: Wrong Pool Size

```java
// BAD: Too many threads
ExecutorService executor = Executors.newFixedThreadPool(1000);
// Context switching overhead

// GOOD: Appropriate size
int cores = Runtime.getRuntime().availableProcessors();
ExecutorService executor = Executors.newFixedThreadPool(cores);
```

### Problem: Blocking Tasks

```java
// BAD: Long-running blocking tasks
executor.execute(() -> {
    Thread.sleep(10000); // Blocks thread
});

// GOOD: Use appropriate pool or async I/O
// Use cached thread pool or async I/O
```

## Quiz

1. What is the main benefit of thread pools?
   - **A)** More memory
   - **B)** Reuse threads to avoid creation overhead and manage resources
   - **C)** Faster execution
   - **D)** Simpler code

2. What is work-stealing?
   - **A)** Stealing threads
   - **B)** Idle threads taking work from busy threads' queues
   - **C)** Stealing memory
   - **D)** Stealing CPU

3. How do you size a thread pool for CPU-bound tasks?
   - **A)** Always 100 threads
   - **B)** Approximately equal to number of CPU cores
   - **C)** Always 1 thread
   - **D)** Unlimited threads

**Answers:**
1. **B** - Thread pools reuse threads to avoid the overhead of creating/destroying threads for each task and help manage system resources by limiting the number of concurrent threads
2. **B** - Work-stealing allows idle threads to take (steal) tasks from other threads' queues, improving load balancing and keeping threads busy
3. **B** - For CPU-bound tasks, thread pool size should be approximately equal to the number of CPU cores to maximize utilization without excessive context switching

## Next Steps

- [Deadlocks, Livelocks & Starvation](../concurrency_parallelism/05.%20Deadlocks.md) - Concurrency problems
- [Race Condition Detection](../concurrency_parallelism/06.%20Race%20Condition%20Detection.md) - Debugging concurrency

