---
number: 1
title: "Introduction to Concurrency & Parallelism"
slug: "introduction-to-concurrency-and-parallelism"
level: "beginner"
tags: ["concurrency", "parallelism", "threads", "multithreading", "fundamentals"]
prerequisites: []
estimated_minutes: 75
contributors: []
diagrams: []
examples: []
canonical_id: "cs-concurrency-01"
---

# Introduction to Concurrency & Parallelism

## Overview

Concurrency and parallelism are fundamental concepts in modern computing that enable programs to execute multiple tasks simultaneously. Understanding the difference between these concepts and when to use them is crucial for building efficient, responsive applications.

## Deep Explanation

### What is Concurrency?

Concurrency is about dealing with multiple things at once. It's the composition of independently executing processes or the ability to run multiple tasks in overlapping time periods, not necessarily simultaneously.

**Key Points:**
- Multiple tasks make progress
- Tasks may not run at the exact same time
- Time-slicing on single CPU
- About structure and design

**Example:**
A web server handling multiple requests concurrently - it switches between requests, giving each some CPU time.

### What is Parallelism?

Parallelism is about doing multiple things at the same time. It requires multiple processing units (cores, CPUs) to execute tasks simultaneously.

**Key Points:**
- Multiple tasks execute simultaneously
- Requires multiple CPUs/cores
- True simultaneous execution
- About execution

**Example:**
Rendering a video using all CPU cores simultaneously - each core processes different frames at the same time.

### Key Differences

| Aspect | Concurrency | Parallelism |
|--------|-------------|-------------|
| Definition | Multiple tasks in progress | Multiple tasks simultaneously |
| Requires | Single CPU (can use multiple) | Multiple CPUs/cores |
| Goal | Structure, responsiveness | Speed, throughput |
| Example | Web server, UI responsiveness | Video rendering, data processing |

### Why Concurrency?

1. **Responsiveness**: UI stays responsive while processing
2. **Efficiency**: Better resource utilization
3. **Throughput**: Handle more work
4. **User Experience**: Non-blocking operations

### Why Parallelism?

1. **Performance**: Faster execution on multi-core systems
2. **Scalability**: Utilize all available cores
3. **Throughput**: Process more data simultaneously
4. **Speed**: Reduce total execution time

### Common Patterns

#### Threads

Lightweight processes that share memory:

```kotlin
// Pseudo-code
thread {
    // Task 1
}
thread {
    // Task 2
}
```

#### Processes

Independent programs with separate memory:

```bash
# Multiple processes
process1 &
process2 &
```

#### Async/Await

Non-blocking asynchronous operations:

```kotlin
async {
    val data = fetchData()
    process(data)
}
```

### Challenges

1. **Race Conditions**: Multiple threads accessing shared data
2. **Deadlocks**: Threads waiting for each other
3. **Synchronization**: Coordinating access to shared resources
4. **Complexity**: Harder to reason about and debug

### When to Use

**Concurrency:**
- I/O-bound operations
- User interfaces
- Network servers
- Responsive applications

**Parallelism:**
- CPU-intensive tasks
- Data processing
- Scientific computing
- When you have multiple cores

## Summary

Concurrency is about structure and dealing with multiple tasks, while parallelism is about execution and doing things simultaneously. Both are essential for modern software development, and understanding when to use each is key to building efficient applications.

## Next Steps

- Learn about threads and processes
- Understand synchronization primitives
- Explore lock-free algorithms
- Study memory models

