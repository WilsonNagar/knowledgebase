---
number: 1
title: "Cryptography Fundamentals"
slug: "cryptography-fundamentals"
level: "intermediate"
tags: ["security", "cryptography", "encryption", "hashing", "crypto"]
prerequisites: []
estimated_minutes: 120
contributors: []
diagrams: []
examples: []
canonical_id: "cs-sec-01"
---

# Cryptography Fundamentals

## Overview

Cryptography is the foundation of modern security, providing confidentiality, integrity, and authentication. Understanding symmetric encryption (AES), asymmetric encryption (RSA, ECC), hashing (SHA-256), and cryptographic protocols is essential for secure system design and implementation.

## Table of Contents

1. [Cryptography Overview](#overview)
2. [Symmetric Encryption](#symmetric)
3. [AES (Advanced Encryption Standard)](#aes)
4. [Asymmetric Encryption](#asymmetric)
5. [RSA Encryption](#rsa)
6. [Elliptic Curve Cryptography (ECC)](#ecc)
7. [Hashing](#hashing)
8. [SHA-256](#sha256)
9. [Digital Signatures](#signatures)
10. [Key Exchange](#key-exchange)

## Cryptography Overview

### Goals of Cryptography

**1. Confidentiality**:
- **Encryption**: Hide data from unauthorized access
- **Example**: Encrypting messages

**2. Integrity**:
- **Hashing**: Detect tampering
- **Example**: Checksums, digital signatures

**3. Authentication**:
- **Digital signatures**: Verify identity
- **Example**: SSL/TLS certificates

**4. Non-repudiation**:
- **Digital signatures**: Cannot deny sending
- **Example**: Signed contracts

### Cryptographic Primitives

**Symmetric Encryption**:
- Same key for encryption and decryption
- **Fast**: Efficient for bulk data
- **Examples**: AES, ChaCha20

**Asymmetric Encryption**:
- Different keys (public/private)
- **Slow**: But enables key exchange
- **Examples**: RSA, ECC

**Hashing**:
- One-way function
- **Fast**: Efficient integrity checking
- **Examples**: SHA-256, SHA-3

## Symmetric Encryption

### What is Symmetric Encryption?

**Symmetric**: Same key for encryption and decryption

**Process**:
```
Encrypt: Plaintext + Key → Ciphertext
Decrypt: Ciphertext + Key → Plaintext
```

**Key Requirements**:
- **Secret**: Must be kept secret
- **Shared**: Both parties need same key
- **Strong**: Sufficiently random

### Block Ciphers vs Stream Ciphers

**Block Ciphers**:
- **Process**: Fixed-size blocks (e.g., 128 bits)
- **Examples**: AES, DES
- **Modes**: ECB, CBC, GCM

**Stream Ciphers**:
- **Process**: One byte/bit at a time
- **Examples**: ChaCha20, RC4
- **Use**: Real-time encryption

### Encryption Modes

**ECB (Electronic Codebook)**:
- **Simple**: Each block encrypted independently
- **Problem**: Identical blocks → Identical ciphertext
- **Not secure**: For most uses

**CBC (Cipher Block Chaining)**:
- **Chaining**: Each block XORed with previous ciphertext
- **IV**: Initialization vector needed
- **Secure**: Widely used

**GCM (Galois/Counter Mode)**:
- **Authenticated**: Provides integrity
- **Parallel**: Can encrypt in parallel
- **Modern**: Recommended for new systems

## AES (Advanced Encryption Standard)

### What is AES?

**AES**: Advanced Encryption Standard

**Standard**: NIST standard (2001)

**Key Sizes**: 128, 192, 256 bits

**Block Size**: 128 bits

### AES Structure

**Rounds**:
- **128-bit key**: 10 rounds
- **192-bit key**: 12 rounds
- **256-bit key**: 14 rounds

**Operations** (per round):
1. **SubBytes**: Substitution using S-box
2. **ShiftRows**: Shift rows
3. **MixColumns**: Mix columns
4. **AddRoundKey**: XOR with round key

### AES Example

**Encryption**:
```
Plaintext: "Hello, World!"
Key: 128-bit key

1. Convert to 128-bit block
2. AddRoundKey (initial)
3. For each round (10 rounds):
   a. SubBytes
   b. ShiftRows
   c. MixColumns (except last round)
   d. AddRoundKey
4. Output: Ciphertext
```

**Security**: 
- **Brute force**: 2^128 operations (infeasible)
- **Best attack**: Slightly better than brute force
- **Secure**: For foreseeable future

## Asymmetric Encryption

### What is Asymmetric Encryption?

**Asymmetric**: Different keys for encryption and decryption

**Keys**:
- **Public key**: Can be shared publicly
- **Private key**: Must be kept secret

**Process**:
```
Encrypt: Plaintext + Public Key → Ciphertext
Decrypt: Ciphertext + Private Key → Plaintext
```

**Security**: Based on mathematical problems (factoring, discrete log)

### Use Cases

**1. Key Exchange**:
- Share symmetric key securely
- **Example**: TLS handshake

**2. Digital Signatures**:
- Sign with private key
- Verify with public key

**3. Encryption**:
- Encrypt with public key
- Decrypt with private key
- **Slow**: Usually used for small data

## RSA Encryption

### What is RSA?

**RSA**: Rivest-Shamir-Adleman

**Security**: Based on factoring large numbers

**Key Generation**:
```
1. Choose two large primes: p, q
2. Compute n = p × q
3. Compute φ(n) = (p-1)(q-1)
4. Choose e (public exponent): gcd(e, φ(n)) = 1
5. Compute d (private exponent): e × d ≡ 1 (mod φ(n))
6. Public key: (n, e)
7. Private key: (n, d)
```

### RSA Encryption/Decryption

**Encryption**:
```
c = m^e mod n
```

**Decryption**:
```
m = c^d mod n
```

**Example**:
```
p = 61, q = 53
n = 3233
e = 17
d = 2753

Encrypt "HI" (m = 89):
c = 89^17 mod 3233 = 1394

Decrypt:
m = 1394^2753 mod 3233 = 89
```

### RSA Security

**Key Size**:
- **1024 bits**: Deprecated (can be broken)
- **2048 bits**: Minimum recommended
- **4096 bits**: High security

**Attacks**:
- **Factoring**: Factor n to break
- **Timing**: Side-channel attacks
- **Padding**: PKCS#1 padding attacks

## Elliptic Curve Cryptography (ECC)

### What is ECC?

**ECC**: Cryptography based on elliptic curves

**Advantages**:
- **Smaller keys**: Same security with smaller keys
- **Faster**: More efficient operations
- **Modern**: Widely adopted

**Key Sizes** (equivalent security):
- **RSA 2048-bit** ≈ **ECC 224-bit**
- **RSA 3072-bit** ≈ **ECC 256-bit**
- **RSA 7680-bit** ≈ **ECC 384-bit**

### Elliptic Curve

**Equation**: y² = x³ + ax + b

**Properties**:
- **Group operation**: Point addition
- **Discrete log**: Hard problem
- **Security**: Based on ECDLP

### ECC Operations

**Point Addition**:
```
P + Q = R (on curve)
```

**Scalar Multiplication**:
```
k × P = P + P + ... + P (k times)
```

**Key Generation**:
```
1. Choose curve and generator point G
2. Choose private key: d (random)
3. Compute public key: Q = d × G
```

### ECC Advantages

**1. Smaller Keys**:
- 256-bit ECC ≈ 3072-bit RSA
- Less storage, faster transmission

**2. Faster Operations**:
- ECC operations faster than RSA
- Better for mobile devices

**3. Lower Power**:
- Less computation
- Better for IoT devices

## Hashing

### What is Hashing?

**Hash Function**: Maps input to fixed-size output

**Properties**:
- **Deterministic**: Same input → Same output
- **One-way**: Cannot reverse
- **Avalanche**: Small change → Large output change
- **Collision resistant**: Hard to find collisions

### Hash Function Uses

**1. Integrity Checking**:
```
File → Hash → Store hash
Later: File' → Hash' → Compare
If Hash ≠ Hash': File modified
```

**2. Password Storage**:
```
Password → Hash → Store hash (not password)
Login: Password' → Hash' → Compare
```

**3. Digital Signatures**:
```
Message → Hash → Sign hash (faster)
```

**4. Data Structures**:
```
Hash tables, Bloom filters
```

## SHA-256

### What is SHA-256?

**SHA-256**: Secure Hash Algorithm 256-bit

**Output**: 256 bits (32 bytes)

**Properties**:
- **Collision resistant**: Hard to find two inputs with same hash
- **Preimage resistant**: Hard to find input given hash
- **Avalanche effect**: 1-bit change → ~50% output bits change

### SHA-256 Algorithm

**Process**:
```
1. Padding: Add bits to make length multiple of 512
2. Initialize: 8 hash values (h0-h7)
3. For each 512-bit chunk:
   a. Create message schedule
   b. Compression function (64 rounds)
   c. Update hash values
4. Output: Concatenate final hash values
```

**Security**:
- **Brute force**: 2^256 operations (infeasible)
- **Best attack**: 2^256 (no better than brute force)
- **Secure**: For foreseeable future

### SHA-256 Example

```python
import hashlib

message = "Hello, World!"
hash_obj = hashlib.sha256(message.encode())
hash_hex = hash_obj.hexdigest()
# Output: dffd6021bb2bd5b0af676290809ec3a53191dd81c7f70a4b28688a362182986f
```

## Digital Signatures

### What are Digital Signatures?

**Digital Signature**: Cryptographic proof of authenticity

**Properties**:
- **Authenticity**: Verifies sender
- **Integrity**: Detects tampering
- **Non-repudiation**: Cannot deny signing

### Signature Process

**Signing**:
```
1. Message → Hash
2. Hash → Encrypt with private key → Signature
```

**Verification**:
```
1. Message → Hash
2. Signature → Decrypt with public key → Hash'
3. Compare Hash == Hash'
```

### RSA Signatures

**Sign**:
```
s = H(m)^d mod n
```

**Verify**:
```
H(m) == s^e mod n
```

### ECDSA (Elliptic Curve Digital Signatures)

**Advantages**:
- **Smaller**: Smaller signatures than RSA
- **Faster**: Faster than RSA
- **Modern**: Widely used (Bitcoin, TLS)

## Key Exchange

### The Problem

**Symmetric Encryption**: Need shared secret key

**Challenge**: How to share key securely?

**Solution**: Key exchange protocols

### Diffie-Hellman Key Exchange

**Process**:
```
1. Alice and Bob agree on public parameters (g, p)
2. Alice chooses private key a, computes A = g^a mod p
3. Bob chooses private key b, computes B = g^b mod p
4. Exchange: Alice sends A, Bob sends B
5. Alice computes: K = B^a mod p = g^(ab) mod p
6. Bob computes: K = A^b mod p = g^(ab) mod p
7. Shared secret: K
```

**Security**: Based on discrete logarithm problem

### ECDH (Elliptic Curve Diffie-Hellman)

**Process**:
```
1. Alice: Private key a, Public key A = a × G
2. Bob: Private key b, Public key B = b × G
3. Exchange public keys
4. Alice: K = a × B = a × b × G
5. Bob: K = b × A = b × a × G
6. Shared secret: K
```

**Advantages**: Smaller keys, faster than DH

## Real-World Examples

### Example 1: TLS/SSL

**Protocol**: Uses multiple cryptographic primitives

**Handshake**:
1. **Key exchange**: ECDH or RSA
2. **Authentication**: RSA or ECDSA signatures
3. **Encryption**: AES-GCM (symmetric)
4. **Integrity**: HMAC-SHA256

### Example 2: Bitcoin

**Cryptography Used**:
- **Hashing**: SHA-256 (proof-of-work)
- **Signatures**: ECDSA (transactions)
- **Addresses**: Hash of public key

### Example 3: Password Storage

**Best Practice**:
```
Password → bcrypt/Argon2 → Store hash
```

**Why**: Slow hash functions prevent brute force

## Common Pitfalls

### Problem: Weak Keys

```c
// BAD: Predictable key
char key[] = "password123"; // Weak!

// GOOD: Random key
unsigned char key[32];
RAND_bytes(key, 32); // Cryptographically random
```

### Problem: Reusing IVs

```c
// BAD: Same IV for multiple encryptions
encrypt(data1, key, iv); // Reuses IV
encrypt(data2, key, iv); // Security compromised

// GOOD: Unique IV for each encryption
unsigned char iv[16];
RAND_bytes(iv, 16); // New IV each time
encrypt(data, key, iv);
```

### Problem: Weak Hash Functions

```c
// BAD: MD5 (broken)
MD5(password); // Vulnerable to collisions

// GOOD: SHA-256 or bcrypt
SHA256(password); // Still secure
bcrypt(password); // Slow, good for passwords
```

## Quiz

1. What is the main advantage of symmetric encryption?
   - **A)** More secure
   - **B)** Faster and more efficient for bulk data
   - **C)** Easier key management
   - **D)** No key exchange needed

2. What is the main advantage of ECC over RSA?
   - **A)** More secure
   - **B)** Smaller keys for same security level
   - **C)** Easier to implement
   - **D)** Older standard

3. What property makes hash functions useful for integrity checking?
   - **A)** Reversible
   - **B)** Collision resistant and one-way
   - **C)** Fast
   - **D)** Deterministic only

**Answers:**
1. **B** - Symmetric encryption is faster and more efficient for encrypting large amounts of data, which is why it's used for bulk encryption after key exchange
2. **B** - ECC provides the same security as RSA with much smaller keys (e.g., 256-bit ECC ≈ 3072-bit RSA), making it more efficient
3. **B** - Hash functions are useful for integrity because they are collision resistant (hard to find two inputs with same hash) and one-way (cannot reverse to find original input)

## Next Steps

- [RSA & ECC Deep Dive](./02.%20RSA%20%26%20ECC%20Deep%20Dive.md) - Detailed algorithms
- [Secure Coding Practices](./03.%20Secure%20Coding%20Practices.md) - Avoiding vulnerabilities

