---
number: 3
title: "Secure Coding Practices"
slug: "secure-coding-practices"
level: "intermediate"
tags: ["security", "secure-coding", "vulnerabilities", "buffer-overflow", "sql-injection"]
prerequisites: ["cryptography-fundamentals"]
estimated_minutes: 125
contributors: []
diagrams: []
examples: []
canonical_id: "cs-sec-03"
---

# Secure Coding Practices

## Overview

Secure coding practices are essential for building secure software. Understanding common vulnerabilities like buffer overflows, SQL injection, XSS, CSRF, and how to prevent them is crucial for software security and protecting applications from attacks.

## Table of Contents

1. [Security Principles](#principles)
2. [Buffer Overflow](#buffer-overflow)
3. [SQL Injection](#sql-injection)
4. [Cross-Site Scripting (XSS)](#xss)
5. [Cross-Site Request Forgery (CSRF)](#csrf)
6. [Input Validation](#input-validation)
7. [Authentication & Authorization](#auth)
8. [Secure Communication](#secure-comm)
9. [Best Practices](#best-practices)

## Security Principles

### Defense in Depth

**Principle**: Multiple layers of security

**Layers**:
- **Network**: Firewalls, IDS
- **Application**: Input validation, authentication
- **Data**: Encryption, access control
- **Host**: OS hardening, patches

### Principle of Least Privilege

**Principle**: Grant minimum necessary permissions

**Application**: 
- **Users**: Minimum required access
- **Processes**: Run with minimum privileges
- **Services**: Access only needed resources

### Fail Secure

**Principle**: System fails in secure state

**Example**: 
- **Authentication failure**: Deny access
- **Error**: Don't leak sensitive information

## Buffer Overflow

### What is Buffer Overflow?

**Buffer Overflow**: Writing beyond buffer boundaries

**Cause**: Insufficient bounds checking

**Impact**: Can overwrite memory, execute arbitrary code

### Stack Buffer Overflow

**Example**:
```c
// BAD: No bounds checking
void vulnerable(char* input) {
    char buffer[64];
    strcpy(buffer, input); // May overflow!
}

// Attack: Input longer than 64 bytes
vulnerable("A" * 100); // Overflows buffer
```

**Exploitation**:
```
Overflow can overwrite:
  - Return address → Control execution
  - Local variables → Modify behavior
  - Function pointers → Redirect execution
```

### Prevention

**1. Bounds Checking**:
```c
// GOOD: Check bounds
void safe(char* input, size_t len) {
    char buffer[64];
    if (len >= sizeof(buffer)) {
        return; // Reject
    }
    strncpy(buffer, input, sizeof(buffer) - 1);
    buffer[sizeof(buffer) - 1] = '\0';
}
```

**2. Safe Functions**:
```c
// BAD: strcpy, gets, sprintf
strcpy(dest, src);

// GOOD: strncpy, fgets, snprintf
strncpy(dest, src, sizeof(dest) - 1);
```

**3. Stack Canaries**:
```
Compiler adds canary value
Check canary before return
If modified: Abort (overflow detected)
```

**4. ASLR** (Address Space Layout Randomization):
```
Randomize memory addresses
Makes exploitation harder
```

## SQL Injection

### What is SQL Injection?

**SQL Injection**: Injecting malicious SQL code

**Cause**: Unsanitized user input in SQL queries

**Impact**: Unauthorized database access, data theft

### SQL Injection Example

**Vulnerable Code**:
```c
// BAD: String concatenation
char query[256];
sprintf(query, "SELECT * FROM users WHERE username='%s'", username);
execute(query);

// Attack: username = "admin' OR '1'='1"
// Query becomes:
// SELECT * FROM users WHERE username='admin' OR '1'='1'
// Returns all users!
```

**More Dangerous**:
```sql
-- Attack: username = "admin'; DROP TABLE users; --"
-- Query becomes:
SELECT * FROM users WHERE username='admin'; DROP TABLE users; --'
-- Deletes table!
```

### Prevention

**1. Parameterized Queries**:
```c
// GOOD: Use parameters
PreparedStatement stmt = conn.prepareStatement(
    "SELECT * FROM users WHERE username=?");
stmt.setString(1, username);
ResultSet rs = stmt.executeQuery();
```

**2. Input Validation**:
```c
// GOOD: Validate input
if (!is_valid_username(username)) {
    return error("Invalid username");
}
```

**3. Escaping**:
```c
// GOOD: Escape special characters
char* escaped = escape_sql(username);
```

**4. Least Privilege**:
```
Database user: Minimum required permissions
Don't use admin account for application
```

## Cross-Site Scripting (XSS)

### What is XSS?

**XSS**: Injecting malicious scripts into web pages

**Types**:
- **Stored XSS**: Script stored in database
- **Reflected XSS**: Script in URL/parameters
- **DOM XSS**: Script in DOM manipulation

### XSS Example

**Vulnerable Code**:
```html
<!-- BAD: Direct output -->
<div><?php echo $_GET['name']; ?></div>

<!-- Attack: name = <script>alert('XSS')</script> -->
<!-- Renders: -->
<div><script>alert('XSS')</script></div>
<!-- Script executes! -->
```

**Impact**:
- **Steal cookies**: Access user sessions
- **Phishing**: Redirect to malicious sites
- **Keylogging**: Capture user input

### Prevention

**1. Output Encoding**:
```html
<!-- GOOD: Encode output -->
<div><?php echo htmlspecialchars($_GET['name']); ?></div>
<!-- Converts < to &lt; -->
```

**2. Content Security Policy (CSP)**:
```html
<!-- GOOD: Restrict script sources -->
<meta http-equiv="Content-Security-Policy" 
      content="script-src 'self'">
```

**3. Input Validation**:
```php
// GOOD: Validate and sanitize
$name = filter_input(INPUT_GET, 'name', FILTER_SANITIZE_STRING);
```

## Cross-Site Request Forgery (CSRF)

### What is CSRF?

**CSRF**: Forcing user to execute unwanted actions

**Attack**: User logged into site A, visits malicious site B

**Site B**: Sends request to site A using user's session

**Impact**: Unauthorized actions (transfer money, change password)

### CSRF Example

**Vulnerable Form**:
```html
<!-- BAD: No CSRF protection -->
<form action="/transfer" method="POST">
    <input name="amount" value="1000">
    <input name="to" value="attacker">
    <button>Transfer</button>
</form>
```

**Attack**:
```html
<!-- Malicious site -->
<img src="https://bank.com/transfer?amount=1000&to=attacker">
<!-- User's browser sends request with cookies! -->
```

### Prevention

**1. CSRF Tokens**:
```html
<!-- GOOD: Include CSRF token -->
<form action="/transfer" method="POST">
    <input type="hidden" name="csrf_token" value="<?php echo $token; ?>">
    <!-- ... -->
</form>

<!-- Server validates token -->
```

**2. SameSite Cookies**:
```php
// GOOD: Set SameSite attribute
setcookie('session', $value, [
    'samesite' => 'Strict',
    'secure' => true
]);
```

**3. Referer Check**:
```php
// GOOD: Check Referer header
if ($_SERVER['HTTP_REFERER'] !== 'https://yourdomain.com') {
    die('Invalid referer');
}
```

## Input Validation

### Validation Principles

**1. Validate All Input**:
```
Never trust user input
Validate on server side (client-side is not enough)
```

**2. Whitelist vs Blacklist**:
```
Whitelist: Allow only known good
Blacklist: Block known bad (less secure)
```

**3. Validate Early**:
```
Validate as soon as input received
Fail fast
```

### Validation Examples

**Email Validation**:
```c
// GOOD: Validate email format
bool is_valid_email(const char* email) {
    // Check format: user@domain.com
    // Use regex or library
    return regex_match(email, EMAIL_PATTERN);
}
```

**Numeric Validation**:
```c
// GOOD: Validate numbers
int parse_int(const char* str, int* result) {
    char* end;
    long val = strtol(str, &end, 10);
    if (*end != '\0' || val < INT_MIN || val > INT_MAX) {
        return -1; // Invalid
    }
    *result = (int)val;
    return 0;
}
```

## Authentication & Authorization

### Authentication

**Purpose**: Verify user identity

**Methods**:
- **Passwords**: Hash and salt
- **Multi-factor**: Additional factors
- **Tokens**: JWT, OAuth

### Secure Password Storage

**BAD**:
```c
// BAD: Plain text
store_password(username, password);

// BAD: Simple hash
hash = md5(password);
store_hash(username, hash);
// Vulnerable to rainbow tables
```

**GOOD**:
```c
// GOOD: Salted hash
salt = generate_random_salt();
hash = bcrypt(password, salt);
store(username, hash, salt);

// Verification
stored_hash = get_hash(username);
stored_salt = get_salt(username);
if (bcrypt_verify(password, stored_salt) == stored_hash) {
    // Authenticated
}
```

### Authorization

**Purpose**: Control access to resources

**Methods**:
- **RBAC**: Role-Based Access Control
- **ACL**: Access Control Lists
- **Capabilities**: Capability-based security

## Secure Communication

### HTTPS/TLS

**Requirement**: Encrypt all sensitive communication

**Benefits**:
- **Confidentiality**: Data encrypted
- **Integrity**: Detect tampering
- **Authentication**: Verify server identity

### Certificate Validation

**BAD**:
```c
// BAD: Disable certificate validation
SSL_CTX_set_verify(ctx, SSL_VERIFY_NONE, NULL);
// Vulnerable to man-in-the-middle!
```

**GOOD**:
```c
// GOOD: Validate certificates
SSL_CTX_set_verify(ctx, SSL_VERIFY_PEER, verify_callback);
```

## Best Practices

### Secure Development Lifecycle

**1. Threat Modeling**: Identify threats

**2. Secure Design**: Design with security in mind

**3. Secure Coding**: Follow secure coding practices

**4. Security Testing**: Test for vulnerabilities

**5. Code Review**: Review for security issues

### Security Checklist

**Input Validation**:
- [ ] Validate all input
- [ ] Use parameterized queries
- [ ] Encode output

**Authentication**:
- [ ] Strong password requirements
- [ ] Salt and hash passwords
- [ ] Implement account lockout

**Authorization**:
- [ ] Check permissions
- [ ] Principle of least privilege
- [ ] Validate on server side

**Cryptography**:
- [ ] Use proven algorithms
- [ ] Secure key management
- [ ] Don't roll your own crypto

**Error Handling**:
- [ ] Don't leak sensitive info
- [ ] Log securely
- [ ] Fail securely

## Real-World Examples

### Example 1: Heartbleed Bug

**Vulnerability**: Buffer over-read in OpenSSL

**Impact**: Leaked memory contents

**Lesson**: Always validate input lengths

### Example 2: Equifax Breach

**Vulnerability**: Unpatched Apache Struts

**Impact**: 147 million records exposed

**Lesson**: Keep dependencies updated

## Common Pitfalls

### Problem: Trusting Client-Side Validation

```javascript
// BAD: Only client-side validation
if (username.length < 3) {
    alert("Username too short");
    return;
}
// Attacker can bypass!

// GOOD: Server-side validation
if (strlen(username) < 3) {
    return error("Username too short");
}
```

### Problem: Weak Random Numbers

```c
// BAD: Predictable random
int token = rand(); // Predictable!

// GOOD: Cryptographically secure random
unsigned char token[32];
RAND_bytes(token, 32); // Secure
```

## Quiz

1. What is the main cause of buffer overflow vulnerabilities?
   - **A)** Too much memory
   - **B)** Insufficient bounds checking when writing to buffers
   - **C)** Slow execution
   - **D)** Too many variables

2. How do you prevent SQL injection?
   - **A)** Use longer passwords
   - **B)** Use parameterized queries instead of string concatenation
   - **C)** Encrypt database
   - **D)** Use faster database

3. What is XSS?
   - **A)** Cross-Site Scripting - injecting malicious scripts into web pages
   - **B)** Extra Secure System
   - **C)** XML Security Standard
   - **D)** Extended Security System

**Answers:**
1. **B** - Buffer overflow occurs when code writes beyond buffer boundaries due to insufficient bounds checking
2. **B** - Parameterized queries (prepared statements) prevent SQL injection by separating SQL code from data, preventing malicious SQL from being executed
3. **A** - XSS (Cross-Site Scripting) is injecting malicious scripts into web pages that execute in users' browsers, potentially stealing data or performing unauthorized actions

## Next Steps

- [Authentication Protocols - OAuth, JWT](../security/04.%20Authentication%20Protocols.md) - Auth standards
- [Network Security](../security/05.%20Network%20Security.md) - Network-level security

