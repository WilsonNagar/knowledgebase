---
number: 6
title: "Algorithmic Optimization"
slug: "algorithmic-optimization"
level: "intermediate"
tags: ["performance", "algorithms", "optimization", "complexity", "efficiency"]
prerequisites: ["performance-benchmarking"]
estimated_minutes: 140
contributors: []
diagrams: []
examples: []
canonical_id: "cs-mem-06"
---

# Algorithmic Optimization

## Overview

Algorithmic optimization focuses on improving algorithm efficiency through better algorithms, data structures, and optimization techniques. Understanding algorithmic complexity, optimization strategies, and trade-offs is essential for writing high-performance code.

## Table of Contents

1. [Algorithmic Complexity](#complexity)
2. [Optimization Strategies](#strategies)
3. [Data Structure Optimization](#data-structures)
4. [Algorithm Selection](#algorithm-selection)
5. [Space-Time Trade-offs](#trade-offs)
6. [Optimization Techniques](#techniques)
7. [Real-World Examples](#examples)
8. [Best Practices](#best-practices)

## Algorithmic Complexity

### Time Complexity

**Time Complexity**: How time scales with input

**Big O Notation**: 
- **O(1)**: Constant time
- **O(log n)**: Logarithmic
- **O(n)**: Linear
- **O(n log n)**: Linearithmic
- **O(n²)**: Quadratic
- **O(2ⁿ)**: Exponential

**Goal**: Lower time complexity

### Space Complexity

**Space Complexity**: How space scales with input

**Considerations**: 
- **Auxiliary Space**: Extra space
- **Input Space**: Input space
- **Total Space**: Total space

**Goal**: Lower space complexity

## Optimization Strategies

### Strategy 1: Choose Better Algorithm

**Better Algorithm**: Lower complexity

**Example**:
```c
// BAD: O(n²) - nested loops
for (int i = 0; i < n; i++) {
    for (int j = 0; j < n; j++) {
        // O(n²) operations
    }
}

// GOOD: O(n log n) - sorting + linear scan
sort(arr, n);
for (int i = 0; i < n; i++) {
    // O(n) operations
}
```

### Strategy 2: Use Better Data Structure

**Better Data Structure**: More efficient operations

**Example**:
```c
// BAD: O(n) lookup - array
int find(int arr[], int n, int key) {
    for (int i = 0; i < n; i++) {
        if (arr[i] == key) return i;
    }
    return -1;
}

// GOOD: O(1) lookup - hash table
int find(HashTable* ht, int key) {
    return hash_table_get(ht, key);
}
```

### Strategy 3: Cache Results

**Memoization**: Cache computed results

**Example**:
```c
// BAD: Recompute - O(2ⁿ)
int fib(int n) {
    if (n <= 1) return n;
    return fib(n-1) + fib(n-2);
}

// GOOD: Memoize - O(n)
int fib_memo(int n, int* memo) {
    if (n <= 1) return n;
    if (memo[n] != -1) return memo[n];
    memo[n] = fib_memo(n-1, memo) + fib_memo(n-2, memo);
    return memo[n];
}
```

## Data Structure Optimization

### Choose Right Data Structure

**Array**: 
- **Access**: O(1) random access
- **Insert**: O(n) insertion
- **Use**: When need random access

**Linked List**: 
- **Access**: O(n) access
- **Insert**: O(1) insertion
- **Use**: When need frequent insertion

**Hash Table**: 
- **Access**: O(1) average
- **Insert**: O(1) average
- **Use**: When need fast lookup

**Tree**: 
- **Access**: O(log n)
- **Insert**: O(log n)
- **Use**: When need ordered data

## Algorithm Selection

### Selection Criteria

**1. Input Size**:
```
Small: Simple algorithm
Large: Efficient algorithm
```

**2. Data Characteristics**:
```
Sorted: Use binary search
Unsorted: Use linear search
```

**3. Operations**:
```
Frequent lookup: Hash table
Frequent insertion: Linked list
```

**4. Constraints**:
```
Memory: Space-efficient
Time: Time-efficient
```

## Space-Time Trade-offs

### Trade-off Examples

**1. Hash Table**:
```
Time: O(1) lookup
Space: O(n) extra space
```

**2. Sorting**:
```
Time: O(n log n) sort
Space: O(1) in-place vs O(n) extra
```

**3. Memoization**:
```
Time: Faster (cache hits)
Space: O(n) cache space
```

### Choosing Trade-offs

**Consider**:
- **Memory Available**: How much memory?
- **Time Critical**: How time-critical?
- **Input Size**: How large input?
- **Frequency**: How often called?

## Optimization Techniques

### Technique 1: Early Exit

**Early Exit**: Exit early when possible

**Example**:
```c
// BAD: Always check all
bool contains(int arr[], int n, int key) {
    for (int i = 0; i < n; i++) {
        if (arr[i] == key) return true;
    }
    return false;
}

// GOOD: Early exit (same but clearer intent)
```

### Technique 2: Reduce Redundant Work

**Avoid Redundant Work**:
```c
// BAD: Redundant computation
for (int i = 0; i < n; i++) {
    int sum = 0;
    for (int j = 0; j < n; j++) {
        sum += arr[j];  // Computed n times
    }
    result[i] = sum;
}

// GOOD: Compute once
int sum = 0;
for (int j = 0; j < n; j++) {
    sum += arr[j];
}
for (int i = 0; i < n; i++) {
    result[i] = sum;
}
```

### Technique 3: Use Specialized Algorithms

**Specialized Algorithms**: Use when applicable

**Example**:
```c
// BAD: General sort - O(n log n)
sort(arr, n);

// GOOD: Counting sort for small range - O(n + k)
counting_sort(arr, n, max_val);
```

## Real-World Examples

### Example 1: Database Query

**Problem**: Slow query

**Optimization**: Add index

**Result**: O(n) → O(log n)

### Example 2: String Matching

**Problem**: Slow string search

**Optimization**: Use KMP algorithm

**Result**: O(nm) → O(n + m)

### Example 3: Graph Traversal

**Problem**: Slow graph search

**Optimization**: Use A* instead of BFS

**Result**: Fewer nodes explored

## Best Practices

### Practice 1: Measure First

**Measure**: 
```
Measure before optimizing
Identify bottlenecks
```

**Benefit**: Focus on real bottlenecks

### Practice 2: Optimize Algorithm First

**Algorithm First**: 
```
Optimize algorithm before micro-optimizations
```

**Benefit**: Bigger impact

### Practice 3: Consider Trade-offs

**Trade-offs**: 
```
Consider space-time trade-offs
Choose based on constraints
```

**Benefit**: Optimal solution

## Common Pitfalls

### Problem: Premature Optimization

```c
// BAD: Optimize without measuring
// May optimize wrong thing

// GOOD: Measure first
// Optimize bottlenecks
```

### Problem: Wrong Algorithm

```c
// BAD: Use wrong algorithm
// Poor performance

// GOOD: Choose right algorithm
// For the use case
```

## Quiz

1. What is algorithmic optimization?
   - **A)** Code formatting
   - **B)** Improving algorithm efficiency through better algorithms and data structures
   - **C)** Adding comments
   - **D)** Code review

2. What is the goal of algorithmic optimization?
   - **A)** More code
   - **B)** Lower time/space complexity and better performance
   - **C)** Simpler code
   - **D)** More features

3. What is memoization?
   - **A)** Memory allocation
   - **B)** Caching computed results to avoid recomputation
   - **C)** Memory deallocation
   - **D)** Memory profiling

**Answers:**
1. **B** - Algorithmic optimization improves efficiency by choosing better algorithms, data structures, and optimization techniques
2. **B** - The goal is to reduce time and space complexity, improving performance for given inputs
3. **B** - Memoization caches previously computed results to avoid redundant calculations, trading space for time

## Next Steps

- [Profiling Tools](../memory_performance/07.%20Profiling%20Tools.md) - Profiling tools
- [Memory Management Advanced](../memory_performance/08.%20Memory%20Management%20Advanced.md) - Advanced memory

