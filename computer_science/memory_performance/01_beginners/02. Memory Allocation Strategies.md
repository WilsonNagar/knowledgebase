---
number: 2
title: "Memory Allocation Strategies"
slug: "memory-allocation-strategies"
level: "fundamentals"
tags: ["memory", "allocation", "malloc", "gc", "memory-management"]
prerequisites: ["stack-vs-heap-deep-dive"]
estimated_minutes: 125
contributors: []
diagrams: []
examples: []
canonical_id: "cs-mem-02"
---

# Memory Allocation Strategies

## Overview

Memory allocation strategies determine how memory is allocated and deallocated. Understanding different allocation strategies like manual allocation, garbage collection, memory pools, and their trade-offs is essential for efficient memory management and performance optimization.

## Table of Contents

1. [Manual Memory Management](#manual)
2. [Garbage Collection](#garbage-collection)
3. [Memory Pools](#memory-pools)
4. [Arena Allocation](#arena-allocation)
5. [Stack Allocation](#stack-allocation)
6. [Allocation Strategies Comparison](#comparison)
7. [Performance Considerations](#performance)
8. [Best Practices](#best-practices)

## Manual Memory Management

### What is Manual Management?

**Manual Management**: Programmer manages memory

**Operations**:
- **Allocate**: malloc, new
- **Deallocate**: free, delete

**Languages**: C, C++

**Control**: Full control

**Risk**: Memory leaks, use-after-free

### Manual Allocation Example

**C**:
```c
// Allocate
int* arr = malloc(100 * sizeof(int));

// Use
for (int i = 0; i < 100; i++) {
    arr[i] = i;
}

// Deallocate
free(arr);
```

**C++**:
```cpp
// Allocate
int* arr = new int[100];

// Use
for (int i = 0; i < 100; i++) {
    arr[i] = i;
}

// Deallocate
delete[] arr;
```

### Manual Management Challenges

**1. Memory Leaks**:
```
Forget to free memory
```

**2. Use-After-Free**:
```
Use freed memory
```

**3. Double Free**:
```
Free same memory twice
```

**4. Dangling Pointers**:
```
Pointers to freed memory
```

## Garbage Collection

### What is Garbage Collection?

**Garbage Collection**: Automatic memory management

**Process**: 
```
1. Identify unreachable objects
2. Reclaim memory
```

**Languages**: Java, C#, Python, Go, JavaScript

**Benefit**: No manual management

**Cost**: GC pauses, overhead

### GC Types

**1. Mark-Sweep**:
```
Mark reachable, sweep unreachable
```

**2. Mark-Compact**:
```
Mark, compact live objects
```

**3. Copying**:
```
Copy live objects to new space
```

**4. Generational**:
```
Separate young/old generations
```

### GC Example

**Java**:
```java
// Allocate (automatic)
int[] arr = new int[100];

// Use
for (int i = 0; i < 100; i++) {
    arr[i] = i;
}

// Deallocate (automatic)
// GC reclaims when unreachable
```

## Memory Pools

### What are Memory Pools?

**Memory Pool**: Pre-allocated memory blocks

**Purpose**: Reduce allocation overhead

**Method**: 
```
1. Pre-allocate pool
2. Allocate from pool
3. Return to pool
```

**Benefit**: Fast allocation

### Memory Pool Example

**Implementation**:
```c
typedef struct {
    void* pool;
    size_t block_size;
    size_t num_blocks;
    bool* used;
} MemoryPool;

MemoryPool* create_pool(size_t block_size, size_t num_blocks) {
    MemoryPool* pool = malloc(sizeof(MemoryPool));
    pool->pool = malloc(block_size * num_blocks);
    pool->block_size = block_size;
    pool->num_blocks = num_blocks;
    pool->used = calloc(num_blocks, sizeof(bool));
    return pool;
}

void* pool_alloc(MemoryPool* pool) {
    for (size_t i = 0; i < pool->num_blocks; i++) {
        if (!pool->used[i]) {
            pool->used[i] = true;
            return (char*)pool->pool + i * pool->block_size;
        }
    }
    return NULL;  // Pool exhausted
}

void pool_free(MemoryPool* pool, void* ptr) {
    size_t index = ((char*)ptr - (char*)pool->pool) / pool->block_size;
    pool->used[index] = false;
}
```

## Arena Allocation

### What is Arena Allocation?

**Arena**: Contiguous memory region

**Purpose**: Fast allocation, easy deallocation

**Method**: 
```
1. Allocate arena
2. Allocate from arena sequentially
3. Free entire arena at once
```

**Benefit**: Very fast allocation

### Arena Example

**Implementation**:
```c
typedef struct {
    char* memory;
    size_t size;
    size_t offset;
} Arena;

Arena* create_arena(size_t size) {
    Arena* arena = malloc(sizeof(Arena));
    arena->memory = malloc(size);
    arena->size = size;
    arena->offset = 0;
    return arena;
}

void* arena_alloc(Arena* arena, size_t size) {
    if (arena->offset + size > arena->size) {
        return NULL;  // Arena full
    }
    void* ptr = arena->memory + arena->offset;
    arena->offset += size;
    return ptr;
}

void arena_free(Arena* arena) {
    arena->offset = 0;  // Reset (or free entire arena)
}
```

## Stack Allocation

### Stack Allocation

**Stack**: Automatic stack allocation

**Use**: Local variables, small objects

**Benefit**: Very fast, automatic

**Limitation**: Limited size, function scope

### Stack Allocation Example

**C**:
```c
void function() {
    int arr[100];  // Stack allocation
    // Automatic deallocation when function returns
}
```

**C++**:
```cpp
void function() {
    std::array<int, 100> arr;  // Stack allocation
    // Automatic deallocation
}
```

## Allocation Strategies Comparison

### Comparison Table

| Strategy | Speed | Control | Safety | Use Case |
|----------|-------|---------|--------|----------|
| **Manual** | Fast | Full | Low | C, C++ |
| **GC** | Medium | Low | High | Java, C#, Python |
| **Memory Pool** | Very Fast | Medium | Medium | Game engines, embedded |
| **Arena** | Very Fast | Medium | Medium | Parsers, compilers |
| **Stack** | Fastest | Low | High | Local variables |

### When to Use Each

**Manual**: 
- **Control**: Need full control
- **Performance**: Critical performance

**GC**: 
- **Safety**: Need safety
- **Productivity**: Faster development

**Memory Pool**: 
- **Many Small Objects**: Many small allocations
- **Performance**: Need performance

**Arena**: 
- **Temporary Objects**: Temporary objects
- **Batch Deallocation**: Batch deallocation

**Stack**: 
- **Small Objects**: Small, local objects
- **Automatic**: Automatic management

## Performance Considerations

### Allocation Performance

**Fastest to Slowest**:
1. **Stack**: O(1) - just move pointer
2. **Arena**: O(1) - sequential allocation
3. **Memory Pool**: O(n) - find free block
4. **Manual**: O(log n) - heap manager
5. **GC**: Variable - depends on GC algorithm

### Fragmentation

**Stack**: No fragmentation

**Arena**: No fragmentation (if used correctly)

**Memory Pool**: No fragmentation (fixed block size)

**Manual**: Possible fragmentation

**GC**: Possible fragmentation (depends on GC)

## Best Practices

### Practice 1: Choose Right Strategy

**Choose Appropriately**:
```c
// Small, local → Stack
int arr[100];

// Many small objects → Memory pool
MemoryPool* pool = create_pool(sizeof(Object), 1000);

// Temporary objects → Arena
Arena* arena = create_arena(1024 * 1024);
```

### Practice 2: Minimize Allocations

**Reduce Allocations**:
```c
// BAD: Many allocations
for (int i = 0; i < 1000; i++) {
    int* x = malloc(sizeof(int));
    free(x);
}

// GOOD: Fewer allocations
int* arr = malloc(1000 * sizeof(int));
// Use arr
free(arr);
```

### Practice 3: Use Object Pooling

**Object Pooling**:
```c
// Reuse objects instead of allocating new ones
Object* obj = pool_get_object(pool);
// Use obj
pool_return_object(pool, obj);
```

## Real-World Examples

### Example 1: Game Engine

**Use**: Memory pools

**Reason**: Many small allocations

**Benefit**: Fast allocation, no fragmentation

### Example 2: Parser

**Use**: Arena allocation

**Reason**: Temporary objects

**Benefit**: Fast allocation, easy cleanup

### Example 3: Web Server

**Use**: Stack + manual

**Reason**: Performance critical

**Benefit**: Fast, controlled

## Common Pitfalls

### Problem: Memory Leak

```c
// BAD: Forget to free
int* arr = malloc(100 * sizeof(int));
// Memory leak if not freed

// GOOD: Always free
int* arr = malloc(100 * sizeof(int));
// Use arr
free(arr);
```

### Problem: Wrong Strategy

```c
// BAD: Heap for small, local data
void function() {
    int* x = malloc(sizeof(int));  // Unnecessary
    free(x);
}

// GOOD: Stack for small, local data
void function() {
    int x;  // Stack allocation
}
```

## Quiz

1. What is manual memory management?
   - **A)** Automatic management
   - **B)** Programmer manually allocates and deallocates memory
   - **C)** Garbage collection
   - **D)** Stack allocation

2. What is garbage collection?
   - **A)** Manual management
   - **B)** Automatic memory management that reclaims unreachable objects
   - **C)** Memory pools
   - **D)** Stack allocation

3. What is a memory pool?
   - **A)** Garbage collection
   - **B)** Pre-allocated memory blocks for fast allocation
   - **C)** Stack memory
   - **D)** Heap memory

**Answers:**
1. **B** - Manual memory management requires the programmer to explicitly allocate (malloc/new) and deallocate (free/delete) memory
2. **B** - Garbage collection automatically identifies and reclaims memory occupied by unreachable objects, eliminating manual memory management
3. **B** - A memory pool pre-allocates a set of memory blocks, allowing fast allocation/deallocation by reusing blocks from the pool

## Next Steps

- [Cache Optimization Techniques](./03.%20Cache%20Optimization%20Techniques.md) - Cache optimization
- [Memory Profiling & Analysis](../02_intermediate/04.%20Memory%20Profiling%20%26%20Analysis.md) - Memory profiling

