---
number: 8
title: "Assembly Language Fundamentals - x86, ARM"
slug: "assembly-language-fundamentals-x86-arm"
level: "intermediate"
tags: ["computer-architecture", "assembly", "x86", "arm", "low-level"]
prerequisites: ["risc-vs-cisc-architectures"]
estimated_minutes: 140
contributors: []
diagrams: []
examples: []
canonical_id: "cs-arch-08"
---

# Assembly Language Fundamentals - x86, ARM

## Overview

Assembly language provides direct access to CPU instructions. Understanding x86 and ARM assembly, instruction formats, addressing modes, and low-level programming is essential for systems programming, optimization, and understanding how high-level code executes.

## Table of Contents

1. [What is Assembly Language?](#what-is-assembly)
2. [x86 Assembly](#x86-assembly)
3. [ARM Assembly](#arm-assembly)
4. [Instruction Formats](#instruction-formats)
5. [Addressing Modes](#addressing-modes)
6. [Common Instructions](#common-instructions)
7. [Calling Conventions](#calling-conventions)
8. [Real-World Examples](#examples)

## What is Assembly Language?

### Definition

**Assembly Language**: Low-level programming language

**Purpose**: Direct CPU control

**Characteristics**:
- **Mnemonics**: Human-readable mnemonics
- **One-to-One**: One instruction per CPU instruction
- **Platform-Specific**: Platform-specific
- **Direct Control**: Direct hardware control

**Use**: Systems programming, optimization, embedded systems

### Assembly vs High-Level Languages

**Assembly**:
- **Control**: Full control
- **Performance**: Maximum performance
- **Complexity**: Complex
- **Portability**: Not portable

**High-Level**:
- **Abstraction**: High abstraction
- **Productivity**: Higher productivity
- **Portability**: Portable
- **Performance**: May be slower

## x86 Assembly

### x86 Registers

**General-Purpose Registers**:
- **EAX/RAX**: Accumulator (return value)
- **EBX/RBX**: Base
- **ECX/RCX**: Counter
- **EDX/RDX**: Data
- **ESI/RSI**: Source index
- **EDI/RDI**: Destination index
- **EBP/RBP**: Base pointer
- **ESP/RSP**: Stack pointer

**x86-64**: 64-bit versions (RAX, RBX, etc.)

### x86 Instruction Format

**Format**: 
```
[prefix] opcode [operands]
```

**Example**:
```assembly
MOV EAX, 10        ; Move 10 to EAX
ADD EAX, EBX       ; Add EBX to EAX
MOV [EBP-4], EAX   ; Store EAX to stack
```

### x86 Examples

**Simple Operations**:
```assembly
MOV EAX, 10        ; EAX = 10
MOV EBX, 20        ; EBX = 20
ADD EAX, EBX       ; EAX = EAX + EBX (30)
SUB EAX, 5         ; EAX = EAX - 5 (25)
```

**Memory Access**:
```assembly
MOV EAX, [EBP+8]   ; Load from stack
MOV [EBP-4], EAX   ; Store to stack
MOV EAX, [ESI]     ; Load from address in ESI
```

## ARM Assembly

### ARM Registers

**General-Purpose Registers**:
- **R0-R12**: General-purpose
- **R13/SP**: Stack pointer
- **R14/LR**: Link register (return address)
- **R15/PC**: Program counter

**ARM64**: 64-bit versions (X0-X30)

### ARM Instruction Format

**Format**: 
```
opcode destination, source1, source2
```

**Example**:
```assembly
MOV R0, #10        ; Move 10 to R0
ADD R0, R0, R1     ; Add R1 to R0
LDR R0, [SP, #4]   ; Load from stack
STR R0, [SP, #4]   ; Store to stack
```

### ARM Examples

**Simple Operations**:
```assembly
MOV R0, #10        ; R0 = 10
MOV R1, #20        ; R1 = 20
ADD R0, R0, R1     ; R0 = R0 + R1 (30)
SUB R0, R0, #5     ; R0 = R0 - 5 (25)
```

**Memory Access**:
```assembly
LDR R0, [SP, #4]   ; Load from stack
STR R0, [SP, #4]   ; Store to stack
LDR R0, [R1]       ; Load from address in R1
STR R0, [R1]       ; Store to address in R1
```

## Instruction Formats

### x86 Format

**Format**: 
```
[prefix] opcode [modrm] [sib] [displacement] [immediate]
```

**Variable Length**: 1-15 bytes

**Example**:
```assembly
MOV EAX, 10        ; opcode + immediate
ADD EAX, EBX       ; opcode + modrm
MOV [EBP-4], EAX   ; opcode + modrm + displacement
```

### ARM Format

**Format**: 
```
opcode destination, source1, source2
```

**Fixed Length**: 32 bits (ARM), 32/64 bits (ARM64)

**Example**:
```assembly
MOV R0, #10        ; opcode + destination + immediate
ADD R0, R0, R1     ; opcode + destination + source1 + source2
LDR R0, [SP, #4]   ; opcode + destination + base + offset
```

## Addressing Modes

### x86 Addressing Modes

**1. Immediate**:
```
MOV EAX, 10        ; Immediate value
```

**2. Register**:
```
MOV EAX, EBX       ; Register
```

**3. Direct Memory**:
```
MOV EAX, [0x1234]  ; Direct address
```

**4. Register Indirect**:
```
MOV EAX, [EBX]     ; Address in register
```

**5. Base + Displacement**:
```
MOV EAX, [EBP-4]   ; Base + offset
```

**6. Indexed**:
```
MOV EAX, [ESI+EDI] ; Indexed
```

### ARM Addressing Modes

**1. Immediate**:
```
MOV R0, #10        ; Immediate value
```

**2. Register**:
```
MOV R0, R1         ; Register
```

**3. Register Indirect**:
```
LDR R0, [R1]       ; Address in register
```

**4. Base + Offset**:
```
LDR R0, [SP, #4]   ; Base + offset
```

**5. Pre-indexed**:
```
LDR R0, [R1, #4]!  ; Update R1
```

**6. Post-indexed**:
```
LDR R0, [R1], #4   ; Load, then update R1
```

## Common Instructions

### Arithmetic Instructions

**x86**:
```assembly
ADD EAX, EBX       ; Addition
SUB EAX, EBX       ; Subtraction
MUL EBX            ; Multiplication
DIV EBX            ; Division
```

**ARM**:
```assembly
ADD R0, R0, R1     ; Addition
SUB R0, R0, R1     ; Subtraction
MUL R0, R0, R1     ; Multiplication
```

### Control Flow

**x86**:
```assembly
CMP EAX, EBX       ; Compare
JE label           ; Jump if equal
JMP label          ; Unconditional jump
CALL function      ; Call function
RET                ; Return
```

**ARM**:
```assembly
CMP R0, R1         ; Compare
BEQ label          ; Branch if equal
B label            ; Unconditional branch
BL function        ; Branch with link (call)
BX LR              ; Return
```

## Calling Conventions

### x86 Calling Convention

**cdecl** (C calling convention):
- **Arguments**: Passed on stack (right to left)
- **Return**: EAX
- **Caller Cleanup**: Caller cleans stack

**Example**:
```assembly
PUSH 20            ; Push second argument
PUSH 10            ; Push first argument
CALL add           ; Call function
ADD ESP, 8         ; Clean stack
```

### ARM Calling Convention

**ARM Procedure Call Standard**:
- **Arguments**: R0-R3 (first 4), then stack
- **Return**: R0
- **Callee Save**: R4-R11, SP, LR

**Example**:
```assembly
MOV R0, #10        ; First argument
MOV R1, #20        ; Second argument
BL add             ; Call function
```

## Real-World Examples

### Example 1: Simple Function

**C Code**:
```c
int add(int a, int b) {
    return a + b;
}
```

**x86 Assembly**:
```assembly
add:
    MOV EAX, [ESP+4]    ; Load a
    ADD EAX, [ESP+8]    ; Add b
    RET                 ; Return
```

**ARM Assembly**:
```assembly
add:
    ADD R0, R0, R1      ; Add arguments
    BX LR               ; Return
```

### Example 2: Loop

**C Code**:
```c
int sum = 0;
for (int i = 0; i < 10; i++) {
    sum += i;
}
```

**x86 Assembly**:
```assembly
MOV EAX, 0          ; sum = 0
MOV ECX, 0          ; i = 0
loop:
    ADD EAX, ECX     ; sum += i
    INC ECX          ; i++
    CMP ECX, 10      ; Compare i with 10
    JL loop          ; Jump if less
```

**ARM Assembly**:
```assembly
MOV R0, #0          ; sum = 0
MOV R1, #0          ; i = 0
loop:
    ADD R0, R0, R1   ; sum += i
    ADD R1, R1, #1   ; i++
    CMP R1, #10      ; Compare i with 10
    BLT loop         ; Branch if less than
```

## Common Pitfalls

### Problem: Register Clobbering

```assembly
// BAD: Clobber callee-save registers
// Without saving

// GOOD: Save callee-save registers
PUSH EBP
MOV EBP, ESP
// ... function code ...
POP EBP
```

### Problem: Stack Alignment

```assembly
// BAD: Misaligned stack
// May cause issues

// GOOD: Align stack
SUB ESP, 16         ; Align to 16 bytes
```

## Quiz

1. What is assembly language?
   - **A)** High-level language
   - **B)** Low-level language providing direct CPU control with mnemonics
   - **C)** Scripting language
   - **D)** Markup language

2. What is the main difference between x86 and ARM assembly?
   - **A)** No difference
   - **B)** x86 uses variable-length instructions and CISC; ARM uses fixed-length instructions and RISC
   - **C)** x86 is simpler
   - **D)** ARM is more complex

3. What is a calling convention?
   - **A)** Function name
   - **B)** Standard for how functions pass arguments and return values
   - **C)** Function call
   - **D)** Function definition

**Answers:**
1. **B** - Assembly language is a low-level programming language that uses mnemonics to represent CPU instructions, providing direct hardware control
2. **B** - x86 uses variable-length CISC instructions; ARM uses fixed-length RISC instructions with load/store architecture
3. **B** - A calling convention defines how functions pass arguments (registers/stack), return values, and manage registers/stack

## Next Steps

- [Out-of-Order Execution](./09.%20Out-of-Order%20Execution.md) - OoO execution
- [Speculative Execution & Security](./10.%20Speculative%20Execution%20%26%20Security.md) - Speculation security

