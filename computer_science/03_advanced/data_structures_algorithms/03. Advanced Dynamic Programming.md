---
number: 3
title: "Advanced Dynamic Programming"
slug: "advanced-dynamic-programming"
level: "advanced"
tags: ["data-structures", "dynamic-programming", "algorithms", "optimization", "dp"]
prerequisites: []
estimated_minutes: 145
contributors: []
diagrams: []
examples: []
canonical_id: "cs-dsa-adv-03"
---

# Advanced Dynamic Programming

## Overview

Advanced dynamic programming techniques extend basic DP to solve complex optimization problems. Understanding digit DP, bitmask DP, DP on trees, and advanced optimization techniques like convex hull trick and divide and conquer optimization is essential for competitive programming and solving challenging optimization problems.

## Table of Contents

1. [DP Review](#dp-review)
2. [Digit DP](#digit-dp)
3. [Bitmask DP](#bitmask-dp)
4. [DP on Trees](#dp-trees)
5. [DP Optimization](#dp-optimization)
6. [Convex Hull Trick](#convex-hull-trick)
7. [Divide and Conquer DP](#divide-conquer-dp)
8. [Applications](#applications)

## DP Review

### Basic DP

**Principle**: Optimal substructure + Overlapping subproblems

**Approach**: 
- **Memoization**: Top-down
- **Tabulation**: Bottom-up

**Example**: Fibonacci
```c
int fib(int n) {
    if (n <= 1) return n;
    if (dp[n] != -1) return dp[n];
    return dp[n] = fib(n-1) + fib(n-2);
}
```

## Digit DP

### What is Digit DP?

**Digit DP**: DP on digits of number

**Use**: Count numbers with properties

**Example**: Count numbers ≤ N with digit sum = S

### Digit DP Structure

**State**: (position, tight, sum, ...)

**Tight**: Whether prefix equals N's prefix

**Process**: 
```
1. Process digits left to right
2. For each digit:
   If tight: Can only use digits ≤ N's digit
   Else: Can use any digit
3. Recurse with new state
```

**Code**:
```c
int dp[20][2][200];  // pos, tight, sum

int digit_dp(string num, int pos, int tight, int sum, int target) {
    if (pos == num.length()) {
        return sum == target;
    }
    
    if (dp[pos][tight][sum] != -1) {
        return dp[pos][tight][sum];
    }
    
    int limit = tight ? (num[pos] - '0') : 9;
    int result = 0;
    
    for (int digit = 0; digit <= limit; digit++) {
        int new_tight = tight && (digit == limit);
        int new_sum = sum + digit;
        result += digit_dp(num, pos + 1, new_tight, new_sum, target);
    }
    
    return dp[pos][tight][sum] = result;
}
```

## Bitmask DP

### What is Bitmask DP?

**Bitmask DP**: DP using bitmasks

**Use**: Subset problems, TSP

**Bitmask**: Integer representing subset

**Example**: mask = 5 (binary 101) = {0, 2}

### Traveling Salesman Problem

**Problem**: Visit all cities, return to start

**State**: dp[mask][last] = minimum cost

**Transition**: 
```
dp[mask | (1<<next)][next] = min(
    dp[mask | (1<<next)][next],
    dp[mask][last] + cost[last][next]
)
```

**Code**:
```c
int dp[1<<n][n];

int tsp(int mask, int last) {
    if (mask == (1<<n) - 1) {
        return cost[last][0];  // Return to start
    }
    
    if (dp[mask][last] != -1) {
        return dp[mask][last];
    }
    
    int result = INT_MAX;
    for (int next = 0; next < n; next++) {
        if (!(mask & (1<<next))) {
            result = min(result, 
                cost[last][next] + tsp(mask | (1<<next), next));
        }
    }
    
    return dp[mask][last] = result;
}
```

## DP on Trees

### Tree DP

**Problem**: Solve DP on tree structure

**Approach**: 
- **Rooted Tree**: Root at arbitrary node
- **Bottom-up**: Process from leaves to root

**Example**: Maximum independent set on tree

**State**: dp[node][taken] = max value

**Code**:
```c
int dp[MAX][2];  // [node][taken]

void tree_dp(int node, int parent) {
    dp[node][0] = 0;  // Not taken
    dp[node][1] = value[node];  // Taken
    
    for (int child : tree[node]) {
        if (child == parent) continue;
        
        tree_dp(child, node);
        
        // Not take node: can take or not take children
        dp[node][0] += max(dp[child][0], dp[child][1]);
        
        // Take node: cannot take children
        dp[node][1] += dp[child][0];
    }
}
```

## DP Optimization

### Space Optimization

**1D DP**: Often only need previous row

**Example**: 
```
// Before: O(n²) space
int dp[n+1][m+1];

// After: O(m) space
int dp[m+1];
int prev[m+1];
```

### State Reduction

**Reduce States**: Eliminate unnecessary states

**Example**: If only need last k states, use sliding window

## Convex Hull Trick

### What is Convex Hull Trick?

**Use**: Optimize DP transitions

**Form**: dp[i] = min/max(a[j] × x[i] + b[j])

**Optimization**: Use convex hull to find optimal j

**Complexity**: O(n log n) instead of O(n²)

## Divide and Conquer DP

### Optimization

**Condition**: dp[i][j] = min(dp[i-1][k] + cost(k, j))

**Property**: Optimal k is monotonic

**Method**: Divide and conquer

**Complexity**: O(n² log n) → O(n log² n)

## Applications

### Application 1: Counting Problems

**Use**: Digit DP for counting

**Example**: Count numbers with properties

### Application 2: Optimization

**Use**: Bitmask DP for subset problems

**Example**: TSP, assignment problems

### Application 3: Tree Problems

**Use**: DP on trees

**Example**: Tree coloring, independent set

## Real-World Examples

### Example 1: Number Counting

**Problem**: Count numbers in range with digit sum = S

**Solution**: Digit DP

### Example 2: Task Assignment

**Problem**: Assign tasks to workers

**Solution**: Bitmask DP

## Common Pitfalls

### Problem: State Explosion

```c
// BAD: Too many states
dp[1000][1000][1000];  // 1 billion states!

// GOOD: Reduce states
// Use space optimization, state reduction
```

### Problem: Wrong Transition

```c
// BAD: Incorrect recurrence
dp[i] = dp[i-1] + dp[i-2];  // Wrong!

// GOOD: Verify recurrence
// Test on small cases
```

## Quiz

1. What is digit DP?
   - **A)** DP on arrays
   - **B)** DP on digits of numbers for counting problems
   - **C)** DP on strings
   - **D)** DP on graphs

2. What is bitmask DP?
   - **A)** DP on bits
   - **B)** DP using bitmasks to represent subsets
   - **C)** DP on binary trees
   - **D)** DP optimization

3. What is DP on trees?
   - **A)** DP on arrays
   - **B)** Solving DP problems on tree structures bottom-up
   - **C)** DP on graphs
   - **D)** Tree traversal

**Answers:**
1. **B** - Digit DP processes numbers digit by digit, using state like (position, tight constraint, current sum) to count numbers with specific properties
2. **B** - Bitmask DP uses integers as bitmasks to represent subsets, enabling efficient DP solutions for subset problems like TSP
3. **B** - DP on trees solves optimization problems on tree structures by processing nodes from leaves to root, with state depending on tree structure

## Next Steps

- [Approximation Algorithms](../data_structures_algorithms/04.%20Approximation%20Algorithms.md) - Approximation methods
- [Advanced Algorithm Design](../data_structures_algorithms/05.%20Advanced%20Algorithm%20Design.md) - Algorithm techniques

