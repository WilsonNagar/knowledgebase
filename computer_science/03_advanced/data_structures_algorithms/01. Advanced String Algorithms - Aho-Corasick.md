---
number: 1
title: "Advanced String Algorithms - Aho-Corasick"
slug: "advanced-string-algorithms-aho-corasick"
level: "advanced"
tags: ["data-structures", "string-algorithms", "aho-corasick", "trie", "pattern-matching"]
prerequisites: ["suffix-arrays-trees"]
estimated_minutes: 135
contributors: []
diagrams: []
examples: []
canonical_id: "cs-dsa-adv-01"
---

# Advanced String Algorithms - Aho-Corasick

## Overview

Aho-Corasick is a powerful algorithm for finding all occurrences of multiple patterns in a text simultaneously. Understanding the Aho-Corasick automaton, failure links, and how it extends the trie with automaton properties is essential for efficient multi-pattern string matching in text processing and bioinformatics.

## Table of Contents

1. [Multi-Pattern Matching Problem](#multi-pattern)
2. [What is Aho-Corasick?](#what-is-aho-corasick)
3. [Trie Construction](#trie-construction)
4. [Failure Links](#failure-links)
5. [Automaton Construction](#automaton)
6. [Pattern Matching](#pattern-matching)
7. [Output Links](#output-links)
8. [Applications](#applications)

## Multi-Pattern Matching Problem

### Problem Statement

**Input**: 
- **Text**: T[0..n-1]
- **Patterns**: P₁, P₂, ..., Pₖ

**Output**: All occurrences of all patterns in text

**Naive**: Run KMP k times → O(k × (n + m))

**Goal**: O(n + m₁ + m₂ + ... + mₖ)

**Solution**: Aho-Corasick

## What is Aho-Corasick?

### Definition

**Aho-Corasick**: Finite automaton for multi-pattern matching

**Structure**: Trie + Failure links

**Properties**: 
- **Trie**: Stores all patterns
- **Failure Links**: Like KMP failure function
- **Output Links**: Patterns ending at node

**Complexity**: O(n + m + z) where z = number of matches

## Trie Construction

### Building Trie

**Process**: Insert all patterns into trie

**Example**:
```
Patterns: {"he", "she", "his", "hers"}

Trie:
        root
       /    \
      h      s
     / \      \
    e   i     h
   /     \     \
  (he)   s     e
         |      \
        (his)  (she)
                |
                r
                |
                s
              (hers)
```

**Code**:
```c
typedef struct Node {
    struct Node* children[26];
    struct Node* failure;
    int output;  // Pattern ending here
} Node;

Node* insert(Node* root, char* pattern) {
    Node* node = root;
    for (int i = 0; pattern[i] != '\0'; i++) {
        int idx = pattern[i] - 'a';
        if (node->children[idx] == NULL) {
            node->children[idx] = create_node();
        }
        node = node->children[idx];
    }
    node->output = 1;  // Mark pattern end
    return node;
}
```

## Failure Links

### What are Failure Links?

**Failure Link**: Longest proper suffix that's also prefix

**Similar**: To KMP failure function

**Purpose**: Continue matching when mismatch

**Example**:
```
Pattern: "she"
Failure links:
  's' → root
  'h' → root (no 'h' from root)
  'e' → 'e' in "he" (if exists)
```

### Computing Failure Links

**BFS**: Compute level by level

**Process**:
```
1. Root failure = NULL
2. For each level:
   For each node:
     For each child:
       Find failure link
```

**Code**:
```c
void build_failure_links(Node* root) {
    queue<Node*> q;
    
    // Root's children point to root
    for (int i = 0; i < 26; i++) {
        if (root->children[i] != NULL) {
            root->children[i]->failure = root;
            q.push(root->children[i]);
        }
    }
    
    while (!q.empty()) {
        Node* node = q.front();
        q.pop();
        
        for (int i = 0; i < 26; i++) {
            if (node->children[i] != NULL) {
                Node* child = node->children[i];
                Node* failure = node->failure;
                
                // Find failure link
                while (failure != NULL && failure->children[i] == NULL) {
                    failure = failure->failure;
                }
                
                if (failure != NULL) {
                    child->failure = failure->children[i];
                } else {
                    child->failure = root;
                }
                
                q.push(child);
            }
        }
    }
}
```

## Automaton Construction

### Complete Automaton

**Components**:
- **Trie**: Pattern trie
- **Failure Links**: Transition on failure
- **Output Links**: Patterns ending at node

**State**: Current node in automaton

**Transition**: Follow edge or failure link

## Pattern Matching

### Matching Process

**Process**:
```
1. Start at root
2. For each character in text:
   a. Try to follow edge
   b. If no edge, follow failure link
   c. Check for output (patterns found)
   d. Move to next state
```

**Code**:
```c
void search(Node* root, char* text) {
    Node* node = root;
    
    for (int i = 0; text[i] != '\0'; i++) {
        int idx = text[i] - 'a';
        
        // Follow failure links until edge found
        while (node != NULL && node->children[idx] == NULL) {
            node = node->failure;
        }
        
        if (node != NULL) {
            node = node->children[idx];
        } else {
            node = root;
        }
        
        // Check for matches
        Node* temp = node;
        while (temp != NULL) {
            if (temp->output) {
                // Pattern found ending at position i
                printf("Pattern found at %d\n", i);
            }
            temp = temp->failure;  // Check failure chain
        }
    }
}
```

## Output Links

### What are Output Links?

**Output Links**: Chain of patterns ending at node

**Purpose**: Find all patterns ending at current state

**Method**: Follow failure links, collect outputs

**Optimization**: Precompute output links

### Output Link Construction

**Process**: 
```
1. Build failure links
2. For each node:
   If node has output or failure has output:
     Set output link
```

**Benefit**: O(1) output checking

## Applications

### Application 1: Text Search

**Use**: Search for multiple keywords

**Example**: Search for {"algorithm", "data", "structure"}

**Benefit**: Single pass through text

### Application 2: Intrusion Detection

**Use**: Detect multiple attack patterns

**Patterns**: Known attack signatures

**Benefit**: Efficient pattern matching

### Application 3: DNA Sequence Analysis

**Use**: Find multiple sequences

**Patterns**: DNA sequences

**Benefit**: Fast multi-pattern matching

### Application 4: Spam Detection

**Use**: Detect spam keywords

**Patterns**: Spam keywords

**Benefit**: Efficient keyword detection

## Real-World Examples

### Example 1: Search Engine

**Problem**: Find multiple keywords in documents

**Solution**: Aho-Corasick

**Benefit**: Fast multi-keyword search

### Example 2: Antivirus

**Problem**: Scan for multiple virus signatures

**Solution**: Aho-Corasick

**Benefit**: Efficient signature matching

## Common Pitfalls

### Problem: Not Following Failure Links

```c
// BAD: Stop on mismatch
if (node->children[idx] == NULL) {
    return;  // Miss matches!
}

// GOOD: Follow failure links
while (node != NULL && node->children[idx] == NULL) {
    node = node->failure;
}
```

### Problem: Not Checking Output Chain

```c
// BAD: Only check current node
if (node->output) {
    // May miss patterns in failure chain
}

// GOOD: Check failure chain
Node* temp = node;
while (temp != NULL) {
    if (temp->output) {
        // Found pattern
    }
    temp = temp->failure;
}
```

## Quiz

1. What is Aho-Corasick used for?
   - **A)** Single pattern matching
   - **B)** Multi-pattern matching - finding all occurrences of multiple patterns
   - **C)** Pattern generation
   - **D)** Pattern compression

2. What are failure links?
   - **A)** Broken links
   - **B)** Links to longest proper suffix that's also a prefix (like KMP)
   - **C)** Random links
   - **D)** Forward links

3. What is the time complexity of Aho-Corasick?
   - **A)** O(n × m)
   - **B)** O(n + m + z) where n=text length, m=total pattern length, z=matches
   - **C)** O(n²)
   - **D)** O(m²)

**Answers:**
1. **B** - Aho-Corasick efficiently finds all occurrences of multiple patterns in a text simultaneously, building a finite automaton from a trie with failure links
2. **B** - Failure links point to the longest proper suffix of the current string that is also a prefix of some pattern, similar to the KMP failure function, allowing continued matching on mismatch
3. **B** - Aho-Corasick processes the text in O(n) time, builds the automaton in O(m) time where m is total pattern length, and reports z matches, giving overall O(n + m + z) complexity

## Next Steps

- [Computational Geometry Algorithms](../data_structures_algorithms/02.%20Computational%20Geometry.md) - Geometric algorithms
- [Advanced Dynamic Programming](../data_structures_algorithms/03.%20Advanced%20Dynamic%20Programming.md) - DP advanced

