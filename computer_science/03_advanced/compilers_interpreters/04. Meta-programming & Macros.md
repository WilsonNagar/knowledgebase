---
number: 4
title: "Meta-programming & Macros"
slug: "meta-programming-macros"
level: "advanced"
tags: ["compilers", "meta-programming", "macros", "code-generation", "lisp"]
prerequisites: ["domain-specific-languages-dsl"]
estimated_minutes: 140
contributors: []
diagrams: []
examples: []
canonical_id: "cs-comp-adv-04"
---

# Meta-programming & Macros

## Overview

Meta-programming allows programs to generate or manipulate code at compile time or runtime. Understanding macros, code generation, template metaprogramming, and reflection is essential for advanced language features and understanding how languages enable code generation.

## Table of Contents

1. [What is Meta-programming?](#what-is-metaprogramming)
2. [Macros](#macros)
3. [Lisp Macros](#lisp-macros)
4. [Template Metaprogramming](#template-metaprogramming)
5. [Reflection](#reflection)
6. [Code Generation](#code-generation)
7. [AST Manipulation](#ast-manipulation)
8. [Applications](#applications)

## What is Meta-programming?

### Definition

**Meta-programming**: Programs that manipulate programs

**Levels**:
- **Compile-time**: Generate code at compile time
- **Runtime**: Generate/manipulate code at runtime

**Purpose**: Reduce boilerplate, enable abstractions

### Meta-programming Types

**1. Macros**:
```
Code transformation
```

**2. Templates**:
```
Generic code generation
```

**3. Reflection**:
```
Introspect and modify code
```

**4. Code Generation**:
```
Generate code programmatically
```

## Macros

### What are Macros?

**Macros**: Code transformation

**Process**: 
```
1. Define macro
2. Expand macro
3. Replace with generated code
```

**Types**:
- **Text Macros**: Simple text replacement
- **Syntax Macros**: AST transformation

### Text Macros

**C Preprocessor**:
```c
#define MAX(a, b) ((a) > (b) ? (a) : (b))
```

**Expansion**: Text replacement

**Problem**: No syntax awareness

**Use**: Simple cases

### Syntax Macros

**Lisp Macros**:
```lisp
(defmacro when (condition &body body)
  `(if ,condition
       (progn ,@body)))
```

**Expansion**: AST transformation

**Benefit**: Syntax-aware

## Lisp Macros

### Lisp Macro System

**Powerful**: Very powerful macro system

**Homoiconicity**: Code is data

**Process**:
```
1. Macro receives AST
2. Transform AST
3. Return new AST
4. Evaluate transformed AST
```

### Lisp Macro Example

**Define Macro**:
```lisp
(defmacro incf (var &optional (delta 1))
  `(setf ,var (+ ,var ,delta)))
```

**Usage**:
```lisp
(incf x)      ; Expands to (setf x (+ x 1))
(incf x 5)    ; Expands to (setf x (+ x 5))
```

**Benefit**: Extend language

## Template Metaprogramming

### C++ Templates

**Templates**: Generic programming

**Metaprogramming**: Compute at compile time

**Example**:
```cpp
template<int N>
struct Factorial {
    static const int value = N * Factorial<N-1>::value;
};

template<>
struct Factorial<0> {
    static const int value = 1;
};

// Factorial<5>::value computed at compile time
```

### Template Metaprogramming Benefits

**1. Compile-Time Computation**:
```
Compute values at compile time
```

**2. Code Generation**:
```
Generate code from templates
```

**3. Type Safety**:
```
Type checking at compile time
```

## Reflection

### What is Reflection?

**Reflection**: Introspect program structure

**Capabilities**:
- **Inspect Types**: Get type information
- **Access Fields**: Access fields dynamically
- **Call Methods**: Call methods dynamically
- **Modify Code**: Modify code at runtime

**Use**: Frameworks, serialization

### Reflection Example

**Java Reflection**:
```java
Class<?> clazz = obj.getClass();
Field field = clazz.getField("name");
Object value = field.get(obj);
Method method = clazz.getMethod("getName");
Object result = method.invoke(obj);
```

**Benefit**: Dynamic code manipulation

## Code Generation

### Code Generation Techniques

**1. String Templates**:
```
Generate code as strings
```

**2. AST Generation**:
```
Generate AST programmatically
```

**3. Template Engines**:
```
Use template engines
```

**4. Compiler Plugins**:
```
Extend compiler
```

### Code Generation Example

**Annotation Processing** (Java):
```java
@GenerateBuilder
public class Person {
    private String name;
    private int age;
}

// Generates:
public class PersonBuilder {
    public PersonBuilder name(String name) { ... }
    public PersonBuilder age(int age) { ... }
    public Person build() { ... }
}
```

## AST Manipulation

### AST Transformation

**Method**: Manipulate AST

**Process**:
```
1. Parse code to AST
2. Transform AST
3. Generate code from AST
```

**Use**: Macros, code generation

### AST Manipulation Example

**Macro Expansion**:
```
Input AST: (when condition body)
Transform: (if condition (progn body))
Output: Transformed AST
```

## Applications

### Application 1: Code Generation

**Use**: Generate boilerplate code

**Examples**: 
- **Builders**: Generate builder classes
- **Serializers**: Generate serialization code
- **ORM**: Generate database code

### Application 2: Language Extension

**Use**: Extend language

**Examples**: 
- **DSLs**: Create domain languages
- **Syntax Sugar**: Add convenient syntax
- **Abstractions**: Create abstractions

### Application 3: Frameworks

**Use**: Framework code generation

**Examples**: 
- **Web Frameworks**: Generate routes
- **ORM**: Generate queries
- **Testing**: Generate test code

## Real-World Examples

### Example 1: Rust Macros

**Use**: Code generation

**Features**: 
- **Declarative Macros**: Pattern matching
- **Procedural Macros**: Full Rust code

**Benefit**: Powerful code generation

### Example 2: Scala Macros

**Use**: Code generation

**Features**: 
- **Def Macros**: Function-like macros
- **Type Macros**: Type-level macros

**Benefit**: Advanced metaprogramming

## Common Pitfalls

### Problem: Overuse of Macros

```lisp
;; BAD: Too many macros
;; Hard to understand, debug

;; GOOD: Use macros judiciously
;; When they add real value
```

### Problem: Unhygienic Macros

```c
// BAD: Variable capture
#define MACRO(x) int temp = x; ...

// GOOD: Hygienic macros
// Avoid variable capture
```

## Quiz

1. What is meta-programming?
   - **A)** Regular programming
   - **B)** Programs that generate or manipulate other programs
   - **C)** Database programming
   - **D)** Web programming

2. What are macros?
   - **A)** Functions
   - **B)** Code transformation mechanisms that expand before execution
   - **C)** Variables
   - **D)** Types

3. What is reflection?
   - **A)** Memory reflection
   - **B)** Ability to introspect and modify program structure at runtime
   - **C)** Code reflection
   - **D)** Type reflection

**Answers:**
1. **B** - Meta-programming involves writing programs that generate, transform, or manipulate other programs, either at compile time (macros, templates) or runtime (reflection)
2. **B** - Macros are code transformation mechanisms that expand code before execution, replacing macro invocations with generated code
3. **B** - Reflection allows programs to introspect their own structure (types, fields, methods) and modify code dynamically at runtime

## Next Steps

- [Advanced Language Features](../compilers_interpreters/05.%20Advanced%20Language%20Features.md) - Language design
- [Compiler Construction](../compilers_interpreters/06.%20Compiler%20Construction.md) - Building compilers

