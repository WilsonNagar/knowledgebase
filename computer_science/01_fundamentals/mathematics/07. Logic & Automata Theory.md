---
number: 7
title: "Logic & Automata Theory"
slug: "logic-automata-theory"
level: "fundamentals"
tags: ["mathematics", "logic", "automata", "formal-languages", "computation"]
prerequisites: ["complexity-theory-p-vs-np"]
estimated_minutes: 140
contributors: []
diagrams: []
examples: []
canonical_id: "cs-math-fund-07"
---

# Logic & Automata Theory

## Overview

Logic and automata theory form the mathematical foundation of computation. Understanding propositional logic, predicate logic, finite automata, regular expressions, context-free grammars, and Turing machines is essential for understanding computation theory and formal verification.

## Table of Contents

1. [Propositional Logic](#propositional-logic)
2. [Predicate Logic](#predicate-logic)
3. [Finite Automata](#finite-automata)
4. [Regular Expressions](#regular-expressions)
5. [Context-Free Grammars](#context-free)
6. [Pushdown Automata](#pushdown)
7. [Turing Machines](#turing-machines)
8. [Computability](#computability)

## Propositional Logic

### What is Propositional Logic?

**Propositional Logic**: Logic of propositions

**Propositions**: Statements that are true or false

**Operators**: 
- **AND (∧)**: Conjunction
- **OR (∨)**: Disjunction
- **NOT (¬)**: Negation
- **IMPLIES (→)**: Implication
- **IFF (↔)**: Biconditional

**Use**: Boolean logic, circuit design

### Truth Tables

**Truth Table**: Shows truth values

**Example**:
```
P | Q | P ∧ Q | P ∨ Q | ¬P
T | T |   T   |   T   | F
T | F |   F   |   T   | F
F | T |   F   |   T   | T
F | F |   F   |   F   | T
```

**Use**: Evaluate logical expressions

## Predicate Logic

### What is Predicate Logic?

**Predicate Logic**: Logic with quantifiers

**Quantifiers**: 
- **∀ (For All)**: Universal quantifier
- **∃ (Exists)**: Existential quantifier

**Predicates**: Functions returning true/false

**Use**: Formal specification, verification

### Predicate Logic Example

**Example**:
```
∀x (Student(x) → HasID(x))
```

**Meaning**: All students have IDs

**Use**: Formal specifications

## Finite Automata

### What are Finite Automata?

**Finite Automata**: Abstract machines

**Components**: 
- **States**: Finite set of states
- **Transitions**: State transitions
- **Start State**: Initial state
- **Accept States**: Accepting states

**Types**: 
- **DFA**: Deterministic Finite Automaton
- **NFA**: Nondeterministic Finite Automaton

**Use**: Pattern matching, lexical analysis

### DFA Example

**DFA**: Deterministic Finite Automaton

**Example**: Accept strings ending in "01"
```
States: q0, q1, q2
Start: q0
Accept: q2
Transitions:
  q0 --0--> q1
  q0 --1--> q0
  q1 --0--> q1
  q1 --1--> q2
  q2 --0--> q1
  q2 --1--> q0
```

**Use**: Recognize patterns

## Regular Expressions

### What are Regular Expressions?

**Regular Expressions**: Pattern notation

**Operators**: 
- **Concatenation**: ab
- **Union**: a|b
- **Kleene Star**: a*

**Equivalence**: Equivalent to finite automata

**Use**: Text processing, pattern matching

### Regular Expression Example

**Example**: 
```
(0|1)*01
```

**Meaning**: Strings ending in "01"

**Equivalence**: Equivalent to DFA

## Context-Free Grammars

### What are CFGs?

**CFG**: Context-Free Grammar

**Components**: 
- **Variables**: Non-terminals
- **Terminals**: Terminal symbols
- **Productions**: Production rules
- **Start Symbol**: Start variable

**Use**: Programming languages, parsing

### CFG Example

**Grammar**:
```
S → aSb | ε
```

**Language**: {a^n b^n | n ≥ 0}

**Use**: Generate languages

## Pushdown Automata

### What are Pushdown Automata?

**Pushdown Automata**: Automata with stack

**Components**: 
- **States**: States
- **Stack**: Stack memory
- **Transitions**: Stack operations

**Power**: More powerful than finite automata

**Equivalence**: Equivalent to CFGs

**Use**: Parsing, language recognition

### Pushdown Automata Example

**Example**: Recognize {a^n b^n | n ≥ 0}
```
1. Push 'a' for each 'a'
2. Pop 'a' for each 'b'
3. Accept if stack empty
```

**Use**: Parse context-free languages

## Turing Machines

### What are Turing Machines?

**Turing Machine**: Universal computation model

**Components**: 
- **Tape**: Infinite tape
- **Head**: Read/write head
- **States**: States
- **Transition Function**: State transitions

**Power**: Most powerful computation model

**Use**: Computability theory

### Turing Machine Example

**Example**: Recognize {a^n b^n c^n | n ≥ 0}
```
1. Mark 'a', find 'b', mark it
2. Find 'c', mark it
3. Repeat until all marked
4. Accept if all marked
```

**Use**: Recognize recursive languages

## Computability

### What is Computability?

**Computability**: What can be computed

**Church-Turing Thesis**: 
```
Turing machines = effective computation
```

**Decidability**: 
- **Decidable**: Algorithm exists
- **Undecidable**: No algorithm exists

**Examples**: 
- **Halting Problem**: Undecidable
- **Post Correspondence**: Undecidable

### Halting Problem

**Halting Problem**: 
```
Given program P and input I,
does P halt on I?
```

**Result**: Undecidable

**Proof**: Proof by contradiction

**Implication**: Limits of computation

## Real-World Examples

### Example 1: Compiler Design

**Use**: Compiler lexical analysis

**Automata**: Finite automata

**Regex**: Regular expressions

**Result**: Token recognition

### Example 2: Formal Verification

**Use**: Software verification

**Logic**: Predicate logic

**Tools**: Model checkers

**Result**: Verified software

## Common Pitfalls

### Problem: Confusing Automata Types

```c
// BAD: Use wrong automata type
// Cannot recognize language

// GOOD: Understand automata hierarchy
// Choose appropriate type
```

## Quiz

1. What is propositional logic?
   - **A)** Number theory
   - **B)** Logic of propositions with boolean operators
   - **C)** Set theory
   - **D)** Graph theory

2. What is a finite automaton?
   - **A)** Infinite machine
   - **B)** Abstract machine with finite states for pattern recognition
   - **C)** Computer
   - **D)** Algorithm

3. What is the Halting Problem?
   - **A)** Solvable problem
   - **B)** Undecidable problem - cannot determine if program halts
   - **C)** Easy problem
   - **D)** Simple problem

**Answers:**
1. **B** - Propositional logic deals with propositions (true/false statements) and logical operators (AND, OR, NOT, IMPLIES)
2. **B** - Finite automata are abstract machines with finite states used to recognize patterns and regular languages
3. **B** - The Halting Problem asks whether a program halts on given input, and it's proven undecidable (no algorithm can solve it for all programs)

## Next Steps

- [Set Theory Advanced](../mathematics/08.%20Set%20Theory%20Advanced.md) - Advanced set theory
- [Combinatorics](../mathematics/09.%20Combinatorics.md) - Combinatorics

