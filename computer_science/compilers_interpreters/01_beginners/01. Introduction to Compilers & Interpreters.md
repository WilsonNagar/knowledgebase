---
number: 1
title: "Introduction to Compilers & Interpreters"
slug: "introduction-to-compilers-and-interpreters"
level: "beginner"
tags: ["compilers", "interpreters", "programming-languages", "fundamentals"]
prerequisites: []
estimated_minutes: 60
contributors: []
diagrams: []
examples: []
canonical_id: "cs-compiler-01"
---

# Introduction to Compilers & Interpreters

## Overview

Compilers and interpreters are programs that translate source code written in a high-level programming language into machine code or another form that can be executed. Understanding how they work is fundamental to computer science and programming language design.

## Deep Explanation

### What is a Compiler?

A compiler is a program that translates source code written in a high-level language into machine code (or bytecode) that can be executed directly by a computer. The translation happens all at once before execution.

**Characteristics:**
- Translates entire program before execution
- Produces executable file
- Faster execution (optimized code)
- Errors detected at compile time

**Examples:**
- C/C++ compilers (GCC, Clang)
- Java compiler (javac)
- Kotlin compiler (kotlinc)

### What is an Interpreter?

An interpreter is a program that executes source code directly, translating and executing it line by line or statement by statement.

**Characteristics:**
- Translates and executes simultaneously
- No separate executable file
- Slower execution (interpreted on-the-fly)
- Errors detected at runtime

**Examples:**
- Python interpreter
- JavaScript interpreter (V8, SpiderMonkey)
- Ruby interpreter

### Compiler vs Interpreter

| Aspect | Compiler | Interpreter |
|--------|----------|-------------|
| Translation | Entire program at once | Line by line |
| Execution Speed | Faster | Slower |
| Error Detection | Compile time | Runtime |
| Output | Executable file | Direct execution |
| Memory Usage | Higher (optimized) | Lower |

### Compilation Process

1. **Lexical Analysis**: Breaks source code into tokens
2. **Syntax Analysis**: Builds parse tree from tokens
3. **Semantic Analysis**: Checks meaning and types
4. **Code Generation**: Produces target code
5. **Optimization**: Improves code efficiency

### Interpretation Process

1. **Read**: Reads source code line/statement
2. **Parse**: Analyzes syntax
3. **Execute**: Runs the code immediately
4. **Repeat**: Continues for next line

### Hybrid Approaches

Many modern languages use hybrid approaches:

- **Java**: Compiles to bytecode, interpreted by JVM
- **Python**: Compiles to bytecode (.pyc), interpreted
- **JavaScript**: JIT compilation (Just-In-Time)

### Why Understanding Matters

1. **Performance**: Understanding compilation helps optimize code
2. **Debugging**: Know where errors come from
3. **Language Design**: Design better languages
4. **Tooling**: Build better development tools

## Summary

Compilers translate entire programs before execution, while interpreters execute code line by line. Modern languages often use hybrid approaches combining both techniques for optimal performance and flexibility.

## Next Steps

- Learn about lexical analysis and tokenization
- Understand parsing and syntax trees
- Explore code generation
- Study optimization techniques

