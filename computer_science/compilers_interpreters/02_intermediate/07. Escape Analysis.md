---
number: 7
title: "Escape Analysis"
slug: "escape-analysis"
level: "intermediate"
tags: ["compilers", "escape-analysis", "optimization", "stack-allocation", "jit"]
prerequisites: ["garbage-collection-design"]
estimated_minutes: 110
contributors: []
diagrams: []
examples: []
canonical_id: "cs-comp-07"
---

# Escape Analysis

## Overview

Escape analysis determines whether objects can be allocated on the stack instead of the heap. Understanding escape analysis, stack allocation optimizations, and how JIT compilers use this analysis is essential for understanding modern language performance optimizations.

## Table of Contents

1. [What is Escape Analysis?](#what-is-escape)
2. [Escape Types](#escape-types)
3. [Escape Analysis Algorithm](#algorithm)
4. [Stack Allocation](#stack-allocation)
5. [Scalar Replacement](#scalar-replacement)
6. [Lock Elision](#lock-elision)
7. [JIT Compilation](#jit)
8. [Applications](#applications)

## What is Escape Analysis?

### Definition

**Escape Analysis**: Determine if object escapes method

**Escape**: Object accessible outside method

**No Escape**: Object only used within method

**Benefit**: Can allocate on stack instead of heap

### Why Escape Analysis?

**Heap Allocation**:
- **Cost**: Expensive (GC pressure)
- **Overhead**: Allocation overhead

**Stack Allocation**:
- **Cost**: Free (just move stack pointer)
- **Overhead**: Minimal

**Benefit**: Stack allocation much faster

## Escape Types

### No Escape

**No Escape**: Object doesn't escape method

**Example**:
```java
void method() {
    Object obj = new Object();
    obj.doSomething();
    // obj doesn't escape
}
```

**Optimization**: Allocate on stack

### Method Escape

**Method Escape**: Object escapes to caller

**Example**:
```java
Object method() {
    Object obj = new Object();
    return obj;  // Escapes!
}
```

**Optimization**: Must allocate on heap

### Thread Escape

**Thread Escape**: Object escapes to another thread

**Example**:
```java
void method() {
    Object obj = new Object();
    thread.start(() -> obj.doSomething());  // Escapes!
}
```

**Optimization**: Must allocate on heap

## Escape Analysis Algorithm

### Analysis Process

**1. Build Call Graph**:
```
Track method calls
```

**2. Track Object Flows**:
```
Track where objects flow
```

**3. Check Escape**:
```
Check if object escapes
```

**4. Optimize**:
```
Allocate on stack if no escape
```

### Points-to Analysis

**Points-to**: Track what pointers point to

**Use**: Determine escape

**Complexity**: May be expensive

**Trade-off**: Accuracy vs cost

## Stack Allocation

### When to Allocate on Stack?

**Condition**: Object doesn't escape

**Benefit**: 
- **Fast**: Stack allocation is fast
- **No GC**: No garbage collection needed
- **Locality**: Better cache locality

### Stack Allocation Example

**Before**:
```java
void method() {
    Point p = new Point(1, 2);  // Heap allocation
    int sum = p.x + p.y;
}
```

**After Escape Analysis**:
```java
void method() {
    Point p = stack_alloc(Point);  // Stack allocation
    p.x = 1;
    p.y = 2;
    int sum = p.x + p.y;
    // p automatically freed when method returns
}
```

## Scalar Replacement

### What is Scalar Replacement?

**Scalar Replacement**: Replace object with fields

**Method**: 
```
Instead of object, use individual fields
```

**Benefit**: 
- **No Allocation**: No allocation at all
- **Better Optimization**: Compiler can optimize fields

### Scalar Replacement Example

**Before**:
```java
void method() {
    Point p = new Point(1, 2);
    int sum = p.x + p.y;
}
```

**After**:
```java
void method() {
    int p_x = 1;  // Scalar replacement
    int p_y = 2;
    int sum = p_x + p_y;
}
```

**Benefit**: No allocation, better optimization

## Lock Elision

### What is Lock Elision?

**Lock Elision**: Remove unnecessary locks

**Condition**: Object doesn't escape

**Benefit**: Eliminate lock overhead

### Lock Elision Example

**Before**:
```java
void method() {
    Object obj = new Object();
    synchronized(obj) {  // Lock needed if escapes
        obj.doSomething();
    }
}
```

**After Escape Analysis**:
```java
void method() {
    Object obj = new Object();
    // Lock elided - obj doesn't escape, no contention possible
    obj.doSomething();
}
```

**Benefit**: No lock overhead

## JIT Compilation

### JIT and Escape Analysis

**JIT**: Just-In-Time compiler

**Escape Analysis**: Done at runtime

**Benefit**: 
- **Profile-Guided**: Can use runtime information
- **Adaptive**: Can optimize based on actual usage

### HotSpot JVM

**HotSpot**: Java Virtual Machine

**Escape Analysis**: Part of C2 compiler

**Optimizations**: 
- **Stack Allocation**: Allocate on stack
- **Scalar Replacement**: Replace with fields
- **Lock Elision**: Remove locks

## Applications

### Application 1: Java HotSpot

**Use**: Escape analysis in JIT

**Benefit**: Better performance

**Optimizations**: Stack allocation, scalar replacement

### Application 2: Go Compiler

**Use**: Escape analysis in compiler

**Benefit**: Better performance

**Optimizations**: Stack vs heap allocation

## Real-World Examples

### Example 1: Temporary Objects

**Use**: Temporary objects in loops

**Optimization**: Stack allocate if don't escape

**Benefit**: Reduce GC pressure

### Example 2: Builder Pattern

**Use**: Builder objects

**Optimization**: Stack allocate if don't escape

**Benefit**: Faster allocation

## Common Pitfalls

### Problem: Over-Optimistic Analysis

```java
// BAD: Assume object doesn't escape
// May be wrong, cause bugs

// GOOD: Conservative analysis
// Only optimize when certain
```

### Problem: Not Considering Reflection

```java
// BAD: Ignore reflection
// Reflection may access objects

// GOOD: Consider all access paths
// Including reflection
```

## Quiz

1. What is escape analysis?
   - **A)** Memory leak detection
   - **B)** Analysis to determine if objects can be allocated on stack instead of heap
   - **C)** Garbage collection
   - **D)** Memory allocation

2. What is scalar replacement?
   - **A)** Replacing scalars
   - **B)** Replacing objects with individual fields for better optimization
   - **C)** Replacing fields
   - **D)** Replacing variables

3. What is lock elision?
   - **A)** Adding locks
   - **B)** Removing unnecessary locks when objects don't escape
   - **C)** Locking objects
   - **D)** Unlocking objects

**Answers:**
1. **B** - Escape analysis determines whether objects escape their allocating method, enabling stack allocation instead of heap allocation for non-escaping objects
2. **B** - Scalar replacement replaces objects with their individual fields, eliminating allocation entirely and enabling better compiler optimizations
3. **B** - Lock elision removes synchronization locks when the compiler can prove that an object doesn't escape, eliminating lock overhead since no other thread can access the object

## Next Steps

- [Type Systems & Type Inference](./08.%20Type%20Systems%20%26%20Type%20Inference.md) - Type checking
- [Language Runtime Design](../03_advanced/02.%20Language%20Runtime%20Design.md) - Runtime systems

