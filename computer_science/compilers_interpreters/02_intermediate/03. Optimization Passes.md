---
number: 3
title: "Optimization Passes"
slug: "optimization-passes"
level: "intermediate"
tags: ["compilers", "optimization", "ir", "code-optimization", "llvm"]
prerequisites: ["ast-intermediate-representation"]
estimated_minutes: 115
contributors: []
diagrams: []
examples: []
canonical_id: "cs-comp-03"
---

# Optimization Passes

## Overview

Optimization passes transform code to improve performance, reduce size, or enhance other characteristics. Understanding different optimization techniques, when to apply them, and how they work is essential for compiler construction and understanding how compilers generate efficient code.

## Table of Contents

1. [What is Code Optimization?](#what-is-optimization)
2. [Optimization Levels](#optimization-levels)
3. [Local Optimizations](#local-optimizations)
4. [Global Optimizations](#global-optimizations)
5. [Loop Optimizations](#loop-optimizations)
6. [Interprocedural Optimizations](#interprocedural)
7. [Optimization Passes](#passes)
8. [LLVM Optimization](#llvm-optimization)

## What is Code Optimization?

### Purpose

**Optimization**: Transform code to improve characteristics

**Goals**:
- **Performance**: Faster execution
- **Size**: Smaller code
- **Power**: Lower power consumption
- **Memory**: Less memory usage

### Optimization Trade-offs

**Compile Time**: Optimizations take time

**Code Size**: May increase or decrease

**Debugging**: Optimized code harder to debug

**Correctness**: Must preserve semantics

## Optimization Levels

### Common Levels

**-O0**: No optimization (fast compilation, easy debugging)

**-O1**: Basic optimizations (balance)

**-O2**: Standard optimizations (default for most)

**-O3**: Aggressive optimizations (may increase code size)

**-Os**: Optimize for size

**-Ofast**: Fast math (may break IEEE compliance)

### Optimization Philosophy

**Safe**: Optimizations that always help

**Aggressive**: Optimizations that usually help

**Risky**: Optimizations that may hurt

## Local Optimizations

### Constant Folding

**Idea**: Evaluate constants at compile time

**Before**:
```llvm
%1 = add i32 5, 3
```

**After**:
```llvm
%1 = i32 8
```

**Benefit**: Eliminates runtime computation

### Constant Propagation

**Idea**: Replace variables with constants

**Before**:
```c
int x = 5;
int y = x + 3; // y = 8
```

**After**:
```c
int y = 8;
```

**Benefit**: Enables further optimizations

### Dead Code Elimination

**Idea**: Remove unreachable code

**Before**:
```c
int x = 5;
if (false) {
    x = 10; // Never executed
}
return x;
```

**After**:
```c
int x = 5;
return x;
```

**Benefit**: Smaller code, faster execution

### Common Subexpression Elimination

**Idea**: Reuse computed values

**Before**:
```c
int a = x + y;
int b = x + y; // Recompute
```

**After**:
```c
int temp = x + y;
int a = temp;
int b = temp;
```

**Benefit**: Fewer computations

## Global Optimizations

### Global Constant Propagation

**Idea**: Propagate constants across basic blocks

**Example**:
```c
int x = 5;
if (condition) {
    y = x + 1; // y = 6
} else {
    z = x + 2; // z = 7
}
```

**Optimization**: Replace x with 5 everywhere

### Global Value Numbering

**Idea**: Assign numbers to equivalent values

**Purpose**: Detect redundant computations

**Example**:
```
a = x + y  → VN1
b = x + y  → VN1 (same as a)
c = a + z  → VN2
d = b + z  → VN2 (same as c)
```

**Optimization**: Reuse VN1 and VN2

### Copy Propagation

**Idea**: Replace copies with original

**Before**:
```c
int x = a;
int y = x; // Copy
use(y);
```

**After**:
```c
int x = a;
use(a); // Use original
```

**Benefit**: May enable further optimizations

## Loop Optimizations

### Loop Invariant Code Motion

**Idea**: Move computations outside loop

**Before**:
```c
for (int i = 0; i < n; i++) {
    result = x * y + i; // x * y invariant
}
```

**After**:
```c
int temp = x * y;
for (int i = 0; i < n; i++) {
    result = temp + i;
}
```

**Benefit**: Compute once instead of n times

### Loop Unrolling

**Idea**: Duplicate loop body

**Before**:
```c
for (int i = 0; i < 4; i++) {
    a[i] = b[i] + c[i];
}
```

**After**:
```c
a[0] = b[0] + c[0];
a[1] = b[1] + c[1];
a[2] = b[2] + c[2];
a[3] = b[3] + c[3];
```

**Benefit**: Reduces loop overhead

**Trade-off**: Increases code size

### Loop Fusion

**Idea**: Combine multiple loops

**Before**:
```c
for (int i = 0; i < n; i++) {
    a[i] = b[i] + 1;
}
for (int i = 0; i < n; i++) {
    c[i] = a[i] * 2;
}
```

**After**:
```c
for (int i = 0; i < n; i++) {
    a[i] = b[i] + 1;
    c[i] = a[i] * 2;
}
```

**Benefit**: Better cache locality

### Loop Vectorization

**Idea**: Use SIMD instructions

**Before**:
```c
for (int i = 0; i < n; i++) {
    c[i] = a[i] + b[i];
}
```

**After** (SIMD):
```c
for (int i = 0; i < n; i += 4) {
    // Process 4 elements at once
    c[i:i+3] = a[i:i+3] + b[i:i+3];
}
```

**Benefit**: 4x speedup (if 4-wide SIMD)

## Interprocedural Optimizations

### Inlining

**Idea**: Replace function call with function body

**Before**:
```c
int add(int a, int b) {
    return a + b;
}
int result = add(x, y);
```

**After**:
```c
int result = x + y;
```

**Benefit**: Eliminates call overhead

**Trade-off**: Increases code size

### Interprocedural Constant Propagation

**Idea**: Propagate constants across functions

**Example**:
```c
int f(int x) {
    return x + 1;
}
int y = f(5); // Constant argument
```

**Optimization**: Inline and propagate → y = 6

### Dead Function Elimination

**Idea**: Remove unused functions

**Benefit**: Smaller binary

## Optimization Passes

### Pass Ordering

**Order Matters**: Later passes benefit from earlier

**Typical Order**:
```
1. Local optimizations
2. Global optimizations
3. Loop optimizations
4. Interprocedural optimizations
5. Code generation optimizations
```

### Pass Dependencies

**Example**:
```
Constant propagation → Dead code elimination
(Constants enable dead code detection)

Loop invariant motion → Loop unrolling
(Move invariants before unrolling)
```

## LLVM Optimization

### LLVM Passes

**LLVM**: Modular optimization framework

**Passes**: Independent optimization modules

**Example Passes**:
- **-instcombine**: Instruction combining
- **-simplifycfg**: Simplify control flow
- **-mem2reg**: Promote memory to registers
- **-loop-unroll**: Loop unrolling
- **-inline**: Function inlining

### Using LLVM Optimizer

**Command**:
```bash
opt -O3 input.ll -o output.ll
```

**Passes Applied**: Many optimization passes

**Result**: Optimized IR

### Custom Passes

**LLVM**: Allows custom passes

**Use**: Domain-specific optimizations

**Example**: Custom loop transformations

## Real-World Examples

### Example 1: GCC Optimization

**Levels**: -O1, -O2, -O3

**Passes**: Hundreds of optimization passes

**Result**: Highly optimized code

### Example 2: LLVM Optimization

**Passes**: Modular, composable

**Benefits**: Easy to add custom passes

**Use**: Many compilers (Clang, Rust, Swift)

## Common Pitfalls

### Problem: Over-Optimization

```c
// BAD: Aggressive optimization breaks code
float x = 0.1;
float y = 0.2;
float z = x + y;
// May not equal 0.3 due to floating point

// GOOD: Understand optimization effects
// Use appropriate optimization level
```

### Problem: Debugging Optimized Code

```c
// BAD: Optimized code hard to debug
// Variables may be eliminated
// Code may be reordered

// GOOD: Use -O0 for debugging
// Or use debug symbols with -g
```

## Quiz

1. What is constant folding?
   - **A)** Removing constants
   - **B)** Evaluating constant expressions at compile time
   - **C)** Adding constants
   - **D)** Moving constants

2. What is loop unrolling?
   - **A)** Removing loops
   - **B)** Duplicating loop body to reduce overhead
   - **C)** Making loops longer
   - **D)** Slowing loops

3. What is function inlining?
   - **A)** Removing functions
   - **B)** Replacing function call with function body
   - **C)** Adding functions
   - **D)** Moving functions

**Answers:**
1. **B** - Constant folding evaluates constant expressions at compile time instead of runtime, eliminating unnecessary computations
2. **B** - Loop unrolling duplicates the loop body multiple times, reducing loop overhead (increment, condition check) at the cost of increased code size
3. **B** - Function inlining replaces a function call with the actual function body, eliminating call overhead but potentially increasing code size

## Next Steps

- [Register Allocation](./04.%20Register%20Allocation.md) - Code generation
- [JIT Compilation](./05.%20JIT%20Compilation.md) - Just-in-time compilation

