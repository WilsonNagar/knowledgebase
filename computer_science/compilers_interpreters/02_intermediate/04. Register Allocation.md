---
number: 4
title: "Register Allocation"
slug: "register-allocation"
level: "intermediate"
tags: ["compilers", "register-allocation", "code-generation", "graph-coloring", "spilling"]
prerequisites: ["optimization-passes"]
estimated_minutes: 115
contributors: []
diagrams: []
examples: []
canonical_id: "cs-comp-04"
---

# Register Allocation

## Overview

Register allocation is a critical phase of code generation that maps variables to CPU registers. Understanding register allocation algorithms like graph coloring, spilling, and live range analysis is essential for compiler construction and understanding how compilers generate efficient code.

## Table of Contents

1. [The Register Allocation Problem](#problem)
2. [Live Range Analysis](#live-ranges)
3. [Interference Graph](#interference-graph)
4. [Graph Coloring Algorithm](#graph-coloring)
5. [Spilling](#spilling)
6. [Linear Scan](#linear-scan)
7. [Register Coalescing](#coalescing)
8. [Real-World Examples](#examples)

## The Register Allocation Problem

### The Challenge

**Registers**: Limited number (e.g., 16 registers)

**Variables**: Many variables in program

**Goal**: Map variables to registers efficiently

**Constraint**: Variables live at same time cannot share register

### Benefits of Registers

**Registers vs Memory**:
- **Registers**: ~1 cycle access
- **Memory**: ~100 cycles access
- **Speedup**: 100x faster!

**Goal**: Keep frequently used variables in registers

## Live Range Analysis

### What is a Live Range?

**Live Range**: Range where variable is live

**Live**: Variable may be used

**Definition**: Variable live from definition to last use

### Computing Live Ranges

**Process**:
```
1. Find all definitions
2. Find all uses
3. Live range: [definition, last_use]
```

**Example**:
```c
x = 10;      // Definition
y = x + 5;   // Use x (x live here)
z = y * 2;   // x no longer live
```

**Live Range**: x live from line 1 to line 2

## Interference Graph

### What is an Interference Graph?

**Interference Graph**: Graph where edges = interference

**Vertices**: Variables

**Edges**: Variables interfere (live at same time)

**Coloring**: Color = register assignment

### Building Interference Graph

**Process**:
```
For each variable:
  For each other variable:
    If live ranges overlap:
      Add edge (interference)
```

**Example**:
```
x live: [1, 5]
y live: [3, 7]
z live: [6, 10]

Interferences:
  x ↔ y (overlap [3, 5])
  y ↔ z (overlap [6, 7])
  x ↮ z (no overlap)
```

## Graph Coloring Algorithm

### Graph Coloring Problem

**Problem**: Color graph with k colors

**Constraint**: Adjacent vertices different colors

**k**: Number of registers

### Greedy Coloring

**Algorithm**:
```
1. Order vertices
2. For each vertex:
   a. Find colors used by neighbors
   b. Assign smallest available color
```

**Example**:
```
Variables: x, y, z
Registers: 2 (R0, R1)

Interference: x-y, y-z

Color x: R0 (no neighbors colored)
Color y: R1 (neighbor x uses R0)
Color z: R0 (neighbor y uses R1, but x not neighbor)
```

### Chaitin's Algorithm

**Algorithm**:
```
1. Build interference graph
2. Simplify: Remove vertices with degree < k
3. If all removed: Color in reverse order
4. Else: Spill variable (remove and mark)
```

**Process**:
```
While graph not empty:
  If vertex with degree < k:
    Push to stack, remove from graph
  Else:
    Spill vertex (mark for spilling)
Color vertices popped from stack
```

## Spilling

### What is Spilling?

**Spilling**: Store variable in memory instead of register

**When**: Not enough registers

**Process**:
```
1. Select variable to spill
2. Store to memory before use
3. Load from memory when needed
```

### Spill Cost

**Cost**: Load/store operations

**Heuristic**: Spill variable with:
- **High degree**: Many interferences
- **Low usage**: Infrequently used
- **Long live range**: Long time in register

### Spill Code Generation

**Before Spilling**:
```c
x = 10;
y = x + 5;
```

**After Spilling x**:
```c
store x, memory_x  // Spill
x = 10;
load x, memory_x   // Reload
y = x + 5;
```

## Linear Scan

### What is Linear Scan?

**Linear Scan**: Simpler register allocation

**Idea**: Scan code linearly, allocate registers

**Process**:
```
1. Compute live ranges
2. Scan code in order
3. Allocate register when variable becomes live
4. Free register when variable dies
```

### Linear Scan Algorithm

**Process**:
```
For each instruction in order:
  Expire: Free registers for variables that died
  Spill: If no free register, spill variable
  Allocate: Assign register to new variables
```

**Benefits**: Faster than graph coloring

**Trade-off**: May use more registers or spill more

## Register Coalescing

### What is Coalescing?

**Coalescing**: Merge variables that don't interfere

**Purpose**: Reduce register pressure

**Example**:
```c
x = y;  // Copy
// x and y don't interfere
// Can use same register
```

**Benefit**: Fewer registers needed

## Real-World Examples

### Example 1: LLVM Register Allocation

**Algorithm**: Graph coloring (Greedy)

**Features**: 
- **Coalescing**: Merge non-interfering variables
- **Rematerialization**: Recompute instead of spilling
- **Live range splitting**: Split long live ranges

### Example 2: GCC Register Allocation

**Algorithm**: Graph coloring (Chaitin's)

**Features**:
- **Multiple passes**: Iterative improvement
- **Rematerialization**: Recompute values
- **Register pressure**: Consider pressure

## Common Pitfalls

### Problem: Not Considering Spill Cost

```c
// BAD: Spill frequently used variable
// High overhead from loads/stores

// GOOD: Spill infrequently used variable
// Lower overhead
```

### Problem: Ignoring Register Pressure

```c
// BAD: Allocate registers without considering pressure
// May run out of registers

// GOOD: Consider register pressure
// Spill when pressure high
```

## Quiz

1. What is register allocation?
   - **A)** Memory allocation
   - **B)** Mapping variables to CPU registers efficiently
   - **C)** Variable allocation
   - **D)** Code allocation

2. What is an interference graph?
   - **A)** Graph of functions
   - **B)** Graph where edges represent variables that are live at the same time
   - **C)** Graph of registers
   - **D)** Control flow graph

3. What is spilling?
   - **A)** Deleting variables
   - **B)** Storing variables in memory when not enough registers
   - **C)** Allocating registers
   - **D)** Coloring graph

**Answers:**
1. **B** - Register allocation maps program variables to CPU registers, trying to keep frequently used variables in fast registers instead of slower memory
2. **B** - An interference graph has vertices for variables and edges between variables that are live at the same time (interfere), used to determine which variables can share registers
3. **B** - Spilling is storing variables in memory instead of registers when there aren't enough registers, requiring load/store operations when the variable is needed

## Next Steps

- [JIT Compilation](./05.%20JIT%20Compilation.md) - Just-in-time compilation
- [Garbage Collection Design](./06.%20Garbage%20Collection%20Design.md) - GC algorithms

