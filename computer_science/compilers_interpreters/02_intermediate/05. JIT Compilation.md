---
number: 5
title: "JIT Compilation"
slug: "jit-compilation"
level: "intermediate"
tags: ["compilers", "jit", "just-in-time", "runtime", "optimization"]
prerequisites: ["register-allocation"]
estimated_minutes: 120
contributors: []
diagrams: []
examples: []
canonical_id: "cs-comp-05"
---

# JIT Compilation

## Overview

Just-In-Time (JIT) compilation combines the portability of interpretation with the performance of compilation. Understanding JIT compilation, adaptive optimization, profiling, and how modern runtimes like JVM and V8 work is essential for understanding modern language implementations and performance optimization.

## Table of Contents

1. [Interpretation vs Compilation](#interpretation-vs-compilation)
2. [What is JIT?](#what-is-jit)
3. [JIT Architecture](#jit-architecture)
4. [Adaptive Optimization](#adaptive-optimization)
5. [Profiling](#profiling)
6. [Hot Spot Detection](#hot-spot)
7. [Deoptimization](#deoptimization)
8. [Real-World Examples](#examples)

## Interpretation vs Compilation

### Interpretation

**Process**: Execute code directly

**Advantages**:
- **Portability**: Works on any platform
- **Startup**: Fast startup
- **Flexibility**: Dynamic features easy

**Disadvantages**:
- **Performance**: Slower execution
- **Overhead**: Interpretation overhead

### AOT Compilation

**Process**: Compile before execution

**Advantages**:
- **Performance**: Fast execution
- **Optimization**: Can optimize heavily

**Disadvantages**:
- **Portability**: Platform-specific
- **Startup**: Slower startup
- **Flexibility**: Less flexible

### JIT Compilation

**Process**: Compile during execution

**Advantages**:
- **Performance**: Fast execution (after compilation)
- **Portability**: Portable bytecode
- **Adaptive**: Can optimize based on runtime behavior

**Trade-off**: Compilation overhead during execution

## What is JIT?

### JIT Concept

**JIT**: Just-In-Time compilation

**Process**:
```
1. Start with interpretation
2. Profile code during execution
3. Compile hot code to native code
4. Execute native code (faster)
```

**Goal**: Best of both worlds

### JIT Benefits

**1. Performance**:
```
Native code execution
Close to AOT performance
```

**2. Portability**:
```
Portable bytecode
Compile to native on target
```

**3. Adaptive**:
```
Optimize based on actual usage
Better than static optimization
```

## JIT Architecture

### Components

**1. Interpreter**:
```
Execute bytecode
Profile execution
```

**2. Compiler**:
```
Compile hot code
Generate native code
```

**3. Profiler**:
```
Collect execution statistics
Identify hot spots
```

**4. Code Cache**:
```
Store compiled code
Reuse compiled code
```

### JIT Process Flow

```
Bytecode → Interpreter → Profile → Hot? → Compiler → Native Code
                              ↓
                         Not Hot → Continue Interpreting
```

## Adaptive Optimization

### What is Adaptive Optimization?

**Adaptive**: Optimize based on runtime behavior

**Static**: Optimize before execution

**Dynamic**: Optimize during execution

**Benefit**: Optimize what's actually used

### Optimization Strategies

**1. Inlining**:
```
Inline frequently called functions
Based on call frequency
```

**2. Loop Unrolling**:
```
Unroll hot loops
Based on iteration count
```

**3. Dead Code Elimination**:
```
Remove unused code
Based on execution profile
```

**4. Type Specialization**:
```
Specialize for common types
Based on observed types
```

## Profiling

### What is Profiling?

**Profiling**: Collect execution statistics

**Metrics**:
- **Call frequency**: How often called
- **Execution time**: How long takes
- **Type information**: Types observed
- **Branch prediction**: Branch outcomes

### Profiling Methods

**1. Counter-Based**:
```
Count method calls
Count loop iterations
```

**2. Sampling**:
```
Sample execution periodically
Lower overhead
```

**3. Instrumentation**:
```
Add profiling code
Higher overhead, more accurate
```

## Hot Spot Detection

### What are Hot Spots?

**Hot Spots**: Frequently executed code

**Detection**: Based on profiling

**Threshold**: Compile when threshold exceeded

**Example**: Method called 10,000+ times

### Hot Spot Compilation

**Process**:
```
1. Profile code
2. Detect hot spots
3. Queue for compilation
4. Compile to native code
5. Replace interpreted code
```

**Benefit**: Focus compilation on hot code

## Deoptimization

### What is Deoptimization?

**Deoptimization**: Revert to interpreted code

**When**: 
- **Assumption invalid**: Optimization assumption wrong
- **Type change**: Type changed
- **Exception**: Exception in optimized code

**Process**:
```
1. Detect invalid assumption
2. Deoptimize code
3. Revert to interpreter
4. May recompile later
```

### Example: Type Speculation

**Optimization**: Assume integer type

**Reality**: String passed

**Deoptimization**: Revert to generic code

## Real-World Examples

### Example 1: Java Virtual Machine (JVM)

**JIT**: HotSpot JIT compiler

**Process**:
```
1. Interpret bytecode
2. Profile execution
3. Compile hot methods
4. Use compiled code
```

**Optimizations**: Inlining, loop optimization, escape analysis

### Example 2: V8 JavaScript Engine

**JIT**: TurboFan compiler

**Process**:
```
1. Ignition interpreter
2. Profile execution
3. TurboFan compiler
4. Optimized code
```

**Optimizations**: Type specialization, inlining

### Example 3: .NET Runtime

**JIT**: RyuJIT compiler

**Process**:
```
1. Interpret IL
2. Profile execution
3. JIT compile
4. Optimized code
```

**Optimizations**: Inlining, devirtualization

## Common Pitfalls

### Problem: Over-Compilation

```c
// BAD: Compile everything immediately
// High compilation overhead

// GOOD: Compile only hot code
// Balance compilation cost vs benefit
```

### Problem: Not Profiling

```c
// BAD: Compile without profiling
// May compile cold code

// GOOD: Profile first
// Compile based on actual usage
```

## Quiz

1. What is JIT compilation?
   - **A)** Compile before execution
   - **B)** Compile code during execution based on profiling
   - **C)** Interpret code
   - **D)** Optimize code

2. What is a hot spot?
   - **A)** Error in code
   - **B)** Frequently executed code that benefits from compilation
   - **C)** Slow code
   - **D)** Buggy code

3. What is deoptimization?
   - **A)** Optimize code
   - **B)** Revert optimized code to interpreted when assumptions invalid
   - **C)** Remove optimization
   - **D)** Add optimization

**Answers:**
1. **B** - JIT (Just-In-Time) compilation compiles code during execution, typically starting with interpretation, profiling to find hot spots, then compiling frequently executed code to native code for better performance
2. **B** - Hot spots are frequently executed code paths that benefit from compilation to native code, detected through profiling of execution frequency
3. **B** - Deoptimization reverts optimized (compiled) code back to interpreted code when optimization assumptions prove incorrect (e.g., type speculation wrong, exception in optimized code)

## Next Steps

- [Garbage Collection Design](./06.%20Garbage%20Collection%20Design.md) - GC algorithms
- [Escape Analysis](./07.%20Escape%20Analysis.md) - Stack allocation

