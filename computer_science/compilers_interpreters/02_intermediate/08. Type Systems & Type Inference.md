---
number: 8
title: "Type Systems & Type Inference"
slug: "type-systems-type-inference"
level: "intermediate"
tags: ["compilers", "type-systems", "type-inference", "type-checking", "polymorphism"]
prerequisites: ["escape-analysis"]
estimated_minutes: 130
contributors: []
diagrams: []
examples: []
canonical_id: "cs-comp-08"
---

# Type Systems & Type Inference

## Overview

Type systems ensure program correctness by checking types at compile time or runtime. Understanding static vs dynamic typing, type inference algorithms, polymorphism, and advanced type system features is essential for language design and understanding modern programming languages.

## Table of Contents

1. [What are Type Systems?](#what-are-types)
2. [Static vs Dynamic Typing](#static-dynamic)
3. [Type Checking](#type-checking)
4. [Type Inference](#type-inference)
5. [Polymorphism](#polymorphism)
6. [Subtyping](#subtyping)
7. [Advanced Type Features](#advanced)
8. [Applications](#applications)

## What are Type Systems?

### Definition

**Type System**: Set of rules for types

**Purpose**: 
- **Correctness**: Catch type errors
- **Documentation**: Types document code
- **Optimization**: Enable optimizations

**Types**: Classify values and operations

### Type System Benefits

**1. Error Detection**:
```
Catch errors at compile time
```

**2. Documentation**:
```
Types document interfaces
```

**3. Optimization**:
```
Enable compiler optimizations
```

**4. Tooling**:
```
Enable better IDE support
```

## Static vs Dynamic Typing

### Static Typing

**Static**: Types checked at compile time

**Examples**: Java, C++, Rust, Haskell

**Benefits**: 
- **Early Detection**: Catch errors early
- **Performance**: Better optimization
- **Documentation**: Types document code

**Limitations**: 
- **Verbose**: More typing required
- **Less Flexible**: Less flexible

### Dynamic Typing

**Dynamic**: Types checked at runtime

**Examples**: Python, JavaScript, Ruby

**Benefits**: 
- **Flexible**: More flexible
- **Less Verbose**: Less typing

**Limitations**: 
- **Runtime Errors**: Errors at runtime
- **Performance**: Less optimization

## Type Checking

### Type Checking Process

**1. Parse**:
```
Parse source code
```

**2. Build AST**:
```
Build abstract syntax tree
```

**3. Type Check**:
```
Check types of expressions
```

**4. Report Errors**:
```
Report type errors
```

### Type Rules

**Rules**: Define valid operations

**Example**:
```
If e1: int and e2: int
Then e1 + e2: int

If e: int
Then e + "string": ERROR
```

## Type Inference

### What is Type Inference?

**Type Inference**: Infer types automatically

**Purpose**: Reduce type annotations

**Method**: Algorithm infers types

**Examples**: Haskell, OCaml, Rust, TypeScript

### Hindley-Milner Algorithm

**Algorithm**: Unification-based inference

**Process**:
```
1. Assign type variables
2. Collect constraints
3. Unify constraints
4. Infer types
```

**Example**:
```haskell
-- No type annotation needed
f x y = x + y
-- Inferred: f :: Num a => a -> a -> a
```

### Type Inference Example

**Code**:
```rust
let x = 5;        // x: i32 inferred
let y = x + 3;    // y: i32 inferred
let z = "hello";  // z: &str inferred
```

**Inference**: Compiler infers types

**Benefit**: Less verbose, still type-safe

## Polymorphism

### What is Polymorphism?

**Polymorphism**: One interface, multiple implementations

**Types**:
- **Parametric**: Generic types
- **Ad-hoc**: Overloading
- **Subtype**: Inheritance

### Parametric Polymorphism

**Generic Types**: Type parameters

**Example**:
```java
<T> T identity(T x) {
    return x;
}
```

**Use**: Write code once, use with many types

### Ad-hoc Polymorphism

**Overloading**: Same name, different types

**Example**:
```java
int add(int a, int b) { return a + b; }
String add(String a, String b) { return a + b; }
```

**Use**: Different implementations for different types

## Subtyping

### What is Subtyping?

**Subtyping**: Type hierarchy

**Subtype**: More specific type

**Supertype**: More general type

**Example**: 
```
Dog <: Animal
Cat <: Animal
```

### Subtyping Rules

**Liskov Substitution**: 
```
Subtype can replace supertype
```

**Variance**: 
- **Covariant**: Preserves subtyping
- **Contravariant**: Reverses subtyping
- **Invariant**: No subtyping

## Advanced Type Features

### Dependent Types

**Dependent Types**: Types depend on values

**Example**:
```idris
Vect : Nat -> Type -> Type
-- Vector length is part of type
```

**Use**: More precise types

**Complexity**: Very complex

### Higher-Kinded Types

**Higher-Kinded**: Types parameterized by types

**Example**:
```haskell
class Functor f where
    fmap :: (a -> b) -> f a -> f b
-- f is higher-kinded
```

**Use**: Generic programming

## Applications

### Application 1: Language Design

**Use**: Design type systems

**Considerations**: 
- **Expressiveness**: What can express
- **Safety**: How safe
- **Complexity**: How complex

### Application 2: Compiler Optimization

**Use**: Use types for optimization

**Examples**: 
- **Monomorphization**: Specialize generics
- **Devirtualization**: Remove virtual calls

## Real-World Examples

### Example 1: TypeScript

**Use**: Type inference for JavaScript

**Benefit**: Type safety with JavaScript flexibility

### Example 2: Rust

**Use**: Advanced type system

**Features**: Ownership, lifetimes, traits

**Benefit**: Memory safety without GC

## Common Pitfalls

### Problem: Over-Complex Types

```haskell
-- BAD: Too complex types
-- Hard to understand

-- GOOD: Balance expressiveness and simplicity
```

### Problem: Ignoring Type Errors

```typescript
// BAD: Ignore type errors
// @ts-ignore everywhere

// GOOD: Fix type errors
// Proper types
```

## Quiz

1. What is a type system?
   - **A)** Memory system
   - **B)** Set of rules for types to ensure correctness
   - **C)** Runtime system
   - **D)** Compilation system

2. What is type inference?
   - **A)** Type checking
   - **B)** Automatically inferring types without explicit annotations
   - **C)** Type conversion
   - **D)** Type casting

3. What is polymorphism?
   - **A)** Single type
   - **B)** One interface with multiple implementations
   - **C)** Type conversion
   - **D)** Type checking

**Answers:**
1. **B** - A type system is a set of rules that assign types to program constructs (variables, expressions, functions) to ensure type safety and catch errors
2. **B** - Type inference automatically deduces the types of expressions and variables without requiring explicit type annotations, reducing verbosity while maintaining type safety
3. **B** - Polymorphism allows writing code that works with multiple types through parametric polymorphism (generics), ad-hoc polymorphism (overloading), or subtype polymorphism (inheritance)

## Next Steps

- [Language Runtime Design](../03_advanced/02.%20Language%20Runtime%20Design.md) - Runtime systems
- [Just-In-Time Compilation Advanced](./05.%20JIT%20Compilation.md) - Advanced JIT

