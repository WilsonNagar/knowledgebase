---
number: 2
title: "AST & Intermediate Representation"
slug: "ast-intermediate-representation"
level: "intermediate"
tags: ["compilers", "ast", "ir", "llvm", "code-generation"]
prerequisites: ["lexing-parsing-fundamentals"]
estimated_minutes: 110
contributors: []
diagrams: []
examples: []
canonical_id: "cs-comp-02"
---

# AST & Intermediate Representation

## Overview

Abstract Syntax Trees (AST) and Intermediate Representations (IR) are crucial stages in compilation. Understanding AST design, IR formats like LLVM IR, and how compilers transform source code through these representations is essential for compiler construction and language implementation.

## Table of Contents

1. [What is an AST?](#what-is-ast)
2. [AST Structure](#ast-structure)
3. [AST Construction](#ast-construction)
4. [AST Traversal](#ast-traversal)
5. [What is IR?](#what-is-ir)
6. [LLVM IR](#llvm-ir)
7. [IR Optimization](#ir-optimization)
8. [AST to IR Translation](#ast-to-ir)

## What is an AST?

### Definition

**AST**: Abstract Syntax Tree

**Purpose**: Represent program structure

**Abstract**: Removes syntactic details

**Tree**: Hierarchical structure

### AST vs Parse Tree

**Parse Tree**:
- **Complete**: Every grammar rule represented
- **Verbose**: Includes all syntactic details
- **Example**: Includes parentheses, semicolons

**AST**:
- **Simplified**: Only essential structure
- **Compact**: Removes syntactic sugar
- **Example**: No parentheses, semicolons

### Example

**Code**: `x = 10 + 20 * 30`

**Parse Tree**:
```
    =
   / \
  x   +
     / \
   10   *
        / \
      20  30
```

**AST**:
```
    =
   / \
  x   +
     / \
   10   *
        / \
      20  30
```

(Same structure, but parse tree has more details)

## AST Structure

### AST Node Types

**1. Expression Nodes**:
- **BinaryOp**: +, -, *, /
- **UnaryOp**: -, !
- **Literal**: Numbers, strings
- **Variable**: Variable references
- **Call**: Function calls

**2. Statement Nodes**:
- **Assignment**: x = value
- **If**: if (condition) { ... }
- **While**: while (condition) { ... }
- **Return**: return value
- **Block**: { statements }

**3. Declaration Nodes**:
- **Variable**: int x;
- **Function**: int f() { ... }
- **Class**: class C { ... }

### AST Node Structure

**Basic Node**:
```c
typedef enum {
    NODE_BINARY_OP,
    NODE_LITERAL,
    NODE_VARIABLE,
    NODE_ASSIGNMENT,
    // ...
} NodeType;

typedef struct Node {
    NodeType type;
    // Node-specific data
} Node;
```

**Binary Operation Node**:
```c
typedef struct {
    NodeType type;  // NODE_BINARY_OP
    char op;        // '+', '-', '*', '/'
    Node* left;
    Node* right;
} BinaryOpNode;
```

**Literal Node**:
```c
typedef struct {
    NodeType type;  // NODE_LITERAL
    int value;      // For integers
} LiteralNode;
```

## AST Construction

### During Parsing

**Recursive Descent Parser**:
```c
Node* parse_expression() {
    Node* left = parse_term();
    
    while (peek().type == TOKEN_PLUS || peek().type == TOKEN_MINUS) {
        Token op = consume();
        Node* right = parse_term();
        left = create_binary_op(op.type, left, right);
    }
    
    return left;
}

Node* parse_term() {
    Node* left = parse_factor();
    
    while (peek().type == TOKEN_MULTIPLY || peek().type == TOKEN_DIVIDE) {
        Token op = consume();
        Node* right = parse_factor();
        left = create_binary_op(op.type, left, right);
    }
    
    return left;
}

Node* parse_factor() {
    if (peek().type == TOKEN_NUMBER) {
        return create_literal(consume().value);
    }
    if (peek().type == TOKEN_IDENTIFIER) {
        return create_variable(consume().value);
    }
    // ...
}
```

### AST Building Functions

**Create Nodes**:
```c
Node* create_binary_op(char op, Node* left, Node* right) {
    BinaryOpNode* node = malloc(sizeof(BinaryOpNode));
    node->type = NODE_BINARY_OP;
    node->op = op;
    node->left = left;
    node->right = right;
    return (Node*)node;
}

Node* create_literal(int value) {
    LiteralNode* node = malloc(sizeof(LiteralNode));
    node->type = NODE_LITERAL;
    node->value = value;
    return (Node*)node;
}

Node* create_variable(char* name) {
    VariableNode* node = malloc(sizeof(VariableNode));
    node->type = NODE_VARIABLE;
    node->name = strdup(name);
    return (Node*)node;
}
```

## AST Traversal

### Visitor Pattern

**Visitor**: Traverse AST and perform operations

**Benefits**: Separate traversal from operations

**Structure**:
```c
typedef struct Visitor Visitor;

typedef struct {
    void (*visit_binary_op)(Visitor* v, BinaryOpNode* node);
    void (*visit_literal)(Visitor* v, LiteralNode* node);
    void (*visit_variable)(Visitor* v, VariableNode* node);
    // ...
} VisitorVTable;

struct Visitor {
    VisitorVTable* vtable;
    void* data;
};
```

### Traversal Example

**Evaluate Expression**:
```c
int evaluate(Visitor* v, Node* node) {
    switch (node->type) {
        case NODE_BINARY_OP: {
            BinaryOpNode* bin = (BinaryOpNode*)node;
            int left = evaluate(v, bin->left);
            int right = evaluate(v, bin->right);
            switch (bin->op) {
                case '+': return left + right;
                case '-': return left - right;
                case '*': return left * right;
                case '/': return left / right;
            }
        }
        case NODE_LITERAL: {
            LiteralNode* lit = (LiteralNode*)node;
            return lit->value;
        }
        // ...
    }
}
```

## What is IR?

### Definition

**IR**: Intermediate Representation

**Purpose**: Platform-independent code representation

**Benefits**:
- **Portability**: Can target multiple architectures
- **Optimization**: Optimize before code generation
- **Abstraction**: Higher level than assembly

### IR Characteristics

**1. Platform-Independent**:
- **No architecture**: Not tied to specific CPU
- **Abstract**: Machine-independent

**2. Optimizable**:
- **Optimizations**: Can apply optimizations
- **Analysis**: Easier to analyze than source

**3. Lower Level**:
- **Than source**: Closer to machine code
- **Than assembly**: Still abstract

## LLVM IR

### What is LLVM IR?

**LLVM IR**: LLVM Intermediate Representation

**Format**: Text or binary

**Characteristics**:
- **SSA**: Static Single Assignment
- **Typed**: Strongly typed
- **Three-address**: Three-address code

### LLVM IR Example

**C Code**:
```c
int add(int a, int b) {
    return a + b;
}
```

**LLVM IR**:
```llvm
define i32 @add(i32 %a, i32 %b) {
  %1 = add i32 %a, %b
  ret i32 %1
}
```

### LLVM IR Structure

**Functions**:
```llvm
define return_type @function_name(param_types) {
  ; function body
}
```

**Instructions**:
```llvm
%result = opcode type operand1, operand2
```

**SSA Form**:
```llvm
%1 = add i32 %a, %b
%2 = mul i32 %1, %c  ; %1 used here
```

### LLVM IR Types

**Basic Types**:
- **i32**: 32-bit integer
- **i64**: 64-bit integer
- **float**: 32-bit float
- **double**: 64-bit double

**Pointer Types**:
- **i32***: Pointer to i32

**Composite Types**:
- **{i32, float}**: Structure
- **[4 x i32]**: Array

## IR Optimization

### Optimization Passes

**1. Constant Folding**:
```llvm
; Before
%1 = add i32 5, 3

; After
%1 = i32 8
```

**2. Dead Code Elimination**:
```llvm
; Remove unused instructions
```

**3. Loop Optimization**:
```llvm
; Unroll loops, vectorize
```

**4. Inlining**:
```llvm
; Inline function calls
```

### LLVM Optimization

**LLVM Passes**: Modular optimization passes

**Example**:
```bash
opt -O3 input.ll -o output.ll
```

**Passes**: Many optimization passes available

## AST to IR Translation

### Translation Process

**Steps**:
```
1. Traverse AST
2. Generate IR for each node
3. Handle scopes, types
4. Generate SSA form
```

### Translation Example

**AST**:
```
    =
   / \
  x   +
     / \
   10   *
        / \
      20  30
```

**IR Generation**:
```llvm
%1 = mul i32 20, 30    ; 20 * 30
%2 = add i32 10, %1   ; 10 + (20 * 30)
store i32 %2, i32* @x ; x = result
```

### Code Generation

**AST â†’ IR**:
```c
void generate_ir(Visitor* v, Node* node) {
    switch (node->type) {
        case NODE_BINARY_OP: {
            BinaryOpNode* bin = (BinaryOpNode*)node;
            generate_ir(v, bin->left);
            generate_ir(v, bin->right);
            emit_binary_op(v, bin->op);
            break;
        }
        case NODE_LITERAL: {
            LiteralNode* lit = (LiteralNode*)node;
            emit_load_constant(v, lit->value);
            break;
        }
        // ...
    }
}
```

## Real-World Examples

### Example 1: Simple Expression

**Source**: `x = 10 + 20`

**AST**:
```
    =
   / \
  x   +
     / \
   10  20
```

**IR**:
```llvm
%1 = add i32 10, 20
store i32 %1, i32* @x
```

### Example 2: Function Call

**Source**: `result = add(a, b)`

**AST**:
```
      =
     / \
result  call
       / | \
     add a  b
```

**IR**:
```llvm
%1 = load i32, i32* @a
%2 = load i32, i32* @b
%3 = call i32 @add(i32 %1, i32 %2)
store i32 %3, i32* @result
```

## Common Pitfalls

### Problem: Not Handling Scopes

```c
// BAD: Ignore scopes
// Variables from different scopes conflict

// GOOD: Track scopes
// Use symbol table, handle scoping
```

### Problem: Not Generating SSA

```c
// BAD: Reuse variables
x = 1;
x = x + 1; // Not SSA

// GOOD: Generate SSA
%1 = i32 1
%2 = add i32 %1, 1
```

## Quiz

1. What is an AST?
   - **A)** Abstract Syntax Tree - simplified tree representation of program structure
   - **B)** Assembly Syntax Tree
   - **C)** Advanced Syntax Tree
   - **D)** Algorithm Syntax Tree

2. What is IR used for?
   - **A)** Encryption
   - **B)** Platform-independent code representation for optimization and code generation
   - **C)** Compression
   - **D)** Networking

3. What is SSA form?
   - **A)** Single Source Assignment
   - **B)** Static Single Assignment - each variable assigned only once
   - **C)** Simple Source Assignment
   - **D)** Sequential Source Assignment

**Answers:**
1. **A** - An AST (Abstract Syntax Tree) is a simplified tree representation that captures the essential structure of a program, removing syntactic details like parentheses and semicolons
2. **B** - IR (Intermediate Representation) provides a platform-independent code representation that can be optimized and then translated to machine code for different architectures
3. **B** - SSA (Static Single Assignment) form ensures each variable is assigned only once, making optimizations easier and enabling better analysis

## Next Steps

- [Optimization Passes](./03.%20Optimization%20Passes.md) - Code optimization
- [Register Allocation](./04.%20Register%20Allocation.md) - Code generation

