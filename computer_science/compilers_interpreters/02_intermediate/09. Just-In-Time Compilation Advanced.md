---
number: 9
title: "Just-In-Time Compilation Advanced"
slug: "jit-compilation-advanced"
level: "intermediate"
tags: ["compilers", "jit", "optimization", "profiling", "runtime"]
prerequisites: ["type-systems-type-inference"]
estimated_minutes: 135
contributors: []
diagrams: []
examples: []
canonical_id: "cs-comp-09"
---

# Just-In-Time Compilation Advanced

## Overview

Advanced JIT compilation techniques like tiered compilation, on-stack replacement, deoptimization, and profile-guided optimization enable high-performance language runtimes. Understanding these advanced techniques is essential for understanding how modern VMs achieve near-native performance.

## Table of Contents

1. [Tiered Compilation](#tiered)
2. [On-Stack Replacement (OSR)](#osr)
3. [Deoptimization](#deoptimization)
4. [Profile-Guided Optimization](#pgo)
5. [Inlining Strategies](#inlining)
6. [Speculative Optimization](#speculative)
7. [JIT Compiler Architecture](#architecture)
8. [Real-World Examples](#examples)

## Tiered Compilation

### What is Tiered Compilation?

**Tiered**: Multiple compilation tiers

**Tiers**:
- **Tier 0**: Interpreter
- **Tier 1**: Simple compiler (C1)
- **Tier 2**: Optimizing compiler (C2)

**Process**: 
```
Start with interpreter
Profile execution
Compile to C1 (fast compilation)
If hot: Compile to C2 (slow compilation, fast code)
```

### Tiered Compilation Benefits

**1. Fast Startup**:
```
Start with interpreter
No compilation delay
```

**2. Adaptive**:
```
Only compile hot code
```

**3. Balance**:
```
Balance compilation time vs execution time
```

## On-Stack Replacement (OSR)

### What is OSR?

**OSR**: Replace code while executing

**Purpose**: Switch from interpreter to compiled code mid-execution

**Use**: When method becomes hot during execution

### OSR Process

**Process**:
```
1. Method executing in interpreter
2. Method becomes hot
3. Compile method
4. Replace interpreter frame with compiled frame
5. Continue execution in compiled code
```

**Challenge**: Map interpreter state to compiled state

**Benefit**: Don't wait for method return

## Deoptimization

### What is Deoptimization?

**Deoptimization**: Revert optimized code

**When**: 
- **Assumption Invalid**: Optimization assumption wrong
- **Exception**: Exception in optimized code
- **Type Change**: Type changed

**Process**: 
```
1. Detect invalid assumption
2. Deoptimize to interpreter
3. Continue in interpreter
```

### Deoptimization Example

**Optimization**: Assume integer type

**Reality**: String passed

**Deoptimization**: Revert to generic code

**Benefit**: Correctness maintained

## Profile-Guided Optimization

### What is PGO?

**PGO**: Profile-Guided Optimization

**Method**: 
```
1. Profile execution
2. Use profile to guide optimization
3. Optimize based on actual usage
```

**Benefits**: 
- **Better Optimization**: Optimize what's actually used
- **Adaptive**: Adapts to actual behavior

### Profile Data

**Types**:
- **Call Frequency**: How often called
- **Branch Frequency**: Which branches taken
- **Type Information**: Types observed
- **Loop Iterations**: Loop trip counts

**Use**: Guide optimization decisions

## Inlining Strategies

### Inlining Decisions

**When to Inline**:
- **Small Methods**: Inline small methods
- **Hot Methods**: Inline frequently called
- **Monomorphic**: Inline when single target

**When Not to Inline**:
- **Large Methods**: Code size explosion
- **Polymorphic**: Multiple targets
- **Cold Methods**: Not worth it

### Aggressive Inlining

**Strategy**: Inline aggressively

**Benefit**: More optimization opportunities

**Cost**: Code size increase

**Trade-off**: Balance inlining vs code size

## Speculative Optimization

### What is Speculative Optimization?

**Speculative**: Optimize based on assumptions

**Assumptions**: 
- **Type**: Assume common type
- **Branch**: Assume common branch
- **Value**: Assume common value

**Guard**: Check assumption

**If Valid**: Use optimized code

**If Invalid**: Deoptimize

### Speculative Example

**Assumption**: Method always called with integer

**Optimization**: Specialize for integer

**Guard**: Check if integer

**If Integer**: Use optimized code

**If Not**: Deoptimize to generic code

## JIT Compiler Architecture

### Components

**1. Interpreter**:
```
Execute bytecode
Profile execution
```

**2. Compiler**:
```
Compile hot code
Generate native code
```

**3. Profiler**:
```
Collect execution statistics
Identify hot spots
```

**4. Optimizer**:
```
Apply optimizations
Based on profile
```

### Compilation Pipeline

```
Bytecode → Parse → Optimize → Generate → Native Code
              ↓
         Profile Data
```

## Real-World Examples

### Example 1: HotSpot JVM

**Tiers**: Interpreter → C1 → C2

**OSR**: On-stack replacement

**Deoptimization**: Revert on invalid assumptions

**Result**: High performance

### Example 2: V8 JavaScript Engine

**Tiers**: Ignition → TurboFan

**Optimization**: Aggressive inlining, type specialization

**Result**: Fast JavaScript execution

## Common Pitfalls

### Problem: Over-Optimization

```c
// BAD: Optimize everything
// High compilation overhead

// GOOD: Optimize only hot code
// Balance compilation vs execution
```

### Problem: Wrong Assumptions

```c
// BAD: Assume wrong types
// Frequent deoptimization

// GOOD: Use profile data
// Make informed assumptions
```

## Quiz

1. What is tiered compilation?
   - **A)** Single compiler
   - **B)** Multiple compilation tiers (interpreter → simple compiler → optimizing compiler)
   - **C)** Multiple languages
   - **D)** Multiple platforms

2. What is on-stack replacement?
   - **A)** Replace stack
   - **B)** Replace executing code mid-execution (interpreter to compiled)
   - **C)** Replace memory
   - **D)** Replace variables

3. What is speculative optimization?
   - **A)** Certain optimization
   - **B)** Optimize based on assumptions with guards and deoptimization
   - **C)** Slow optimization
   - **D)** Generic optimization

**Answers:**
1. **B** - Tiered compilation uses multiple compilation tiers, starting with a fast interpreter, then a simple fast compiler (C1), and finally an optimizing compiler (C2) for hot code
2. **B** - On-stack replacement (OSR) allows switching from interpreter to compiled code while a method is executing, without waiting for the method to return
3. **B** - Speculative optimization makes optimizations based on assumptions (like common types), uses guards to check assumptions, and deoptimizes if assumptions prove wrong

## Next Steps

- [Language Runtime Design](../03_advanced/02.%20Language%20Runtime%20Design.md) - Runtime systems
- [Domain-Specific Languages](../03_advanced/03.%20Domain-Specific%20Languages%20(DSL).md) - DSL design

