---
number: 2
title: "Transaction Isolation Levels"
slug: "transaction-isolation-levels"
level: "fundamentals"
tags: ["databases", "transactions", "isolation", "concurrency", "acid"]
prerequisites: ["acid-properties-in-depth"]
estimated_minutes: 110
contributors: []
diagrams: []
examples: []
canonical_id: "cs-db-02"
---

# Transaction Isolation Levels

## Overview

Transaction isolation levels control how transactions interact with each other when accessing the same data concurrently. Understanding the different isolation levels, the anomalies they prevent, and their performance trade-offs is essential for database design and application development.

## Table of Contents

1. [Isolation Level Overview](#overview)
2. [Read Uncommitted](#read-uncommitted)
3. [Read Committed](#read-committed)
4. [Repeatable Read](#repeatable-read)
5. [Serializable](#serializable)
6. [Isolation Anomalies](#anomalies)
7. [Implementation Strategies](#implementation)
8. [Choosing Isolation Levels](#choosing)

## Isolation Level Overview

### What are Isolation Levels?

**Isolation Levels**: Define how transactions see each other's changes

**Purpose**: Balance between consistency and performance

**Trade-off**: Higher isolation = better consistency, lower performance

### Standard Isolation Levels

**SQL Standard** (from lowest to highest):
1. **Read Uncommitted**: Lowest isolation
2. **Read Committed**: Default in many databases
3. **Repeatable Read**: MySQL InnoDB default
4. **Serializable**: Highest isolation

### Anomalies Prevented

| Level | Dirty Read | Non-Repeatable Read | Phantom Read |
|-------|------------|---------------------|--------------|
| Read Uncommitted | ❌ Allowed | ❌ Allowed | ❌ Allowed |
| Read Committed | ✅ Prevented | ❌ Allowed | ❌ Allowed |
| Repeatable Read | ✅ Prevented | ✅ Prevented | ❌ Allowed |
| Serializable | ✅ Prevented | ✅ Prevented | ✅ Prevented |

## Read Uncommitted

### Characteristics

**Isolation**: Lowest level

**Anomalies Allowed**:
- ✅ Dirty reads
- ✅ Non-repeatable reads
- ✅ Phantom reads

**Performance**: Highest (no locking overhead)

### Example

**Transaction A**:
```sql
BEGIN TRANSACTION;
UPDATE accounts SET balance = 1000 WHERE id = 1;
-- Not committed yet
```

**Transaction B** (Read Uncommitted):
```sql
BEGIN TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
SELECT balance FROM accounts WHERE id = 1;
-- Reads 1000 (dirty read!)
```

**Transaction A**:
```sql
ROLLBACK; -- Changes undone
```

**Problem**: Transaction B read uncommitted data that was rolled back

### Use Cases

**Rarely Used**:
- **Statistics**: Approximate counts acceptable
- **Reporting**: Stale data acceptable
- **Not recommended**: For most applications

## Read Committed

### Characteristics

**Isolation**: Default in PostgreSQL, SQL Server, Oracle

**Anomalies Prevented**:
- ✅ Dirty reads prevented
- ❌ Non-repeatable reads allowed
- ❌ Phantom reads allowed

**Performance**: Good balance

### Example

**Transaction A**:
```sql
BEGIN TRANSACTION;
SELECT balance FROM accounts WHERE id = 1; -- Reads 100
UPDATE accounts SET balance = 200 WHERE id = 1;
COMMIT;
```

**Transaction B** (Read Committed):
```sql
BEGIN TRANSACTION ISOLATION LEVEL READ COMMITTED;
SELECT balance FROM accounts WHERE id = 1; -- Reads 100
-- Transaction A commits
SELECT balance FROM accounts WHERE id = 1; -- Reads 200 (different!)
COMMIT;
```

**Non-Repeatable Read**: Same query returns different values

### Implementation

**Method**: Row-level locks

**Read Locks**:
- **Shared lock**: While reading
- **Released**: Immediately after read
- **Write lock**: Held until commit

**Benefits**:
- **No dirty reads**: Cannot read uncommitted data
- **Good performance**: Locks released quickly
- **Concurrency**: Multiple readers allowed

## Repeatable Read

### Characteristics

**Isolation**: Default in MySQL InnoDB

**Anomalies Prevented**:
- ✅ Dirty reads prevented
- ✅ Non-repeatable reads prevented
- ❌ Phantom reads allowed

**Performance**: Moderate

### Example

**Transaction A** (Repeatable Read):
```sql
BEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ;
SELECT balance FROM accounts WHERE id = 1; -- Reads 100
-- Transaction B updates and commits
SELECT balance FROM accounts WHERE id = 1; -- Still reads 100 (same!)
COMMIT;
```

**Non-Repeatable Read Prevented**: Same query returns same value

**Phantom Read Still Possible**:
```sql
BEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ;
SELECT COUNT(*) FROM accounts WHERE balance > 100; -- Returns 5
-- Transaction B inserts new account with balance 150
SELECT COUNT(*) FROM accounts WHERE balance > 100; -- Returns 6 (phantom!)
COMMIT;
```

### Implementation

**Method**: Snapshot isolation (MVCC)

**How It Works**:
- **Snapshot**: Transaction sees consistent snapshot
- **Versioning**: Multiple versions of rows
- **Reads**: Read from snapshot
- **Writes**: Create new versions

**Benefits**:
- **No locking**: Readers don't block writers
- **Consistency**: Consistent view throughout transaction
- **Performance**: Good for read-heavy workloads

## Serializable

### Characteristics

**Isolation**: Highest level

**Anomalies Prevented**:
- ✅ Dirty reads prevented
- ✅ Non-repeatable reads prevented
- ✅ Phantom reads prevented

**Performance**: Lowest (most locking)

### Example

**Transaction A** (Serializable):
```sql
BEGIN TRANSACTION ISOLATION LEVEL SERIALIZABLE;
SELECT COUNT(*) FROM accounts WHERE balance > 100; -- Returns 5
-- Transaction B tries to insert account with balance 150
-- Transaction B BLOCKED until Transaction A commits
COMMIT;
-- Now Transaction B can proceed
```

**Phantom Read Prevented**: No new rows can be inserted

### Implementation

**Method**: Strict locking

**Locks**:
- **Range locks**: Lock ranges of rows
- **Predicate locks**: Lock based on WHERE clause
- **Held**: Until transaction commits

**Costs**:
- **Low concurrency**: Many locks held
- **Deadlocks**: More likely
- **Performance**: Slower

## Isolation Anomalies

### Dirty Read

**Definition**: Read uncommitted data

**Example**:
```
T1: UPDATE accounts SET balance = 1000 WHERE id = 1;
T2: SELECT balance FROM accounts WHERE id = 1; -- Reads 1000
T1: ROLLBACK;
T2: Read uncommitted data (dirty read)
```

**Prevented By**: Read Committed or higher

### Non-Repeatable Read

**Definition**: Same query returns different values

**Example**:
```
T1: SELECT balance FROM accounts WHERE id = 1; -- Reads 100
T2: UPDATE accounts SET balance = 200 WHERE id = 1; COMMIT;
T1: SELECT balance FROM accounts WHERE id = 1; -- Reads 200 (different!)
```

**Prevented By**: Repeatable Read or higher

### Phantom Read

**Definition**: Same query returns different number of rows

**Example**:
```
T1: SELECT COUNT(*) FROM accounts WHERE balance > 100; -- Returns 5
T2: INSERT INTO accounts VALUES (6, 150); COMMIT;
T1: SELECT COUNT(*) FROM accounts WHERE balance > 100; -- Returns 6 (phantom!)
```

**Prevented By**: Serializable

### Lost Update

**Definition**: Update overwritten by another transaction

**Example**:
```
T1: SELECT balance FROM accounts WHERE id = 1; -- Reads 100
T2: SELECT balance FROM accounts WHERE id = 1; -- Reads 100
T1: UPDATE accounts SET balance = 100 + 50 WHERE id = 1; -- Sets 150
T2: UPDATE accounts SET balance = 100 + 30 WHERE id = 1; -- Sets 130
-- T1's update lost!
```

**Prevented By**: All isolation levels (with proper locking)

## Implementation Strategies

### Locking-Based (Pessimistic)

**Method**: Lock data to prevent conflicts

**Read Committed**:
- **Shared locks**: While reading
- **Released**: After read
- **Exclusive locks**: For writes

**Repeatable Read**:
- **Shared locks**: Held until commit
- **Exclusive locks**: Held until commit

**Serializable**:
- **Range locks**: Lock ranges
- **Predicate locks**: Lock predicates
- **All locks**: Held until commit

**Pros**:
- **Simple**: Easy to understand
- **Predictable**: Clear behavior

**Cons**:
- **Blocking**: Locks block other transactions
- **Deadlocks**: Can occur
- **Performance**: Lower concurrency

### Multi-Version Concurrency Control (MVCC)

**Method**: Keep multiple versions of rows

**How It Works**:
- **Versions**: Each update creates new version
- **Snapshots**: Transactions see snapshot
- **Reads**: Read from snapshot (no locks)
- **Writes**: Create new versions

**Read Committed**:
- **Snapshot**: Current committed state
- **Updates**: See latest committed data

**Repeatable Read**:
- **Snapshot**: State at transaction start
- **Consistent**: Same data throughout transaction

**Pros**:
- **No blocking**: Readers don't block writers
- **High concurrency**: Many readers
- **Performance**: Good for read-heavy

**Cons**:
- **Storage**: Multiple versions
- **Complexity**: More complex implementation
- **Cleanup**: Old versions must be cleaned

### Timestamp Ordering

**Method**: Order transactions by timestamp

**How It Works**:
- **Timestamp**: Each transaction gets timestamp
- **Read timestamp**: Latest write timestamp
- **Write timestamp**: Transaction timestamp
- **Conflicts**: Resolved by timestamp

**Pros**:
- **No blocking**: No locks needed
- **Deadlock-free**: No deadlocks possible

**Cons**:
- **Aborts**: Many aborts possible
- **Complexity**: Complex conflict resolution

## Choosing Isolation Levels

### Factors to Consider

**1. Data Consistency Requirements**:
- **Critical data**: Higher isolation
- **Approximate OK**: Lower isolation

**2. Performance Requirements**:
- **High throughput**: Lower isolation
- **Consistency critical**: Higher isolation

**3. Read vs Write Ratio**:
- **Read-heavy**: MVCC (Repeatable Read)
- **Write-heavy**: Locking (Read Committed)

**4. Application Logic**:
- **Can handle anomalies**: Lower isolation
- **Cannot handle anomalies**: Higher isolation

### Recommendations

**Read Committed**:
- **Default**: Good balance
- **Use**: Most applications
- **Benefits**: Good performance, prevents dirty reads

**Repeatable Read**:
- **Use**: Financial transactions, reporting
- **Benefits**: Consistent reads, good for MVCC
- **Cost**: Some performance overhead

**Serializable**:
- **Use**: Critical consistency requirements
- **Benefits**: Highest consistency
- **Cost**: Significant performance overhead

**Read Uncommitted**:
- **Avoid**: Almost never use
- **Exception**: Statistics, approximate counts

## Real-World Examples

### Example 1: Banking System

**Requirements**: High consistency

**Isolation**: Serializable or Repeatable Read

```sql
BEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ;
-- Transfer money
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
UPDATE accounts SET balance = balance + 100 WHERE id = 2;
-- Must see consistent balances
COMMIT;
```

### Example 2: Web Application

**Requirements**: Good performance, some inconsistency OK

**Isolation**: Read Committed

```sql
BEGIN TRANSACTION ISOLATION LEVEL READ COMMITTED;
-- Update user profile
UPDATE users SET name = 'John' WHERE id = 1;
-- Other transactions can see update immediately
COMMIT;
```

### Example 3: Reporting System

**Requirements**: Consistent snapshot for report

**Isolation**: Repeatable Read

```sql
BEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ;
-- Generate report
SELECT SUM(balance) FROM accounts;
SELECT COUNT(*) FROM accounts;
-- Both queries see same snapshot
COMMIT;
```

## Common Pitfalls

### Problem: Assuming Higher is Always Better

```sql
-- BAD: Always use Serializable
BEGIN TRANSACTION ISOLATION LEVEL SERIALIZABLE;
-- May cause deadlocks, poor performance

-- GOOD: Use appropriate level
BEGIN TRANSACTION ISOLATION LEVEL READ COMMITTED;
-- Good balance for most cases
```

### Problem: Not Understanding Anomalies

```sql
-- BAD: Assume no anomalies at Read Committed
BEGIN TRANSACTION ISOLATION LEVEL READ COMMITTED;
SELECT balance FROM accounts WHERE id = 1; -- 100
-- Other transaction updates
SELECT balance FROM accounts WHERE id = 1; -- 200 (different!)
-- Application may break

-- GOOD: Understand and handle anomalies
BEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ;
-- Or handle non-repeatable reads in application
```

## Quiz

1. What isolation level prevents dirty reads but allows non-repeatable reads?
   - **A)** Read Uncommitted
   - **B)** Read Committed
   - **C)** Repeatable Read
   - **D)** Serializable

2. What is a phantom read?
   - **A)** Reading uncommitted data
   - **B)** Same query returns different number of rows
   - **C)** Reading corrupted data
   - **D)** Reading from wrong table

3. Why might you choose Read Committed over Repeatable Read?
   - **A)** Better performance and higher concurrency
   - **B)** Better consistency
   - **C)** Prevents more anomalies
   - **D)** Simpler implementation

**Answers:**
1. **B** - Read Committed prevents dirty reads but allows non-repeatable reads (same query can return different values)
2. **B** - A phantom read occurs when the same query returns a different number of rows due to inserts/deletes by other transactions
3. **A** - Read Committed offers better performance and higher concurrency because it releases locks sooner, though it allows more anomalies than Repeatable Read

## Next Steps

- [MVCC Internals](../02_intermediate/03.%20MVCC%20Internals.md) - Multi-version concurrency control
- [Write-Ahead Logging](../02_intermediate/04.%20Write-Ahead%20Logging%20(WAL).md) - WAL implementation

