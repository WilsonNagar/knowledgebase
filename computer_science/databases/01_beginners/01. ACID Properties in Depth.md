---
number: 1
title: "ACID Properties in Depth"
slug: "acid-properties-in-depth"
level: "fundamentals"
tags: ["databases", "acid", "transactions", "consistency", "isolation"]
prerequisites: []
estimated_minutes: 95
contributors: []
diagrams: []
examples: []
canonical_id: "cs-db-01"
---

# ACID Properties in Depth

## Overview

ACID (Atomicity, Consistency, Isolation, Durability) properties are fundamental guarantees that database transactions provide. Understanding these properties, how they're implemented, and the trade-offs involved is essential for database design, application development, and system architecture. This comprehensive guide covers each ACID property in detail with real-world examples and implementation strategies.

## Table of Contents

1. [What are ACID Properties?](#what-is-acid)
2. [Atomicity](#atomicity)
3. [Consistency](#consistency)
4. [Isolation](#isolation)
5. [Durability](#durability)
6. [ACID Implementation Strategies](#implementation)
7. [Trade-offs and Relaxations](#trade-offs)
8. [Real-World Examples](#real-world)

## What are ACID Properties?

### The Problem

**Database Transactions**:
- Multiple operations must succeed or fail together
- Data must remain consistent
- Concurrent transactions must not interfere
- Changes must persist after system failure

**Solution**: ACID Properties

### ACID Overview

**A - Atomicity**:
- All-or-nothing execution
- Either all operations succeed or all fail
- No partial updates

**C - Consistency**:
- Database remains in valid state
- Constraints always satisfied
- No invalid data

**I - Isolation**:
- Concurrent transactions don't interfere
- Each transaction sees consistent snapshot
- Serializability

**D - Durability**:
- Committed changes persist
- Survives system crashes
- Written to non-volatile storage

## Atomicity

### What is Atomicity?

**Atomicity**: Transaction is indivisible unit

**Principle**: "All or nothing"

**Example**:
```
Transaction: Transfer $100 from Account A to Account B

Operations:
1. Debit Account A: $100
2. Credit Account B: $100

If operation 1 succeeds but 2 fails:
  → Rollback operation 1
  → No money lost
  → Database unchanged
```

### Implementing Atomicity

**1. Write-Ahead Logging (WAL)**:
```
Before modifying data:
1. Write intent to log
2. Modify data
3. Write commit to log

On failure:
1. Read log
2. Undo incomplete transactions
3. Database restored to consistent state
```

**2. Two-Phase Commit (2PC)**:
```
Phase 1: Prepare
  - All participants prepare
  - Vote: commit or abort

Phase 2: Commit or Abort
  - If all vote commit: commit
  - If any votes abort: abort all
```

**3. Shadow Paging**:
```
Before transaction:
  - Copy pages to shadow
  - Modify shadow pages
  - On commit: swap shadow and current
  - On abort: discard shadow
```

### Atomicity Examples

**Bank Transfer**:
```sql
BEGIN TRANSACTION;
  UPDATE accounts SET balance = balance - 100 WHERE id = 'A';
  UPDATE accounts SET balance = balance + 100 WHERE id = 'B';
COMMIT;
-- If either UPDATE fails, both are rolled back
```

**E-Commerce Order**:
```sql
BEGIN TRANSACTION;
  INSERT INTO orders (id, customer_id, total) VALUES (...);
  INSERT INTO order_items (order_id, product_id, quantity) VALUES (...);
  UPDATE inventory SET quantity = quantity - 1 WHERE product_id = ...;
  UPDATE accounts SET balance = balance - total WHERE id = ...;
COMMIT;
-- All operations succeed or all fail
```

## Consistency

### What is Consistency?

**Consistency**: Database remains in valid state

**Constraints**:
- **Primary keys**: Unique, not null
- **Foreign keys**: Referenced rows exist
- **Check constraints**: Values satisfy conditions
- **Domain constraints**: Data types, ranges
- **Business rules**: Custom logic

### Consistency Levels

**1. Immediate Consistency**:
- Constraints checked immediately
- Violations cause transaction abort
- Strongest guarantee

**2. Deferred Consistency**:
- Constraints checked at commit
- More flexible
- Better performance

**3. Eventual Consistency**:
- Constraints checked eventually
- Used in distributed systems
- Weaker guarantee

### Consistency Examples

**Referential Integrity**:
```sql
-- Parent table
CREATE TABLE departments (
  id INT PRIMARY KEY,
  name VARCHAR(100)
);

-- Child table
CREATE TABLE employees (
  id INT PRIMARY KEY,
  name VARCHAR(100),
  department_id INT,
  FOREIGN KEY (department_id) REFERENCES departments(id)
);

-- Consistency: Cannot insert employee with non-existent department
INSERT INTO employees VALUES (1, 'John', 999); -- ERROR: Foreign key violation
```

**Check Constraints**:
```sql
CREATE TABLE products (
  id INT PRIMARY KEY,
  name VARCHAR(100),
  price DECIMAL(10,2),
  CHECK (price > 0) -- Consistency: Price must be positive
);

INSERT INTO products VALUES (1, 'Widget', -10); -- ERROR: Check constraint violation
```

**Business Rules**:
```sql
-- Consistency: Account balance cannot go negative
CREATE TABLE accounts (
  id INT PRIMARY KEY,
  balance DECIMAL(10,2),
  CHECK (balance >= 0)
);

UPDATE accounts SET balance = balance - 1000 WHERE id = 1;
-- Fails if balance would become negative
```

## Isolation

### What is Isolation?

**Isolation**: Concurrent transactions don't interfere

**Goal**: Each transaction sees consistent snapshot

**Problem**: Concurrent access can cause anomalies

### Isolation Anomalies

**1. Dirty Read**:
```
Transaction A: UPDATE accounts SET balance = 1000 WHERE id = 1;
Transaction B: SELECT balance FROM accounts WHERE id = 1; -- Reads 1000
Transaction A: ROLLBACK;
Transaction B: Read uncommitted data (dirty read)
```

**2. Non-Repeatable Read**:
```
Transaction A: SELECT balance FROM accounts WHERE id = 1; -- Reads 100
Transaction B: UPDATE accounts SET balance = 200 WHERE id = 1; COMMIT;
Transaction A: SELECT balance FROM accounts WHERE id = 1; -- Reads 200
Transaction A: Different values in same transaction (non-repeatable)
```

**3. Phantom Read**:
```
Transaction A: SELECT COUNT(*) FROM accounts WHERE balance > 100; -- Returns 5
Transaction B: INSERT INTO accounts VALUES (6, 150); COMMIT;
Transaction A: SELECT COUNT(*) FROM accounts WHERE balance > 100; -- Returns 6
Transaction A: Different count (phantom row)
```

**4. Lost Update**:
```
Transaction A: SELECT balance FROM accounts WHERE id = 1; -- Reads 100
Transaction B: SELECT balance FROM accounts WHERE id = 1; -- Reads 100
Transaction A: UPDATE accounts SET balance = 100 + 50 WHERE id = 1; -- Sets 150
Transaction B: UPDATE accounts SET balance = 100 + 30 WHERE id = 1; -- Sets 130
-- Transaction A's update lost
```

### Isolation Levels

**1. Read Uncommitted**:
- **Dirty reads**: Allowed
- **Non-repeatable reads**: Allowed
- **Phantom reads**: Allowed
- **Lowest isolation**: Best performance

**2. Read Committed**:
- **Dirty reads**: Prevented
- **Non-repeatable reads**: Allowed
- **Phantom reads**: Allowed
- **Default in many databases**

**3. Repeatable Read**:
- **Dirty reads**: Prevented
- **Non-repeatable reads**: Prevented
- **Phantom reads**: Allowed
- **MySQL InnoDB default**

**4. Serializable**:
- **All anomalies**: Prevented
- **Highest isolation**: Worst performance
- **True serializability**

### Implementing Isolation

**1. Locking**:
```
Shared Lock (Read Lock):
  - Multiple transactions can read
  - No transaction can write

Exclusive Lock (Write Lock):
  - Only one transaction can write
  - No other transaction can read or write
```

**2. Multi-Version Concurrency Control (MVCC)**:
```
Each transaction sees snapshot:
  - Read from snapshot (no locks)
  - Write creates new version
  - Old versions kept until no longer needed
  - Snapshot isolation
```

**3. Timestamp Ordering**:
```
Each transaction gets timestamp:
  - Operations ordered by timestamp
  - Conflicts detected and resolved
  - Optimistic concurrency control
```

## Durability

### What is Durability?

**Durability**: Committed changes persist

**Requirement**: Survive system crashes

**Guarantee**: Once committed, data is permanent

### Implementing Durability

**1. Write-Ahead Logging (WAL)**:
```
Transaction commit:
1. Write transaction log to disk
2. Flush log to disk (fsync)
3. Mark transaction committed
4. Write data pages (can be buffered)

On crash:
1. Read log from disk
2. Replay committed transactions
3. Database restored
```

**2. Write-Through Caching**:
```
Write operation:
1. Write to cache
2. Immediately write to disk
3. Wait for disk confirmation
4. Return success

Slower but more durable
```

**3. Replication**:
```
Write operation:
1. Write to primary database
2. Replicate to secondary databases
3. Wait for acknowledgment
4. Return success

Survives single node failure
```

### Durability Trade-offs

**Performance vs Durability**:
```
High Durability:
  - fsync after every write
  - Slow but safe
  - No data loss

Low Durability:
  - Buffer writes
  - Fast but risky
  - Possible data loss on crash
```

**Synchronous vs Asynchronous**:
```
Synchronous Replication:
  - Wait for all replicas
  - Strong durability
  - Higher latency

Asynchronous Replication:
  - Don't wait for replicas
  - Weaker durability
  - Lower latency
```

## ACID Implementation Strategies

### Write-Ahead Logging (WAL)

**How It Works**:
```
1. Before modifying page:
   - Write log record (redo log)
   - Log contains: operation, page, old value, new value

2. Modify page in memory:
   - Update buffer pool
   - Don't write to disk yet

3. On commit:
   - Write commit record to log
   - Flush log to disk (fsync)
   - Mark transaction committed

4. Periodically:
   - Write dirty pages to disk (checkpoint)
   - Log can be truncated
```

**Benefits**:
- **Fast commits**: Only log write needed
- **Durability**: Log survives crashes
- **Recovery**: Replay log to restore

### Two-Phase Locking (2PL)

**Phase 1: Growing Phase**:
- Acquire locks
- Cannot release locks
- Can read/write

**Phase 2: Shrinking Phase**:
- Release locks
- Cannot acquire locks
- Prepare for commit

**Strict 2PL**:
- Hold all locks until commit
- Prevents cascading aborts
- Most common implementation

### Snapshot Isolation

**How It Works**:
```
1. Transaction starts:
   - Get snapshot timestamp
   - See database state at that time

2. Read operations:
   - Read from snapshot
   - No locks needed
   - Fast reads

3. Write operations:
   - Create new versions
   - Check for conflicts
   - Abort if conflict detected

4. Commit:
   - Check for write conflicts
   - If no conflicts: commit
   - If conflicts: abort
```

**Benefits**:
- **Fast reads**: No locking
- **Good concurrency**: Multiple readers
- **Write conflicts**: Detected at commit

## Trade-offs and Relaxations

### Why Relax ACID?

**Performance**:
- Strong ACID: Slower
- Weaker guarantees: Faster
- Trade-off for scalability

**Scalability**:
- ACID: Hard to scale
- Relaxed: Easier to scale
- Distributed systems

### CAP Theorem

**CAP**: Consistency, Availability, Partition tolerance

**Choose 2 of 3**:
- **CP**: Consistency + Partition tolerance (ACID databases)
- **AP**: Availability + Partition tolerance (NoSQL)
- **CA**: Consistency + Availability (single node)

### BASE Properties

**BASE**: Basically Available, Soft state, Eventual consistency

**Alternative to ACID**:
- **Basically Available**: System available most of the time
- **Soft state**: State may change without input
- **Eventual consistency**: Will become consistent eventually

**Use Cases**:
- High availability systems
- Distributed systems
- Large-scale applications

## Real-World Examples

### Example 1: Banking System

**Requirements**: Strong ACID
```
Transaction: Transfer money

Atomicity: Both debit and credit succeed or fail
Consistency: Balances always sum correctly
Isolation: Concurrent transfers don't interfere
Durability: Transfer persists after crash

Implementation:
- Write-ahead logging
- Two-phase commit
- Serializable isolation
- Synchronous replication
```

### Example 2: E-Commerce Inventory

**Requirements**: Moderate ACID
```
Transaction: Place order

Atomicity: Order and inventory update together
Consistency: Inventory cannot go negative
Isolation: Read committed (acceptable)
Durability: Order must persist

Implementation:
- Write-ahead logging
- Repeatable read isolation
- Asynchronous replication (acceptable delay)
```

### Example 3: Social Media Feed

**Requirements**: Weak ACID
```
Operation: Post update

Atomicity: Post succeeds or fails
Consistency: Eventually consistent
Isolation: Read uncommitted acceptable
Durability: Eventually durable

Implementation:
- Eventual consistency
- Asynchronous replication
- High availability prioritized
```

## Common Pitfalls

### Problem: Assuming Perfect ACID

```sql
-- BAD: Assume perfect isolation
BEGIN TRANSACTION;
  SELECT balance FROM accounts WHERE id = 1; -- 100
  -- Other transaction updates balance
  UPDATE accounts SET balance = balance + 50 WHERE id = 1; -- Uses stale value
COMMIT;

-- GOOD: Use proper isolation level
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
BEGIN TRANSACTION;
  SELECT balance FROM accounts WHERE id = 1 FOR UPDATE; -- Lock row
  UPDATE accounts SET balance = balance + 50 WHERE id = 1;
COMMIT;
```

### Problem: Ignoring Durability Trade-offs

```python
# BAD: Assume immediate durability
db.execute("INSERT INTO orders ...")
# System crashes before fsync
# Data lost

# GOOD: Understand durability guarantees
db.execute("INSERT INTO orders ...")
db.commit() # Wait for fsync
# Data persisted
```

## Quiz

1. What does Atomicity guarantee?
   - **A)** All transactions succeed
   - **B)** All operations in transaction succeed or all fail
   - **C)** No concurrent access
   - **D)** Data persists forever

2. What isolation level prevents dirty reads?
   - **A)** Read Uncommitted
   - **B)** Read Committed or higher
   - **C)** Repeatable Read only
   - **D)** Serializable only

3. How is durability typically implemented?
   - **A)** In-memory caching
   - **B)** Write-ahead logging (WAL)
   - **C)** Lazy writing
   - **D)** Read-only database

**Answers:**
1. **B** - Atomicity guarantees that all operations in a transaction succeed together or all fail together (all-or-nothing)
2. **B** - Read Committed and higher isolation levels prevent dirty reads by only allowing reads of committed data
3. **B** - Durability is typically implemented using Write-Ahead Logging (WAL), where transaction logs are written to disk before data pages

## Next Steps

- [Transaction Isolation Levels](./02.%20Transaction%20Isolation%20Levels.md) - Deep dive into isolation
- [Write-Ahead Logging](../02_intermediate/04.%20Write-Ahead%20Logging%20(WAL).md) - WAL implementation

