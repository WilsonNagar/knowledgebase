---
number: 11
title: "Database Indexing Strategies"
slug: "database-indexing-strategies"
level: "intermediate"
tags: ["databases", "indexing", "b-tree", "hash-index", "composite-index"]
prerequisites: ["storage-engines-innodb-rocksdb"]
estimated_minutes: 135
contributors: []
diagrams: []
examples: []
canonical_id: "cs-db-11"
---

# Database Indexing Strategies

## Overview

Database indexing strategies determine how data is organized for fast retrieval. Understanding different index types, indexing strategies, composite indexes, covering indexes, and index optimization is essential for database performance tuning and query optimization.

## Table of Contents

1. [What are Indexes?](#what-are-indexes)
2. [Index Types](#index-types)
3. [B-Tree Indexes](#b-tree-indexes)
4. [Hash Indexes](#hash-indexes)
5. [Composite Indexes](#composite-indexes)
6. [Covering Indexes](#covering-indexes)
7. [Index Selection](#index-selection)
8. [Index Maintenance](#index-maintenance)

## What are Indexes?

### Definition

**Index**: Data structure for fast lookup

**Purpose**: Speed up queries

**Trade-off**: 
- **Read**: Faster reads
- **Write**: Slower writes (maintenance)
- **Space**: Extra space

**Analogy**: Book index

### Index Benefits

**1. Fast Lookup**:
```
O(log n) instead of O(n)
```

**2. Sorted Access**:
```
Sorted data access
```

**3. Range Queries**:
```
Efficient range queries
```

**4. Join Performance**:
```
Faster joins
```

## Index Types

### Primary Index Types

**1. B-Tree Index**:
```
Most common
Balanced tree
```

**2. Hash Index**:
```
Hash table
Exact match only
```

**3. Bitmap Index**:
```
Bitmap for each value
```

**4. Full-Text Index**:
```
Text search
```

**5. Spatial Index**:
```
Geographic data
```

## B-Tree Indexes

### What is a B-Tree Index?

**B-Tree**: Balanced tree structure

**Structure**: 
```
Root
├── Internal nodes
│   ├── Leaf nodes
│   └── Leaf nodes
└── Leaf nodes (data)
```

**Operations**: 
- **Lookup**: O(log n)
- **Insert**: O(log n)
- **Delete**: O(log n)
- **Range**: O(log n + k)

### B-Tree Index Example

**Table**:
```
id | name | age
1  | Alice| 25
2  | Bob  | 30
3  | Carol| 25
```

**Index on age**:
```
25 → [1, 3]
30 → [2]
```

**Query**: `SELECT * FROM users WHERE age = 25`
**Result**: Fast lookup using index

## Hash Indexes

### What is a Hash Index?

**Hash Index**: Hash table structure

**Structure**: 
```
Hash function → Buckets → Values
```

**Operations**: 
- **Lookup**: O(1) average
- **Insert**: O(1) average
- **Delete**: O(1) average
- **Range**: Not supported

### Hash Index Characteristics

**Advantages**:
- **Fast Lookup**: O(1) average
- **Simple**: Simple structure

**Disadvantages**:
- **No Range**: No range queries
- **Collisions**: Hash collisions
- **Memory**: May need memory

## Composite Indexes

### What is a Composite Index?

**Composite Index**: Index on multiple columns

**Purpose**: Support multi-column queries

**Order**: Column order matters

**Example**:
```sql
CREATE INDEX idx_name_age ON users(name, age);
```

### Composite Index Order

**Order Matters**:
```
Index (name, age):
- Supports: WHERE name = ?
- Supports: WHERE name = ? AND age = ?
- Does NOT support: WHERE age = ?
```

**Rule**: Leftmost prefix

**Example**:
```
Index (a, b, c):
✓ WHERE a = ?
✓ WHERE a = ? AND b = ?
✓ WHERE a = ? AND b = ? AND c = ?
✗ WHERE b = ?
✗ WHERE c = ?
```

## Covering Indexes

### What is a Covering Index?

**Covering Index**: Index contains all needed data

**Purpose**: Avoid table lookup

**Benefit**: 
- **Faster**: Faster queries
- **Less I/O**: Less I/O

**Example**:
```sql
-- Query
SELECT name, age FROM users WHERE age = 25;

-- Covering index
CREATE INDEX idx_age_name ON users(age, name);
-- Index contains age and name
-- No table lookup needed
```

### Covering Index Benefits

**1. Performance**:
```
Faster queries
```

**2. I/O Reduction**:
```
Less I/O operations
```

**3. Cache Efficiency**:
```
Better cache usage
```

## Index Selection

### When to Create Indexes

**1. Foreign Keys**:
```
Index foreign keys
```

**2. WHERE Clauses**:
```
Index columns in WHERE
```

**3. JOIN Columns**:
```
Index JOIN columns
```

**4. ORDER BY**:
```
Index ORDER BY columns
```

### When NOT to Create Indexes

**1. Small Tables**:
```
Small tables (< 1000 rows)
```

**2. Low Selectivity**:
```
Low selectivity columns
```

**3. Frequently Updated**:
```
Frequently updated columns
```

**4. Too Many Indexes**:
```
Too many indexes
```

## Index Maintenance

### Index Maintenance

**1. Rebuilding**:
```
Rebuild indexes periodically
```

**2. Statistics**:
```
Update statistics
```

**3. Monitoring**:
```
Monitor index usage
```

**4. Dropping**:
```
Drop unused indexes
```

### Index Fragmentation

**Fragmentation**: Index becomes fragmented

**Impact**: 
- **Performance**: Reduced performance
- **Space**: Wasted space

**Solution**: Rebuild indexes

## Real-World Examples

### Example 1: E-Commerce Database

**Indexes**: 
- **Product ID**: Primary key
- **Category**: For filtering
- **Price**: For sorting
- **Composite**: (category, price) for queries

**Benefit**: Fast queries

### Example 2: User Database

**Indexes**: 
- **User ID**: Primary key
- **Email**: Unique index
- **Username**: Unique index
- **Composite**: (status, created_at) for queries

**Benefit**: Fast lookups

## Common Pitfalls

### Problem: Too Many Indexes

```sql
-- BAD: Too many indexes
-- Slows down writes

-- GOOD: Create indexes selectively
-- Based on query patterns
```

### Problem: Wrong Index Order

```sql
-- BAD: Wrong column order
CREATE INDEX idx_age_name ON users(age, name);
-- Query: WHERE name = ? AND age = ?
-- Index doesn't help

-- GOOD: Match query pattern
CREATE INDEX idx_name_age ON users(name, age);
```

## Quiz

1. What is a database index?
   - **A)** Table
   - **B)** Data structure for fast data lookup
   - **C)** Query
   - **D)** Constraint

2. What is a composite index?
   - **A)** Single column index
   - **B)** Index on multiple columns with leftmost prefix rule
   - **C)** Hash index
   - **D)** Bitmap index

3. What is a covering index?
   - **A)** Index covering table
   - **B)** Index containing all columns needed by query, avoiding table lookup
   - **C)** Full table index
   - **D)** Partial index

**Answers:**
1. **B** - A database index is a data structure that speeds up data retrieval by providing fast lookup paths, trading write performance and space for read performance
2. **B** - A composite index indexes multiple columns, supporting queries that use the leftmost prefix of indexed columns
3. **B** - A covering index contains all columns needed by a query, allowing the query to be satisfied entirely from the index without accessing the table

## Next Steps

- [Query Execution Plans Deep Dive](./12.%20Query%20Execution%20Plans%20Deep%20Dive.md) - Execution plans
- [Database Concurrency Control Advanced](./13.%20Database%20Concurrency%20Control%20Advanced.md) - Advanced concurrency

