---
number: 4
title: "Write-Ahead Logging (WAL)"
slug: "write-ahead-logging-wal"
level: "intermediate"
tags: ["databases", "wal", "logging", "durability", "recovery"]
prerequisites: ["acid-properties-in-depth"]
estimated_minutes: 110
contributors: []
diagrams: []
examples: []
canonical_id: "cs-db-04"
---

# Write-Ahead Logging (WAL)

## Overview

Write-Ahead Logging (WAL) is a fundamental technique for ensuring database durability and enabling crash recovery. Understanding how WAL works, log records, checkpoints, and recovery procedures is essential for database design, performance optimization, and understanding how modern databases guarantee ACID properties.

## Table of Contents

1. [What is Write-Ahead Logging?](#what-is-wal)
2. [Why WAL?](#why-wal)
3. [WAL Principles](#principles)
4. [Log Records](#log-records)
5. [WAL Process](#wal-process)
6. [Checkpoints](#checkpoints)
7. [Recovery](#recovery)
8. [Performance Optimization](#optimization)

## What is Write-Ahead Logging?

### Definition

**WAL**: Write changes to log before applying to data

**Principle**: "Write log first, then data"

**Purpose**: Ensure durability and enable recovery

### Traditional Approach (Without WAL)

**Process**:
```
1. Modify data pages in memory
2. Write pages to disk
3. Commit transaction
```

**Problem**: 
- **Slow**: Must write data pages for commit
- **Random I/O**: Writing pages scattered on disk
- **Recovery**: Hard to recover if crash during write

### WAL Approach

**Process**:
```
1. Write log record to disk (sequential)
2. Modify data pages in memory
3. Commit transaction (log flushed)
4. Write pages to disk later (asynchronous)
```

**Benefits**:
- **Fast commits**: Only log write needed
- **Sequential I/O**: Log is sequential
- **Recovery**: Can replay log

## Why WAL?

### Durability Guarantee

**Requirement**: Committed transactions must persist

**Without WAL**:
```
Transaction commits
  → Write data pages (slow, random I/O)
  → If crash during write: Data lost!
```

**With WAL**:
```
Transaction commits
  → Write log (fast, sequential)
  → Log flushed to disk
  → Data pages written later
  → If crash: Replay log to recover
```

### Performance Benefits

**1. Fast Commits**:
- **Log write**: Sequential, fast
- **Data write**: Can be deferred
- **Commit**: Only waits for log flush

**2. Sequential I/O**:
- **Log**: Append-only, sequential
- **Better**: Than random page writes
- **Throughput**: Higher

**3. Group Commit**:
- **Batch**: Multiple transactions
- **Single write**: One log write for many
- **Efficient**: Better throughput

## WAL Principles

### WAL Rule

**Fundamental Rule**: 
```
Before modifying data page:
  Write log record describing change
  Flush log to disk
  Then modify page
```

**Guarantee**: Log always ahead of data

### Log Sequence Number (LSN)

**LSN**: Unique identifier for log records

**Purpose**: Order log records

**Structure**: Monotonically increasing number

**Example**:
```
LSN 100: BEGIN transaction T1
LSN 101: UPDATE accounts SET balance=100 WHERE id=1
LSN 102: UPDATE accounts SET balance=200 WHERE id=2
LSN 103: COMMIT transaction T1
```

## Log Records

### Log Record Structure

**Basic Structure**:
```
┌──────────┬──────────┬──────────┬──────────┐
│ LSN      │ Type     │ Txn ID   │ Data     │
└──────────┴──────────┴──────────┴──────────┘
```

**Fields**:
- **LSN**: Log sequence number
- **Type**: BEGIN, UPDATE, COMMIT, etc.
- **Transaction ID**: Which transaction
- **Data**: Change description

### Log Record Types

**1. BEGIN**:
```
LSN: 100
Type: BEGIN
Txn ID: T1
```

**2. UPDATE**:
```
LSN: 101
Type: UPDATE
Txn ID: T1
Table: accounts
Row: id=1
Old value: balance=50
New value: balance=100
```

**3. COMMIT**:
```
LSN: 102
Type: COMMIT
Txn ID: T1
```

**4. ABORT**:
```
LSN: 103
Type: ABORT
Txn ID: T1
```

### Physical vs Logical Logging

**Physical Logging**:
- **Records**: Actual bytes changed
- **Example**: "Page 5, offset 100, old: 0x1234, new: 0x5678"
- **Efficient**: Fast recovery
- **Complex**: More log data

**Logical Logging**:
- **Records**: High-level operations
- **Example**: "UPDATE accounts SET balance=100 WHERE id=1"
- **Compact**: Less log data
- **Complex**: Recovery more complex

**Physiological Logging** (common):
- **Hybrid**: Physical for page, logical for operation
- **Balance**: Good performance and recovery

## WAL Process

### Transaction Execution

**Step 1: Begin Transaction**:
```
Write BEGIN log record
LSN = allocate_next_lsn()
log_write(BEGIN, txn_id, LSN)
```

**Step 2: Execute Operations**:
```
For each operation:
  1. Write log record
  2. Modify data page in memory
  3. Update page LSN
```

**Step 3: Commit**:
```
1. Write COMMIT log record
2. Flush log to disk (fsync)
3. Mark transaction committed
4. Return success to client
```

**Step 4: Write Data Pages** (asynchronous):
```
Later (background):
  1. Write dirty pages to disk
  2. Update checkpoint
```

### Log Flush

**When**: On commit

**Why**: Ensure durability

**How**: fsync() system call

**Cost**: ~1-10ms (disk I/O)

**Optimization**: Group commit (batch multiple commits)

## Checkpoints

### What is a Checkpoint?

**Checkpoint**: Point where all data pages written

**Purpose**: Reduce recovery time

**Process**:
```
1. Write all dirty pages to disk
2. Write checkpoint record to log
3. Update checkpoint LSN
```

### Checkpoint Benefits

**Recovery Time**:
```
Without checkpoint:
  Replay entire log (may be huge)

With checkpoint:
  Replay log from checkpoint (much smaller)
```

**Checkpoint Frequency**:
- **Frequent**: Faster recovery, more overhead
- **Infrequent**: Slower recovery, less overhead
- **Balance**: Every few minutes

### Checkpoint Process

**Steps**:
```
1. Start checkpoint
2. Write all dirty pages
3. Write checkpoint record:
   - Checkpoint LSN
   - List of active transactions
4. Flush log
5. Update checkpoint pointer
```

## Recovery

### Recovery Process

**After Crash**:
```
1. Find last checkpoint
2. Redo: Replay log from checkpoint
3. Undo: Rollback uncommitted transactions
```

### Redo Phase

**Purpose**: Reapply committed changes

**Process**:
```
For each log record after checkpoint:
  if (record.committed && page.LSN < record.LSN):
    apply_change(record)
    update page.LSN
```

**Example**:
```
Checkpoint at LSN 1000
Log records: 1001, 1002, 1003 (all committed)
Redo: Apply all three records
```

### Undo Phase

**Purpose**: Rollback uncommitted transactions

**Process**:
```
For each uncommitted transaction:
  For each log record (reverse order):
    undo_change(record)
    write compensation log record
```

**Example**:
```
Transaction T1: LSN 1001, 1002 (not committed)
Undo: Rollback changes in reverse order
```

### Recovery Example

**Scenario**: Crash during transaction

**Before Crash**:
```
LSN 100: BEGIN T1
LSN 101: UPDATE accounts SET balance=100 WHERE id=1 (T1)
LSN 102: BEGIN T2
LSN 103: UPDATE accounts SET balance=200 WHERE id=2 (T2)
LSN 104: COMMIT T2
LSN 105: UPDATE accounts SET balance=300 WHERE id=3 (T1)
[CRASH - T1 not committed]
```

**Recovery**:
```
1. Redo phase:
   - LSN 104: COMMIT T2 → T2 changes applied
   - LSN 103: UPDATE (T2) → Applied
   - LSN 102: BEGIN T2 → Applied
   - LSN 101: UPDATE (T1) → Applied (but will undo)
   - LSN 105: UPDATE (T1) → Applied (but will undo)

2. Undo phase:
   - T1 not committed → Rollback
   - Undo LSN 105: Restore balance=old_value
   - Undo LSN 101: Restore balance=old_value
```

## Performance Optimization

### Group Commit

**Idea**: Batch multiple commits

**Process**:
```
Transaction 1: Commit → Wait
Transaction 2: Commit → Wait
Transaction 3: Commit → Wait
[All waiting]
Leader: Flush log (one fsync)
All: Return success
```

**Benefits**: 
- **Fewer fsyncs**: One instead of many
- **Better throughput**: Higher commit rate

### Log Buffering

**Buffer**: Keep log in memory

**Flush**: Periodically or on commit

**Benefits**:
- **Faster**: Memory writes fast
- **Batching**: Can batch writes

**Trade-off**: Durability vs performance

### Asynchronous Writes

**Data Pages**: Write asynchronously

**Process**:
```
Commit: Flush log only
Background: Write dirty pages
```

**Benefits**: Fast commits

**Risk**: More data to recover (but log has it)

## Real-World Examples

### Example 1: PostgreSQL WAL

**Implementation**: Physical logging

**Features**:
- **WAL files**: Sequential files
- **Checkpoints**: Automatic
- **Recovery**: Replay WAL

**Configuration**:
```sql
wal_level = replica
checkpoint_timeout = 5min
max_wal_size = 1GB
```

### Example 2: MySQL InnoDB

**Implementation**: Redo log (WAL)

**Features**:
- **Redo log**: Circular log files
- **Checkpoints**: Continuous
- **Recovery**: Apply redo log

**Configuration**:
```ini
innodb_log_file_size = 256M
innodb_log_files_in_group = 2
```

## Common Pitfalls

### Problem: Not Flushing Log

```sql
-- BAD: Commit without log flush
COMMIT; -- Log not flushed
-- Crash → Transaction lost!

-- GOOD: Log flushed on commit
COMMIT; -- Log flushed (fsync)
-- Crash → Can recover
```

### Problem: Too Frequent Checkpoints

```sql
-- BAD: Checkpoint every second
-- High overhead, frequent I/O

-- GOOD: Reasonable checkpoint interval
-- Every few minutes
```

## Quiz

1. What is the fundamental principle of WAL?
   - **A)** Write data first
   - **B)** Write log record before modifying data page
   - **C)** Write data and log simultaneously
   - **D)** Write log after data

2. Why are checkpoints used in WAL?
   - **A)** To speed up writes
   - **B)** To reduce recovery time by limiting how much log needs to be replayed
   - **C)** To encrypt data
   - **D)** To compress log

3. What happens during recovery redo phase?
   - **A)** Rollback transactions
   - **B)** Reapply committed changes from log
   - **C)** Delete log
   - **D)** Nothing

**Answers:**
1. **B** - The fundamental WAL principle is to write the log record describing the change before modifying the actual data page, ensuring the log is always ahead
2. **B** - Checkpoints mark points where all data pages are written to disk, allowing recovery to start from the checkpoint instead of the beginning of the log, significantly reducing recovery time
3. **B** - The redo phase replays committed transactions from the log to restore the database to its state before the crash

## Next Steps

- [B-Tree vs LSM Trees](./05.%20B-Tree%20vs%20LSM%20Trees.md) - Storage structures
- [Query Optimizers](./06.%20Query%20Optimizers.md) - Query optimization

