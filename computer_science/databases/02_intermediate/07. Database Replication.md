---
number: 7
title: "Database Replication"
slug: "database-replication"
level: "intermediate"
tags: ["databases", "replication", "master-slave", "master-master", "consistency"]
prerequisites: ["query-optimizers"]
estimated_minutes: 115
contributors: []
diagrams: []
examples: []
canonical_id: "cs-db-07"
---

# Database Replication

## Overview

Database replication creates and maintains copies of data across multiple database servers. Understanding replication strategies, master-slave vs master-master, consistency models, and replication topologies is essential for building highly available, scalable database systems.

## Table of Contents

1. [What is Replication?](#what-is-replication)
2. [Replication Benefits](#benefits)
3. [Master-Slave Replication](#master-slave)
4. [Master-Master Replication](#master-master)
5. [Replication Methods](#methods)
6. [Consistency Models](#consistency)
7. [Replication Topologies](#topologies)
8. [Conflict Resolution](#conflict-resolution)

## What is Replication?

### Definition

**Replication**: Copying data to multiple servers

**Purpose**: 
- **Availability**: Survive server failures
- **Performance**: Distribute read load
- **Scalability**: Handle more requests
- **Geographic**: Reduce latency

### Replication Components

**Primary/Master**: Source of truth

**Replica/Slave**: Copy of data

**Replication**: Process of copying data

## Replication Benefits

### High Availability

**Single Point of Failure**: One server fails → System down

**With Replication**: 
- **Failover**: Switch to replica
- **Uptime**: System continues operating

### Read Scalability

**Single Server**: Limited read capacity

**With Replication**:
- **Distribute Reads**: Across replicas
- **Higher Throughput**: More read capacity

### Geographic Distribution

**Single Location**: High latency for distant users

**With Replication**:
- **Local Replicas**: Reduce latency
- **Better UX**: Faster responses

## Master-Slave Replication

### Architecture

**Master**: 
- **Writes**: All writes go to master
- **Source**: Source of truth

**Slaves**:
- **Reads**: Can serve read requests
- **Replication**: Receive updates from master

**Flow**:
```
Write → Master → Replicate → Slaves
Read  → Master or Slaves
```

### Master-Slave Process

**1. Write to Master**:
```
Client → Master: INSERT/UPDATE/DELETE
Master: Apply change, write to binlog
```

**2. Replication**:
```
Master: Send binlog events to slaves
Slaves: Apply events (replay)
```

**3. Read from Slaves**:
```
Client → Slave: SELECT
Slave: Return data (may be slightly stale)
```

### Master-Slave Benefits

**1. Read Scaling**:
```
Distribute reads across slaves
Higher read throughput
```

**2. High Availability**:
```
If master fails: Promote slave to master
System continues
```

**3. Backup**:
```
Slaves can be used for backups
No impact on master
```

### Master-Slave Limitations

**1. Single Write Point**:
```
All writes go to master
Master may become bottleneck
```

**2. Replication Lag**:
```
Slaves may be behind master
Stale reads possible
```

**3. Failover Complexity**:
```
Promoting slave requires coordination
May lose some writes
```

## Master-Master Replication

### Architecture

**Multiple Masters**:
- **Writes**: Can write to any master
- **Replication**: Masters replicate to each other

**Flow**:
```
Write → Master 1 → Replicate → Master 2
Write → Master 2 → Replicate → Master 1
Read  → Any Master
```

### Master-Master Benefits

**1. Write Scaling**:
```
Writes can go to any master
Higher write throughput
```

**2. Geographic Distribution**:
```
Masters in different regions
Low latency for local writes
```

**3. No Single Point of Failure**:
```
If one master fails, others continue
```

### Master-Master Challenges

**1. Conflict Resolution**:
```
Concurrent writes to same data
Need conflict resolution
```

**2. Complexity**:
```
More complex than master-slave
Harder to reason about
```

**3. Consistency**:
```
Eventual consistency
May see temporary inconsistencies
```

## Replication Methods

### Statement-Based Replication

**Method**: Replicate SQL statements

**Process**:
```
Master: Execute INSERT INTO users VALUES (...)
Master: Log: "INSERT INTO users VALUES (...)"
Slave: Execute logged statement
```

**Benefits**: 
- **Compact**: Logs are small
- **Simple**: Easy to understand

**Problems**:
- **Non-deterministic**: RAND(), NOW() may differ
- **Side effects**: Triggers, stored procedures

### Row-Based Replication

**Method**: Replicate changed rows

**Process**:
```
Master: UPDATE users SET name='Alice' WHERE id=1
Master: Log: Row before: {id:1, name:'Bob'}
         Row after: {id:1, name:'Alice'}
Slave: Apply row change
```

**Benefits**:
- **Deterministic**: Always same result
- **Safe**: Handles non-deterministic functions

**Problems**:
- **Larger logs**: More data
- **Slower**: More I/O

### Mixed Replication

**Method**: Use both (statement-based default, row-based when needed)

**Benefits**: Best of both worlds

## Consistency Models

### Strong Consistency

**Guarantee**: All replicas see same data immediately

**Method**: Synchronous replication

**Process**:
```
Write → Master
Master → Wait for all slaves to confirm
Master → Return success
```

**Trade-off**: Higher latency, lower availability

### Eventual Consistency

**Guarantee**: Replicas eventually converge

**Method**: Asynchronous replication

**Process**:
```
Write → Master
Master → Return success immediately
Master → Replicate to slaves (async)
```

**Trade-off**: Lower latency, temporary inconsistencies

### Read Consistency Levels

**1. Read from Master**:
```
Always consistent
Higher load on master
```

**2. Read from Slave**:
```
May be stale (replication lag)
Lower load on master
```

**3. Read from Quorum**:
```
Read from majority
Balanced consistency/performance
```

## Replication Topologies

### Star Topology

**Structure**:
```
    Master
   /  |  \
Slave1 Slave2 Slave3
```

**Benefits**: Simple, master controls all

**Limitation**: Master is bottleneck

### Chain Topology

**Structure**:
```
Master → Slave1 → Slave2 → Slave3
```

**Benefits**: Reduces load on master

**Limitation**: Higher latency for distant slaves

### Tree Topology

**Structure**:
```
      Master
     /      \
  Slave1  Slave2
  /  \     /  \
S1  S2   S3  S4
```

**Benefits**: Scalable, reduces master load

**Limitation**: More complex

## Conflict Resolution

### Conflict Types

**1. Write-Write Conflict**:
```
Master 1: UPDATE users SET balance=100 WHERE id=1
Master 2: UPDATE users SET balance=200 WHERE id=1
Both apply → Which value?
```

**2. Insert Conflict**:
```
Master 1: INSERT INTO users VALUES (1, 'Alice')
Master 2: INSERT INTO users VALUES (1, 'Bob')
Same primary key → Conflict!
```

### Resolution Strategies

**1. Last Write Wins**:
```
Use timestamp
Latest timestamp wins
```

**2. Application-Level**:
```
Application resolves conflicts
Custom logic
```

**3. Conflict-Free Replicated Data Types (CRDTs)**:
```
Data types that merge automatically
No conflicts possible
```

## Real-World Examples

### Example 1: MySQL Replication

**Type**: Master-Slave

**Method**: Binary log replication

**Use**: Read scaling, backups

**Configuration**:
```sql
-- Master
CHANGE MASTER TO
  MASTER_HOST='slave1',
  MASTER_USER='repl',
  MASTER_PASSWORD='password',
  MASTER_LOG_FILE='binlog.000001',
  MASTER_LOG_POS=100;

START SLAVE;
```

### Example 2: PostgreSQL Replication

**Type**: Master-Slave (Streaming Replication)

**Method**: WAL (Write-Ahead Log) streaming

**Use**: High availability

**Configuration**:
```
primary_conninfo = 'host=master port=5432'
```

### Example 3: MongoDB Replication

**Type**: Master-Slave (Replica Set)

**Method**: Oplog (operations log)

**Use**: High availability, read scaling

**Features**: Automatic failover

## Common Pitfalls

### Problem: Replication Lag

```sql
-- BAD: Assume immediate consistency
INSERT INTO users VALUES (1, 'Alice');
-- Read from slave immediately
SELECT * FROM users WHERE id=1; -- May not see insert!

-- GOOD: Read from master for critical reads
-- Or wait for replication
```

### Problem: Split-Brain

```c
// BAD: Two masters think they're primary
// Writes to both → Conflicts

// GOOD: Use consensus (Paxos, Raft)
// Only one master at a time
```

### Problem: Not Monitoring Lag

```c
// BAD: Ignore replication lag
// Slaves fall behind → Stale data

// GOOD: Monitor replication lag
// Alert if lag too high
```

## Quiz

1. What is the main benefit of database replication?
   - **A)** Faster writes
   - **B)** High availability, read scaling, and geographic distribution
   - **C)** Simpler queries
   - **D)** Less storage

2. What is the difference between master-slave and master-master replication?
   - **A)** No difference
   - **B)** Master-slave: single write point; Master-master: multiple write points
   - **C)** Master-master is simpler
   - **D)** Master-slave allows writes to slaves

3. What is replication lag?
   - **A)** Network delay
   - **B)** Delay between master write and slave applying it
   - **C)** Query delay
   - **D)** Connection delay

**Answers:**
1. **B** - Database replication provides high availability (survive failures), read scaling (distribute read load), and geographic distribution (reduce latency)
2. **B** - Master-slave has a single write point (master), while master-master allows writes to any master, enabling write scaling but requiring conflict resolution
3. **B** - Replication lag is the delay between when a write occurs on the master and when it's applied to replicas, causing potential stale reads

## Next Steps

- [Sharding & Partitioning](./08.%20Sharding%20%26%20Partitioning.md) - Horizontal scaling
- [Database Backup & Recovery](./09.%20Database%20Backup%20%26%20Recovery.md) - Data protection

