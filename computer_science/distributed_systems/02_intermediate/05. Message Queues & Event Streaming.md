---
number: 5
title: "Message Queues & Event Streaming"
slug: "message-queues-event-streaming"
level: "intermediate"
tags: ["distributed-systems", "message-queues", "event-streaming", "kafka", "rabbitmq"]
prerequisites: ["eventual-consistency"]
estimated_minutes: 120
contributors: []
diagrams: []
examples: []
canonical_id: "cs-dist-05"
---

# Message Queues & Event Streaming

## Overview

Message queues and event streaming systems enable asynchronous communication and event-driven architectures in distributed systems. Understanding message queues, pub/sub patterns, event streaming, and systems like Kafka and RabbitMQ is essential for building scalable, decoupled distributed systems.

## Table of Contents

1. [What are Message Queues?](#what-are-queues)
2. [Message Queue Patterns](#patterns)
3. [Point-to-Point Messaging](#point-to-point)
4. [Publish-Subscribe](#pub-sub)
5. [Message Queue Properties](#properties)
6. [Event Streaming](#event-streaming)
7. [Apache Kafka](#kafka)
8. [RabbitMQ](#rabbitmq)
9. [Use Cases](#use-cases)

## What are Message Queues?

### Definition

**Message Queue**: Asynchronous communication mechanism

**Purpose**: Decouple producers and consumers

**Benefits**:
- **Asynchronous**: Non-blocking communication
- **Decoupling**: Producers and consumers independent
- **Buffering**: Handle traffic spikes
- **Reliability**: Messages persisted

### Basic Model

**Components**:
- **Producer**: Sends messages
- **Queue**: Stores messages
- **Consumer**: Receives messages

**Flow**:
```
Producer → Queue → Consumer
```

## Message Queue Patterns

### Point-to-Point

**Model**: One producer, one consumer

**Queue**: Messages delivered to one consumer

**Use**: Task distribution, work queues

### Publish-Subscribe

**Model**: One producer, multiple consumers

**Topic**: Messages published to topic

**Subscribers**: All subscribers receive message

**Use**: Event broadcasting, notifications

## Point-to-Point Messaging

### How It Works

**Process**:
```
1. Producer sends message to queue
2. Queue stores message
3. Consumer receives message
4. Message removed from queue
```

**Properties**:
- **At-most-once**: Message delivered at most once
- **At-least-once**: Message delivered at least once
- **Exactly-once**: Message delivered exactly once

### Example: Task Queue

**Use Case**: Image processing

**Process**:
```
Producer: Upload image → Send to queue
Queue: Store processing task
Consumer: Process image → Send result
```

**Benefits**: 
- **Scalability**: Multiple workers
- **Reliability**: Tasks not lost
- **Load balancing**: Distribute work

## Publish-Subscribe

### How It Works

**Process**:
```
1. Publisher sends message to topic
2. Topic distributes to all subscribers
3. Each subscriber receives copy
```

**Properties**:
- **Broadcast**: All subscribers receive
- **Decoupling**: Publishers don't know subscribers
- **Scalability**: Add subscribers easily

### Example: Event Notifications

**Use Case**: User registration

**Process**:
```
Publisher: User registered → Publish event
Subscribers:
  - Email service: Send welcome email
  - Analytics: Track registration
  - Recommendations: Update profile
```

## Message Queue Properties

### Delivery Guarantees

**1. At-Most-Once**:
```
Message delivered at most once
May be lost
```

**2. At-Least-Once**:
```
Message delivered at least once
May be duplicated
```

**3. Exactly-Once**:
```
Message delivered exactly once
Most complex, highest overhead
```

### Ordering

**FIFO**: First-In-First-Out

**Partitioned**: Order within partition

**No Ordering**: No guarantee

### Durability

**Persistent**: Messages survive crashes

**In-Memory**: Messages lost on crash

**Trade-off**: Performance vs reliability

## Event Streaming

### What is Event Streaming?

**Event Streaming**: Continuous flow of events

**Properties**:
- **Ordered**: Events in order
- **Immutable**: Events append-only
- **Replayable**: Can replay events
- **Partitioned**: Distributed across partitions

### Event Stream Model

**Stream**: Ordered sequence of events

**Partition**: Subdivision of stream

**Offset**: Position in partition

**Consumer Group**: Group of consumers

## Apache Kafka

### What is Kafka?

**Kafka**: Distributed event streaming platform

**Properties**:
- **Distributed**: Runs on cluster
- **Scalable**: Handles high throughput
- **Durable**: Persistent storage
- **Replayable**: Can replay events

### Kafka Architecture

**Topics**: Categories of events

**Partitions**: Subdivisions of topics

**Brokers**: Kafka servers

**Producers**: Publish to topics

**Consumers**: Subscribe to topics

**Consumer Groups**: Coordinate consumption

### Kafka Concepts

**1. Topic**:
```
Category of events
Example: "user-events", "orders"
```

**2. Partition**:
```
Subdivision of topic
Enables parallelism
```

**3. Offset**:
```
Position in partition
Consumer tracks offset
```

**4. Consumer Group**:
```
Group of consumers
Partitions distributed among group
```

### Kafka Example

**Producer**:
```java
ProducerRecord<String, String> record = 
    new ProducerRecord<>("user-events", "user123", "registered");
producer.send(record);
```

**Consumer**:
```java
ConsumerRecords<String, String> records = consumer.poll(Duration.ofMillis(100));
for (ConsumerRecord<String, String> record : records) {
    process(record.value());
}
```

## RabbitMQ

### What is RabbitMQ?

**RabbitMQ**: Message broker

**Properties**:
- **AMQP**: Advanced Message Queuing Protocol
- **Flexible**: Multiple messaging patterns
- **Reliable**: Message acknowledgments
- **Management**: Web UI for management

### RabbitMQ Concepts

**1. Exchange**:
```
Routes messages to queues
Types: Direct, Topic, Fanout, Headers
```

**2. Queue**:
```
Stores messages
Consumers receive from queues
```

**3. Binding**:
```
Links exchange to queue
Defines routing rules
```

**4. Routing Key**:
```
Used for routing
Matches binding patterns
```

### RabbitMQ Example

**Producer**:
```python
channel.exchange_declare(exchange='logs', exchange_type='fanout')
channel.basic_publish(exchange='logs', routing_key='', body='Hello World')
```

**Consumer**:
```python
channel.queue_declare(queue='', exclusive=True)
channel.queue_bind(exchange='logs', queue=queue_name)

def callback(ch, method, properties, body):
    print(f"Received: {body}")

channel.basic_consume(queue=queue_name, on_message_callback=callback)
channel.start_consuming()
```

## Use Cases

### Use Case 1: Microservices Communication

**Pattern**: Event-driven architecture

**Benefits**:
- **Decoupling**: Services independent
- **Scalability**: Scale independently
- **Resilience**: Failures isolated

### Use Case 2: Log Aggregation

**Pattern**: Centralized logging

**Process**:
```
Services → Kafka → Log processors → Storage
```

**Benefits**: Centralized, searchable logs

### Use Case 3: Real-Time Analytics

**Pattern**: Stream processing

**Process**:
```
Events → Kafka → Stream processors → Analytics
```

**Benefits**: Real-time insights

### Use Case 4: CQRS (Command Query Responsibility Segregation)

**Pattern**: Separate write and read models

**Process**:
```
Commands → Event store → Events → Read models
```

**Benefits**: Optimized for reads and writes

## Real-World Examples

### Example 1: E-Commerce Platform

**Events**:
- Order placed
- Payment processed
- Order shipped
- Order delivered

**Consumers**:
- Inventory service
- Notification service
- Analytics service
- Recommendation service

### Example 2: Social Media Feed

**Events**:
- Post created
- Like added
- Comment added

**Consumers**:
- Feed generation
- Notification service
- Analytics

## Common Pitfalls

### Problem: Message Loss

```python
# BAD: No acknowledgment
consumer.receive()  # May lose message if crash

# GOOD: Acknowledge after processing
message = consumer.receive()
process(message)
consumer.acknowledge(message)  # Mark as processed
```

### Problem: Duplicate Processing

```python
# BAD: Process without idempotency
process_order(message)  # May process twice!

# GOOD: Idempotent processing
if not already_processed(message.id):
    process_order(message)
    mark_processed(message.id)
```

### Problem: Consumer Lag

```python
# BAD: Slow processing
for message in messages:
    slow_operation(message)  # Consumer falls behind

# GOOD: Parallel processing
with ThreadPoolExecutor() as executor:
    executor.map(process, messages)
```

## Quiz

1. What is the main benefit of message queues?
   - **A)** Faster execution
   - **B)** Asynchronous communication and decoupling of producers and consumers
   - **C)** Lower memory usage
   - **D)** Simpler code

2. What is the difference between point-to-point and pub/sub?
   - **A)** No difference
   - **B)** Point-to-point: one consumer; Pub/sub: multiple consumers receive same message
   - **C)** Point-to-point is faster
   - **D)** Pub/sub is simpler

3. What is Kafka's main advantage?
   - **A)** Simple API
   - **B)** High throughput, distributed, replayable event streaming
   - **C)** Low latency
   - **D)** Small footprint

**Answers:**
1. **B** - Message queues enable asynchronous communication, decoupling producers and consumers, allowing them to operate independently and handle traffic spikes
2. **B** - Point-to-point delivers messages to one consumer, while pub/sub broadcasts messages to all subscribers of a topic
3. **B** - Kafka provides high throughput, distributed event streaming with the ability to replay events, making it ideal for event-driven architectures

## Next Steps

- [Gossip Protocols](./06.%20Gossip%20Protocols.md) - Epidemic protocols
- [Distributed Tracing](./07.%20Distributed%20Tracing.md) - Observability

