---
number: 4
title: "Vector Clocks & Lamport Clocks"
slug: "vector-clocks-lamport-clocks"
level: "intermediate"
tags: ["distributed-systems", "vector-clocks", "lamport-clocks", "causality", "happens-before"]
prerequisites: ["eventual-consistency"]
estimated_minutes: 115
contributors: []
diagrams: []
examples: []
canonical_id: "cs-dist-04"
---

# Vector Clocks & Lamport Clocks

## Overview

Vector clocks and Lamport clocks are mechanisms for tracking causality and ordering events in distributed systems. Understanding how these clocks work, their differences, and when to use each is essential for building distributed systems that need to reason about event ordering and causality.

## Table of Contents

1. [The Causality Problem](#causality-problem)
2. [Happens-Before Relation](#happens-before)
3. [Lamport Clocks](#lamport-clocks)
4. [Vector Clocks](#vector-clocks)
5. [Clock Comparison](#comparison)
6. [Use Cases](#use-cases)
7. [Implementation](#implementation)

## The Causality Problem

### The Challenge

**Distributed Systems**: No global clock

**Problem**: How to order events across nodes?

**Example**:
```
Node A: Event E1 at time 10:00:01
Node B: Event E2 at time 10:00:00
Which happened first?
```

**Physical Time**: Unreliable, not synchronized

**Need**: Logical clocks to track causality

## Happens-Before Relation

### Definition

**Happens-Before (→)**: Partial ordering of events

**Rules**:
1. **Same process**: If event a occurs before b in same process, then a → b
2. **Message send**: If a sends message and b receives it, then a → b
3. **Transitivity**: If a → b and b → c, then a → c

### Happens-Before Example

**Scenario**: 3 processes, messages

```
Process 1: E1 → E2 → E3
Process 2:        E4 → E5
Process 3:             E6 → E7

Messages:
  E2 sends to Process 2 (received at E4)
  E5 sends to Process 3 (received at E6)

Happens-Before:
  E1 → E2 → E4 → E5 → E6 → E7
  E3 (concurrent with E4, E5, E6, E7)
```

### Concurrent Events

**Concurrent**: Events that are not causally related

**Definition**: a || b if neither a → b nor b → a

**Example**: E3 || E4 (no causal relationship)

## Lamport Clocks

### What are Lamport Clocks?

**Lamport Clock**: Logical clock for each process

**Property**: If a → b, then L(a) < L(b)

**Converse**: Not true (L(a) < L(b) doesn't imply a → b)

### Lamport Clock Algorithm

**Initialization**: L = 0

**On Local Event**:
```
L = L + 1
```

**On Send Message**:
```
L = L + 1
Send (message, L)
```

**On Receive Message**:
```
L = max(L, received_timestamp) + 1
```

### Lamport Clock Example

**Scenario**: 3 processes

```
Process 1:  E1(1) → E2(2) → E3(3)
Process 2:        E4(3) → E5(4)
Process 3:             E6(5) → E7(6)

Messages:
  E2(2) sends to Process 2
  E5(4) sends to Process 3

Timestamps:
  E1: 1
  E2: 2 (sends message with timestamp 2)
  E3: 3
  E4: max(0, 2) + 1 = 3 (receives message)
  E5: 4 (sends message with timestamp 4)
  E6: max(0, 4) + 1 = 5 (receives message)
  E7: 6
```

### Lamport Clock Properties

**1. Causality Preservation**:
```
If a → b, then L(a) < L(b)
```

**2. Not Sufficient**:
```
L(a) < L(b) does NOT imply a → b
```

**3. Total Ordering**:
```
Can create total order (break ties with process ID)
```

## Vector Clocks

### What are Vector Clocks?

**Vector Clock**: Array of Lamport clocks (one per process)

**Property**: If a → b, then VC(a) < VC(b)

**Converse**: True! VC(a) < VC(b) implies a → b

### Vector Clock Structure

**Vector**: [L₁, L₂, ..., Lₙ] for n processes

**Component**: Lᵢ is Lamport clock for process i

### Vector Clock Algorithm

**Initialization**: VC = [0, 0, ..., 0]

**On Local Event**:
```
VC[i] = VC[i] + 1
```

**On Send Message**:
```
VC[i] = VC[i] + 1
Send (message, VC)
```

**On Receive Message**:
```
VC[i] = VC[i] + 1
For all j: VC[j] = max(VC[j], received_VC[j])
```

### Vector Clock Example

**Scenario**: 3 processes

```
Process 1:  E1([1,0,0]) → E2([2,0,0]) → E3([3,0,0])
Process 2:        E4([2,1,0]) → E5([2,2,0])
Process 3:             E6([2,2,1]) → E7([2,2,2])

Messages:
  E2([2,0,0]) sends to Process 2
  E5([2,2,0]) sends to Process 3

Timestamps:
  E1: [1,0,0]
  E2: [2,0,0] (sends message)
  E3: [3,0,0]
  E4: [max(2,0), max(0,0)+1, max(0,0)] = [2,1,0]
  E5: [2,2,0] (sends message)
  E6: [max(2,0), max(2,0), max(0,0)+1] = [2,2,1]
  E7: [2,2,2]
```

### Vector Clock Comparison

**Less Than**:
```
VC₁ < VC₂ if:
  VC₁[i] ≤ VC₂[i] for all i
  VC₁[j] < VC₂[j] for some j
```

**Concurrent**:
```
VC₁ || VC₂ if:
  Neither VC₁ < VC₂ nor VC₂ < VC₁
```

**Example**:
```
[1,2,3] < [2,3,4] ✓
[1,2,3] < [1,2,4] ✓
[1,2,3] || [2,1,3] (concurrent)
```

## Clock Comparison

### Lamport vs Vector Clocks

| Aspect | Lamport | Vector |
|--------|---------|--------|
| **Size** | O(1) | O(n) |
| **Causality** | One-way | Two-way |
| **Concurrent Detection** | No | Yes |
| **Overhead** | Low | Higher |

### When to Use What

**Lamport Clocks**:
- **Total ordering**: Need total order
- **Low overhead**: Want minimal overhead
- **No concurrent detection**: Don't need to detect concurrency

**Vector Clocks**:
- **Causality tracking**: Need to track causality
- **Concurrent detection**: Need to detect concurrency
- **Event ordering**: Need precise event ordering

## Use Cases

### Use Case 1: Distributed Version Control

**Problem**: Track file versions across replicas

**Solution**: Vector clocks

**Example**: Git, Mercurial use similar concepts

### Use Case 2: Distributed Databases

**Problem**: Order updates across replicas

**Solution**: Vector clocks

**Example**: Riak, Dynamo use vector clocks

### Use Case 3: Event Ordering

**Problem**: Order events in distributed system

**Solution**: Lamport or Vector clocks

**Example**: Distributed logging, tracing

## Implementation

### Lamport Clock Implementation

```c
typedef struct {
    int clock;
    int process_id;
} LamportClock;

void local_event(LamportClock* lc) {
    lc->clock++;
}

void send_message(LamportClock* lc, Message* msg) {
    lc->clock++;
    msg->timestamp = lc->clock;
    send(msg);
}

void receive_message(LamportClock* lc, Message* msg) {
    lc->clock = max(lc->clock, msg->timestamp) + 1;
}
```

### Vector Clock Implementation

```c
typedef struct {
    int clocks[MAX_PROCESSES];
    int num_processes;
    int process_id;
} VectorClock;

void local_event(VectorClock* vc) {
    vc->clocks[vc->process_id]++;
}

void send_message(VectorClock* vc, Message* msg) {
    vc->clocks[vc->process_id]++;
    msg->vector_clock = copy_vector(vc->clocks, vc->num_processes);
    send(msg);
}

void receive_message(VectorClock* vc, Message* msg) {
    vc->clocks[vc->process_id]++;
    for (int i = 0; i < vc->num_processes; i++) {
        vc->clocks[i] = max(vc->clocks[i], msg->vector_clock[i]);
    }
}

bool happens_before(VectorClock* vc1, VectorClock* vc2) {
    bool less_or_equal = true;
    bool strictly_less = false;
    
    for (int i = 0; i < vc1->num_processes; i++) {
        if (vc1->clocks[i] > vc2->clocks[i]) {
            less_or_equal = false;
            break;
        }
        if (vc1->clocks[i] < vc2->clocks[i]) {
            strictly_less = true;
        }
    }
    
    return less_or_equal && strictly_less;
}
```

## Real-World Examples

### Example 1: Riak (Distributed Database)

**Use**: Vector clocks for conflict detection

**Process**:
```
1. Update creates new vector clock
2. Replicas merge vector clocks
3. Detect conflicts (concurrent updates)
4. Resolve conflicts
```

### Example 2: Distributed Tracing

**Use**: Vector clocks or Lamport clocks

**Purpose**: Order events across services

**Example**: OpenTracing, Jaeger

## Common Pitfalls

### Problem: Not Handling Clock Overflow

```c
// BAD: Clock may overflow
int clock = INT_MAX;
clock++; // Overflow!

// GOOD: Handle overflow or use larger type
long long clock = INT_MAX;
clock++; // Safe
```

### Problem: Not Updating All Components

```c
// BAD: Only update own component
vc->clocks[vc->process_id]++;

// GOOD: Update all components on receive
for (int i = 0; i < num_processes; i++) {
    vc->clocks[i] = max(vc->clocks[i], received_vc[i]);
}
```

## Quiz

1. What is the main difference between Lamport and Vector clocks?
   - **A)** No difference
   - **B)** Vector clocks can detect concurrency and provide two-way causality, Lamport clocks cannot
   - **C)** Lamport clocks are faster
   - **D)** Vector clocks are simpler

2. What does happens-before relation represent?
   - **A)** Physical time ordering
   - **B)** Causal ordering of events in distributed system
   - **C)** Message ordering
   - **D)** Process ordering

3. When should you use Vector clocks over Lamport clocks?
   - **A)** Always
   - **B)** When you need to detect concurrent events and track causality precisely
   - **C)** Never
   - **D)** Only for small systems

**Answers:**
1. **B** - Vector clocks can detect concurrent events and provide two-way causality (if VC(a) < VC(b), then a → b), while Lamport clocks only provide one-way (if a → b, then L(a) < L(b), but not vice versa)
2. **B** - The happens-before relation represents causal ordering: if event a happens before event b, then a causally affects b (either same process or message send/receive)
3. **B** - Use Vector clocks when you need to detect concurrent events and track causality precisely, despite higher overhead compared to Lamport clocks

## Next Steps

- [Message Queues & Event Streaming](../distributed_systems/05.%20Message%20Queues.md) - Asynchronous communication
- [Gossip Protocols](../distributed_systems/06.%20Gossip%20Protocols.md) - Epidemic protocols

