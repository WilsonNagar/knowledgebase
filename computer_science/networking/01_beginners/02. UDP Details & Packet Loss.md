---
number: 2
title: "UDP Details & Packet Loss"
slug: "udp-details-packet-loss"
level: "fundamentals"
tags: ["networking", "udp", "packet-loss", "protocols", "reliability"]
prerequisites: ["tcp-ip-internals-deep-dive"]
estimated_minutes: 85
contributors: []
diagrams: []
examples: []
canonical_id: "cs-net-02"
---

# UDP Details & Packet Loss

## Overview

UDP (User Datagram Protocol) is a connectionless, unreliable transport protocol that provides minimal overhead and low latency. Understanding UDP's characteristics, when to use it, how to handle packet loss, and how to build reliability on top of UDP is essential for network programming, especially for real-time applications, gaming, and streaming.

## Table of Contents

1. [UDP Overview](#udp-overview)
2. [UDP Header Structure](#udp-header)
3. [UDP Characteristics](#characteristics)
4. [Packet Loss & Causes](#packet-loss)
5. [UDP vs TCP](#udp-vs-tcp)
6. [When to Use UDP](#when-to-use)
7. [Building Reliability on UDP](#reliability)
8. [UDP Best Practices](#best-practices)

## UDP Overview

### What is UDP?

**UDP**: User Datagram Protocol

**Type**: Connectionless, unreliable transport protocol

**Layer**: Transport layer (Layer 4)

**Characteristics**:
- **No connection**: No handshake, no connection state
- **Unreliable**: No guarantees about delivery
- **Unordered**: Packets may arrive out of order
- **Lightweight**: Minimal overhead

### UDP Philosophy

**"Fire and Forget"**:
- Send packet
- Hope it arrives
- No acknowledgment
- No retransmission

**Benefits**:
- **Low latency**: No connection setup
- **Low overhead**: Small header
- **Simple**: No state to maintain
- **Fast**: No retransmission delays

## UDP Header Structure

### UDP Header Format

**UDP Header** (8 bytes):
```
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          Source Port          |       Destination Port        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|            Length             |           Checksum             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

**Fields**:
- **Source Port** (16 bits): Sender's port
- **Destination Port** (16 bits): Receiver's port
- **Length** (16 bits): UDP header + data length
- **Checksum** (16 bits): Error detection (optional)

### UDP Packet Structure

**Complete UDP Datagram**:
```
┌─────────────────┐
│   IP Header     │ (20 bytes)
├─────────────────┤
│   UDP Header    │ (8 bytes)
├─────────────────┤
│   UDP Data      │ (variable)
└─────────────────┘
```

**Total Overhead**: 28 bytes (IP + UDP headers)

**Maximum Data**: 65,507 bytes (65,535 - 20 - 8)

## UDP Characteristics

### Connectionless

**No Connection State**:
- No handshake
- No connection establishment
- No connection teardown
- Stateless

**Implications**:
- **Fast**: Send immediately
- **Simple**: No state management
- **Stateless**: Each packet independent

### Unreliable Delivery

**No Guarantees**:
- **Delivery**: Packets may be lost
- **Ordering**: Packets may arrive out of order
- **Duplication**: Packets may be duplicated
- **Corruption**: Packets may be corrupted (checksum detects)

### Unordered Delivery

**No Sequence Numbers**:
- Packets may arrive in any order
- Application must handle ordering
- Or accept unordered delivery

### Lightweight

**Minimal Overhead**:
- **Header**: Only 8 bytes
- **No state**: No connection state
- **No retransmission**: No retry logic
- **Fast**: Low processing overhead

## Packet Loss & Causes

### What is Packet Loss?

**Packet Loss**: Packet sent but not received

**Measurement**: Percentage of packets lost

**Example**: 1% packet loss = 1 in 100 packets lost

### Causes of Packet Loss

**1. Network Congestion**:
- **Router buffers full**: Packets dropped
- **High traffic**: Network overloaded
- **Solution**: Reduce sending rate

**2. Network Errors**:
- **Bit errors**: Corruption detected by checksum
- **Physical issues**: Cable problems, interference
- **Solution**: Retransmission (if needed)

**3. Router/Switch Issues**:
- **Buffer overflow**: Queues full
- **Processing overload**: Can't process fast enough
- **Solution**: Better network equipment

**4. Firewall/Security**:
- **Filtering**: Firewall drops packets
- **Rate limiting**: Too many packets
- **Solution**: Configure firewall rules

### Detecting Packet Loss

**Methods**:
1. **Sequence numbers**: Track expected packets
2. **Acknowledgments**: Receiver reports missing packets
3. **Timestamps**: Detect gaps in time
4. **Application-level**: Application detects missing data

**Example**:
```c
// Send with sequence number
struct packet {
    uint32_t seq;
    char data[1400];
};

send_packet(seq++, data);

// Receiver detects gaps
if (received_seq != expected_seq) {
    // Packet loss detected
    lost_packets++;
}
```

## UDP vs TCP

### Comparison Table

| Aspect | UDP | TCP |
|--------|-----|-----|
| **Connection** | Connectionless | Connection-oriented |
| **Reliability** | Unreliable | Reliable |
| **Ordering** | Unordered | Ordered |
| **Overhead** | Low (8 bytes) | High (20+ bytes) |
| **Latency** | Low | Higher |
| **Throughput** | High (no retransmission) | Lower (retransmission overhead) |
| **Flow Control** | No | Yes |
| **Congestion Control** | No | Yes |

### When UDP is Better

**1. Real-Time Applications**:
- **Gaming**: Low latency critical
- **VoIP**: Old packets useless
- **Video streaming**: Can tolerate some loss

**2. Broadcast/Multicast**:
- **DNS**: Simple queries
- **DHCP**: Broadcast discovery
- **Multicast**: One-to-many

**3. Simple Request-Response**:
- **DNS queries**: Single packet
- **NTP**: Time synchronization
- **SNMP**: Network management

### When TCP is Better

**1. Reliable Transfer**:
- **File transfer**: Must be complete
- **Web browsing**: Need all data
- **Email**: Cannot lose messages

**2. Ordered Delivery**:
- **Database replication**: Must be ordered
- **Log streaming**: Sequential data
- **State synchronization**: Order matters

## When to Use UDP

### Good Use Cases

**1. Real-Time Gaming**:
```
Requirements:
- Low latency (<50ms)
- Can tolerate some loss
- Old data useless

UDP Benefits:
- No retransmission delay
- Lower latency
- Simpler protocol
```

**2. Video/Audio Streaming**:
```
Requirements:
- High throughput
- Some loss acceptable
- Real-time playback

UDP Benefits:
- No retransmission overhead
- Higher throughput
- Lower latency
```

**3. DNS Queries**:
```
Requirements:
- Simple request-response
- Fast resolution
- Small packets

UDP Benefits:
- Low overhead
- Fast
- Simple
```

**4. IoT Sensors**:
```
Requirements:
- Many small packets
- Low power
- Simple protocol

UDP Benefits:
- Low overhead
- No connection state
- Efficient
```

### Bad Use Cases

**1. File Transfer**:
- Need reliable delivery
- Must be complete
- Use TCP instead

**2. Database Replication**:
- Need ordered delivery
- Cannot lose data
- Use TCP instead

**3. Web Browsing**:
- Need reliable delivery
- Need ordered data
- Use TCP instead

## Building Reliability on UDP

### Application-Level Reliability

**Techniques**:
1. **Sequence numbers**: Detect missing packets
2. **Acknowledgments**: Confirm receipt
3. **Retransmission**: Resend lost packets
4. **Checksums**: Detect corruption
5. **Ordering**: Reorder packets

### Reliable UDP Protocol Design

**Features**:
```
1. Sequence numbers: Track packet order
2. Acknowledgments: Confirm receipt
3. Selective retransmission: Resend only lost packets
4. Flow control: Prevent receiver overflow
5. Congestion control: Adapt to network
```

**Example Protocol**:
```c
struct reliable_packet {
    uint32_t seq;           // Sequence number
    uint32_t ack;           // Acknowledgment
    uint16_t flags;         // SYN, ACK, FIN, etc.
    uint16_t window;        // Receive window
    char data[1400];        // Payload
};
```

### QUIC Protocol

**QUIC**: Quick UDP Internet Connections

**Built on UDP**:
- Reliable delivery
- Ordered delivery
- Flow control
- Congestion control
- Encryption built-in

**Benefits**:
- **Faster**: No TCP handshake
- **Better**: Multiplexing, connection migration
- **Secure**: TLS 1.3 built-in

**Used by**: HTTP/3

## UDP Best Practices

### 1. Handle Packet Loss

```c
// BAD: Assume all packets arrive
send_udp(data);
receive_udp(); // May not receive

// GOOD: Handle loss
send_udp_with_seq(data, seq++);
if (!receive_ack_within_timeout()) {
    // Retransmit or handle loss
    handle_packet_loss();
}
```

### 2. Use Appropriate Buffer Sizes

```c
// BAD: Small buffer
char buffer[64];
recvfrom(sock, buffer, 64, ...); // May truncate

// GOOD: Appropriate size
char buffer[65507]; // Max UDP size
recvfrom(sock, buffer, sizeof(buffer), ...);
```

### 3. Handle Out-of-Order Packets

```c
// BAD: Assume ordered
process_packet(packet); // May be out of order

// GOOD: Reorder if needed
if (packet.seq == expected_seq) {
    process_packet(packet);
    expected_seq++;
} else if (packet.seq > expected_seq) {
    // Store for later
    buffer_packet(packet);
} else {
    // Duplicate or old packet
    discard_packet(packet);
}
```

### 4. Rate Limiting

```c
// BAD: Send as fast as possible
while (has_data()) {
    send_udp(data); // May overwhelm network
}

// GOOD: Rate limit
while (has_data()) {
    send_udp(data);
    usleep(1000); // Limit to ~1000 packets/sec
}
```

### 5. Error Handling

```c
// BAD: Ignore errors
sendto(sock, data, len, 0, addr, addrlen);

// GOOD: Check errors
ssize_t sent = sendto(sock, data, len, 0, addr, addrlen);
if (sent < 0) {
    if (errno == EAGAIN || errno == EWOULDBLOCK) {
        // Buffer full, handle
    } else {
        // Other error
        perror("sendto");
    }
}
```

## Real-World Examples

### Example 1: DNS Query

```c
// DNS uses UDP
struct dns_query {
    uint16_t id;
    uint16_t flags;
    uint16_t questions;
    // ... query data
};

// Send query
sendto(dns_socket, &query, sizeof(query), 0, 
       dns_server, sizeof(dns_server));

// Receive response (may need timeout/retry)
recvfrom(dns_socket, &response, sizeof(response), 0, 
         NULL, NULL);
```

### Example 2: Game Networking

```c
// Game uses UDP for low latency
struct game_packet {
    uint32_t seq;
    uint32_t ack;
    float player_x, player_y;
    uint8_t actions;
};

// Send player state
send_game_packet(player_state);

// Receive other players (handle loss)
while (has_packets()) {
    game_packet pkt = receive_game_packet();
    if (is_valid(pkt)) {
        update_player(pkt);
    }
    // Lost packets: use last known state
}
```

### Example 3: Video Streaming

```c
// Video streaming uses UDP
struct video_packet {
    uint32_t frame_num;
    uint32_t packet_num;
    uint32_t total_packets;
    char video_data[1400];
};

// Send video frame (split into packets)
for (int i = 0; i < num_packets; i++) {
    video_packet pkt = create_packet(frame, i);
    sendto(video_socket, &pkt, sizeof(pkt), 0, 
           client_addr, addrlen);
}

// Receiver handles loss (may skip frames)
```

## Common Pitfalls

### Problem: Assuming Reliability

```c
// BAD: Assume packet arrives
send_udp(critical_data);
// If lost, data gone forever

// GOOD: Add reliability
send_udp_with_ack(critical_data);
if (!received_ack()) {
    retransmit(critical_data);
}
```

### Problem: Ignoring Order

```c
// BAD: Assume ordered
process_packet(packet1); // May arrive after packet2
process_packet(packet2);

// GOOD: Handle ordering
if (packet.seq == expected_seq) {
    process_packet(packet);
    expected_seq++;
} else {
    buffer_for_later(packet);
}
```

### Problem: Buffer Overflow

```c
// BAD: Small buffer
char buf[100];
recvfrom(sock, buf, 100, ...); // May truncate

// GOOD: Appropriate size
char buf[65507]; // Max UDP size
ssize_t received = recvfrom(sock, buf, sizeof(buf), ...);
if (received > 0) {
    process_data(buf, received);
}
```

## Quiz

1. What is the main advantage of UDP over TCP?
   - **A)** Reliability
   - **B)** Lower latency and overhead
   - **C)** Ordered delivery
   - **D)** Flow control

2. What causes UDP packet loss?
   - **A)** Network congestion, errors, buffer overflow
   - **B)** Only network errors
   - **C)** Only congestion
   - **D)** UDP never loses packets

3. When should you use UDP?
   - **A)** Always
   - **B)** For real-time applications where low latency is critical
   - **C)** Never
   - **D)** Only for file transfer

**Answers:**
1. **B** - UDP has lower latency (no connection setup, no retransmission) and lower overhead (8-byte header vs 20+ bytes for TCP)
2. **A** - UDP packet loss can be caused by network congestion (full buffers), network errors (corruption), router/switch buffer overflow, and firewall filtering
3. **B** - UDP is best for real-time applications like gaming, VoIP, and streaming where low latency is more important than reliability

## Next Steps

- [HTTP/2, HTTP/3 & QUIC](../networking/03.%20HTTP2%20HTTP3%20%26%20QUIC.md) - Modern web protocols
- [DNS Resolution Path](../02_intermediate/04.%20DNS%20Resolution%20Path.md) - DNS internals

