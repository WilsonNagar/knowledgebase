---
number: 1
title: "TCP/IP Internals - Deep Dive"
slug: "tcp-ip-internals-deep-dive"
level: "fundamentals"
tags: ["networking", "tcp", "ip", "protocols", "internet"]
prerequisites: []
estimated_minutes: 120
contributors: []
diagrams: []
examples: []
canonical_id: "cs-net-01"
---

# TCP/IP Internals - Deep Dive

## Overview

TCP/IP is the foundation of modern networking. Understanding how TCP establishes connections, manages flow control, handles congestion, and ensures reliable data delivery is essential for network programming, system design, and performance optimization. This comprehensive guide covers TCP internals from packet structure to congestion control algorithms.

## Table of Contents

1. [TCP/IP Stack Overview](#tcp-ip-stack)
2. [IP Protocol Basics](#ip-protocol)
3. [TCP Protocol Deep Dive](#tcp-protocol)
4. [TCP Three-Way Handshake](#three-way-handshake)
5. [TCP Flow Control](#flow-control)
6. [TCP Congestion Control](#congestion-control)
7. [TCP Connection Termination](#connection-termination)
8. [TCP Performance Optimization](#performance)

## TCP/IP Stack Overview

### OSI Model vs TCP/IP

**OSI Model** (7 layers):
```
7. Application
6. Presentation
5. Session
4. Transport      ← TCP/UDP
3. Network        ← IP
2. Data Link
1. Physical
```

**TCP/IP Model** (4 layers):
```
4. Application   (HTTP, FTP, SMTP)
3. Transport     (TCP, UDP)
2. Internet      (IP, ICMP)
1. Link          (Ethernet, WiFi)
```

### Protocol Relationships

**Encapsulation**:
```
Application Data
    ↓
TCP Header + Data
    ↓
IP Header + TCP Segment
    ↓
Ethernet Header + IP Packet
    ↓
Physical Transmission
```

**Each Layer Adds Header**:
- **Application**: Application data
- **TCP**: Port numbers, sequence numbers, flags
- **IP**: Source/destination IP addresses
- **Ethernet**: MAC addresses

## IP Protocol Basics

### IP Header Structure

**IPv4 Header** (20 bytes minimum):
```
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|Version|  IHL  |Type of Service|          Total Length         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|         Identification        |Flags|      Fragment Offset    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  Time to Live |    Protocol   |         Header Checksum       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       Source Address                          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Destination Address                        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

**Key Fields**:
- **Version**: 4 (IPv4)
- **IHL**: Internet Header Length (header size in 32-bit words)
- **Total Length**: Packet size (header + data)
- **TTL**: Time To Live (prevents infinite loops)
- **Protocol**: 6 (TCP), 17 (UDP)
- **Source/Destination**: IP addresses

### IP Routing

**Routing Process**:
```
1. Check destination IP
2. Look up routing table
3. Find next hop
4. Forward packet
5. Decrement TTL
6. Repeat until destination
```

**Routing Table**:
```
Destination    Gateway        Interface
0.0.0.0/0      192.168.1.1    eth0      (default route)
192.168.1.0/24 0.0.0.0        eth0      (local network)
10.0.0.0/8     192.168.1.100  eth0      (VPN)
```

## TCP Protocol Deep Dive

### TCP Header Structure

**TCP Header** (20 bytes minimum):
```
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          Source Port          |       Destination Port        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        Sequence Number                        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Acknowledgment Number                      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  Data |           |U|A|P|R|S|F|                               |
| Offset| Reserved  |R|C|S|S|Y|I|            Window             |
|       |           |G|K|H|T|N|N|                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|           Checksum            |         Urgent Pointer        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

**Key Fields**:
- **Source/Destination Port**: Identifies application
- **Sequence Number**: Byte sequence for ordering
- **Acknowledgment Number**: Next expected sequence
- **Flags**: SYN, ACK, FIN, RST, PSH, URG
- **Window**: Receive window size (flow control)
- **Checksum**: Error detection

### TCP Characteristics

**1. Connection-Oriented**:
- Establishes connection before data transfer
- Three-way handshake
- Stateful protocol

**2. Reliable**:
- Acknowledgments for received data
- Retransmission of lost packets
- Sequence numbers for ordering

**3. Flow Control**:
- Receiver controls sender rate
- Prevents receiver overflow
- Window-based mechanism

**4. Congestion Control**:
- Adapts to network conditions
- Prevents network collapse
- Multiple algorithms (Reno, CUBIC)

**5. Full-Duplex**:
- Both sides can send simultaneously
- Independent sequence numbers
- Bidirectional communication

## TCP Three-Way Handshake

### Connection Establishment

**Purpose**: Synchronize sequence numbers, establish connection

**Steps**:
```
Client                          Server
  |                               |
  |-------- SYN (seq=x) -------->|
  |                               | (SYN_RCVD)
  |<------ SYN-ACK (seq=y, ack=x+1) --|
  |                               |
  |-------- ACK (ack=y+1) ------>|
  |                               | (ESTABLISHED)
(ESTABLISHED)                      |
```

### Detailed Explanation

**Step 1: SYN**:
```
Client sends:
  SYN flag = 1
  Sequence number = x (random)
  Acknowledgment = 0
```

**Step 2: SYN-ACK**:
```
Server sends:
  SYN flag = 1
  ACK flag = 1
  Sequence number = y (random)
  Acknowledgment = x + 1
```

**Step 3: ACK**:
```
Client sends:
  ACK flag = 1
  Sequence number = x + 1
  Acknowledgment = y + 1
```

### Why Three Steps?

**1. Prevents Old Duplicate Connections**:
- Random sequence numbers
- Old packets have wrong sequence
- Connection rejected

**2. Synchronizes Both Sides**:
- Client knows server's initial sequence
- Server knows client's initial sequence
- Both sides synchronized

**3. Establishes State**:
- Both sides allocate resources
- Connection state created
- Ready for data transfer

## TCP Flow Control

### The Problem

**Receiver Buffer Overflow**:
- Sender sends faster than receiver processes
- Receiver buffer fills up
- Packets dropped
- Retransmissions needed

**Solution**: Flow Control

### How Flow Control Works

**Receive Window**:
```
Receiver advertises available buffer space
Sender limits data to window size
Prevents receiver overflow
```

**Window Advertisement**:
```
TCP Header includes Window field
Receiver sets window = available buffer
Sender sends data ≤ window size
```

### Flow Control Example

**Scenario**:
```
Receiver buffer: 4096 bytes
Window advertised: 4096 bytes
Sender sends: 4096 bytes
Receiver processes: 2048 bytes
New window: 2048 bytes (4096 - 2048 + 0)
Sender sends: ≤ 2048 bytes
```

**Zero Window**:
```
Receiver buffer full
Window = 0
Sender stops sending
Receiver sends window update when space available
```

### Sliding Window

**Concept**: Window slides as data acknowledged

**Example**:
```
Initial: [0──────4096]
         ^window

After 1024 bytes ACKed:
         [1024──────5120]
              ^window (slides right)

After 2048 more bytes ACKed:
         [3072──────7168]
              ^window
```

## TCP Congestion Control

### The Problem

**Network Congestion**:
- Too much data in network
- Routers drop packets
- Performance degrades
- Network collapse possible

**Solution**: Congestion Control

### Congestion Window (cwnd)

**Concept**: Sender's estimate of network capacity

**Limits**: Sender sends min(cwnd, receiver_window)

**Increases**: When no congestion detected
**Decreases**: When congestion detected

### Congestion Control Phases

**1. Slow Start**:
```
cwnd starts at 1 MSS (Maximum Segment Size)
Doubles every RTT (Round Trip Time)
Exponential growth
Continues until threshold or loss
```

**2. Congestion Avoidance**:
```
After slow start threshold (ssthresh)
Linear growth: cwnd += MSS every RTT
More conservative
Continues until loss
```

**3. Fast Retransmit**:
```
After 3 duplicate ACKs
Retransmit immediately
Don't wait for timeout
Faster recovery
```

**4. Fast Recovery**:
```
After fast retransmit
Set ssthresh = cwnd / 2
Set cwnd = ssthresh + 3 MSS
Continue congestion avoidance
```

### TCP Reno Algorithm

**States**:
```
Slow Start → Congestion Avoidance → Fast Recovery
     ↑                                    ↓
     └────────────────────────────────────┘
```

**Behavior**:
- **Loss detected**: ssthresh = cwnd / 2, cwnd = 1, slow start
- **3 duplicate ACKs**: Fast retransmit, fast recovery
- **Timeout**: ssthresh = cwnd / 2, cwnd = 1, slow start

### TCP CUBIC Algorithm

**Modern Algorithm** (Linux default):
- **Cubic function**: cwnd = C(t-K)³ + W_max
- **Better for high BDP**: Bandwidth-Delay Product
- **Fair**: Multiple flows converge
- **Fast recovery**: Quick return to capacity

**Benefits**:
- Better performance on high-speed networks
- Fairer sharing between flows
- More stable

## TCP Connection Termination

### Four-Way Handshake

**Purpose**: Gracefully close connection

**Steps**:
```
Client                          Server
  |                               |
  |-------- FIN (seq=x) -------->|
  |                               | (CLOSE_WAIT)
  |<------ ACK (ack=x+1) --------|
  |                               |
  |<------ FIN (seq=y) ----------|
  |                               | (LAST_ACK)
  |-------- ACK (ack=y+1) ------>|
  |                               |
(TIME_WAIT)                    (CLOSED)
```

### Connection States

**Client States**:
```
ESTABLISHED → FIN_WAIT_1 → FIN_WAIT_2 → TIME_WAIT → CLOSED
```

**Server States**:
```
ESTABLISHED → CLOSE_WAIT → LAST_ACK → CLOSED
```

### TIME_WAIT State

**Purpose**: Handle delayed packets

**Duration**: 2 × MSL (Maximum Segment Lifetime)

**Why Needed**:
- Final ACK might be lost
- Server retransmits FIN
- Client must be able to ACK
- Prevents old packets from being accepted

**Problems**:
- Ports held for 2×MSL (typically 60 seconds)
- Can exhaust available ports
- High connection rate problematic

**Solutions**:
- **SO_REUSEADDR**: Reuse address immediately
- **Connection pooling**: Reuse connections
- **HTTP Keep-Alive**: Reuse TCP connections

## TCP Performance Optimization

### Nagle's Algorithm

**Problem**: Small packets inefficient

**Solution**: Nagle's Algorithm
- Buffer small writes
- Send when buffer full or ACK received
- Reduces packet overhead

**Disable When**: Low latency needed (telnet, games)

**Code**:
```c
int flag = 1;
setsockopt(sock, IPPROTO_TCP, TCP_NODELAY, &flag, sizeof(flag));
```

### Delayed ACK

**Problem**: ACK for every packet inefficient

**Solution**: Delayed ACK
- Wait up to 200ms for data to ACK
- ACK multiple segments together
- Reduces ACK overhead

**Trade-off**: Slightly higher latency

### Window Scaling

**Problem**: 16-bit window (max 65KB) too small for high BDP

**Solution**: Window Scaling (RFC 1323)
- Scale factor: 0-14 (multiply by 2^scale)
- Effective window: up to 1GB
- Enables high-speed transfers

**Negotiation**: During handshake (TCP options)

### Selective Acknowledgment (SACK)

**Problem**: Single ACK doesn't indicate gaps

**Solution**: SACK
- Acknowledge non-contiguous blocks
- Faster recovery from multiple losses
- More efficient retransmission

**Example**:
```
Received: 1, 2, 4, 5, 7
SACK: ACK 3, SACK [4-5], SACK [7-7]
Retransmit: 3, 6
```

## Real-World Considerations

### TCP vs UDP

**TCP**:
- Reliable, ordered delivery
- Connection-oriented
- Flow and congestion control
- Higher overhead
- Use for: HTTP, FTP, email

**UDP**:
- Unreliable, unordered delivery
- Connectionless
- No flow/congestion control
- Lower overhead
- Use for: DNS, video streaming, games

### Common Issues

**1. Connection Reset**:
- RST packet received
- Connection aborted
- Check firewall, application errors

**2. Connection Timeout**:
- SYN not ACKed
- Network unreachable
- Firewall blocking

**3. Slow Transfer**:
- Small window (flow control)
- Congestion (packet loss)
- High latency (RTT)
- Check network conditions

**4. Port Exhaustion**:
- Too many connections
- TIME_WAIT accumulation
- Use connection pooling

## Common Pitfalls

### Problem: Not Handling Backpressure

```c
// BAD: Ignore send() return value
send(sock, data, len, 0); // May not send all data

// GOOD: Handle partial sends
int sent = 0;
while (sent < len) {
    int n = send(sock, data + sent, len - sent, 0);
    if (n < 0) {
        // Handle error
        break;
    }
    sent += n;
}
```

### Problem: Small Buffer Sizes

```c
// BAD: Small receive buffer
int buf_size = 1024;
setsockopt(sock, SOL_SOCKET, SO_RCVBUF, &buf_size, sizeof(buf_size));

// GOOD: Larger buffer for high throughput
int buf_size = 256 * 1024; // 256KB
setsockopt(sock, SOL_SOCKET, SO_RCVBUF, &buf_size, sizeof(buf_size));
```

## Quiz

1. What is the purpose of the TCP three-way handshake?
   - **A)** Encrypt connection
   - **B)** Synchronize sequence numbers and establish connection
   - **C)** Negotiate window size
   - **D)** Set up routing

2. What does TCP flow control prevent?
   - **A)** Network congestion
   - **B)** Receiver buffer overflow
   - **C)** Packet loss
   - **D)** Connection timeout

3. What happens during TCP slow start?
   - **A)** cwnd decreases linearly
   - **B)** cwnd doubles every RTT
   - **C)** cwnd stays constant
   - **D)** cwnd increases by 1 every RTT

**Answers:**
1. **B** - The three-way handshake synchronizes sequence numbers on both sides and establishes the connection state
2. **B** - Flow control prevents the receiver's buffer from overflowing by limiting how much data the sender can send
3. **B** - During slow start, the congestion window (cwnd) doubles every round-trip time (RTT) until it reaches the slow start threshold

## Next Steps

- [UDP Details & Packet Loss](./02.%20UDP%20Details%20%26%20Packet%20Loss.md) - UDP internals
- [HTTP/2, HTTP/3 & QUIC](../networking/03.%20HTTP2%20HTTP3%20%26%20QUIC.md) - Modern protocols

