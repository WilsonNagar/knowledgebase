---
number: 3
title: "HTTP/2, HTTP/3 & QUIC"
slug: "http2-http3-quic"
level: "intermediate"
tags: ["networking", "http", "http2", "http3", "quic", "web-protocols"]
prerequisites: ["tcp-ip-internals-deep-dive"]
estimated_minutes: 100
contributors: []
diagrams: []
examples: []
canonical_id: "cs-net-03"
---

# HTTP/2, HTTP/3 & QUIC

## Overview

HTTP/2 and HTTP/3 represent major evolutions of the HTTP protocol, addressing performance limitations of HTTP/1.1. Understanding multiplexing, header compression, server push, and QUIC's improvements is essential for modern web development and performance optimization.

## Table of Contents

1. [HTTP/1.1 Limitations](#http1-limitations)
2. [HTTP/2 Overview](#http2-overview)
3. [HTTP/2 Features](#http2-features)
4. [HTTP/2 Multiplexing](#multiplexing)
5. [HTTP/2 Header Compression](#header-compression)
6. [HTTP/3 & QUIC Overview](#http3-overview)
7. [QUIC Protocol](#quic)
8. [Migration & Adoption](#migration)

## HTTP/1.1 Limitations

### Problems with HTTP/1.1

**1. Head-of-Line Blocking**:
```
Request 1: Large image (blocks)
Request 2: Small CSS (waits)
Request 3: Small JS (waits)
```

**Problem**: One slow request blocks others

**2. Multiple Connections**:
```
Browser opens 6 connections per domain
Each connection: TCP handshake overhead
Limited parallelism
```

**3. Redundant Headers**:
```
Every request sends full headers:
Host: example.com
User-Agent: Mozilla/5.0...
Accept: text/html...
Cookie: session=abc123...
```

**Problem**: Same headers sent repeatedly

**4. No Server Push**:
```
Client requests HTML
Server must wait for client to request CSS/JS
Cannot proactively send resources
```

## HTTP/2 Overview

### What is HTTP/2?

**HTTP/2**: Major revision of HTTP protocol

**Based on**: SPDY (Google protocol)

**Goal**: Improve web performance

**Key Changes**:
- **Binary protocol**: Instead of text
- **Multiplexing**: Multiple streams over one connection
- **Header compression**: HPACK
- **Server push**: Proactive resource sending

### HTTP/2 Architecture

**Layers**:
```
HTTP/2 (Application)
    ↓
TLS 1.2+ (Encryption)
    ↓
TCP (Transport)
    ↓
IP (Network)
```

**Key Concept**: Streams over single TCP connection

## HTTP/2 Features

### 1. Multiplexing

**Concept**: Multiple requests/responses over one connection

**HTTP/1.1**:
```
Connection 1: Request → Response
Connection 2: Request → Response
Connection 3: Request → Response
(6 connections max)
```

**HTTP/2**:
```
Single Connection:
  Stream 1: Request → Response
  Stream 2: Request → Response
  Stream 3: Request → Response
  Stream 4: Request → Response
  ... (unlimited streams)
```

**Benefits**:
- **No blocking**: Slow request doesn't block others
- **Efficient**: One TCP connection
- **Parallel**: True parallelism

### 2. Stream Prioritization

**Concept**: Assign priorities to streams

**Priorities**:
```
Stream 1: CSS (priority: HIGH)
Stream 2: JS (priority: HIGH)
Stream 3: Image (priority: LOW)
```

**Server**: Can prioritize sending high-priority streams

**Benefits**: Critical resources sent first

### 3. Header Compression (HPACK)

**HPACK**: Compression algorithm for HTTP headers

**How It Works**:
1. **Static table**: Common headers (built-in)
2. **Dynamic table**: Recently used headers
3. **Huffman encoding**: Compress header values

**Example**:
```
HTTP/1.1:
Host: example.com\r\n
User-Agent: Mozilla/5.0...\r\n
Accept: text/html\r\n
(200+ bytes)

HTTP/2 (HPACK):
:method: GET
:path: /
:authority: example.com
(50 bytes, compressed)
```

**Benefits**: 50-90% reduction in header size

### 4. Server Push

**Concept**: Server proactively sends resources

**Example**:
```
Client: GET /index.html
Server: 
  1. Sends index.html
  2. Pushes style.css (before client requests)
  3. Pushes app.js (before client requests)
```

**Benefits**: 
- **Faster**: Resources arrive before needed
- **Fewer round trips**: Reduced latency

**Caveat**: Can waste bandwidth if client already has resource

### 5. Binary Framing

**HTTP/1.1**: Text-based
```
GET /index.html HTTP/1.1\r\n
Host: example.com\r\n
\r\n
```

**HTTP/2**: Binary frames
```
┌─────────────────┐
│ Frame Header    │ (9 bytes)
├─────────────────┤
│ Frame Payload   │ (variable)
└─────────────────┘
```

**Frame Types**:
- **HEADERS**: Request/response headers
- **DATA**: Body data
- **PRIORITY**: Stream priority
- **RST_STREAM**: Cancel stream
- **SETTINGS**: Connection settings
- **PUSH_PROMISE**: Server push

## HTTP/2 Multiplexing

### How Multiplexing Works

**Streams**:
- **ID**: Unique stream identifier
- **Independent**: Streams don't block each other
- **Ordered**: Data within stream is ordered

**Example**:
```
Stream 1 (ID: 1): GET /image.jpg
  → HEADERS frame
  → DATA frames (chunked)

Stream 2 (ID: 3): GET /style.css
  → HEADERS frame
  → DATA frames

Stream 3 (ID: 5): GET /script.js
  → HEADERS frame
  → DATA frames

All interleaved over single TCP connection
```

### Flow Control

**Per-Stream Flow Control**:
- **Window**: Credit-based flow control
- **Independent**: Each stream has own window
- **Prevents**: One stream from consuming all bandwidth

**Connection Flow Control**:
- **Global**: Overall connection limit
- **Prevents**: Connection from overwhelming receiver

## HTTP/2 Header Compression

### HPACK Algorithm

**Components**:

**1. Static Table** (61 entries):
```
Index  Header Name        Header Value
1      :authority         
2      :method           GET
3      :method           POST
4      :path             /
...
```

**2. Dynamic Table**:
- **Recently used**: Headers added to table
- **Eviction**: Old entries removed (FIFO)
- **Size limit**: Configurable

**3. Encoding**:
- **Indexed**: Reference to table entry
- **Literal**: New header value
- **Huffman**: Compress string values

### HPACK Example

**Request**:
```
GET /index.html HTTP/2
Host: example.com
User-Agent: Mozilla/5.0
```

**Encoding**:
```
:method: GET          → Index 2 (static)
:path: /index.html    → Literal + Huffman
:authority: example.com → Index 1 (static) + Literal
user-agent: Mozilla/5.0 → Literal + Huffman
```

**Result**: ~70% size reduction

## HTTP/3 & QUIC Overview

### Why HTTP/3?

**HTTP/2 Still Has Issues**:
- **TCP head-of-line blocking**: One lost packet blocks all streams
- **TCP handshake**: 3-way handshake delay
- **TCP ossification**: Middleboxes interfere

**Solution**: HTTP/3 over QUIC

### HTTP/3 Architecture

**Layers**:
```
HTTP/3 (Application)
    ↓
QUIC (Transport)
    ↓
UDP (Network)
    ↓
IP
```

**Key Change**: QUIC replaces TCP

## QUIC Protocol

### What is QUIC?

**QUIC**: Quick UDP Internet Connections

**Developed by**: Google

**Based on**: UDP (not TCP)

**Features**:
- **Multiplexing**: Multiple streams
- **Encryption**: Built-in (TLS 1.3)
- **Connection migration**: Survives IP changes
- **0-RTT**: Zero round-trip connection establishment

### QUIC Advantages

**1. No Head-of-Line Blocking**:
```
TCP: Lost packet blocks all streams
QUIC: Lost packet only blocks one stream
```

**2. Faster Connection Establishment**:
```
TCP + TLS:
  1. TCP handshake (1 RTT)
  2. TLS handshake (2 RTTs)
  Total: 3 RTTs

QUIC:
  1. QUIC handshake (1 RTT, includes crypto)
  Total: 1 RTT (or 0 RTT for repeat connections)
```

**3. Connection Migration**:
```
Client changes IP (WiFi → Cellular)
TCP: Connection breaks, must reconnect
QUIC: Connection continues (connection ID)
```

**4. Built-in Encryption**:
```
TCP: Optional TLS
QUIC: Always encrypted (TLS 1.3 built-in)
```

### QUIC Streams

**Independent Streams**:
- **Stream ID**: Unique identifier
- **Independent**: Loss in one stream doesn't affect others
- **Ordered**: Within stream

**Example**:
```
Stream 1: Lost packet → Retransmit only stream 1
Stream 2: Continues normally
Stream 3: Continues normally
```

### QUIC Connection ID

**Purpose**: Identify connection across IP changes

**How It Works**:
```
Connection ID: 0x12345678
Client IP: 192.168.1.100
  ↓ (IP changes)
Client IP: 10.0.0.50
Connection ID: 0x12345678 (same!)
Server: Recognizes connection
```

**Benefits**: Seamless handover (WiFi ↔ Cellular)

## Migration & Adoption

### HTTP/2 Adoption

**Status**: Widely adopted

**Support**:
- **Browsers**: All major browsers
- **Servers**: Nginx, Apache, etc.
- **CDNs**: Cloudflare, AWS CloudFront

**Requirements**:
- **TLS**: HTTP/2 requires HTTPS
- **Server support**: Server must support HTTP/2

### HTTP/3 Adoption

**Status**: Growing adoption

**Support**:
- **Browsers**: Chrome, Firefox, Edge
- **Servers**: Nginx (experimental), Cloudflare
- **CDNs**: Cloudflare, Fastly

**Challenges**:
- **UDP**: Some networks block/throttle UDP
- **Middleboxes**: May interfere with QUIC
- **Deployment**: Requires server support

### Migration Strategy

**Step 1**: Enable HTTP/2
- **Easy**: Most servers support
- **Benefits**: Immediate performance improvement
- **Risk**: Low

**Step 2**: Optimize for HTTP/2
- **Remove**: Domain sharding (not needed)
- **Remove**: Image sprites (multiplexing handles)
- **Use**: Server push (carefully)

**Step 3**: Consider HTTP/3
- **Evaluate**: Network conditions
- **Test**: UDP connectivity
- **Monitor**: Performance improvements

## Real-World Examples

### Example 1: Web Page Load

**HTTP/1.1**:
```
1. GET /index.html (wait)
2. GET /style.css (wait)
3. GET /script.js (wait)
4. GET /image1.jpg (wait)
5. GET /image2.jpg (wait)
Total: 5 sequential requests
```

**HTTP/2**:
```
Single connection:
  Stream 1: GET /index.html
  Stream 2: GET /style.css (parallel)
  Stream 3: GET /script.js (parallel)
  Stream 4: GET /image1.jpg (parallel)
  Stream 5: GET /image2.jpg (parallel)
Total: All parallel, one connection
```

**Result**: 2-3x faster page load

### Example 2: API Calls

**HTTP/1.1**:
```
Request 1: GET /api/users (blocks)
Request 2: GET /api/posts (waits)
Request 3: GET /api/comments (waits)
```

**HTTP/2**:
```
Single connection:
  Stream 1: GET /api/users
  Stream 2: GET /api/posts (parallel)
  Stream 3: GET /api/comments (parallel)
```

**Result**: Faster API responses

## Common Pitfalls

### Problem: Overusing Server Push

```c
// BAD: Push everything
server.push("/style.css");
server.push("/script.js");
server.push("/image1.jpg");
server.push("/image2.jpg");
// Client may already have these!

// GOOD: Push selectively
if (!client_has_resource("/style.css")) {
    server.push("/style.css");
}
```

### Problem: Not Optimizing for HTTP/2

```c
// BAD: Still using HTTP/1.1 optimizations
// Domain sharding (not needed with HTTP/2)
// Image sprites (multiplexing handles parallelism)

// GOOD: Optimize for HTTP/2
// Single domain
// Individual resources
// Use server push strategically
```

## Quiz

1. What is the main advantage of HTTP/2 multiplexing?
   - **A)** Smaller headers
   - **B)** Multiple requests/responses over one connection without blocking
   - **C)** Faster encryption
   - **D)** Smaller packets

2. What problem does QUIC solve that HTTP/2 still has?
   - **A)** Header compression
   - **B)** TCP head-of-line blocking (one lost packet blocks all streams)
   - **C)** Encryption
   - **D)** Multiplexing

3. What is server push in HTTP/2?
   - **A)** Client pushes data to server
   - **B)** Server proactively sends resources before client requests them
   - **C)** Server forces client to download
   - **D)** Compression technique

**Answers:**
1. **B** - HTTP/2 multiplexing allows multiple requests and responses to be sent over a single TCP connection simultaneously without one blocking the others
2. **B** - QUIC solves TCP head-of-line blocking where a single lost TCP packet blocks all HTTP/2 streams, whereas QUIC streams are independent
3. **B** - Server push allows the server to proactively send resources (like CSS/JS) to the client before the client explicitly requests them, reducing latency

## Next Steps

- [TLS Handshake & PKI](../networking/04.%20TLS%20Handshake%20%26%20PKI.md) - TLS internals
- [DNS Resolution Path](../networking/05.%20DNS%20Resolution%20Path.md) - DNS internals

