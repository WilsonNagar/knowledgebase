---
number: 7
title: "Load Balancing & High Availability"
slug: "load-balancing-high-availability"
level: "intermediate"
tags: ["networking", "load-balancing", "high-availability", "scalability", "distributed"]
prerequisites: ["socket-programming-epoll-kqueue-select"]
estimated_minutes: 110
contributors: []
diagrams: []
examples: []
canonical_id: "cs-net-07"
---

# Load Balancing & High Availability

## Overview

Load balancing distributes traffic across multiple servers to improve performance and availability. Understanding load balancing algorithms, health checks, session persistence, and high availability patterns is essential for building scalable, reliable distributed systems.

## Table of Contents

1. [What is Load Balancing?](#what-is-load-balancing)
2. [Load Balancing Algorithms](#algorithms)
3. [Load Balancer Types](#types)
4. [Health Checks](#health-checks)
5. [Session Persistence](#session-persistence)
6. [High Availability](#high-availability)
7. [Load Balancer Placement](#placement)
8. [Real-World Examples](#examples)

## What is Load Balancing?

### Definition

**Load Balancing**: Distribute requests across multiple servers

**Purpose**:
- **Performance**: Distribute load
- **Availability**: Survive server failures
- **Scalability**: Handle more traffic

### Load Balancing Benefits

**1. Performance**:
- **Distribute load**: No single server overloaded
- **Parallel processing**: Multiple servers process requests

**2. Availability**:
- **Failover**: If server fails, others continue
- **Redundancy**: Multiple servers

**3. Scalability**:
- **Horizontal scaling**: Add more servers
- **Handle growth**: Scale to demand

## Load Balancing Algorithms

### Round Robin

**Algorithm**: Distribute requests sequentially

**Process**:
```
Request 1 → Server 1
Request 2 → Server 2
Request 3 → Server 3
Request 4 → Server 1 (cycle)
```

**Benefits**: Simple, fair distribution

**Limitation**: Doesn't consider server load

### Weighted Round Robin

**Algorithm**: Round robin with weights

**Process**:
```
Server 1: Weight 3 (handles 3 requests)
Server 2: Weight 1 (handles 1 request)
Server 3: Weight 2 (handles 2 requests)
Cycle repeats
```

**Benefits**: Account for server capacity

### Least Connections

**Algorithm**: Send to server with fewest active connections

**Process**:
```
Track active connections per server
Route new request to server with minimum connections
```

**Benefits**: Better load distribution

**Use**: Long-lived connections

### Least Response Time

**Algorithm**: Send to server with lowest response time

**Process**:
```
Measure response time per server
Route to server with lowest response time
```

**Benefits**: Optimal performance

**Challenge**: Requires monitoring

### IP Hash

**Algorithm**: Hash client IP to select server

**Process**:
```
hash(client_ip) % num_servers → server_index
Same client → Same server
```

**Benefits**: Session persistence

**Use**: Sticky sessions

## Load Balancer Types

### Layer 4 (Transport Layer)

**Operates**: On TCP/UDP level

**Decisions**: Based on IP and port

**Benefits**: Fast, low overhead

**Limitation**: Cannot inspect application data

**Examples**: LVS, HAProxy (TCP mode)

### Layer 7 (Application Layer)

**Operates**: On HTTP level

**Decisions**: Based on URL, headers, cookies

**Benefits**: More intelligent routing

**Limitation**: Higher overhead

**Examples**: Nginx, HAProxy (HTTP mode), AWS ALB

### Software vs Hardware

**Software Load Balancer**:
- **Examples**: Nginx, HAProxy, AWS ELB
- **Flexible**: Easy to configure
- **Cost**: Lower cost

**Hardware Load Balancer**:
- **Examples**: F5, Citrix
- **Performance**: Very high throughput
- **Cost**: Expensive

## Health Checks

### What are Health Checks?

**Health Check**: Verify server is healthy

**Purpose**: Remove unhealthy servers from rotation

**Types**:
- **Active**: Load balancer probes servers
- **Passive**: Monitor responses

### Health Check Types

**1. TCP Check**:
```
Connect to port
If connection succeeds: Healthy
```

**2. HTTP Check**:
```
GET /health
If 200 OK: Healthy
```

**3. Custom Check**:
```
Custom endpoint
Custom logic
```

### Health Check Configuration

**Interval**: How often to check (e.g., 10s)

**Timeout**: How long to wait (e.g., 5s)

**Threshold**: Failures before marking unhealthy (e.g., 3)

**Recovery**: Successes before marking healthy (e.g., 2)

## Session Persistence

### The Problem

**Stateless**: Requests can go to any server

**Stateful**: Some requests need same server

**Example**: Shopping cart stored on server

### Solutions

**1. Sticky Sessions**:
```
Route same client to same server
Use IP hash or cookie
```

**2. Session Replication**:
```
Replicate session to all servers
Any server can handle request
```

**3. External Session Store**:
```
Store session in Redis/database
All servers access same store
```

### Sticky Sessions

**IP Hash**: Same IP → Same server

**Cookie**: Set cookie with server ID

**Benefits**: Simple

**Problems**: 
- **Uneven distribution**: Some servers overloaded
- **Failover**: Session lost if server fails

## High Availability

### What is High Availability?

**High Availability**: System remains available despite failures

**Goal**: Minimize downtime

**Metrics**: 99.9%+ uptime

### HA Strategies

**1. Redundancy**:
```
Multiple servers
If one fails, others continue
```

**2. Failover**:
```
Automatic switching to backup
Minimal downtime
```

**3. Load Distribution**:
```
Spread load across servers
No single point of failure
```

### Active-Passive

**Architecture**:
```
Active: Handles traffic
Passive: Standby, takes over if active fails
```

**Failover**: Passive becomes active

**Use**: Critical systems

### Active-Active

**Architecture**:
```
All servers active
All handle traffic
```

**Failover**: Remaining servers handle load

**Use**: High throughput systems

## Load Balancer Placement

### Placement Options

**1. Edge** (Internet-facing):
```
Internet → Load Balancer → Servers
```

**2. Internal**:
```
Servers → Internal Load Balancer → Backend Services
```

**3. Multi-Tier**:
```
Internet → Edge LB → Web Servers → Internal LB → App Servers
```

## Real-World Examples

### Example 1: Web Application

**Architecture**:
```
Internet
  ↓
Load Balancer (Nginx/HAProxy)
  ↓
Web Servers (3+ instances)
  ↓
Application Servers
  ↓
Database
```

**Benefits**: Scalable, available

### Example 2: Microservices

**Architecture**:
```
API Gateway (Load Balancer)
  ↓
Service A (multiple instances)
Service B (multiple instances)
Service C (multiple instances)
```

**Benefits**: Independent scaling

## Common Pitfalls

### Problem: Single Load Balancer

```c
// BAD: Single load balancer
// Single point of failure!

// GOOD: Multiple load balancers
// Active-active or active-passive
```

### Problem: Ignoring Health Checks

```c
// BAD: No health checks
// Unhealthy servers still receive traffic

// GOOD: Configure health checks
// Remove unhealthy servers automatically
```

## Quiz

1. What is the main purpose of load balancing?
   - **A)** Encrypt traffic
   - **B)** Distribute requests across multiple servers for performance and availability
   - **C)** Compress data
   - **D)** Cache data

2. What is session persistence?
   - **A)** Keeping sessions forever
   - **B)** Routing same client to same server to maintain session state
   - **C)** Replicating sessions
   - **D)** Deleting sessions

3. What is high availability?
   - **A)** High performance
   - **B)** System remains available despite failures
   - **C)** High throughput
   - **D)** High latency

**Answers:**
1. **B** - Load balancing distributes incoming requests across multiple servers to improve performance, handle more traffic, and provide redundancy for high availability
2. **B** - Session persistence ensures the same client is routed to the same server to maintain session state (like shopping carts) across requests
3. **B** - High availability means the system remains operational and accessible despite component failures, typically achieved through redundancy and failover mechanisms

## Next Steps

- [Routing Protocols - BGP & OSPF](./08.%20Routing%20Protocols%20-%20BGP%20%26%20OSPF.md) - Network routing
- [CDN Architecture](./09.%20CDN%20Architecture.md) - Content delivery

