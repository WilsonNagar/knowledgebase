---
number: 5
title: "TLS Handshake & PKI"
slug: "tls-handshake-pki"
level: "intermediate"
tags: ["networking", "tls", "ssl", "pki", "certificates", "security"]
prerequisites: ["cryptography-fundamentals"]
estimated_minutes: 115
contributors: []
diagrams: []
examples: []
canonical_id: "cs-net-05"
---

# TLS Handshake & PKI

## Overview

TLS (Transport Layer Security) provides secure communication over networks. Understanding the TLS handshake, certificate validation, PKI (Public Key Infrastructure), and how TLS ensures confidentiality, integrity, and authentication is essential for secure network programming and web development.

## Table of Contents

1. [What is TLS?](#what-is-tls)
2. [TLS Handshake Overview](#handshake-overview)
3. [TLS 1.2 Handshake](#tls12-handshake)
4. [TLS 1.3 Handshake](#tls13-handshake)
5. [Public Key Infrastructure (PKI)](#pki)
6. [Certificate Validation](#certificate-validation)
7. [Certificate Authorities](#cas)
8. [TLS Performance](#performance)

## What is TLS?

### TLS Definition

**TLS**: Transport Layer Security

**Purpose**: Secure communication over network

**Provides**:
- **Confidentiality**: Encryption
- **Integrity**: Detect tampering
- **Authentication**: Verify identity

### TLS vs SSL

**SSL**: Secure Sockets Layer (deprecated)

**TLS**: Successor to SSL

**Versions**: TLS 1.0, 1.1, 1.2, 1.3

**Current**: TLS 1.2 and 1.3 (1.0 and 1.1 deprecated)

## TLS Handshake Overview

### Purpose

**Handshake**: Establish secure connection

**Goals**:
- **Agree on cipher suite**: Encryption algorithms
- **Exchange keys**: Establish shared secret
- **Authenticate**: Verify server (and optionally client)
- **Establish session**: Ready for encrypted data

### Handshake Steps (High-Level)

```
1. Client Hello: Client capabilities
2. Server Hello: Server choices
3. Certificate Exchange: Server certificate
4. Key Exchange: Establish shared secret
5. Finished: Verify handshake
6. Encrypted Data: Secure communication
```

## TLS 1.2 Handshake

### Detailed Steps

**Step 1: Client Hello**:
```
Client sends:
  - TLS version (1.2)
  - Random number (client random)
  - Cipher suites supported
  - Compression methods
  - Extensions (SNI, etc.)
```

**Step 2: Server Hello**:
```
Server responds:
  - TLS version (1.2)
  - Random number (server random)
  - Selected cipher suite
  - Selected compression method
  - Server certificate
```

**Step 3: Certificate Exchange**:
```
Server sends:
  - Certificate chain
  - Certificate signature algorithm
```

**Step 4: Server Key Exchange** (if needed):
```
Server sends:
  - Diffie-Hellman parameters (if DHE)
  - Or RSA public key (if RSA)
```

**Step 5: Server Hello Done**:
```
Server signals: Handshake parameters complete
```

**Step 6: Client Key Exchange**:
```
Client sends:
  - Pre-master secret (encrypted with server's public key)
  - Or Diffie-Hellman public key
```

**Step 7: Change Cipher Spec**:
```
Both sides: Switch to encrypted communication
```

**Step 8: Finished**:
```
Both sides: Verify handshake integrity
```

### Key Derivation

**Pre-Master Secret**:
```
Client generates random pre-master secret
Encrypts with server's public key
Sends to server
```

**Master Secret**:
```
master_secret = PRF(pre_master_secret, 
                    "master secret",
                    client_random + server_random)
```

**Session Keys**:
```
Derived from master secret:
  - Client write key
  - Server write key
  - Client MAC key
  - Server MAC key
  - Client IV
  - Server IV
```

## TLS 1.3 Handshake

### Improvements

**TLS 1.3**: Faster, more secure

**Changes**:
- **1-RTT**: One round trip (vs 2 in TLS 1.2)
- **0-RTT**: Zero round trip (resumed connections)
- **Removed**: Weak cipher suites
- **Required**: Forward secrecy

### TLS 1.3 Handshake Flow

**Step 1: Client Hello**:
```
Client sends:
  - Supported cipher suites
  - Key share (DH public key)
  - Client random
```

**Step 2: Server Hello**:
```
Server responds:
  - Selected cipher suite
  - Server key share (DH public key)
  - Server random
  - Certificate
  - Certificate Verify (signature)
  - Finished
```

**Step 3: Client Finished**:
```
Client sends:
  - Finished (verify handshake)
```

**Result**: Encrypted data can flow

### Key Differences

**TLS 1.2**: 2 round trips

**TLS 1.3**: 1 round trip (or 0 for resumed)

**Security**: TLS 1.3 removes weak algorithms

## Public Key Infrastructure (PKI)

### What is PKI?

**PKI**: System for managing digital certificates

**Components**:
- **Certificates**: Bind identity to public key
- **Certificate Authorities**: Issue certificates
- **Validation**: Verify certificate authenticity

### Digital Certificates

**Certificate**: Signed document binding identity to public key

**Contents**:
- **Subject**: Entity (domain name, organization)
- **Public Key**: Public key of subject
- **Issuer**: Certificate Authority
- **Validity**: Start and end dates
- **Signature**: CA's signature

**Format**: X.509 standard

### Certificate Structure

**X.509 Certificate**:
```
Certificate:
  Version: 3
  Serial Number: Unique ID
  Signature Algorithm: SHA256 with RSA
  Issuer: CN=Let's Encrypt
  Validity:
    Not Before: 2024-01-01
    Not After: 2024-04-01
  Subject: CN=example.com
  Public Key: RSA 2048-bit
  Extensions:
    Subject Alternative Name: *.example.com
  Signature: CA's signature
```

## Certificate Validation

### Validation Process

**Step 1: Certificate Chain**:
```
Certificate → Intermediate CA → Root CA
```

**Step 2: Verify Chain**:
```
1. Verify certificate signature with issuer's public key
2. Verify intermediate CA signature with root CA's public key
3. Verify root CA is trusted
```

**Step 3: Check Validity**:
```
1. Check expiration date
2. Check revocation status (CRL/OCSP)
3. Check hostname matches
```

**Step 4: Trust**:
```
Root CA must be in trust store
```

### Certificate Chain Example

**Chain**:
```
example.com certificate
  ↓ (signed by)
Let's Encrypt Intermediate CA
  ↓ (signed by)
Let's Encrypt Root CA
  ↓ (trusted)
Trust store
```

**Validation**:
```
1. Verify example.com signature with Intermediate CA public key ✓
2. Verify Intermediate CA signature with Root CA public key ✓
3. Root CA in trust store ✓
4. Certificate valid ✓
```

## Certificate Authorities

### What is a CA?

**CA**: Certificate Authority

**Role**: Issue and sign certificates

**Trust**: Root CAs are trusted

**Process**:
```
1. Entity requests certificate
2. CA verifies identity
3. CA issues certificate
4. CA signs certificate
```

### Types of CAs

**1. Public CAs**:
- **Examples**: Let's Encrypt, DigiCert, GlobalSign
- **Trust**: Widely trusted
- **Use**: Public websites

**2. Private CAs**:
- **Examples**: Internal corporate CAs
- **Trust**: Only within organization
- **Use**: Internal services

**3. Self-Signed**:
- **No CA**: Self-signed certificate
- **Trust**: Not trusted by default
- **Use**: Development, testing

### Certificate Revocation

**Revocation**: Invalidate certificate before expiration

**Reasons**:
- **Compromised**: Private key leaked
- **Misissued**: Certificate issued incorrectly
- **Changed**: Entity no longer authorized

**Methods**:

**1. CRL** (Certificate Revocation List):
```
CA publishes list of revoked certificates
Clients check CRL
```

**2. OCSP** (Online Certificate Status Protocol):
```
Real-time revocation checking
Query CA for certificate status
```

## TLS Performance

### Handshake Overhead

**TLS 1.2**: ~2 round trips (~100-200ms)

**TLS 1.3**: ~1 round trip (~50-100ms)

**0-RTT**: 0 round trips (resumed connections)

### Optimization Techniques

**1. Session Resumption**:
```
Reuse previous session
Skip full handshake
Faster connection establishment
```

**2. TLS False Start**:
```
Send data before handshake completes
Reduces latency
```

**3. Certificate Pinning**:
```
Pin expected certificate
Skip validation (faster, but less secure)
```

**4. OCSP Stapling**:
```
Server includes OCSP response
Client doesn't need to query CA
Faster validation
```

## Real-World Examples

### Example 1: HTTPS Connection

**Process**:
```
1. Browser: Connect to https://example.com
2. TLS handshake:
   a. Client Hello
   b. Server Hello + Certificate
   c. Key Exchange
   d. Finished
3. Encrypted HTTP: Secure communication
```

### Example 2: Certificate Validation

**Browser Validation**:
```
1. Receive certificate
2. Check certificate chain
3. Verify signatures
4. Check expiration
5. Check revocation (OCSP)
6. Verify hostname
7. If all pass: Show padlock
```

## Common Pitfalls

### Problem: Expired Certificates

```c
// BAD: Ignore expiration
// Certificate expired → Connection fails

// GOOD: Monitor expiration
check_certificate_expiration();
renew_before_expiration();
```

### Problem: Wrong Hostname

```c
// BAD: Certificate for example.com, accessing www.example.com
// Hostname mismatch → Connection fails

// GOOD: Use Subject Alternative Names
// Certificate includes: example.com, www.example.com
```

### Problem: Self-Signed Certificates

```c
// BAD: Self-signed in production
// Browsers show warning → Users may ignore

// GOOD: Use trusted CA
// Get certificate from Let's Encrypt or commercial CA
```

## Quiz

1. What is the main purpose of TLS handshake?
   - **A)** Encrypt data
   - **B)** Establish secure connection by agreeing on encryption and exchanging keys
   - **C)** Route packets
   - **D)** Compress data

2. What is PKI?
   - **A)** Private key infrastructure
   - **B)** Public Key Infrastructure - system for managing digital certificates
   - **C)** Public key integration
   - **D)** Performance key indicator

3. What is the main improvement in TLS 1.3?
   - **A)** More cipher suites
   - **B)** Faster handshake (1-RTT vs 2-RTT) and better security
   - **C)** Larger keys
   - **D)** More certificates

**Answers:**
1. **B** - The TLS handshake establishes a secure connection by negotiating encryption algorithms (cipher suite), exchanging keys to establish a shared secret, and authenticating the server
2. **B** - PKI (Public Key Infrastructure) is a system for managing digital certificates, including Certificate Authorities that issue and sign certificates
3. **B** - TLS 1.3 reduces handshake to 1 round trip (vs 2 in TLS 1.2), removes weak cipher suites, and requires forward secrecy for better security

## Next Steps

- [Socket Programming](./06.%20Socket%20Programming%20-%20epoll%2C%20kqueue%2C%20select.md) - Network programming
- [Load Balancing & High Availability](../../../backend/03_advanced/02.%20Load%20Balancing%20Strategies.md) - Scalability

