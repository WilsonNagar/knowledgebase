---
number: 1
title: "Containers, Namespaces & cgroups"
slug: "containers-namespaces-cgroups"
level: "intermediate"
tags: ["cloud", "containers", "docker", "namespaces", "cgroups", "linux"]
prerequisites: []
estimated_minutes: 110
contributors: []
diagrams: []
examples: []
canonical_id: "cs-cloud-01"
---

# Containers, Namespaces & cgroups

## Overview

Containers have revolutionized application deployment by providing lightweight isolation. Understanding Linux namespaces, cgroups, and how they enable containerization is essential for modern DevOps, cloud computing, and system administration. This guide covers the fundamental Linux kernel features that make containers possible.

## Table of Contents

1. [What are Containers?](#containers)
2. [Linux Namespaces](#namespaces)
3. [Namespace Types](#namespace-types)
4. [Control Groups (cgroups)](#cgroups)
5. [Container Runtime](#container-runtime)
6. [Docker Internals](#docker)
7. [Container vs Virtual Machine](#container-vm)
8. [Security Considerations](#security)

## What are Containers?

### Container Definition

**Container**: Isolated environment for running applications

**Characteristics**:
- **Lightweight**: Share host OS kernel
- **Isolated**: Process isolation, resource limits
- **Portable**: Run anywhere
- **Fast**: Quick startup (seconds vs minutes)

### Container Benefits

**1. Isolation**:
- **Process isolation**: Cannot see other containers
- **File system isolation**: Own root filesystem
- **Network isolation**: Own network namespace

**2. Resource Limits**:
- **CPU**: Limit CPU usage
- **Memory**: Limit memory usage
- **I/O**: Limit disk/network I/O

**3. Portability**:
- **Consistent**: Same environment everywhere
- **Dependencies**: Bundled with application
- **Deployment**: Easy to deploy

## Linux Namespaces

### What are Namespaces?

**Namespace**: Kernel feature providing isolation

**Purpose**: Isolate resources from other processes

**Types**: 7 namespace types in Linux

### Namespace Concept

**Without Namespaces**:
```
All processes see:
  - Same process tree (PID 1, 2, 3, ...)
  - Same network interfaces
  - Same file system
  - Same hostname
```

**With Namespaces**:
```
Container 1 sees:
  - Own process tree (PID 1, 2, 3, ...)
  - Own network interfaces
  - Own file system
  - Own hostname

Container 2 sees:
  - Different process tree (PID 1, 2, 3, ...)
  - Different network interfaces
  - Different file system
  - Different hostname
```

## Namespace Types

### 1. PID Namespace

**Purpose**: Isolate process IDs

**Effect**: Processes see different PID space

**Example**:
```
Host:        Container:
PID 1 (init)  PID 1 (container init)
PID 2         PID 2
PID 100       PID 3
PID 101       PID 4
```

**Implementation**:
```c
// Create new PID namespace
unshare(CLONE_NEWPID);

// Process in namespace sees:
// - Own PID as 1
// - Cannot see host processes
```

### 2. Network Namespace

**Purpose**: Isolate network stack

**Effect**: Own network interfaces, routing tables

**Example**:
```
Host:           Container:
eth0            eth0 (different)
lo              lo
routing table   routing table (different)
```

**Implementation**:
```c
// Create new network namespace
unshare(CLONE_NEWNET);

// Container has:
// - Own network interfaces
// - Own IP addresses
// - Own routing tables
// - Isolated from host network
```

### 3. Mount Namespace

**Purpose**: Isolate file system mounts

**Effect**: Own mount points, root filesystem

**Example**:
```
Host:              Container:
/ (root)           / (container root)
/home               /home (different)
/proc               /proc (different)
```

**Implementation**:
```c
// Create new mount namespace
unshare(CLONE_NEWNS);

// Container has:
// - Own root filesystem
// - Own /proc, /sys
// - Cannot see host mounts
```

### 4. UTS Namespace

**Purpose**: Isolate hostname and domain name

**Effect**: Own hostname

**Example**:
```
Host:              Container:
hostname: server   hostname: container-1
```

**Implementation**:
```c
// Create new UTS namespace
unshare(CLONE_NEWUTS);

// Set hostname
sethostname("container-1", 11);
```

### 5. IPC Namespace

**Purpose**: Isolate inter-process communication

**Effect**: Own shared memory, message queues

**Example**:
```
Host:              Container:
Shared memory A    Shared memory A (different)
Message queue B   Message queue B (different)
```

**Implementation**:
```c
// Create new IPC namespace
unshare(CLONE_NEWIPC);

// Container has:
// - Own shared memory segments
// - Own message queues
// - Own semaphores
```

### 6. User Namespace

**Purpose**: Isolate user IDs

**Effect**: Map host UIDs to container UIDs

**Example**:
```
Host:              Container:
UID 0 (root)       UID 0 (root, but limited)
UID 1000           UID 0 (mapped)
```

**Implementation**:
```c
// Create new user namespace
unshare(CLONE_NEWUSER);

// Container root (UID 0) mapped to host UID 1000
// Container root has limited privileges
```

### 7. Cgroup Namespace

**Purpose**: Isolate cgroup hierarchy

**Effect**: Own cgroup view

**Implementation**:
```c
// Create new cgroup namespace
unshare(CLONE_NEWCGROUP);

// Container sees own cgroup hierarchy
```

## Control Groups (cgroups)

### What are cgroups?

**cgroups**: Control groups for resource limiting

**Purpose**: Limit and account for resource usage

**Resources Controlled**:
- **CPU**: CPU time, CPU sets
- **Memory**: Memory usage, swap
- **I/O**: Disk I/O, network I/O
- **Devices**: Device access

### cgroup Hierarchy

**Structure**: Tree hierarchy

**Example**:
```
/ (root cgroup)
├── system.slice
│   ├── docker.service
│   └── ssh.service
└── user.slice
    └── container-1
        ├── cpu
        ├── memory
        └── blkio
```

### CPU Control

**CPU Limits**:
```
/sys/fs/cgroup/cpu/container-1/
  cpu.cfs_quota_us: 50000  (50% CPU)
  cpu.cfs_period_us: 100000
```

**CPU Sets**:
```
/sys/fs/cgroup/cpuset/container-1/
  cpuset.cpus: 0-1  (Use CPUs 0 and 1)
```

### Memory Control

**Memory Limits**:
```
/sys/fs/cgroup/memory/container-1/
  memory.limit_in_bytes: 1073741824  (1GB)
  memory.usage_in_bytes: 524288000   (current usage)
```

**OOM Killer**:
```
If memory exceeds limit:
  - OOM killer terminates processes in cgroup
  - Host system unaffected
```

### I/O Control

**Block I/O Limits**:
```
/sys/fs/cgroup/blkio/container-1/
  blkio.throttle.read_bps_device: 8:0 10485760  (10MB/s read)
  blkio.throttle.write_bps_device: 8:0 10485760 (10MB/s write)
```

## Container Runtime

### Container Creation Process

**Steps**:
```
1. Create namespaces (PID, network, mount, etc.)
2. Create cgroups
3. Set resource limits
4. Mount root filesystem
5. Set up network
6. Start process in container
```

### Low-Level Tools

**1. unshare**:
```bash
# Create PID namespace
unshare --pid --fork bash

# Process sees own PID namespace
```

**2. nsenter**:
```bash
# Enter existing namespace
nsenter --target <pid> --mount --pid bash

# Enter container's namespaces
```

**3. cgroup-tools**:
```bash
# Create cgroup
cgcreate -g cpu,memory:/container-1

# Set limits
echo 50000 > /sys/fs/cgroup/cpu/container-1/cpu.cfs_quota_us
echo 1073741824 > /sys/fs/cgroup/memory/container-1/memory.limit_in_bytes

# Add process
echo $$ > /sys/fs/cgroup/cpu/container-1/cgroup.procs
```

## Docker Internals

### Docker Architecture

**Components**:
```
Docker Client
    ↓
Docker Daemon
    ↓
containerd
    ↓
runc (OCI runtime)
    ↓
Linux Kernel (namespaces, cgroups)
```

### Docker Container Creation

**Process**:
```
1. Docker client: docker run
2. Docker daemon: Receives request
3. Pull image (if needed)
4. Create container:
   a. Create namespaces
   b. Create cgroups
   c. Mount root filesystem
   d. Set up network
5. Start process
```

### Docker Namespaces

**Docker Uses**:
- **PID**: Process isolation
- **Network**: Network isolation
- **Mount**: File system isolation
- **UTS**: Hostname isolation
- **IPC**: IPC isolation
- **User**: User ID mapping (optional)

### Docker cgroups

**Docker Creates**:
```
/sys/fs/cgroup/cpu/docker/<container-id>/
/sys/fs/cgroup/memory/docker/<container-id>/
/sys/fs/cgroup/blkio/docker/<container-id>/
```

**Limits Set**:
- **CPU**: --cpus flag
- **Memory**: --memory flag
- **I/O**: --device-read-bps, --device-write-bps

## Container vs Virtual Machine

### Architecture Comparison

**Virtual Machine**:
```
Application
    ↓
Guest OS (Linux/Windows)
    ↓
Hypervisor (KVM, VMware)
    ↓
Host OS
    ↓
Hardware
```

**Container**:
```
Application
    ↓
Container Runtime
    ↓
Host OS (Linux)
    ↓
Hardware
```

### Key Differences

| Aspect | VM | Container |
|--------|----|-----------|
| **Isolation** | Strong (separate OS) | Process-level |
| **Overhead** | High (full OS) | Low (shared kernel) |
| **Startup** | Minutes | Seconds |
| **Resource** | More | Less |
| **Security** | Strong isolation | Namespace isolation |

### When to Use What

**Virtual Machines**:
- **Different OS**: Need different kernel
- **Strong isolation**: Security critical
- **Legacy apps**: Cannot containerize

**Containers**:
- **Same OS**: Linux applications
- **Microservices**: Many small services
- **CI/CD**: Fast deployment
- **Cloud-native**: Designed for containers

## Security Considerations

### Container Security

**1. Namespace Isolation**:
- **Not perfect**: Kernel vulnerabilities affect all
- **Escape**: Possible to escape namespaces
- **Mitigation**: Keep kernel updated

**2. Root in Container**:
- **Mapped**: Container root ≠ host root
- **User namespace**: Maps to non-root on host
- **Still risky**: Some capabilities retained

**3. Resource Limits**:
- **cgroups**: Prevent resource exhaustion
- **Important**: Set appropriate limits
- **DDoS**: Limits prevent attacks

### Best Practices

**1. Run as Non-Root**:
```dockerfile
# BAD
USER root

# GOOD
USER appuser
```

**2. Limit Capabilities**:
```bash
# Drop all capabilities, add only needed
docker run --cap-drop=ALL --cap-add=NET_BIND_SERVICE
```

**3. Read-Only Root**:
```bash
# Mount root as read-only
docker run --read-only
```

**4. Resource Limits**:
```bash
# Set limits
docker run --memory=512m --cpus=1.0
```

## Real-World Examples

### Example 1: Simple Container

```bash
# Create namespace and run command
unshare --pid --mount --net --uts --ipc --fork bash

# Inside namespace:
hostname container-1
ip addr add 10.0.0.1/24 dev eth0
mount -t proc proc /proc
# Process sees isolated environment
```

### Example 2: Docker Container

```bash
# Run container with limits
docker run -d \
  --name myapp \
  --memory=512m \
  --cpus=1.0 \
  --network=isolated \
  myapp:latest

# Container has:
# - Isolated namespaces
# - Resource limits
# - Isolated network
```

### Example 3: Kubernetes Pod

```yaml
apiVersion: v1
kind: Pod
spec:
  containers:
  - name: app
    image: myapp:latest
    resources:
      limits:
        memory: "512Mi"
        cpu: "1"
      requests:
        memory: "256Mi"
        cpu: "0.5"
```

## Common Pitfalls

### Problem: Privilege Escalation

```bash
# BAD: Run as root with all capabilities
docker run --privileged myapp

# GOOD: Drop privileges
docker run --user=1000:1000 --cap-drop=ALL myapp
```

### Problem: No Resource Limits

```bash
# BAD: No limits
docker run myapp
# Can consume all resources

# GOOD: Set limits
docker run --memory=512m --cpus=1.0 myapp
```

### Problem: Host Network

```bash
# BAD: Use host network
docker run --network=host myapp
# Bypasses network isolation

# GOOD: Use bridge network
docker run --network=bridge myapp
```

## Quiz

1. What is the main purpose of Linux namespaces?
   - **A)** Resource limiting
   - **B)** Process and resource isolation
   - **C)** Performance optimization
   - **D)** Memory management

2. What is the main difference between containers and VMs?
   - **A)** Containers are faster
   - **B)** Containers share the host OS kernel, VMs have separate OS
   - **C)** Containers are more secure
   - **D)** No difference

3. What do cgroups control?
   - **A)** Only CPU
   - **B)** CPU, memory, I/O, and other resources
   - **C)** Only memory
   - **D)** Only network

**Answers:**
1. **B** - Linux namespaces provide isolation for processes and resources (PID, network, mount, etc.), allowing containers to have isolated views of the system
2. **B** - Containers share the host OS kernel and use namespaces/cgroups for isolation, while VMs run separate guest operating systems on a hypervisor
3. **B** - cgroups can control CPU, memory, block I/O, network I/O, device access, and other system resources

## Next Steps

- [Docker Internals - Layers & Union FS](../cloud_infrastructure/02.%20Docker%20Internals%20-%20Layers%20%26%20Union%20FS.md) - Docker storage
- [Kubernetes Internals](./02.%20Kubernetes%20Internals.md) - Container orchestration

