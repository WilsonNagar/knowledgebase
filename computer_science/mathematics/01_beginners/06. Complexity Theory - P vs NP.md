---
number: 6
title: "Complexity Theory - P vs NP"
slug: "complexity-theory-p-vs-np"
level: "fundamentals"
tags: ["mathematics", "complexity-theory", "p-vs-np", "algorithms", "computability"]
prerequisites: ["number-theory-fundamentals"]
estimated_minutes: 125
contributors: []
diagrams: []
examples: []
canonical_id: "cs-math-06"
---

# Complexity Theory - P vs NP

## Overview

Complexity theory studies the computational resources required to solve problems. Understanding P vs NP, complexity classes, polynomial time, and the implications of P=NP is fundamental to computer science and understanding the limits of computation.

## Table of Contents

1. [Computational Complexity](#computational-complexity)
2. [Time Complexity Classes](#time-complexity)
3. [P Class](#p-class)
4. [NP Class](#np-class)
5. [NP-Completeness](#np-completeness)
6. [P vs NP Problem](#p-vs-np)
7. [Reductions](#reductions)
8. [Implications](#implications)

## Computational Complexity

### What is Complexity?

**Complexity**: Resources needed to solve problem

**Resources**: 
- **Time**: How long
- **Space**: How much memory

**Goal**: Classify problems by difficulty

### Complexity Analysis

**Worst Case**: Maximum resources needed

**Average Case**: Average resources needed

**Best Case**: Minimum resources needed

**Focus**: Usually worst case

## Time Complexity Classes

### Common Classes

**1. O(1)**: Constant time

**2. O(log n)**: Logarithmic time

**3. O(n)**: Linear time

**4. O(n log n)**: Linearithmic time

**5. O(n²)**: Quadratic time

**6. O(2ⁿ)**: Exponential time

### Polynomial vs Exponential

**Polynomial**: O(nᵏ) for some k

**Exponential**: O(2ⁿ), O(n!)

**Difference**: Exponential grows much faster

## P Class

### Definition

**P**: Problems solvable in polynomial time

**Time**: O(nᵏ) for some k

**Deterministic**: Deterministic Turing machine

**Examples**: 
- **Sorting**: O(n log n)
- **Shortest Path**: O(V + E)
- **Matrix Multiplication**: O(n³)

### P Properties

**1. Efficient**:
```
Polynomial time considered efficient
```

**2. Tractable**:
```
Problems we can solve in practice
```

**3. Closed Under Composition**:
```
Composing P algorithms = P algorithm
```

## NP Class

### Definition

**NP**: Problems verifiable in polynomial time

**Verification**: Given solution, can verify quickly

**Non-deterministic**: Non-deterministic Turing machine

**Examples**:
- **SAT**: Boolean satisfiability
- **Graph Coloring**: Can color with k colors?
- **Subset Sum**: Can sum to target?

### NP vs P

**P ⊆ NP**: 
```
If can solve, can verify
```

**Open Question**: Is P = NP?

**Belief**: P ≠ NP (most likely)

### NP-Complete

**NP-Complete**: Hardest problems in NP

**Properties**:
- **In NP**: Verifiable in polynomial time
- **NP-Hard**: All NP problems reduce to it

**If Solve One**: Can solve all NP problems

**Examples**: SAT, Traveling Salesman, Knapsack

## NP-Completeness

### What is NP-Complete?

**NP-Complete**: 
- **In NP**: Verifiable in polynomial time
- **NP-Hard**: All NP problems reduce to it

**Significance**: If P ≠ NP, cannot solve efficiently

### Proving NP-Completeness

**Method**:
```
1. Show problem in NP
2. Reduce known NP-complete problem to it
```

**First NP-Complete**: SAT (Cook-Levin theorem)

**Others**: Reduce from SAT

## P vs NP Problem

### The Question

**P = NP?**: Can we solve NP problems efficiently?

**If P = NP**: 
- **Cryptography**: Broken (most)
- **Optimization**: Easy
- **Revolutionary**: Major impact

**If P ≠ NP**: 
- **Current State**: Continues
- **Hard Problems**: Remain hard
- **Cryptography**: Safe (mostly)

### Current Status

**Status**: Unsolved

**Millennium Problem**: One of seven

**Prize**: $1 million

**Belief**: P ≠ NP (most researchers)

## Reductions

### What are Reductions?

**Reduction**: Transform one problem to another

**Purpose**: Show problems equivalent

**Types**: 
- **Polynomial**: Reduction in polynomial time
- **Log-space**: Reduction in logarithmic space

### Reduction Example

**Problem A**: SAT

**Problem B**: 3-SAT

**Reduction**: 
```
Transform SAT instance to 3-SAT instance
If can solve 3-SAT, can solve SAT
```

**Result**: 3-SAT is NP-complete

## Implications

### If P = NP

**1. Cryptography**:
```
Most cryptography broken
Need new methods
```

**2. Optimization**:
```
Can solve optimization efficiently
```

**3. AI**:
```
Can solve many AI problems
```

**4. Science**:
```
Revolutionary impact
```

### If P ≠ NP

**1. Cryptography**:
```
Current methods secure
```

**2. Hard Problems**:
```
Some problems inherently hard
```

**3. Heuristics**:
```
Need approximation algorithms
```

## Real-World Examples

### Example 1: Traveling Salesman

**Problem**: Find shortest route visiting all cities

**Complexity**: NP-complete

**Practical**: Use heuristics, approximation

### Example 2: Integer Factorization

**Problem**: Factor large integer

**Complexity**: Believed not in P

**Use**: RSA cryptography relies on hardness

## Common Pitfalls

### Problem: Confusing P and NP

```c
// BAD: Think NP means "not polynomial"
// NP means "non-deterministic polynomial"

// GOOD: Understand definitions
// P = solvable in polynomial time
// NP = verifiable in polynomial time
```

### Problem: Thinking NP-Complete = Impossible

```c
// BAD: Think NP-complete = cannot solve
// Can solve, just not efficiently for large inputs

// GOOD: Understand trade-offs
// Can solve for small inputs
// Use heuristics for large inputs
```

## Quiz

1. What is P?
   - **A)** Problems verifiable in polynomial time
   - **B)** Problems solvable in polynomial time
   - **C)** Problems solvable in exponential time
   - **D)** Impossible problems

2. What is NP?
   - **A)** Problems solvable in polynomial time
   - **B)** Problems verifiable in polynomial time
   - **C)** Problems solvable in exponential time
   - **D)** Not polynomial

3. What is the P vs NP problem?
   - **A)** Whether P equals NP (can we solve NP problems efficiently?)
   - **B)** Whether NP equals exponential
   - **C)** Whether P equals exponential
   - **D)** Whether NP equals P-complete

**Answers:**
1. **B** - P is the class of problems that can be solved in polynomial time (O(nᵏ) for some k) on a deterministic Turing machine
2. **B** - NP is the class of problems where solutions can be verified in polynomial time, though finding the solution may require exponential time
3. **A** - The P vs NP problem asks whether every problem that can be verified in polynomial time can also be solved in polynomial time, one of the most important unsolved problems in computer science

## Next Steps

- [Logic & Automata Theory](../mathematics/07.%20Logic%20%26%20Automata.md) - Formal logic
- [Advanced Algorithms](../mathematics/08.%20Advanced%20Algorithms.md) - Algorithm design

