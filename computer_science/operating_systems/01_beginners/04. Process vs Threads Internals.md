---
number: 4
title: "Process vs Threads Internals"
slug: "process-vs-threads-internals"
level: "fundamentals"
tags: ["operating-systems", "processes", "threads", "concurrency", "multithreading"]
prerequisites: ["cpu-scheduling-fundamentals"]
estimated_minutes: 100
contributors: []
diagrams: []
examples: []
canonical_id: "cs-os-04"
---

# Process vs Threads Internals

## Overview

Understanding the fundamental differences between processes and threads, how they're implemented in the operating system, and when to use each is crucial for system programming and concurrent application design. This comprehensive guide covers process and thread internals, their memory models, scheduling, and real-world trade-offs.

## Table of Contents

1. [Process Overview](#process-overview)
2. [Thread Overview](#thread-overview)
3. [Key Differences](#differences)
4. [Process Internals](#process-internals)
5. [Thread Internals](#thread-internals)
6. [Memory Models](#memory-models)
7. [Scheduling](#scheduling)
8. [When to Use What](#when-to-use)

## Process Overview

### What is a Process?

**Process**: Independent execution unit with own address space

**Characteristics**:
- **Isolated memory**: Own virtual address space
- **Independent**: Cannot directly access other processes
- **Heavyweight**: More overhead to create/switch
- **Protected**: OS enforces isolation

### Process Components

**1. Address Space**:
- Code segment (program instructions)
- Data segment (global variables)
- Heap (dynamic allocation)
- Stack (function calls)

**2. Process Control Block (PCB)**:
- Process ID (PID)
- Program counter
- CPU registers
- Memory management info
- File descriptors
- Scheduling information

**3. Resources**:
- Open files
- Network connections
- Shared memory segments
- Semaphores/mutexes

### Process States

```
NEW → READY → RUNNING → WAITING → TERMINATED
       ↑         ↓
       └─────────┘
```

**State Transitions**:
- **NEW**: Process created
- **READY**: Waiting for CPU
- **RUNNING**: Executing on CPU
- **WAITING**: Waiting for I/O or event
- **TERMINATED**: Finished execution

## Thread Overview

### What is a Thread?

**Thread**: Lightweight execution unit within a process

**Characteristics**:
- **Shared memory**: Shares address space with other threads
- **Lightweight**: Less overhead to create/switch
- **Fast communication**: Shared memory
- **Cooperative**: Threads work together

### Thread Components

**1. Thread Control Block (TCB)**:
- Thread ID (TID)
- Program counter
- CPU registers
- Stack pointer
- Stack (local variables)

**2. Shared Resources**:
- Address space (code, data, heap)
- Open files
- Process resources

**3. Private Resources**:
- Stack (local variables)
- Registers
- Thread-local storage

### Thread States

```
NEW → READY → RUNNING → WAITING → TERMINATED
       ↑         ↓
       └─────────┘
```

**Similar to Process States**: But threads share process resources

## Key Differences

### Memory Isolation

**Process**:
```
Process A:              Process B:
┌──────────┐           ┌──────────┐
│ Address  │           │ Address  │
│ Space    │           │ Space    │
│          │           │          │
│ Isolated │           │ Isolated │
└──────────┘           └──────────┘
```

**Threads**:
```
Process:
┌──────────────────────────┐
│     Address Space        │
│  ┌──────┐  ┌──────┐     │
│  │Thread│  │Thread│     │
│  │  1   │  │  2   │     │
│  └──────┘  └──────┘     │
│  Shared Memory           │
└──────────────────────────┘
```

### Creation Overhead

**Process Creation**:
- Allocate new address space
- Copy page tables
- Initialize PCB
- **Cost**: ~1-10 milliseconds

**Thread Creation**:
- Allocate stack
- Initialize TCB
- **Cost**: ~10-100 microseconds (100x faster)

### Communication

**Process Communication**:
- **IPC**: Pipes, sockets, shared memory, message queues
- **Slow**: System calls, context switches
- **Safe**: OS enforces isolation

**Thread Communication**:
- **Shared memory**: Direct access
- **Fast**: No system calls needed
- **Unsafe**: Must synchronize manually

### Fault Isolation

**Process**:
- **Crash**: Only affects that process
- **Memory error**: Isolated to process
- **Security**: Process cannot access others

**Threads**:
- **Crash**: Affects entire process
- **Memory error**: Can corrupt shared memory
- **Security**: Threads share same security context

## Process Internals

### Process Control Block (PCB)

**Structure**:
```
┌─────────────────────────┐
│ Process ID (PID)        │
├─────────────────────────┤
│ Program Counter         │
├─────────────────────────┤
│ CPU Registers           │
│  - General purpose      │
│  - Stack pointer        │
│  - Status register      │
├─────────────────────────┤
│ Memory Management       │
│  - Page table pointer   │
│  - Memory limits        │
├─────────────────────────┤
│ File Descriptors        │
│  - Open files           │
│  - Sockets              │
├─────────────────────────┤
│ Scheduling Info         │
│  - Priority             │
│  - State                │
│  - CPU time             │
└─────────────────────────┘
```

### Process Creation

**Steps**:
```
1. Allocate PCB
2. Assign PID
3. Allocate address space
4. Initialize page tables
5. Load program code
6. Initialize stack
7. Set up file descriptors
8. Add to ready queue
```

**Methods**:
- **fork()**: Clone current process
- **exec()**: Replace process image
- **clone()**: More control (Linux)

### Process Termination

**Steps**:
```
1. Process calls exit()
2. Close all file descriptors
3. Free memory
4. Free PCB
5. Notify parent process
6. Remove from scheduling queues
```

**Zombie Process**:
- Process terminated but PCB not freed
- Parent hasn't called wait()
- Resources freed but PID held

**Orphan Process**:
- Parent terminated
- Adopted by init process (PID 1)
- Cleaned up automatically

## Thread Internals

### Thread Control Block (TCB)

**Structure**:
```
┌─────────────────────────┐
│ Thread ID (TID)         │
├─────────────────────────┤
│ Program Counter         │
├─────────────────────────┤
│ CPU Registers           │
│  - General purpose      │
│  - Stack pointer        │
│  - Status register      │
├─────────────────────────┤
│ Stack Pointer           │
│  - Stack base           │
│  - Stack limit          │
├─────────────────────────┤
│ Thread-Local Storage    │
│  - TLS pointer          │
├─────────────────────────┤
│ Scheduling Info         │
│  - Priority             │
│  - State                │
└─────────────────────────┘
```

### Thread Creation

**Steps**:
```
1. Allocate TCB
2. Assign TID
3. Allocate stack
4. Initialize registers
5. Set entry point
6. Add to ready queue
```

**Methods**:
- **pthread_create()**: POSIX threads
- **CreateThread()**: Windows threads
- **Thread.start()**: Java/Kotlin threads

### Thread Stack

**Stack Layout**:
```
High Address:
┌─────────────┐
│   Guard     │ ← Protection page
├─────────────┤
│   Stack     │ ← Grows down
│   (local    │
│   variables)│
├─────────────┤
│   ...       │
Low Address:
```

**Stack Size**: Typically 1-8MB per thread

**Stack Overflow**: Access beyond stack limit → Segmentation fault

## Memory Models

### Process Memory Model

**Isolated Address Spaces**:
```
Process A:                Process B:
0x00000000               0x00000000
    │                         │
    │ Code                    │ Code
    │ Data                    │ Data
    │ Heap                    │ Heap
    │ Stack                   │ Stack
    │                         │
0xFFFFFFFF               0xFFFFFFFF

Different physical memory
Cannot access each other
```

**Memory Protection**:
- **Hardware**: MMU enforces isolation
- **OS**: Page tables separate
- **Security**: Cannot access other processes

### Thread Memory Model

**Shared Address Space**:
```
Process Address Space:
0x00000000
    │
    │ Code (shared)
    │ Data (shared)
    │ Heap (shared)
    │
    │ Thread 1 Stack
    │ Thread 2 Stack
    │ Thread 3 Stack
    │
0xFFFFFFFF

Same physical memory
Can access shared data
Must synchronize
```

**Memory Sharing**:
- **Code**: Shared (read-only)
- **Data**: Shared (read/write)
- **Heap**: Shared (read/write)
- **Stack**: Private per thread

### Thread-Local Storage (TLS)

**Purpose**: Private storage per thread

**Implementation**:
```
Thread 1:                Thread 2:
TLS[0] = value1         TLS[0] = value2
TLS[1] = value3         TLS[1] = value4

Each thread has own TLS
Not shared between threads
```

**Use Cases**:
- Per-thread counters
- Error codes
- Random number generators
- Caching

## Scheduling

### Process Scheduling

**Unit**: Process

**Context Switch**:
- Save process state (registers, PC, etc.)
- Load new process state
- Switch address space (page tables)
- **Cost**: High (microseconds)

**Considerations**:
- Process priority
- CPU time used
- I/O wait time
- Fairness

### Thread Scheduling

**Unit**: Thread (within process)

**Context Switch**:
- Save thread state (registers, PC)
- Load new thread state
- Same address space (no page table switch)
- **Cost**: Low (nanoseconds)

**Considerations**:
- Thread priority
- CPU affinity
- Load balancing
- User vs kernel threads

### User-Level Threads

**Implementation**: Library (not OS)

**Characteristics**:
- **Fast**: No system calls
- **Portable**: Works on any OS
- **Limited**: Cannot use multiple CPUs
- **Blocking**: One thread blocks all

**Example**: Green threads (old Java)

### Kernel-Level Threads

**Implementation**: OS kernel

**Characteristics**:
- **Slower**: System calls needed
- **OS-specific**: Different APIs
- **Parallel**: Can use multiple CPUs
- **Non-blocking**: One thread blocks, others run

**Example**: pthreads (POSIX threads)

### Hybrid Threads

**Combination**: User-level + kernel-level

**How It Works**:
- User-level threads mapped to kernel threads
- Multiple user threads per kernel thread
- Best of both worlds

**Example**: N:M threading model

## When to Use What

### Use Processes When

**1. Isolation Needed**:
- Security critical
- Fault tolerance
- Independent components

**2. Different Programs**:
- Separate applications
- Different languages
- Independent lifecycles

**3. Heavy Computation**:
- CPU-intensive tasks
- Can use multiple CPUs
- Don't need shared memory

### Use Threads When

**1. Shared Data**:
- Need to share memory
- Fast communication
- Cooperative tasks

**2. I/O Bound**:
- Many I/O operations
- Threads can wait independently
- Better CPU utilization

**3. Responsiveness**:
- UI threads
- Background tasks
- Real-time requirements

### Hybrid Approach

**Common Pattern**:
```
Process 1 (Web Server)
  ├─ Thread 1 (Accept connections)
  ├─ Thread 2 (Handle request 1)
  ├─ Thread 3 (Handle request 2)
  └─ Thread 4 (Handle request 3)

Process 2 (Database)
  ├─ Thread 1 (Query processing)
  └─ Thread 2 (Connection pool)
```

**Benefits**:
- **Isolation**: Processes isolated
- **Efficiency**: Threads share memory
- **Scalability**: Can use multiple CPUs

## Real-World Examples

### Example 1: Web Browser

**Process Model**:
```
Browser Process
  ├─ Renderer Process (Tab 1)
  ├─ Renderer Process (Tab 2)
  ├─ Renderer Process (Tab 3)
  └─ GPU Process

Isolation: Tab crash doesn't kill browser
Security: Tabs cannot access each other
```

### Example 2: Database Server

**Thread Model**:
```
Database Process
  ├─ Thread 1 (Connection handler)
  ├─ Thread 2 (Query processor 1)
  ├─ Thread 3 (Query processor 2)
  ├─ Thread 4 (Background tasks)
  └─ Thread 5 (Log writer)

Shared: Database buffer pool
Fast: Thread communication
Efficient: Shared memory
```

### Example 3: Operating System

**Hybrid Model**:
```
OS Kernel
  ├─ Process 1 (User app)
  │   └─ Threads (user-level)
  ├─ Process 2 (User app)
  │   └─ Threads (user-level)
  └─ Kernel Threads (system tasks)

Kernel threads: OS internal
User processes: Applications
User threads: Within processes
```

## Common Pitfalls

### Problem: Race Conditions

```c
// BAD: Unsynchronized shared access
int counter = 0;

void* thread_func(void* arg) {
    for (int i = 0; i < 1000; i++) {
        counter++; // Race condition!
    }
    return NULL;
}

// GOOD: Use synchronization
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
int counter = 0;

void* thread_func(void* arg) {
    for (int i = 0; i < 1000; i++) {
        pthread_mutex_lock(&mutex);
        counter++;
        pthread_mutex_unlock(&mutex);
    }
    return NULL;
}
```

### Problem: Process vs Thread Confusion

```c
// BAD: Using processes when threads needed
pid_t pid = fork();
if (pid == 0) {
    // Child process - cannot share memory easily
    // Must use IPC
}

// GOOD: Use threads for shared memory
pthread_t thread;
pthread_create(&thread, NULL, thread_func, NULL);
// Can share memory directly
```

## Quiz

1. What is the main difference between processes and threads?
   - **A)** Processes are faster
   - **B)** Processes have isolated memory, threads share memory
   - **C)** Threads are more secure
   - **D)** No difference

2. Why are threads faster to create than processes?
   - **A)** They use less memory
   - **B)** They don't need to allocate new address space
   - **C)** They are simpler
   - **D)** OS optimizes them

3. When should you use processes instead of threads?
   - **A)** Always
   - **B)** When you need isolation and fault tolerance
   - **C)** Never
   - **D)** Only for I/O operations

**Answers:**
1. **B** - Processes have isolated address spaces, while threads share the same address space within a process
2. **B** - Threads are faster to create because they don't need to allocate a new address space or copy page tables
3. **B** - Use processes when you need isolation, security, or fault tolerance (one process crash doesn't affect others)

## Next Steps

- [Thread Scheduling & Affinity](./05.%20Thread%20Scheduling%20%26%20Affinity.md) - Thread scheduling details
- [Synchronization Primitives](./06.%20Synchronization%20Primitives.md) - Mutex, semaphore, etc.

