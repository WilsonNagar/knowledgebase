---
number: 5
title: "Thread Scheduling Internals"
slug: "thread-scheduling-internals"
level: "fundamentals"
tags: ["operating-systems", "threads", "scheduling", "multithreading"]
prerequisites: ["process-vs-threads-internals"]
estimated_minutes: 130
contributors: []
diagrams: []
examples: []
canonical_id: "cs-os-fund-05"
---

# Thread Scheduling Internals

## Overview

Thread scheduling determines which thread runs on which CPU core and when. Understanding thread scheduling algorithms, context switching, thread states, and scheduling internals is essential for understanding operating system behavior and multithreaded application performance.

## Table of Contents

1. [What is Thread Scheduling?](#what-is-thread-scheduling)
2. [Thread States](#thread-states)
3. [Context Switching](#context-switching)
4. [Scheduling Algorithms](#scheduling-algorithms)
5. [Preemptive vs Non-Preemptive](#preemptive)
6. [Scheduler Implementation](#scheduler-implementation)
7. [Thread Priorities](#thread-priorities)
8. [Real-World Examples](#examples)

## What is Thread Scheduling?

### Definition

**Thread Scheduling**: Decide which thread runs

**Purpose**: 
- **CPU Utilization**: Maximize CPU utilization
- **Fairness**: Fair CPU allocation
- **Responsiveness**: Responsive system
- **Throughput**: Maximize throughput

**Challenge**: Balance multiple goals

### Scheduling Goals

**1. Fairness**:
```
Fair CPU time allocation
```

**2. Throughput**:
```
Maximize completed work
```

**3. Response Time**:
```
Minimize response time
```

**4. CPU Utilization**:
```
Maximize CPU usage
```

## Thread States

### Thread State Diagram

**States**:
```
New → Ready → Running → Waiting → Terminated
         ↑         ↓
         └─────────┘
```

**State Transitions**:
- **New**: Thread created
- **Ready**: Ready to run
- **Running**: Currently executing
- **Waiting**: Waiting for event
- **Terminated**: Thread finished

### State Details

**Ready State**:
```
Thread ready to run
Waiting for CPU
```

**Running State**:
```
Thread executing on CPU
```

**Waiting State**:
```
Thread waiting for I/O or event
Not ready to run
```

## Context Switching

### What is Context Switching?

**Context Switch**: Switch between threads

**Process**: 
```
1. Save current thread state
2. Load next thread state
3. Switch to next thread
```

**Cost**: 
- **Time**: Time overhead
- **Cache**: Cache invalidation
- **TLB**: TLB flush

### Context Switch Cost

**Overhead**:
- **CPU Cycles**: CPU cycles
- **Cache Misses**: Cache misses
- **TLB Misses**: TLB misses

**Minimization**: 
- **Efficient Switching**: Efficient switching
- **Cache Affinity**: Cache affinity
- **Minimize Switches**: Minimize switches

## Scheduling Algorithms

### Algorithm 1: Round Robin

**Round Robin**: Time-sliced scheduling

**Method**: 
```
1. Each thread gets time slice
2. After time slice, switch to next
3. Round-robin through threads
```

**Benefit**: Fairness

**Use**: General-purpose scheduling

### Algorithm 2: Priority Scheduling

**Priority Scheduling**: Schedule by priority

**Method**: 
```
1. Assign priorities to threads
2. Schedule highest priority first
3. Preempt lower priority threads
```

**Benefit**: Important threads first

**Use**: Real-time systems

### Algorithm 3: Multilevel Queue

**Multilevel Queue**: Multiple queues

**Method**: 
```
1. Separate queues by priority
2. Schedule from highest queue
3. Round-robin within queue
```

**Benefit**: Balance priorities

**Use**: Complex systems

## Preemptive vs Non-Preemptive

### Preemptive Scheduling

**Preemptive**: Can interrupt running thread

**Method**: 
```
1. Thread runs until time slice
2. Scheduler interrupts
3. Switch to another thread
```

**Benefit**: Responsiveness

**Use**: Most modern systems

### Non-Preemptive Scheduling

**Non-Preemptive**: Thread runs until completion

**Method**: 
```
1. Thread runs until completion
2. Or until voluntary yield
3. No interruption
```

**Benefit**: Simplicity

**Use**: Simple systems

## Scheduler Implementation

### Scheduler Components

**1. Ready Queue**:
```
Queue of ready threads
```

**2. Scheduler**:
```
Selects next thread
```

**3. Dispatcher**:
```
Performs context switch
```

**4. Timer**:
```
Time slice management
```

### Scheduler Flow

**Flow**:
```
1. Timer interrupt
2. Save current thread
3. Select next thread
4. Load next thread
5. Switch to next thread
```

**Frequency**: Every few milliseconds

## Thread Priorities

### Priority Levels

**Priorities**: 
- **High**: High priority threads
- **Normal**: Normal priority threads
- **Low**: Low priority threads

**Scheduling**: Higher priority first

### Priority Inversion

**Priority Inversion**: Low priority blocks high priority

**Problem**: 
```
High priority waits for low priority
```

**Solution**: 
- **Priority Inheritance**: Priority inheritance
- **Priority Ceiling**: Priority ceiling

## Real-World Examples

### Example 1: Linux CFS

**CFS**: Completely Fair Scheduler

**Method**: 
- **Virtual Runtime**: Virtual runtime
- **Fairness**: Fair CPU allocation
- **Dynamic**: Dynamic priorities

**Benefit**: Fair scheduling

### Example 2: Windows Scheduler

**Windows**: Multi-level scheduler

**Method**: 
- **Priorities**: Multiple priority levels
- **Quantum**: Time quantum
- **Preemption**: Preemptive scheduling

**Benefit**: Responsive system

## Common Pitfalls

### Problem: Priority Inversion

```c
// BAD: Priority inversion
// High priority blocked by low priority

// GOOD: Use priority inheritance
// Prevent inversion
```

### Problem: Too Many Context Switches

```c
// BAD: Too frequent switches
// Performance overhead

// GOOD: Appropriate time slices
// Balance responsiveness and overhead
```

## Quiz

1. What is thread scheduling?
   - **A)** Creating threads
   - **B)** Deciding which thread runs on CPU and when
   - **C)** Deleting threads
   - **D)** Synchronizing threads

2. What is context switching?
   - **A)** Creating context
   - **B)** Switching CPU between threads, saving and loading state
   - **C)** Deleting context
   - **D)** Sharing context

3. What is preemptive scheduling?
   - **A)** No interruption
   - **B)** Scheduler can interrupt running thread to switch
   - **C)** Manual switching
   - **D)** No switching

**Answers:**
1. **B** - Thread scheduling decides which thread executes on which CPU core and when, balancing fairness, throughput, and responsiveness
2. **B** - Context switching saves the current thread's state, loads the next thread's state, and switches CPU execution to the next thread
3. **B** - Preemptive scheduling allows the scheduler to interrupt a running thread and switch to another thread, ensuring responsiveness

## Next Steps

- [Memory Barriers & Ordering](./06.%20Memory%20Barriers%20%26%20Ordering.md) - Memory ordering
- [System Call Implementation Details](./07.%20System%20Call%20Implementation%20Details.md) - System calls

