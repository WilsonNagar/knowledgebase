---
number: 17
title: "Process Scheduling Advanced - CFS, MLFQ"
slug: "process-scheduling-advanced-cfs-mlfq"
level: "intermediate"
tags: ["operating-systems", "scheduling", "cfs", "mlfq", "fairness"]
prerequisites: ["file-system-internals-advanced-ext4-zfs-btrfs"]
estimated_minutes: 145
contributors: []
diagrams: []
examples: []
canonical_id: "cs-os-int-17"
---

# Process Scheduling Advanced - CFS, MLFQ

## Overview

Advanced scheduling algorithms like CFS (Completely Fair Scheduler) and MLFQ (Multi-Level Feedback Queue) provide sophisticated CPU scheduling with fairness guarantees and priority handling. Understanding these algorithms, their implementations, and trade-offs is essential for understanding modern operating system scheduling.

## Table of Contents

1. [CFS - Completely Fair Scheduler](#cfs)
2. [CFS Implementation](#cfs-implementation)
3. [MLFQ - Multi-Level Feedback Queue](#mlfq)
4. [MLFQ Implementation](#mlfq-implementation)
5. [CFS vs MLFQ](#cfs-vs-mlfq)
6. [Fairness Metrics](#fairness)
7. [Real-World Examples](#examples)
8. [Best Practices](#best-practices)

## CFS - Completely Fair Scheduler

### What is CFS?

**CFS**: Completely Fair Scheduler

**Goal**: Fair CPU allocation

**Method**: 
- **Virtual Runtime**: Virtual runtime tracking
- **Red-Black Tree**: Red-black tree for scheduling
- **Fairness**: Fair CPU time allocation

**Use**: Linux default scheduler

### CFS Principles

**1. Fairness**:
```
All processes get fair CPU time
```

**2. Proportional Share**:
```
CPU time proportional to weight
```

**3. Low Latency**:
```
Low scheduling latency
```

**4. Throughput**:
```
High throughput
```

## CFS Implementation

### Virtual Runtime

**Virtual Runtime**: Normalized runtime

**Formula**: 
```
vruntime += (runtime * NICE_0_LOAD) / weight
```

**Purpose**: Normalize by priority

**Benefit**: Fair scheduling

### Red-Black Tree

**Red-Black Tree**: Sorted by vruntime

**Structure**: 
```
Left: Lower vruntime (should run)
Right: Higher vruntime
```

**Selection**: Leftmost node (lowest vruntime)

**Insertion**: O(log n)

**Deletion**: O(log n)

### CFS Scheduling

**Process**:
```
1. Select leftmost task (lowest vruntime)
2. Run task
3. Update vruntime
4. Reinsert task
5. Repeat
```

**Fairness**: Lower vruntime runs first

## MLFQ - Multi-Level Feedback Queue

### What is MLFQ?

**MLFQ**: Multi-Level Feedback Queue

**Goal**: Balance response time and throughput

**Method**: 
- **Multiple Queues**: Multiple priority queues
- **Feedback**: Adjust priority based on behavior
- **Time Slices**: Different time slices per queue

**Use**: General-purpose scheduling

### MLFQ Principles

**1. Priority Queues**:
```
Multiple priority levels
```

**2. Feedback**:
```
Adjust priority based on behavior
```

**3. Time Slices**:
```
Higher priority: Shorter time slice
Lower priority: Longer time slice
```

**4. Aging**:
```
Boost priority of waiting processes
```

## MLFQ Implementation

### Queue Structure

**Queues**: 
```
Queue 0: Highest priority, shortest time slice
Queue 1: High priority, short time slice
Queue 2: Medium priority, medium time slice
Queue 3: Low priority, long time slice
```

**Scheduling**: Schedule from highest non-empty queue

### Feedback Mechanism

**Interactive Processes**:
```
Use full time slice → Lower priority
```

**I/O-Bound Processes**:
```
Give up CPU (I/O) → Keep priority
```

**Aging**:
```
Wait too long → Boost priority
```

### MLFQ Scheduling

**Process**:
```
1. Schedule from highest non-empty queue
2. Run for time slice
3. If uses full slice: Lower priority
4. If gives up CPU: Keep priority
5. Age processes in lower queues
```

## CFS vs MLFQ

### Comparison

| Aspect | CFS | MLFQ |
|--------|-----|------|
| **Fairness** | Excellent | Good |
| **Response Time** | Good | Excellent |
| **Throughput** | Excellent | Good |
| **Complexity** | Medium | Medium |
| **Use Case** | General purpose | Interactive systems |

### When to Use Each

**CFS**: 
- **Fairness**: Need fairness
- **General Purpose**: General-purpose systems
- **Throughput**: High throughput needed

**MLFQ**: 
- **Interactive**: Interactive systems
- **Response Time**: Low response time needed
- **Mixed Workloads**: Mixed interactive and batch

## Fairness Metrics

### Fairness Measures

**1. CPU Time**:
```
Equal CPU time per process
```

**2. Wait Time**:
```
Minimize wait time
```

**3. Response Time**:
```
Minimize response time
```

**4. Throughput**:
```
Maximize throughput
```

### CFS Fairness

**Fairness**: 
```
vruntime tracks CPU time
Lower vruntime runs first
```

**Result**: Fair CPU allocation

## Real-World Examples

### Example 1: Linux CFS

**Use**: Linux default scheduler

**Features**: 
- **Fairness**: Fair CPU allocation
- **Performance**: High performance
- **Scalability**: Scalable

**Result**: Fair and efficient scheduling

### Example 2: Interactive System

**Use**: Interactive desktop

**Scheduler**: MLFQ

**Features**: 
- **Response Time**: Low response time
- **Interactive**: Good for interactive
- **Feedback**: Adaptive priority

**Result**: Responsive system

## Best Practices

### Practice 1: Tune Time Slices

**Time Slices**: 
```
Tune time slices for workload
Balance responsiveness and overhead
```

**Benefit**: Optimal performance

### Practice 2: Monitor Fairness

**Monitor**: 
```
Monitor CPU time allocation
Ensure fairness
```

**Benefit**: Fair scheduling

### Practice 3: Handle Priorities

**Priorities**: 
```
Use priorities appropriately
Don't abuse priorities
```

**Benefit**: Correct behavior

## Common Pitfalls

### Problem: Priority Inversion

```c
// BAD: Priority inversion
// Low priority blocks high priority

// GOOD: Use priority inheritance
// Prevent inversion
```

### Problem: Starvation

```c
// BAD: Starvation
// Some processes never run

// GOOD: Use aging
// Prevent starvation
```

## Quiz

1. What is CFS?
   - **A)** Simple scheduler
   - **B)** Completely Fair Scheduler using virtual runtime and red-black tree
   - **C)** Priority scheduler
   - **D)** Round-robin scheduler

2. What is MLFQ?
   - **A)** Single queue scheduler
   - **B)** Multi-Level Feedback Queue with multiple priority queues and feedback
   - **C)** Fair scheduler
   - **D)** Real-time scheduler

3. What is virtual runtime in CFS?
   - **A)** Actual runtime
   - **B)** Normalized runtime accounting for process priority
   - **C)** Virtual time
   - **D)** CPU time

**Answers:**
1. **B** - CFS uses virtual runtime to track normalized CPU time and a red-black tree to efficiently select the task with lowest vruntime
2. **B** - MLFQ uses multiple priority queues with feedback mechanisms to adjust priorities based on process behavior
3. **B** - Virtual runtime normalizes actual runtime by process weight/priority, ensuring fair CPU allocation regardless of priority

## Next Steps

- [I/O Subsystems Advanced](./18.%20I-O%20Subsystems%20Advanced%20-%20Block%20Devices%2C%20DMA%2C%20Async%20I-O.md) - Block devices, DMA
- [Boot Process Advanced](./19.%20Boot%20Process%20Advanced%20-%20UEFI%2C%20Secure%20Boot.md) - UEFI, Secure Boot

