---
number: 8
title: "Interrupts & Traps"
slug: "interrupts-traps"
level: "intermediate"
tags: ["operating-systems", "interrupts", "traps", "hardware", "exceptions"]
prerequisites: ["system-calls-design-implementation"]
estimated_minutes: 95
contributors: []
diagrams: []
examples: []
canonical_id: "cs-os-08"
---

# Interrupts & Traps

## Overview

Interrupts and traps are fundamental mechanisms that allow the operating system to respond to hardware events and handle exceptional conditions. Understanding interrupts, traps, exception handling, and interrupt service routines is essential for system programming, device driver development, and understanding OS internals.

## Table of Contents

1. [What are Interrupts?](#what-are-interrupts)
2. [Types of Interrupts](#types)
3. [Interrupt Handling](#handling)
4. [Interrupt Service Routines](#isr)
5. [Traps & Exceptions](#traps)
6. [Interrupt Priority](#priority)
7. [Nested Interrupts](#nested)
8. [Performance Considerations](#performance)

## What are Interrupts?

### Definition

**Interrupt**: Signal from hardware to CPU

**Purpose**: Notify CPU of events requiring attention

**Effect**: CPU suspends current execution, handles interrupt, resumes

### Why Interrupts?

**Problem**: Polling is inefficient

**Without Interrupts**:
```c
while (true) {
    if (keyboard_has_data()) {
        process_keyboard();
    }
    if (network_has_data()) {
        process_network();
    }
    // Wastes CPU checking constantly
}
```

**With Interrupts**:
```c
// CPU continues normal execution
// When keyboard has data: Interrupt fires
// CPU handles interrupt automatically
// Returns to normal execution
```

**Benefits**: Efficient, responsive

## Types of Interrupts

### Hardware Interrupts

**Source**: External hardware devices

**Examples**:
- **Keyboard**: Key pressed
- **Mouse**: Mouse moved
- **Network**: Packet arrived
- **Disk**: I/O complete
- **Timer**: Timer expired

**Characteristics**:
- **Asynchronous**: Can occur at any time
- **External**: From hardware devices
- **Maskable**: Can be disabled

### Software Interrupts

**Source**: Software (INT instruction)

**Examples**:
- **System calls**: INT 0x80 (x86)
- **Breakpoints**: Debugging
- **Traps**: Exception handling

**Characteristics**:
- **Synchronous**: Occurs at specific instruction
- **Software**: Triggered by program
- **Controlled**: Program controls when

### Exceptions (Traps)

**Source**: CPU itself

**Examples**:
- **Page fault**: Access to unmapped memory
- **Divide by zero**: Arithmetic error
- **Invalid instruction**: Bad opcode
- **General protection fault**: Permission violation

**Characteristics**:
- **Synchronous**: Occurs during instruction execution
- **CPU**: Generated by CPU
- **Unmaskable**: Cannot be disabled

## Interrupt Handling

### Interrupt Flow

**Process**:
```
1. Interrupt occurs
2. CPU saves current state (registers, PC, flags)
3. CPU jumps to interrupt handler
4. Handler executes
5. Handler returns (IRET)
6. CPU restores state
7. Execution resumes
```

### Interrupt Descriptor Table (IDT)

**Purpose**: Maps interrupt numbers to handlers

**Structure** (x86):
```
IDT Entry:
  ┌─────────────┬─────────────┐
  │ Handler Low  │ Selector     │
  ├─────────────┼─────────────┤
  │ Handler High│ Flags        │
  └─────────────┴─────────────┘
```

**Example**:
```
IDT[0x21] → keyboard_handler
IDT[0x80] → system_call_handler
IDT[14]   → page_fault_handler
```

### Interrupt Vector

**Vector**: Number identifying interrupt

**x86 Examples**:
- **0-31**: Exceptions (reserved)
- **32-255**: Hardware/software interrupts

**Assignment**:
```
IRQ 0 (Timer) → Vector 32
IRQ 1 (Keyboard) → Vector 33
IRQ 2 (Cascade) → Vector 34
...
```

## Interrupt Service Routines

### What is an ISR?

**ISR**: Interrupt Service Routine

**Purpose**: Handle interrupt

**Requirements**:
- **Fast**: Minimize interrupt latency
- **Minimal**: Do minimal work
- **Reentrant**: Can be interrupted

### ISR Structure

**Basic ISR**:
```c
void keyboard_isr(void) {
    // 1. Acknowledge interrupt
    acknowledge_interrupt();
    
    // 2. Read data
    char key = read_keyboard_data();
    
    // 3. Queue for processing (defer to bottom half)
    enqueue_key(key);
    
    // 4. Return
    return;
}
```

### Top Half vs Bottom Half

**Top Half (ISR)**:
- **Fast**: Minimal processing
- **Critical**: Time-sensitive
- **Interrupts disabled**: While executing

**Bottom Half**:
- **Deferred**: Process later
- **Non-critical**: Can wait
- **Interrupts enabled**: Can be interrupted

**Example**:
```c
// Top half: Fast
void network_isr(void) {
    // Just queue packet
    enqueue_packet(packet);
    schedule_bottom_half();
}

// Bottom half: Process packet
void process_packets(void) {
    while (!queue_empty()) {
        packet = dequeue_packet();
        process_packet(packet); // Can take time
    }
}
```

## Traps & Exceptions

### What are Traps?

**Trap**: Synchronous interrupt from CPU

**Causes**:
- **Exceptions**: Errors during execution
- **System calls**: INT instruction
- **Breakpoints**: Debugging

### Exception Types

**1. Faults**:
- **Correctable**: Can retry instruction
- **Example**: Page fault
- **Return**: To faulting instruction

**2. Traps**:
- **Reported**: After instruction completes
- **Example**: Breakpoint, system call
- **Return**: To next instruction

**3. Aborts**:
- **Severe**: Cannot recover
- **Example**: Machine check, double fault
- **No return**: System may crash

### Page Fault Example

**Scenario**: Access unmapped memory

**Process**:
```
1. Instruction accesses address
2. MMU checks page table
3. Page not present → Page fault (exception)
4. CPU saves state, jumps to page_fault_handler
5. Handler:
   a. Check if valid access
   b. Load page from disk (if needed)
   c. Update page table
   d. Return
6. CPU retries instruction
```

### System Call Trap

**Process**:
```
1. User program executes: syscall (or INT 0x80)
2. CPU generates trap
3. CPU saves state, jumps to system_call_handler
4. Handler:
   a. Validate system call number
   b. Call appropriate handler
   c. Return result
5. CPU restores state, returns to user
```

## Interrupt Priority

### Priority Levels

**Purpose**: Handle multiple interrupts

**Priority Order** (typical):
```
1. Non-maskable interrupts (NMI)
2. Exceptions (traps)
3. Hardware interrupts (IRQs)
4. Software interrupts
```

### Interrupt Masking

**Mask**: Disable interrupts

**Purpose**: Critical sections

**Example**:
```c
// Disable interrupts
cli(); // Clear interrupt flag

// Critical section
modify_shared_data();

// Enable interrupts
sti(); // Set interrupt flag
```

**Nested Interrupts**: Higher priority can interrupt lower

## Nested Interrupts

### Concept

**Nested**: Interrupt during interrupt handling

**Example**:
```
1. Timer interrupt (low priority)
2. Handling timer interrupt
3. Network interrupt (high priority) occurs
4. Suspend timer handler
5. Handle network interrupt
6. Resume timer handler
```

### Interrupt Nesting Rules

**Rules**:
- **Higher priority**: Can interrupt lower
- **Same priority**: Usually not nested
- **Lower priority**: Cannot interrupt higher

**Implementation**: Interrupt controller (PIC/APIC)

## Performance Considerations

### Interrupt Latency

**Definition**: Time from interrupt to handler start

**Components**:
- **Hardware**: Interrupt propagation
- **Software**: Handler execution time
- **Masking**: Interrupts disabled time

**Target**: Minimize latency

### Interrupt Overhead

**Costs**:
- **Context save**: ~100ns
- **Handler execution**: Variable
- **Context restore**: ~100ns
- **Cache effects**: TLB flush, cache misses

**Total**: ~300-1000ns per interrupt

### Reducing Overhead

**1. Fast Handlers**:
```c
// BAD: Slow handler
void isr(void) {
    process_complex_data(); // Takes milliseconds
}

// GOOD: Fast handler, defer work
void isr(void) {
    queue_data();
    schedule_bottom_half(); // Process later
}
```

**2. Interrupt Coalescing**:
```
Combine multiple interrupts
Process batch together
Reduce interrupt frequency
```

**3. Polling Mode**:
```
For high-frequency events:
  Use polling instead of interrupts
  Check periodically
  Lower overhead if frequent
```

## Real-World Examples

### Example 1: Keyboard Interrupt

**Hardware**: Key pressed

**Process**:
```
1. Keyboard controller generates interrupt
2. CPU receives IRQ 1
3. Jumps to keyboard_isr
4. ISR reads scan code
5. Queues key for processing
6. Returns
7. Bottom half processes key
```

### Example 2: Network Interrupt

**Hardware**: Packet arrived

**Process**:
```
1. Network card receives packet
2. Generates interrupt
3. CPU jumps to network_isr
4. ISR acknowledges, queues packet
5. Schedules bottom half
6. Bottom half processes packet
```

### Example 3: Timer Interrupt

**Hardware**: Timer expired

**Process**:
```
1. Timer generates interrupt (periodic)
2. CPU jumps to timer_isr
3. ISR:
   a. Update system time
   b. Check process time slices
   c. Schedule if needed
4. Returns
```

## Common Pitfalls

### Problem: Long ISR Execution

```c
// BAD: Long ISR
void isr(void) {
    process_large_data(); // Blocks other interrupts
    send_response(); // Takes time
}

// GOOD: Minimal ISR
void isr(void) {
    queue_data(); // Fast
    schedule_bottom_half(); // Defer work
}
```

### Problem: Not Masking Interrupts

```c
// BAD: Race condition
void modify_shared_data(void) {
    shared_data++; // Can be interrupted!
    // Another interrupt modifies shared_data
    // Result: Lost update
}

// GOOD: Mask interrupts
void modify_shared_data(void) {
    cli(); // Disable interrupts
    shared_data++;
    sti(); // Enable interrupts
}
```

## Quiz

1. What is the main difference between interrupts and traps?
   - **A)** No difference
   - **B)** Interrupts are asynchronous (external), traps are synchronous (CPU-generated)
   - **C)** Traps are faster
   - **D)** Interrupts are software only

2. Why use top half and bottom half for interrupt handling?
   - **A)** To make code longer
   - **B)** To minimize interrupt latency by doing minimal work in ISR and deferring processing
   - **C)** To use more memory
   - **D)** No reason

3. What is interrupt latency?
   - **A)** Interrupt frequency
   - **B)** Time from interrupt occurrence to handler start
   - **C)** Handler execution time
   - **D)** Interrupt priority

**Answers:**
1. **B** - Interrupts are asynchronous events from external hardware, while traps are synchronous exceptions generated by the CPU during instruction execution
2. **B** - Top half (ISR) does minimal work quickly to minimize latency, while bottom half defers non-critical processing to maintain system responsiveness
3. **B** - Interrupt latency is the time delay from when an interrupt occurs until the interrupt handler begins executing

## Next Steps

- [I/O Subsystems - Block Devices & DMA](./09.%20I-O%20Subsystems%20-%20Block%20Devices%20%26%20DMA.md) - I/O handling
- [File System Internals](./10.%20File%20System%20Internals.md) - File systems

