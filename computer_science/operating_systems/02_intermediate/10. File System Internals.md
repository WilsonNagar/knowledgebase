---
number: 10
title: "File System Internals"
slug: "file-system-internals"
level: "intermediate"
tags: ["operating-systems", "file-systems", "ext4", "zfs", "journaling", "b-tree"]
prerequisites: ["io-subsystems-block-devices-dma"]
estimated_minutes: 125
contributors: []
diagrams: []
examples: []
canonical_id: "cs-os-10"
---

# File System Internals

## Overview

File systems organize how data is stored on storage devices. Understanding file system internals, including EXT4, ZFS, journaling, B-trees, and how files are organized on disk is essential for system administration, performance optimization, and data recovery.

## Table of Contents

1. [File System Overview](#overview)
2. [File System Layout](#layout)
3. [Inodes](#inodes)
4. [Directory Structure](#directories)
5. [Journaling](#journaling)
6. [EXT4 File System](#ext4)
7. [ZFS File System](#zfs)
8. [Copy-on-Write](#cow)
9. [Performance Considerations](#performance)

## File System Overview

### What is a File System?

**File System**: Organizes data on storage device

**Purpose**:
- **Organization**: Structure files and directories
- **Metadata**: Track file information
- **Access**: Provide file access interface
- **Protection**: Enforce permissions

### File System Layers

**Layers**:
```
Application
    ↓
File System API (open, read, write)
    ↓
File System Implementation
    ↓
Block Device Interface
    ↓
Storage Device
```

## File System Layout

### Disk Layout

**Typical Layout**:
```
┌──────────┬──────────┬──────────┬──────────┐
│ Boot     │ Super    │ Inode    │ Data     │
│ Block    │ Block    │ Table    │ Blocks   │
└──────────┴──────────┴──────────┴──────────┘
```

**Components**:
- **Boot Block**: Boot code (first block)
- **Super Block**: File system metadata
- **Inode Table**: File metadata
- **Data Blocks**: Actual file data

### Super Block

**Purpose**: File system metadata

**Contents**:
- **File system type**: EXT4, XFS, etc.
- **Block size**: Size of blocks
- **Total blocks**: Total storage
- **Free blocks**: Available storage
- **Inode count**: Number of inodes
- **Magic number**: File system identifier

## Inodes

### What is an Inode?

**Inode**: Index node (file metadata)

**Contents**:
- **File type**: Regular file, directory, symlink
- **Permissions**: Read, write, execute
- **Owner**: User ID, group ID
- **Size**: File size
- **Timestamps**: Created, modified, accessed
- **Block pointers**: Pointers to data blocks

### Inode Structure

**Direct Blocks** (12 blocks):
```
Point directly to data blocks
Small files: Use only direct blocks
```

**Indirect Block**:
```
Points to block of pointers
Each pointer → data block
Supports larger files
```

**Double Indirect Block**:
```
Points to block of indirect blocks
Each indirect → block of pointers → data blocks
Supports even larger files
```

**Triple Indirect Block**:
```
Points to block of double indirect blocks
Supports very large files
```

### Inode Example

**File Size Calculation** (4KB blocks):
```
Direct blocks: 12 × 4KB = 48KB
Indirect: 1024 × 4KB = 4MB
Double indirect: 1024 × 4MB = 4GB
Triple indirect: 1024 × 4GB = 4TB
Maximum file size: ~4TB
```

## Directory Structure

### Directory Implementation

**Directory**: Special file containing entries

**Entry Structure**:
```
┌──────────┬──────────┐
│ Inode #  │ Name     │
└──────────┴──────────┘
```

**Example**:
```
Directory /home/user:
  Inode 1001: "file1.txt"
  Inode 1002: "file2.txt"
  Inode 1003: "subdir"
```

### Directory Traversal

**Path Resolution**: `/home/user/file.txt`

**Process**:
```
1. Start at root (inode 2)
2. Look up "home" → Get inode
3. Read home directory → Find "user"
4. Get user inode
5. Read user directory → Find "file.txt"
6. Get file.txt inode
7. Access file
```

### Hash Tables vs B-Trees

**Hash Table** (older):
- **Simple**: Hash name → entry
- **Fast**: O(1) lookup
- **Problem**: Hash collisions

**B-Tree** (modern):
- **Efficient**: O(log n) lookup
- **Scalable**: Handles large directories
- **Used**: EXT4, XFS

## Journaling

### What is Journaling?

**Journaling**: Log changes before applying

**Purpose**: Fast recovery after crash

**Process**:
```
1. Write change to journal (log)
2. Flush journal to disk
3. Apply change to file system
4. Mark journal entry complete
```

### Journaling Modes

**1. Writeback**:
- **Metadata**: Journal metadata only
- **Data**: Not journaled
- **Fast**: Less I/O
- **Risk**: Data may be inconsistent

**2. Ordered**:
- **Metadata**: Journal metadata
- **Data**: Write data before metadata
- **Balance**: Good balance
- **Common**: Default in many file systems

**3. Data**:
- **Everything**: Journal data and metadata
- **Safe**: Most consistent
- **Slow**: More I/O

### Journal Recovery

**After Crash**:
```
1. Read journal
2. Find incomplete transactions
3. Replay transactions
4. File system consistent
```

**Fast**: Minutes instead of hours (fsck)

## EXT4 File System

### EXT4 Overview

**EXT4**: Fourth extended file system

**Successor**: To EXT2/EXT3

**Features**:
- **Large files**: Up to 16TB
- **Large volumes**: Up to 1EB
- **Extents**: Contiguous block allocation
- **Journaling**: Optional

### EXT4 Structure

**Block Groups**:
```
Volume divided into block groups
Each group:
  - Super block copy
  - Group descriptors
  - Inode table
  - Data blocks
```

**Extents**:
```
Instead of block lists:
  Extent: (start_block, length)
  
Example:
  File uses blocks 1000-1999
  Extent: (1000, 1000)
  Instead of 1000 block pointers
```

**Benefits**:
- **Efficient**: Less metadata
- **Fast**: Faster allocation
- **Large files**: Better for large files

### EXT4 Features

**1. Extents**:
- **Contiguous**: Allocate contiguous blocks
- **Efficient**: Less metadata overhead
- **Fast**: Faster file operations

**2. Delayed Allocation**:
- **Defer**: Allocate blocks when flushing
- **Optimization**: Better block allocation
- **Risk**: Data loss if crash before flush

**3. Multiblock Allocation**:
- **Batch**: Allocate multiple blocks
- **Efficient**: Fewer operations

## ZFS File System

### ZFS Overview

**ZFS**: Zettabyte File System

**Features**:
- **Copy-on-Write**: Never overwrites data
- **Snapshots**: Instant, space-efficient
- **Checksums**: Data integrity
- **Pooling**: Unified storage pool

### Copy-on-Write

**Traditional**:
```
Update file:
  1. Read block
  2. Modify in place
  3. Write block back
```

**Copy-on-Write**:
```
Update file:
  1. Read block
  2. Write modified block to new location
  3. Update pointer to new block
  4. Old block becomes free
```

**Benefits**:
- **Snapshots**: Easy (just keep old blocks)
- **Crash-safe**: Never corrupts existing data
- **Atomic**: Updates atomic

### ZFS Structure

**Pool**: Collection of devices

**Datasets**: Filesystems, volumes, snapshots

**Blocks**: Variable-size blocks (up to 1MB)

**Metadata**: Always checksummed

### ZFS Features

**1. Snapshots**:
- **Instant**: Create instantly
- **Space-efficient**: Copy-on-write
- **Many**: Can have many snapshots

**2. Checksums**:
- **Data integrity**: Detect corruption
- **Automatic**: Automatic repair
- **Self-healing**: Can repair from redundancy

**3. Compression**:
- **Transparent**: Automatic compression
- **Efficient**: Saves space
- **Fast**: Hardware-accelerated

## Copy-on-Write

### COW Benefits

**1. Snapshots**:
```
Create snapshot: Just mark current state
No copy needed (COW handles it)
```

**2. Crash Safety**:
```
Never overwrites existing data
Old data always available
Can rollback on crash
```

**3. Atomic Updates**:
```
Updates atomic
Either complete or not applied
No partial updates
```

### COW Trade-offs

**Advantages**:
- **Safety**: Never corrupts data
- **Snapshots**: Easy and efficient
- **Recovery**: Easy rollback

**Disadvantages**:
- **Fragmentation**: Can fragment over time
- **Overhead**: More writes (new blocks)
- **Space**: Old blocks kept until freed

## Performance Considerations

### File System Performance

**Factors**:
- **Block size**: Larger = better for large files
- **Allocation**: Contiguous vs fragmented
- **Journaling**: Overhead vs safety
- **Caching**: Buffer cache effectiveness

### Optimization Techniques

**1. Block Size**:
```
Small blocks (4KB): Good for small files
Large blocks (64KB): Good for large files
Trade-off: Choose based on workload
```

**2. Allocation Strategy**:
```
Contiguous: Better performance
Fragmented: Slower (more seeks)
Preallocation: Reserve space
```

**3. Journaling Mode**:
```
Writeback: Fastest, less safe
Ordered: Balanced
Data: Safest, slowest
```

## Real-World Examples

### Example 1: File Creation

**Process**:
```
1. Allocate inode
2. Allocate data blocks
3. Update directory entry
4. Write inode
5. Write directory
6. Write journal (if journaling)
7. Flush to disk
```

### Example 2: File Update

**EXT4 (Traditional)**:
```
1. Read block
2. Modify in memory
3. Write block back (in place)
4. Update journal
```

**ZFS (COW)**:
```
1. Read block
2. Modify in memory
3. Write to new location
4. Update pointer
5. Old block becomes free
```

## Common Pitfalls

### Problem: Fragmentation

```c
// BAD: Many small writes
for (int i = 0; i < 1000; i++) {
    write(file, &data[i], 1); // Fragments file
}

// GOOD: Large writes
write(file, data, 1000); // Contiguous allocation
```

### Problem: Ignoring Journaling Overhead

```c
// BAD: Many small updates
for (int i = 0; i < 1000; i++) {
    update_metadata(); // Each update journals
}

// GOOD: Batch updates
batch_update_metadata(); // Single journal entry
```

## Quiz

1. What is an inode?
   - **A)** Data block
   - **B)** File metadata structure containing file information and block pointers
   - **C)** Directory entry
   - **D)** Journal entry

2. What is the main advantage of copy-on-write file systems?
   - **A)** Faster writes
   - **B)** Crash safety and easy snapshots (never overwrites existing data)
   - **C)** Less memory usage
   - **D)** Simpler implementation

3. What is journaling in file systems?
   - **A)** Encrypting data
   - **B)** Logging changes before applying them for fast recovery
   - **C)** Compressing data
   - **D)** Backing up data

**Answers:**
1. **B** - An inode is a data structure that stores file metadata (permissions, size, timestamps) and pointers to the data blocks containing the file's content
2. **B** - Copy-on-write file systems never overwrite existing data, writing changes to new locations instead, which provides crash safety and makes snapshots trivial
3. **B** - Journaling logs file system changes to a journal before applying them, enabling fast recovery after crashes by replaying the journal instead of scanning the entire file system

## Next Steps

- [Boot Process - BIOS to Kernel](./11.%20Boot%20Process%20-%20BIOS%20to%20Kernel.md) - System startup
- [Linux Kernel Debugging Tools](./12.%20Linux%20Kernel%20Debugging%20Tools.md) - perf, ftrace, eBPF

