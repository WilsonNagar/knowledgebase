---
number: 5
title: "Synchronization Primitives - Mutex, Spinlock, RW Lock"
slug: "synchronization-primitives-mutex-spinlock-rw-lock"
level: "intermediate"
tags: ["operating-systems", "synchronization", "mutex", "spinlock", "locks", "concurrency"]
prerequisites: ["process-vs-threads-internals"]
estimated_minutes: 110
contributors: []
diagrams: []
examples: []
canonical_id: "cs-os-05"
---

# Synchronization Primitives - Mutex, Spinlock, RW Lock

## Overview

Synchronization primitives are fundamental tools for coordinating access to shared resources in multi-threaded and multi-process systems. Understanding mutexes, spinlocks, read-write locks, and their implementation details is essential for building correct and efficient concurrent programs.

## Table of Contents

1. [The Synchronization Problem](#problem)
2. [Mutex (Mutual Exclusion)](#mutex)
3. [Spinlock](#spinlock)
4. [Read-Write Lock](#rw-lock)
5. [Condition Variables](#condition-variables)
6. [Semaphores](#semaphores)
7. [Barriers](#barriers)
8. [Performance Considerations](#performance)

## The Synchronization Problem

### Race Conditions

**Problem**: Multiple threads access shared data concurrently

**Example**:
```c
// Thread 1 and Thread 2 both execute:
counter = counter + 1;

// What can happen:
// 1. Thread 1 reads counter (value: 5)
// 2. Thread 2 reads counter (value: 5)
// 3. Thread 1 writes counter + 1 (value: 6)
// 4. Thread 2 writes counter + 1 (value: 6)
// Result: Should be 7, but got 6 (lost update)
```

### Critical Section

**Definition**: Code section accessing shared resource

**Requirements**:
- **Mutual Exclusion**: Only one thread at a time
- **Progress**: If no thread in CS, one can enter
- **Bounded Waiting**: No thread waits forever

**Solution**: Synchronization primitives

## Mutex (Mutual Exclusion)

### What is a Mutex?

**Mutex**: Lock that ensures mutual exclusion

**Characteristics**:
- **Binary**: Locked or unlocked
- **Ownership**: Thread that locks must unlock
- **Blocking**: Threads wait if locked
- **Reentrant**: Some mutexes allow same thread to lock again

### Mutex Operations

**Lock**:
```c
pthread_mutex_lock(&mutex);
// Critical section
pthread_mutex_unlock(&mutex);
```

**Try Lock** (non-blocking):
```c
if (pthread_mutex_trylock(&mutex) == 0) {
    // Got lock, enter critical section
    pthread_mutex_unlock(&mutex);
} else {
    // Lock busy, do something else
}
```

### Mutex Implementation

**Simple Mutex** (user-space):
```c
typedef struct {
    int locked;
    int owner;
} mutex_t;

void mutex_lock(mutex_t *m) {
    while (__sync_lock_test_and_set(&m->locked, 1)) {
        // Spin or yield
        sched_yield();
    }
    m->owner = get_thread_id();
}

void mutex_unlock(mutex_t *m) {
    if (m->owner != get_thread_id()) {
        // Error: not owner
        return;
    }
    __sync_lock_release(&m->locked);
}
```

**Kernel Mutex** (Linux):
- **Futex-based**: Fast user-space mutex
- **Hybrid**: User-space fast path, kernel slow path
- **Efficient**: Minimal system calls

### Mutex Types

**1. Normal Mutex**:
- Deadlock if same thread locks twice
- No error checking

**2. Error-Checking Mutex**:
- Detects deadlock (same thread)
- Returns error

**3. Recursive Mutex**:
- Same thread can lock multiple times
- Must unlock same number of times

**4. Adaptive Mutex**:
- Spins briefly, then blocks
- Adapts to contention

### Mutex Best Practices

**Always Unlock**:
```c
// BAD: Forget to unlock
pthread_mutex_lock(&mutex);
// ... code ...
// Forgot unlock â†’ deadlock

// GOOD: Use try-finally or RAII
pthread_mutex_lock(&mutex);
try {
    // ... code ...
} finally {
    pthread_mutex_unlock(&mutex);
}
```

**Hold Lock Briefly**:
```c
// BAD: Hold lock during I/O
pthread_mutex_lock(&mutex);
read_from_disk(); // Blocks, holds lock
process_data();
pthread_mutex_unlock(&mutex);

// GOOD: Minimize critical section
read_from_disk(); // No lock
pthread_mutex_lock(&mutex);
process_data(); // Quick operation
pthread_mutex_unlock(&mutex);
```

## Spinlock

### What is a Spinlock?

**Spinlock**: Lock that spins (busy-waits) instead of blocking

**Characteristics**:
- **Spins**: Continuously checks lock
- **No blocking**: Thread stays runnable
- **Low latency**: Fast when lock available
- **Wastes CPU**: Spins while waiting

### When to Use Spinlocks

**Good For**:
- **Short critical sections**: Lock held briefly
- **Low contention**: Few threads competing
- **Cannot block**: Interrupt handlers, kernel code
- **Low latency**: Need fast acquisition

**Bad For**:
- **Long critical sections**: Wastes CPU
- **High contention**: Many threads spinning
- **User-space**: Usually better to block

### Spinlock Implementation

**Simple Spinlock**:
```c
typedef struct {
    volatile int locked;
} spinlock_t;

void spin_lock(spinlock_t *lock) {
    while (__sync_lock_test_and_set(&lock->locked, 1)) {
        // Spin
        while (lock->locked) {
            cpu_pause(); // Hint to CPU
        }
    }
}

void spin_unlock(spinlock_t *lock) {
    __sync_lock_release(&lock->locked);
}
```

**Optimizations**:
- **CPU pause**: Reduces power consumption
- **Exponential backoff**: Wait longer between checks
- **Yield**: Give up CPU after spinning

### Spinlock vs Mutex

**Spinlock**:
- **Spins**: Busy-waits
- **Low latency**: Fast when available
- **Wastes CPU**: While spinning
- **Use**: Short CS, low contention

**Mutex**:
- **Blocks**: Yields CPU
- **Higher latency**: Context switch overhead
- **Efficient**: No CPU waste
- **Use**: Long CS, high contention

## Read-Write Lock

### What is a Read-Write Lock?

**Read-Write Lock**: Allows multiple readers or one writer

**Characteristics**:
- **Multiple readers**: Can read concurrently
- **Single writer**: Exclusive write access
- **Reader-writer exclusion**: Writers exclude readers
- **Writer-writer exclusion**: Writers exclude each other

### RW Lock Operations

**Read Lock**:
```c
pthread_rwlock_rdlock(&rwlock);
// Multiple threads can read
pthread_rwlock_unlock(&rwlock);
```

**Write Lock**:
```c
pthread_rwlock_wrlock(&rwlock);
// Exclusive write access
pthread_rwlock_unlock(&rwlock);
```

### RW Lock Implementation

**Basic Structure**:
```c
typedef struct {
    int readers;        // Number of readers
    int writer;         // Writer present (0 or 1)
    pthread_mutex_t mutex;
    pthread_cond_t read_cond;
    pthread_cond_t write_cond;
} rwlock_t;
```

**Read Lock**:
```c
void rwlock_rdlock(rwlock_t *rw) {
    pthread_mutex_lock(&rw->mutex);
    while (rw->writer > 0) {
        // Wait for writer to finish
        pthread_cond_wait(&rw->read_cond, &rw->mutex);
    }
    rw->readers++;
    pthread_mutex_unlock(&rw->mutex);
}
```

**Write Lock**:
```c
void rwlock_wrlock(rwlock_t *rw) {
    pthread_mutex_lock(&rw->mutex);
    while (rw->writer > 0 || rw->readers > 0) {
        // Wait for readers and writers
        pthread_cond_wait(&rw->write_cond, &rw->mutex);
    }
    rw->writer = 1;
    pthread_mutex_unlock(&rw->mutex);
}
```

### RW Lock Policies

**1. Reader Preference**:
- Readers get priority
- Writers may starve
- Good for read-heavy workloads

**2. Writer Preference**:
- Writers get priority
- Readers may wait
- Good for write-heavy workloads

**3. Fair (FIFO)**:
- First come, first served
- No starvation
- More complex

## Condition Variables

### What is a Condition Variable?

**Condition Variable**: Synchronization for waiting on conditions

**Purpose**: Wait for condition to become true

**Operations**:
- **wait()**: Wait for condition
- **signal()**: Wake one waiter
- **broadcast()**: Wake all waiters

### Condition Variable Usage

**Pattern**:
```c
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
pthread_cond_t cond = PTHREAD_COND_INITIALIZER;
int condition = 0;

// Waiter
pthread_mutex_lock(&mutex);
while (!condition) {
    pthread_cond_wait(&cond, &mutex);
}
// Condition is true
pthread_mutex_unlock(&mutex);

// Signaler
pthread_mutex_lock(&mutex);
condition = 1;
pthread_cond_signal(&cond);
pthread_mutex_unlock(&mutex);
```

**Why While Loop?**:
- **Spurious wakeups**: Can wake without signal
- **Multiple conditions**: Check condition again
- **Safety**: Always verify condition

### Producer-Consumer Example

```c
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
pthread_cond_t not_empty = PTHREAD_COND_INITIALIZER;
pthread_cond_t not_full = PTHREAD_COND_INITIALIZER;
queue_t queue;

// Producer
void producer() {
    pthread_mutex_lock(&mutex);
    while (queue_full(&queue)) {
        pthread_cond_wait(&not_full, &mutex);
    }
    enqueue(&queue, item);
    pthread_cond_signal(&not_empty);
    pthread_mutex_unlock(&mutex);
}

// Consumer
void consumer() {
    pthread_mutex_lock(&mutex);
    while (queue_empty(&queue)) {
        pthread_cond_wait(&not_empty, &mutex);
    }
    item = dequeue(&queue);
    pthread_cond_signal(&not_full);
    pthread_mutex_unlock(&mutex);
}
```

## Semaphores

### What is a Semaphore?

**Semaphore**: Counter-based synchronization

**Operations**:
- **wait() (P)**: Decrement, block if zero
- **post() (V)**: Increment, wake waiter

**Types**:
- **Binary semaphore**: 0 or 1 (like mutex)
- **Counting semaphore**: 0 to N

### Semaphore Implementation

**Basic Semaphore**:
```c
typedef struct {
    int count;
    pthread_mutex_t mutex;
    pthread_cond_t cond;
} semaphore_t;

void sem_wait(semaphore_t *sem) {
    pthread_mutex_lock(&sem->mutex);
    while (sem->count == 0) {
        pthread_cond_wait(&sem->cond, &sem->mutex);
    }
    sem->count--;
    pthread_mutex_unlock(&sem->mutex);
}

void sem_post(semaphore_t *sem) {
    pthread_mutex_lock(&sem->mutex);
    sem->count++;
    pthread_cond_signal(&sem->cond);
    pthread_mutex_unlock(&sem->mutex);
}
```

### Semaphore Use Cases

**1. Resource Pool**:
```c
semaphore_t pool_sem; // Initialized to pool size

void get_resource() {
    sem_wait(&pool_sem); // Wait for available resource
    // Use resource
}

void release_resource() {
    // Release resource
    sem_post(&pool_sem); // Signal availability
}
```

**2. Producer-Consumer**:
```c
semaphore_t empty_slots; // Initialized to buffer size
semaphore_t full_slots;  // Initialized to 0

// Producer
sem_wait(&empty_slots); // Wait for empty slot
enqueue(item);
sem_post(&full_slots);  // Signal item available

// Consumer
sem_wait(&full_slots);  // Wait for item
item = dequeue();
sem_post(&empty_slots); // Signal slot empty
```

## Barriers

### What is a Barrier?

**Barrier**: Synchronization point for multiple threads

**Purpose**: Wait until all threads reach barrier

**Use Case**: Parallel algorithms, phases

### Barrier Implementation

```c
typedef struct {
    int count;          // Number of threads
    int arrived;        // Threads that arrived
    pthread_mutex_t mutex;
    pthread_cond_t cond;
} barrier_t;

void barrier_wait(barrier_t *barrier) {
    pthread_mutex_lock(&barrier->mutex);
    barrier->arrived++;
    if (barrier->arrived == barrier->count) {
        // Last thread: wake all
        barrier->arrived = 0;
        pthread_cond_broadcast(&barrier->cond);
    } else {
        // Wait for others
        while (barrier->arrived != 0) {
            pthread_cond_wait(&barrier->cond, &barrier->mutex);
        }
    }
    pthread_mutex_unlock(&barrier->mutex);
}
```

### Barrier Example

```c
barrier_t barrier; // Initialized to thread count

void* worker(void* arg) {
    // Phase 1
    do_work_phase1();
    barrier_wait(&barrier); // Wait for all
    
    // Phase 2 (all threads synchronized)
    do_work_phase2();
    barrier_wait(&barrier);
    
    return NULL;
}
```

## Performance Considerations

### Lock Contention

**High Contention**:
- Many threads compete for lock
- Performance degrades
- Consider: Fine-grained locking, lock-free algorithms

**Low Contention**:
- Few threads compete
- Good performance
- Mutex or spinlock fine

### Lock Granularity

**Coarse-Grained**:
```c
// BAD: One lock for everything
pthread_mutex_lock(&big_lock);
update_data1();
update_data2();
update_data3();
pthread_mutex_unlock(&big_lock);
```

**Fine-Grained**:
```c
// GOOD: Separate locks
pthread_mutex_lock(&lock1);
update_data1();
pthread_mutex_unlock(&lock1);

pthread_mutex_lock(&lock2);
update_data2();
pthread_mutex_unlock(&lock2);
```

**Trade-off**: More locks = more complexity, less contention

### Lock-Free Algorithms

**Alternative**: Avoid locks entirely

**Techniques**:
- **Atomic operations**: Compare-and-swap
- **Lock-free data structures**: Queues, stacks
- **Hazard pointers**: Memory management

**Benefits**:
- **No blocking**: No deadlocks
- **Better performance**: Under contention
- **Complexity**: Harder to implement correctly

## Common Pitfalls

### Problem: Deadlock

```c
// BAD: Lock ordering issue
// Thread 1:
pthread_mutex_lock(&lockA);
pthread_mutex_lock(&lockB); // Waits for Thread 2

// Thread 2:
pthread_mutex_lock(&lockB);
pthread_mutex_lock(&lockA); // Waits for Thread 1
// DEADLOCK!

// GOOD: Consistent lock ordering
// Always lock A before B
pthread_mutex_lock(&lockA);
pthread_mutex_lock(&lockB);
```

### Problem: Forgotten Unlock

```c
// BAD: Early return without unlock
pthread_mutex_lock(&mutex);
if (error) {
    return; // Forgot unlock!
}
pthread_mutex_unlock(&mutex);

// GOOD: Use RAII or try-finally
pthread_mutex_lock(&mutex);
try {
    if (error) {
        return;
    }
} finally {
    pthread_mutex_unlock(&mutex);
}
```

## Quiz

1. What is the main difference between mutex and spinlock?
   - **A)** Mutex is faster
   - **B)** Mutex blocks, spinlock spins
   - **C)** Spinlock is more secure
   - **D)** No difference

2. When should you use a read-write lock?
   - **A)** Always
   - **B)** When you have many readers and few writers
   - **C)** Never
   - **D)** Only for single-threaded code

3. Why use a while loop with condition variables?
   - **A)** For performance
   - **B)** To handle spurious wakeups and verify condition
   - **C)** It's required
   - **D)** No reason

**Answers:**
1. **B** - Mutex blocks the thread (yields CPU), while spinlock spins (busy-waits)
2. **B** - Read-write locks are beneficial when you have many concurrent readers and occasional writers
3. **B** - The while loop handles spurious wakeups and ensures the condition is actually true before proceeding

## Next Steps

- [Futex Internals](./07.%20Futex%20Internals.md) - Linux futex implementation
- [Memory Barriers & Acquire/Release Semantics](./08.%20Memory%20Barriers%20%26%20Acquire-Release%20Semantics.md) - Memory ordering

