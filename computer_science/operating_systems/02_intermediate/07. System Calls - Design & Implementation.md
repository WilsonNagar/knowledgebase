---
number: 7
title: "System Calls - Design & Implementation"
slug: "system-calls-design-implementation"
level: "intermediate"
tags: ["operating-systems", "system-calls", "syscalls", "kernel", "api"]
prerequisites: ["kernel-architecture-monolithic-microkernel"]
estimated_minutes: 100
contributors: []
diagrams: []
examples: []
canonical_id: "cs-os-07"
---

# System Calls - Design & Implementation

## Overview

System calls are the interface between user applications and the operating system kernel. Understanding how system calls work, their design, implementation, and performance characteristics is essential for system programming, performance optimization, and understanding OS internals.

## Table of Contents

1. [What are System Calls?](#what-are-syscalls)
2. [Why System Calls?](#why-syscalls)
3. [System Call Interface](#interface)
4. [System Call Implementation](#implementation)
5. [System Call Table](#syscall-table)
6. [System Call Execution](#execution)
7. [Common System Calls](#common-syscalls)
8. [Performance Considerations](#performance)

## What are System Calls?

### Definition

**System Call**: Request to kernel for service

**Purpose**: User programs request kernel services

**Examples**:
- **File operations**: open, read, write, close
- **Process management**: fork, exec, exit
- **Memory management**: mmap, brk
- **Network**: socket, bind, connect

### User Space vs Kernel Space

**User Space**:
- **Applications**: User programs run here
- **Limited**: Cannot access hardware directly
- **Protected**: Isolated from kernel

**Kernel Space**:
- **OS**: Kernel runs here
- **Privileged**: Full hardware access
- **Protected**: Isolated from user programs

**System Call**: Bridge between user and kernel space

## Why System Calls?

### The Problem

**User Programs Need**:
- File I/O
- Network access
- Process creation
- Memory allocation

**But Cannot**:
- Access hardware directly
- Modify kernel data structures
- Execute privileged instructions

**Solution**: System calls (kernel does it for user)

### Protection

**Hardware Protection**:
- **CPU modes**: User mode vs kernel mode
- **Privileged instructions**: Only in kernel mode
- **Memory protection**: User cannot access kernel memory

**System Calls**: Controlled entry point to kernel

## System Call Interface

### POSIX System Calls

**POSIX**: Portable Operating System Interface

**Standard**: Defines system call interface

**Examples**:
```c
int open(const char *pathname, int flags);
ssize_t read(int fd, void *buf, size_t count);
ssize_t write(int fd, const void *buf, size_t count);
int close(int fd);
pid_t fork(void);
int execve(const char *pathname, char *const argv[]);
```

### System Call Wrappers

**C Library**: Provides wrappers

**Example**:
```c
// User code
int fd = open("file.txt", O_RDONLY);

// C library wrapper
int open(const char *pathname, int flags) {
    return syscall(SYS_open, pathname, flags);
}

// Actual system call
syscall(SYS_open, ...)
```

## System Call Implementation

### System Call Mechanism

**Process**:
```
1. User program calls library function
2. Library function invokes system call
3. CPU switches to kernel mode
4. Kernel executes system call handler
5. Kernel returns to user mode
6. Library function returns to user program
```

### x86-64 System Call

**Method**: SYSCALL instruction

**Registers**:
- **RAX**: System call number
- **RDI, RSI, RDX, R10, R8, R9**: Arguments
- **RCX**: Return address (saved by CPU)
- **R11**: Flags (saved by CPU)

**Example**:
```asm
mov rax, 0    ; SYS_read
mov rdi, 0    ; fd (stdin)
mov rsi, buf  ; buffer
mov rdx, 100  ; count
syscall       ; Invoke system call
```

### ARM64 System Call

**Method**: SVC (Supervisor Call) instruction

**Registers**:
- **X8**: System call number
- **X0-X5**: Arguments
- **X0**: Return value

**Example**:
```asm
mov x8, #63   ; SYS_read
mov x0, #0    ; fd
mov x1, buf   ; buffer
mov x2, #100  ; count
svc #0        ; Invoke system call
```

## System Call Table

### What is Syscall Table?

**Syscall Table**: Maps system call numbers to handlers

**Purpose**: Dispatch system calls to correct handler

**Structure**:
```c
typedef long (*sys_call_ptr_t)(...);

sys_call_ptr_t sys_call_table[] = {
    [0] = sys_read,
    [1] = sys_write,
    [2] = sys_open,
    [3] = sys_close,
    // ...
};
```

### System Call Numbers

**Linux x86-64**:
```
0: read
1: write
2: open
3: close
4: stat
5: fstat
// ... (hundreds more)
```

**Finding Numbers**:
```bash
# Find system call number
grep __NR_read /usr/include/asm/unistd_64.h
# Output: #define __NR_read 0
```

## System Call Execution

### Execution Flow

**Step 1: User Invocation**:
```c
int fd = open("file.txt", O_RDONLY);
```

**Step 2: Library Wrapper**:
```c
// glibc wrapper
int open(const char *pathname, int flags) {
    return INLINE_SYSCALL(open, 2, pathname, flags);
}
```

**Step 3: System Call Invocation**:
```asm
mov rax, 2      ; SYS_open
mov rdi, pathname
mov rsi, flags
syscall         ; Switch to kernel mode
```

**Step 4: Kernel Entry**:
```c
// Kernel entry point
entry_SYSCALL_64:
    swapgs
    mov %rsp, PER_CPU_VAR(rsp_scratch)
    mov PER_CPU_VAR(cpu_current_top_of_stack), %rsp
    // Save registers
    // Call do_syscall_64
```

**Step 5: System Call Handler**:
```c
long do_syscall_64(struct pt_regs *regs) {
    unsigned long nr = regs->orig_ax;
    
    if (nr < NR_syscalls) {
        regs->ax = sys_call_table[nr](regs);
    }
    
    return regs->ax;
}
```

**Step 6: Actual Handler**:
```c
long sys_open(const char __user *filename, int flags, umode_t mode) {
    // Kernel implementation
    // Access file system
    // Return file descriptor
}
```

**Step 7: Return to User**:
```asm
sysret          ; Return to user mode
```

### Context Switch

**What Happens**:
1. **Save user context**: Registers, stack pointer
2. **Switch to kernel stack**: Use kernel stack
3. **Execute kernel code**: In kernel mode
4. **Restore user context**: Restore registers
5. **Return to user**: Switch back to user mode

**Cost**: ~100-1000 nanoseconds

## Common System Calls

### File Operations

**open**:
```c
int fd = open("/path/to/file", O_RDONLY);
// Returns file descriptor
```

**read**:
```c
ssize_t n = read(fd, buffer, size);
// Reads data from file
```

**write**:
```c
ssize_t n = write(fd, buffer, size);
// Writes data to file
```

**close**:
```c
close(fd);
// Closes file descriptor
```

### Process Operations

**fork**:
```c
pid_t pid = fork();
// Creates new process (child)
// Returns 0 in child, child PID in parent
```

**execve**:
```c
execve("/bin/ls", argv, envp);
// Replaces current process image
```

**exit**:
```c
exit(0);
// Terminates process
```

### Memory Operations

**mmap**:
```c
void* addr = mmap(NULL, size, PROT_READ|PROT_WRITE, 
                  MAP_PRIVATE, fd, 0);
// Maps file to memory
```

**brk**:
```c
void* new_brk = brk(addr);
// Changes program break (heap size)
```

## Performance Considerations

### System Call Overhead

**Costs**:
- **Mode switch**: User ↔ Kernel (~100ns)
- **Context save/restore**: Registers, stack (~100ns)
- **Cache effects**: TLB flush, cache misses (~100ns)
- **Total**: ~300-1000ns per system call

### Reducing Overhead

**1. Batch Operations**:
```c
// BAD: Many system calls
for (int i = 0; i < 1000; i++) {
    write(fd, &data[i], 1); // 1000 system calls
}

// GOOD: Batch writes
write(fd, data, 1000); // 1 system call
```

**2. Avoid Unnecessary Calls**:
```c
// BAD: Check then do
if (access("file", F_OK) == 0) {
    open("file", O_RDONLY); // Two system calls
}

// GOOD: Try directly
int fd = open("file", O_RDONLY);
if (fd < 0) {
    // Handle error
}
```

**3. Use Alternatives**:
```c
// BAD: System call for each operation
for (int i = 0; i < n; i++) {
    gettimeofday(&tv, NULL); // System call
}

// GOOD: Use vDSO (virtual dynamic shared object)
// gettimeofday may use vDSO (no system call)
```

### vDSO (Virtual Dynamic Shared Object)

**Purpose**: Some system calls optimized

**Implementation**: Code in user space

**Benefits**: No mode switch needed

**Examples**: gettimeofday, clock_gettime

## Real-World Examples

### Example 1: File Copy

```c
// System calls used:
int src_fd = open("source.txt", O_RDONLY);  // sys_open
int dst_fd = open("dest.txt", O_WRONLY|O_CREAT, 0644); // sys_open

char buffer[4096];
ssize_t n;
while ((n = read(src_fd, buffer, sizeof(buffer))) > 0) { // sys_read
    write(dst_fd, buffer, n); // sys_write
}

close(src_fd);  // sys_close
close(dst_fd);  // sys_close
```

### Example 2: Process Creation

```c
pid_t pid = fork(); // sys_fork
if (pid == 0) {
    // Child process
    execve("/bin/ls", argv, envp); // sys_execve
} else {
    // Parent process
    wait(NULL); // sys_wait4
}
```

## Common Pitfalls

### Problem: Assuming System Calls are Fast

```c
// BAD: Many system calls in loop
for (int i = 0; i < 1000000; i++) {
    getpid(); // System call each iteration
}

// GOOD: Cache result or avoid
pid_t my_pid = getpid(); // Once
// Use my_pid
```

### Problem: Not Handling Errors

```c
// BAD: Ignore return value
open("file", O_RDONLY); // May fail!

// GOOD: Check return value
int fd = open("file", O_RDONLY);
if (fd < 0) {
    perror("open");
    exit(1);
}
```

## Quiz

1. What is the main purpose of system calls?
   - **A)** Improve performance
   - **B)** Provide controlled interface for user programs to request kernel services
   - **C)** Simplify programming
   - **D)** Encrypt data

2. What happens during a system call?
   - **A)** Nothing special
   - **B)** CPU switches to kernel mode, kernel executes handler, returns to user mode
   - **C)** Only mode switch
   - **D)** Only context switch

3. What is the main performance cost of system calls?
   - **A)** CPU usage
   - **B)** Mode switching, context saving, and cache effects
   - **C)** Memory usage
   - **D)** Disk I/O

**Answers:**
1. **B** - System calls provide a controlled, secure interface allowing user programs to request kernel services while maintaining system protection
2. **B** - During a system call, the CPU switches to kernel mode, the kernel executes the system call handler, and then returns to user mode
3. **B** - The main performance costs are mode switching (user↔kernel), context saving/restoring, and cache/TLB effects, totaling ~300-1000ns per call

## Next Steps

- [Interrupts & Traps](./08.%20Interrupts%20%26%20Traps.md) - Hardware interrupts
- [I/O Subsystems](./09.%20I-O%20Subsystems%20-%20Block%20Devices%20%26%20DMA.md) - Block devices, DMA

