---
number: 1
title: "Advanced Trees - AVL, Red-Black, B-Trees"
slug: "advanced-trees-avl-red-black-b-trees"
level: "intermediate"
tags: ["data-structures", "trees", "avl", "red-black", "b-trees", "algorithms"]
prerequisites: []
estimated_minutes: 130
contributors: []
diagrams: []
examples: []
canonical_id: "cs-dsa-01"
---

# Advanced Trees - AVL, Red-Black, B-Trees

## Overview

Advanced tree data structures provide efficient search, insertion, and deletion operations while maintaining balance. Understanding AVL trees, Red-Black trees, and B-trees is essential for database systems, file systems, and high-performance applications. This comprehensive guide covers their properties, operations, and use cases.

## Table of Contents

1. [Why Balanced Trees?](#why-balanced)
2. [AVL Trees](#avl-trees)
3. [Red-Black Trees](#red-black)
4. [B-Trees](#b-trees)
5. [B+ Trees](#b-plus)
6. [Comparison & Use Cases](#comparison)
7. [Implementation Details](#implementation)

## Why Balanced Trees?

### The Problem with Unbalanced Trees

**Unbalanced BST**:
```
    1
     \
      2
       \
        3
         \
          4
           \
            5
```

**Problems**:
- **Height**: O(n) in worst case
- **Operations**: O(n) instead of O(log n)
- **Performance**: Degrades to linked list

**Solution**: Self-balancing trees

### Balance Requirements

**Goals**:
- **Height**: O(log n)
- **Operations**: O(log n)
- **Balance**: Maintain balance after operations

**Trade-offs**:
- **More complex**: Harder to implement
- **More overhead**: Balance maintenance
- **Better performance**: Guaranteed O(log n)

## AVL Trees

### What is an AVL Tree?

**AVL**: Adelson-Velsky and Landis

**Property**: Height-balanced binary search tree

**Balance Factor**: Height(left) - Height(right)

**Requirement**: Balance factor ∈ {-1, 0, 1}

### AVL Tree Properties

**1. Binary Search Tree Property**:
- Left subtree < root < right subtree

**2. AVL Property**:
- |height(left) - height(right)| ≤ 1

**3. Height**:
- Height = O(log n)
- Maximum height ≈ 1.44 × log₂(n)

### Rotations

**Purpose**: Restore balance after insertion/deletion

**Types**:
1. **Right Rotation** (Left-Left case)
2. **Left Rotation** (Right-Right case)
3. **Left-Right Rotation** (Left-Right case)
4. **Right-Left Rotation** (Right-Left case)

### Right Rotation

**When**: Left subtree taller, left child's left subtree taller

**Operation**:
```
    Before:          After:
        z               y
       / \            / \
      y   T4         x   z
     / \     →      / \ / \
    x   T3        T1 T2 T3 T4
   / \
  T1 T2
```

**Code**:
```c
Node* right_rotate(Node* z) {
    Node* y = z->left;
    Node* T3 = y->right;
    
    y->right = z;
    z->left = T3;
    
    // Update heights
    z->height = max(height(z->left), height(z->right)) + 1;
    y->height = max(height(y->left), height(y->right)) + 1;
    
    return y; // New root
}
```

### Left Rotation

**When**: Right subtree taller, right child's right subtree taller

**Operation**:
```
    Before:          After:
        z               y
       / \            / \
      T1  y          z   x
         / \   →    / \ / \
        T2  x     T1 T2 T3 T4
           / \
          T3 T4
```

### Left-Right Rotation

**When**: Left subtree taller, left child's right subtree taller

**Operation**:
```
    Before:          After:
        z               z               x
       / \            / \             / \
      y   T4         x   T4          y   z
     / \      →     / \       →     / \ / \
    T1  x          y   T3         T1 T2 T3 T4
       / \        / \
      T2 T3      T1 T2
```

**Steps**:
1. Left rotate y
2. Right rotate z

### AVL Insertion

**Algorithm**:
```
1. Insert like BST
2. Update heights
3. Calculate balance factor
4. If unbalanced:
   a. Left-Left: Right rotate
   b. Right-Right: Left rotate
   c. Left-Right: Left rotate, then right rotate
   d. Right-Left: Right rotate, then left rotate
```

**Time Complexity**: O(log n)

### AVL Deletion

**Algorithm**:
```
1. Delete like BST
2. Update heights
3. Calculate balance factor
4. If unbalanced: Rotate (same cases as insertion)
```

**Time Complexity**: O(log n)

## Red-Black Trees

### What is a Red-Black Tree?

**Red-Black Tree**: Self-balancing BST with color property

**Properties**:
1. Every node is red or black
2. Root is black
3. Red nodes cannot have red children
4. Every path from root to leaf has same number of black nodes
5. Null leaves are black

### Red-Black Tree Properties

**Height**: O(log n)

**Maximum Height**: 2 × log₂(n+1)

**Balance**: Less strict than AVL (more rotations allowed)

### Insertion

**Algorithm**:
```
1. Insert like BST (new node is RED)
2. If parent is BLACK: Done
3. If parent is RED: Fix violations
   a. Uncle is RED: Recolor
   b. Uncle is BLACK: Rotate
```

**Cases**:

**Case 1: Uncle is RED**:
```
      Black (G)
     /        \
   Red(P)    Red(U)
   /
 Red(N)

Fix: Recolor
      Red (G)
     /        \
  Black(P)  Black(U)
   /
 Red(N)
```

**Case 2: Uncle is BLACK, Left-Left**:
```
      Black (G)
     /
   Red(P)
   /
 Red(N)

Fix: Right rotate G, recolor
      Red (P)
     /        \
  Black(N)  Black(G)
```

**Case 3: Uncle is BLACK, Left-Right**:
```
      Black (G)
     /
   Red(P)
     \
     Red(N)

Fix: Left rotate P, then right rotate G
```

### Deletion

**Algorithm**:
```
1. Delete like BST
2. If deleted node was RED: Done
3. If deleted node was BLACK: Fix double-black
   a. Sibling is RED: Rotate and recolor
   b. Sibling is BLACK with red child: Rotate and recolor
   c. Sibling is BLACK with black children: Recolor
```

**Complex**: More cases than insertion

**Time Complexity**: O(log n)

## B-Trees

### What is a B-Tree?

**B-Tree**: Self-balancing tree with multiple keys per node

**Purpose**: Optimize for disk I/O

**Properties**:
1. All leaves at same level
2. Internal nodes have 2 to t children (t = minimum degree)
3. Root has 1 to 2t-1 keys (or 2 to 2t children if not leaf)
4. Internal nodes have t-1 to 2t-1 keys

### B-Tree Structure

**Node Structure**:
```
┌─────────────────────────┐
│ [Key1] [Key2] [Key3]    │
│ /    \  /   \  /    \   │
│Child1 Child2 Child3 Child4│
└─────────────────────────┘
```

**Example** (t=3, max 5 keys, max 6 children):
```
        [20, 40]
       /    |    \
   [10,15] [25,30] [50,60]
```

### B-Tree Properties

**Height**: O(log_t n) where t = minimum degree

**Typical t**: 100-1000 (for disk blocks)

**Height**: Very shallow (2-3 levels for millions of keys)

### B-Tree Search

**Algorithm**:
```
1. Start at root
2. Find key in node (or range)
3. Follow appropriate child pointer
4. Repeat until found or leaf
```

**Time Complexity**: O(log_t n)

**Disk Accesses**: O(height) = O(log_t n)

### B-Tree Insertion

**Algorithm**:
```
1. Search for insertion point
2. Insert in leaf
3. If leaf full (2t-1 keys):
   a. Split leaf
   b. Promote middle key to parent
   c. If parent full: Split parent (recursive)
```

**Example** (t=3, inserting 25):
```
Before: [20, 30, 40, 50] (full, 4 keys)
After split:
  [20, 30] [40, 50]
  Promote 35 (middle) to parent
```

**Time Complexity**: O(log_t n)

### B-Tree Deletion

**Algorithm**:
```
1. Search for key
2. If in internal node:
   a. Replace with predecessor/successor
   b. Delete from leaf
3. If in leaf:
   a. Delete directly
   b. If underflow (< t-1 keys): Merge or borrow
```

**Complex**: Many cases

**Time Complexity**: O(log_t n)

## B+ Trees

### What is a B+ Tree?

**B+ Tree**: Variant of B-tree optimized for databases

**Differences from B-Tree**:
1. **Keys in leaves**: All keys appear in leaves
2. **Leaf links**: Leaves linked for range queries
3. **Internal keys**: Only separators (not data)

### B+ Tree Structure

**Internal Node**:
```
┌─────────────────┐
│ [10] [20] [30]  │  (Separators only)
│ /  |  |  |  \   │
└─────────────────┘
```

**Leaf Node**:
```
┌─────────────────────────────┐
│ [10,data] [20,data] [30,data]│ → (next leaf)
└─────────────────────────────┘
```

### B+ Tree Advantages

**1. Range Queries**:
- **Efficient**: Follow leaf links
- **Sequential**: No tree traversal needed

**2. All Data in Leaves**:
- **Consistent**: Same access time
- **Cache friendly**: Leaves can be cached

**3. Higher Fanout**:
- **More keys**: Internal nodes only separators
- **Shallower**: Fewer levels

### Database Indexes

**B+ Trees**: Standard for database indexes

**Why**:
- **Disk optimized**: Few disk accesses
- **Range queries**: Efficient sequential access
- **Updates**: Efficient insertion/deletion

**Example**: MySQL InnoDB uses B+ trees

## Comparison & Use Cases

### Comparison Table

| Tree | Height | Rotations | Use Case |
|------|--------|-----------|----------|
| **AVL** | ~1.44 log n | Many | When lookups dominate |
| **Red-Black** | ~2 log n | Fewer | General purpose, std::map |
| **B-Tree** | log_t n | Splits | Disk-based storage |
| **B+ Tree** | log_t n | Splits | Database indexes |

### When to Use What

**AVL Trees**:
- **Use**: Lookup-heavy workloads
- **Avoid**: Many insertions/deletions
- **Example**: Dictionary, symbol table

**Red-Black Trees**:
- **Use**: General purpose, balanced operations
- **Avoid**: Lookup-only workloads
- **Example**: std::map (C++), TreeMap (Java)

**B-Trees**:
- **Use**: Disk-based storage, large datasets
- **Avoid**: In-memory only, small datasets
- **Example**: File systems, databases

**B+ Trees**:
- **Use**: Database indexes, range queries
- **Avoid**: Point queries only, small datasets
- **Example**: MySQL, PostgreSQL indexes

## Implementation Details

### AVL Tree Node

```c
typedef struct AVLNode {
    int key;
    struct AVLNode* left;
    struct AVLNode* right;
    int height;
} AVLNode;

int height(AVLNode* node) {
    if (node == NULL) return 0;
    return node->height;
}

int balance_factor(AVLNode* node) {
    if (node == NULL) return 0;
    return height(node->left) - height(node->right);
}
```

### Red-Black Tree Node

```c
typedef enum { RED, BLACK } Color;

typedef struct RBNode {
    int key;
    struct RBNode* left;
    struct RBNode* right;
    struct RBNode* parent;
    Color color;
} RBNode;
```

### B-Tree Node

```c
#define MAX_KEYS (2*t - 1)
#define MAX_CHILDREN (2*t)

typedef struct BTreeNode {
    int keys[MAX_KEYS];
    struct BTreeNode* children[MAX_CHILDREN];
    int num_keys;
    int is_leaf;
} BTreeNode;
```

## Real-World Examples

### Example 1: Database Index (B+ Tree)

**MySQL InnoDB**:
- Uses B+ trees for indexes
- Leaf nodes contain row data or pointers
- Internal nodes contain separators
- Supports range queries efficiently

### Example 2: File System (B-Tree)

**NTFS, HFS+**:
- Use B-trees for directory structure
- Efficient for large directories
- Few disk accesses needed

### Example 3: Standard Library (Red-Black)

**C++ std::map**:
- Implemented as Red-Black tree
- Balanced operations
- O(log n) guarantees

## Common Pitfalls

### Problem: Not Maintaining Balance

```c
// BAD: Insert without rebalancing
void insert_bad(Node* root, int key) {
    if (root == NULL) {
        return new_node(key);
    }
    if (key < root->key) {
        root->left = insert_bad(root->left, key);
    } else {
        root->right = insert_bad(root->right, key);
    }
    return root; // No rebalancing!
}

// GOOD: Rebalance after insertion
Node* insert_good(Node* root, int key) {
    // ... insertion ...
    root->height = update_height(root);
    int balance = balance_factor(root);
    
    if (balance > 1) {
        // Rebalance
    }
    return root;
}
```

## Quiz

1. What is the main advantage of AVL trees over Red-Black trees?
   - **A)** Simpler implementation
   - **B)** Stricter balance (better lookup performance)
   - **C)** Fewer rotations
   - **D)** Lower memory usage

2. Why are B-trees used for disk-based storage?
   - **A)** Simpler than binary trees
   - **B)** Optimize for disk I/O (fewer disk accesses)
   - **C)** Faster in-memory operations
   - **D)** Lower memory usage

3. What is the key difference between B-trees and B+ trees?
   - **A)** B+ trees are binary
   - **B)** B+ trees store all keys in leaves and link leaves for range queries
   - **C)** B+ trees don't allow deletions
   - **D)** B+ trees are always balanced

**Answers:**
1. **B** - AVL trees maintain stricter balance (height difference ≤ 1) which provides better lookup performance, though they require more rotations
2. **B** - B-trees optimize for disk I/O by having high fanout (many keys per node), resulting in very shallow trees and fewer disk accesses
3. **B** - B+ trees store all keys in leaf nodes and link leaves together, making range queries very efficient by following leaf links sequentially

## Next Steps

- [Graph Algorithms - Dijkstra & A*](./02.%20Graph%20Algorithms%20-%20Dijkstra%20%26%20A-Star.md) - Graph traversal
- [Hash Tables & Hashing](./03.%20Hash%20Tables%20%26%20Hashing.md) - Hash-based structures

