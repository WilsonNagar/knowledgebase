---
number: 5
title: "Advanced Data Structures - Tries, Segment Trees"
slug: "advanced-data-structures-tries-segment-trees"
level: "intermediate"
tags: ["data-structures", "tries", "segment-trees", "fenwick-trees", "algorithms"]
prerequisites: ["hash-tables-hashing"]
estimated_minutes: 125
contributors: []
diagrams: []
examples: []
canonical_id: "cs-dsa-05"
---

# Advanced Data Structures - Tries, Segment Trees

## Overview

Advanced data structures like tries and segment trees solve specific problems efficiently. Understanding tries for string operations, segment trees for range queries, and Fenwick trees for prefix sums is essential for competitive programming and efficient algorithm design.

## Table of Contents

1. [Tries Overview](#tries-overview)
2. [Trie Implementation](#trie-implementation)
3. [Trie Applications](#trie-applications)
4. [Segment Trees](#segment-trees)
5. [Segment Tree Operations](#segment-operations)
6. [Fenwick Trees](#fenwick-trees)
7. [Comparison](#comparison)
8. [Real-World Examples](#examples)

## Tries Overview

### What is a Trie?

**Trie**: Prefix tree

**Structure**: Tree where each node represents character

**Path**: Path from root to node = string

**Use**: String operations, autocomplete

### Trie Properties

**1. Prefix Sharing**:
```
"cat" and "car" share "ca"
```

**2. Efficient Lookup**:
```
O(m) where m = string length
```

**3. Space Efficient**:
```
Shares common prefixes
```

## Trie Implementation

### Trie Node Structure

```c
typedef struct TrieNode {
    struct TrieNode* children[26]; // For lowercase letters
    bool is_end; // Marks end of word
} TrieNode;
```

### Trie Operations

**Insert**:
```c
void insert(TrieNode* root, char* word) {
    TrieNode* node = root;
    for (int i = 0; word[i] != '\0'; i++) {
        int index = word[i] - 'a';
        if (node->children[index] == NULL) {
            node->children[index] = create_node();
        }
        node = node->children[index];
    }
    node->is_end = true;
}
```

**Search**:
```c
bool search(TrieNode* root, char* word) {
    TrieNode* node = root;
    for (int i = 0; word[i] != '\0'; i++) {
        int index = word[i] - 'a';
        if (node->children[index] == NULL) {
            return false;
        }
        node = node->children[index];
    }
    return node->is_end;
}
```

**Prefix Search**:
```c
bool starts_with(TrieNode* root, char* prefix) {
    TrieNode* node = root;
    for (int i = 0; prefix[i] != '\0'; i++) {
        int index = prefix[i] - 'a';
        if (node->children[index] == NULL) {
            return false;
        }
        node = node->children[index];
    }
    return true; // Prefix exists
}
```

## Trie Applications

### Application 1: Autocomplete

**Use**: Suggest completions

**Process**:
```
1. Build trie from dictionary
2. User types prefix
3. Traverse trie from prefix
4. Collect all words with prefix
```

### Application 2: Spell Checker

**Use**: Check if word exists

**Process**:
```
1. Build trie from dictionary
2. Check word in trie
3. If not found: Suggest similar words
```

### Application 3: IP Routing

**Use**: Longest prefix matching

**Process**:
```
1. Store routes in trie
2. Match IP address
3. Find longest matching prefix
```

## Segment Trees

### What is a Segment Tree?

**Segment Tree**: Tree for range queries

**Structure**: Binary tree

**Leaves**: Array elements

**Internal Nodes**: Aggregated values (sum, min, max)

**Use**: Range queries, range updates

### Segment Tree Structure

**Array**: [1, 3, 5, 7, 9, 11]

**Segment Tree**:
```
        [1,11]: 36
       /         \
  [1,5]: 9    [7,11]: 27
   / \          / \
[1,3]:4 [5,5]:5 [7,9]:16 [11,11]:11
/ \     |      / \       |
1  3    5     7  9       11
```

### Segment Tree Operations

**Build**: O(n)

**Query**: O(log n)

**Update**: O(log n)

## Segment Tree Operations

### Building Segment Tree

```c
void build(int* arr, int* tree, int node, int start, int end) {
    if (start == end) {
        tree[node] = arr[start];
    } else {
        int mid = (start + end) / 2;
        build(arr, tree, 2*node, start, mid);
        build(arr, tree, 2*node+1, mid+1, end);
        tree[node] = tree[2*node] + tree[2*node+1];
    }
}
```

### Range Query

```c
int query(int* tree, int node, int start, int end, 
          int l, int r) {
    if (r < start || l > end) {
        return 0; // Outside range
    }
    if (l <= start && end <= r) {
        return tree[node]; // Completely inside
    }
    int mid = (start + end) / 2;
    return query(tree, 2*node, start, mid, l, r) +
           query(tree, 2*node+1, mid+1, end, l, r);
}
```

### Point Update

```c
void update(int* tree, int node, int start, int end, 
            int idx, int val) {
    if (start == end) {
        tree[node] = val;
    } else {
        int mid = (start + end) / 2;
        if (idx <= mid) {
            update(tree, 2*node, start, mid, idx, val);
        } else {
            update(tree, 2*node+1, mid+1, end, idx, val);
        }
        tree[node] = tree[2*node] + tree[2*node+1];
    }
}
```

## Fenwick Trees

### What is a Fenwick Tree?

**Fenwick Tree**: Binary Indexed Tree

**Purpose**: Prefix sums efficiently

**Operations**: 
- **Update**: O(log n)
- **Query**: O(log n)

**Space**: O(n)

### Fenwick Tree Structure

**Array**: [1, 3, 5, 7, 9, 11]

**Fenwick Tree**: Stores prefix sums

**Indexing**: Uses binary representation

### Fenwick Tree Operations

**Update**:
```c
void update(int* fenwick, int n, int idx, int delta) {
    idx++;
    while (idx <= n) {
        fenwick[idx] += delta;
        idx += idx & -idx; // Add least significant bit
    }
}
```

**Query**:
```c
int query(int* fenwick, int idx) {
    idx++;
    int sum = 0;
    while (idx > 0) {
        sum += fenwick[idx];
        idx -= idx & -idx; // Remove least significant bit
    }
    return sum;
}
```

## Comparison

### Segment Tree vs Fenwick Tree

| Aspect | Segment Tree | Fenwick Tree |
|--------|--------------|--------------|
| **Range Query** | Any range | Prefix only |
| **Range Update** | Yes | Point only |
| **Code Complexity** | More complex | Simpler |
| **Space** | O(4n) | O(n) |

### When to Use What

**Trie**: String operations, prefix matching

**Segment Tree**: Range queries, range updates

**Fenwick Tree**: Prefix sums, point updates

## Real-World Examples

### Example 1: Autocomplete (Trie)

**Use**: Search suggestions

**Implementation**: Trie stores all words

**Query**: Prefix â†’ All words with prefix

### Example 2: Range Sum (Segment Tree)

**Use**: Sum of subarray

**Query**: Sum from index i to j

**Update**: Update element at index i

### Example 3: Prefix Sums (Fenwick Tree)

**Use**: Cumulative sums

**Query**: Sum from 0 to i

**Update**: Update element

## Common Pitfalls

### Problem: Not Handling Empty Trie

```c
// BAD: Assume trie not empty
search(root, word); // May crash if root NULL

// GOOD: Check empty
if (root == NULL) return false;
```

### Problem: Segment Tree Size

```c
// BAD: Array size = n
int tree[n]; // Too small!

// GOOD: Size = 4n
int tree[4*n]; // Safe
```

## Quiz

1. What is a trie used for?
   - **A)** Sorting
   - **B)** String operations like prefix matching and autocomplete
   - **C)** Hashing
   - **D)** Searching numbers

2. What is a segment tree used for?
   - **A)** String matching
   - **B)** Efficient range queries and updates
   - **C)** Hashing
   - **D)** Sorting

3. What is the main advantage of Fenwick tree over segment tree?
   - **A)** More features
   - **B)** Simpler code and less space for prefix sum queries
   - **C)** Faster
   - **D)** More flexible

**Answers:**
1. **B** - Tries are used for string operations, particularly prefix matching (checking if strings start with a prefix) and autocomplete (finding all words with a given prefix)
2. **B** - Segment trees efficiently support range queries (like sum/min/max over a range) and range updates in O(log n) time
3. **B** - Fenwick trees are simpler to implement and use less space (O(n) vs O(4n)) when you only need prefix sum queries, though they're less flexible than segment trees

## Next Steps

- [Suffix Arrays & Trees](./06.%20Suffix%20Arrays%20%26%20Trees.md) - Advanced string structures
- [Bloom Filters & Probabilistic Data Structures](./07.%20Bloom%20Filters.md) - Probabilistic structures

