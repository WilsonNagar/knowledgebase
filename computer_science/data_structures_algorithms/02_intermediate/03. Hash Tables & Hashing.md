---
number: 3
title: "Hash Tables & Hashing"
slug: "hash-tables-hashing"
level: "intermediate"
tags: ["data-structures", "hash-tables", "hashing", "collision-resolution", "algorithms"]
prerequisites: []
estimated_minutes: 115
contributors: []
diagrams: []
examples: []
canonical_id: "cs-dsa-03"
---

# Hash Tables & Hashing

## Overview

Hash tables are fundamental data structures providing average O(1) insertion, deletion, and lookup. Understanding hash functions, collision resolution strategies, and hash table implementation is essential for efficient data storage and retrieval in many applications.

## Table of Contents

1. [What are Hash Tables?](#what-are-hash-tables)
2. [Hash Functions](#hash-functions)
3. [Collision Resolution](#collision-resolution)
4. [Chaining](#chaining)
5. [Open Addressing](#open-addressing)
6. [Load Factor & Rehashing](#load-factor)
7. [Hash Table Operations](#operations)
8. [Applications](#applications)

## What are Hash Tables?

### Definition

**Hash Table**: Data structure mapping keys to values

**Operation**: O(1) average case for insert, delete, lookup

**Structure**: Array + hash function

### Basic Concept

**Process**:
```
1. Key → Hash function → Index
2. Store value at index
3. Lookup: Key → Hash → Index → Value
```

**Example**:
```
Key: "apple"
Hash("apple") = 5
Store: table[5] = value
Lookup: table[5] → value
```

### Hash Table Structure

**Array**: Buckets/slots

**Hash Function**: Maps key to index

**Collision Handling**: When multiple keys map to same index

## Hash Functions

### Properties of Good Hash Functions

**1. Deterministic**: Same key → same hash

**2. Uniform Distribution**: Keys distributed evenly

**3. Fast**: Compute quickly

**4. Avalanche Effect**: Small key change → large hash change

### Simple Hash Functions

**Division Method**:
```c
int hash(int key, int table_size) {
    return key % table_size;
}
```

**Multiplication Method**:
```c
int hash(int key, int table_size) {
    double A = 0.6180339887; // (√5 - 1) / 2
    return (int)(table_size * ((key * A) % 1));
}
```

### String Hashing

**Simple Hash**:
```c
int hash_string(char* str, int table_size) {
    int hash = 0;
    for (int i = 0; str[i] != '\0'; i++) {
        hash = (hash * 31 + str[i]) % table_size;
    }
    return hash;
}
```

**djb2 Hash**:
```c
unsigned long hash_djb2(char* str) {
    unsigned long hash = 5381;
    int c;
    while ((c = *str++)) {
        hash = ((hash << 5) + hash) + c; // hash * 33 + c
    }
    return hash;
}
```

## Collision Resolution

### The Problem

**Collision**: Two keys hash to same index

**Example**:
```
hash("apple") = 5
hash("banana") = 5  // Collision!
```

**Solutions**: Chaining or Open Addressing

## Chaining

### What is Chaining?

**Chaining**: Store collisions in linked list

**Structure**: Array of linked lists

**Process**:
```
Index 5: [apple → value1] → [banana → value2] → NULL
```

### Chaining Operations

**Insert**:
```c
void insert_chaining(HashTable* ht, char* key, void* value) {
    int index = hash(key, ht->size);
    Node* node = create_node(key, value);
    node->next = ht->buckets[index];
    ht->buckets[index] = node;
}
```

**Lookup**:
```c
void* lookup_chaining(HashTable* ht, char* key) {
    int index = hash(key, ht->size);
    Node* node = ht->buckets[index];
    while (node != NULL) {
        if (strcmp(node->key, key) == 0) {
            return node->value;
        }
        node = node->next;
    }
    return NULL; // Not found
}
```

### Chaining Analysis

**Average Case**: O(1 + α) where α = n/m (load factor)

**Worst Case**: O(n) if all keys hash to same bucket

**Space**: O(n + m) where m = table size

## Open Addressing

### What is Open Addressing?

**Open Addressing**: Store collisions in other slots

**No chains**: All data in array

**Probing**: Find next available slot

### Probing Methods

**1. Linear Probing**:
```
h(k, i) = (hash(k) + i) % m
```

**2. Quadratic Probing**:
```
h(k, i) = (hash(k) + c₁i + c₂i²) % m
```

**3. Double Hashing**:
```
h(k, i) = (hash₁(k) + i × hash₂(k)) % m
```

### Linear Probing Example

**Insert**:
```
hash("apple") = 5 → table[5] (occupied)
Probe: table[6] (occupied)
Probe: table[7] (free) → Insert here
```

**Lookup**:
```
hash("apple") = 5 → table[5] (not "apple")
Probe: table[6] (not "apple")
Probe: table[7] ("apple") → Found!
```

### Open Addressing Operations

**Insert**:
```c
void insert_open_addressing(HashTable* ht, char* key, void* value) {
    int index = hash(key, ht->size);
    int i = 0;
    while (ht->table[index] != NULL && 
           ht->table[index] != DELETED &&
           strcmp(ht->table[index]->key, key) != 0) {
        index = (hash(key, ht->size) + i) % ht->size;
        i++;
    }
    ht->table[index] = create_entry(key, value);
}
```

**Lookup**:
```c
void* lookup_open_addressing(HashTable* ht, char* key) {
    int index = hash(key, ht->size);
    int i = 0;
    while (ht->table[index] != NULL) {
        if (ht->table[index] != DELETED &&
            strcmp(ht->table[index]->key, key) == 0) {
            return ht->table[index]->value;
        }
        index = (hash(key, ht->size) + i) % ht->size;
        i++;
        if (i >= ht->size) break; // Not found
    }
    return NULL;
}
```

### Deletion in Open Addressing

**Problem**: Cannot simply set to NULL (breaks lookup)

**Solution**: Use special marker (DELETED)

**Process**:
```
1. Mark as DELETED (not NULL)
2. Lookup: Skip DELETED entries
3. Insert: Can reuse DELETED slots
```

## Load Factor & Rehashing

### Load Factor

**Load Factor**: α = n / m

**Where**:
- **n**: Number of elements
- **m**: Table size

**Optimal**: 
- **Chaining**: α < 1 (can be > 1)
- **Open Addressing**: α < 0.7-0.8

### Rehashing

**When**: Load factor too high

**Process**:
```
1. Create larger table (typically 2× size)
2. Rehash all elements
3. Update table
```

**Example**:
```
Old table: size 10, 8 elements (α = 0.8)
New table: size 20
Rehash: All 8 elements
New α = 0.4
```

### Rehashing Implementation

```c
void rehash(HashTable* ht) {
    int old_size = ht->size;
    Entry** old_table = ht->table;
    
    ht->size *= 2;
    ht->table = calloc(ht->size, sizeof(Entry*));
    
    for (int i = 0; i < old_size; i++) {
        if (old_table[i] != NULL && old_table[i] != DELETED) {
            insert(ht, old_table[i]->key, old_table[i]->value);
        }
    }
    
    free(old_table);
}
```

## Hash Table Operations

### Insert

**Average**: O(1)

**Worst**: O(n) if many collisions

**Process**: Hash → Find slot → Insert

### Lookup

**Average**: O(1)

**Worst**: O(n) if many collisions

**Process**: Hash → Probe → Compare → Return

### Delete

**Average**: O(1)

**Worst**: O(n)

**Process**: Hash → Find → Mark deleted (open addressing) or remove (chaining)

## Applications

### Example 1: Dictionary/Map

**Use**: Fast key-value lookup

**Languages**: Python dict, Java HashMap, C++ unordered_map

**Performance**: O(1) average

### Example 2: Caching

**Use**: Cache frequently accessed data

**Example**: Memcached, Redis

**Benefit**: Fast lookup

### Example 3: Database Indexing

**Use**: Index database tables

**Benefit**: Fast record lookup

### Example 4: Deduplication

**Use**: Detect duplicates

**Process**: Hash items, check if seen

**Benefit**: O(1) duplicate detection

## Real-World Examples

### Example 1: Python Dictionary

**Implementation**: Open addressing with probing

**Features**: Dynamic resizing, good performance

**Use**: Core data structure

### Example 2: Java HashMap

**Implementation**: Chaining (Java 8+ uses tree for long chains)

**Features**: Thread-safe variants available

**Use**: Most common map implementation

## Common Pitfalls

### Problem: Poor Hash Function

```c
// BAD: Poor distribution
int hash(int key, int size) {
    return key % 10; // Only 10 buckets!
}
// Many collisions

// GOOD: Good distribution
int hash(int key, int size) {
    return key % size; // Use full range
}
```

### Problem: High Load Factor

```c
// BAD: Load factor too high
// Many collisions, poor performance

// GOOD: Rehash when load factor high
if (load_factor > 0.75) {
    rehash();
}
```

### Problem: Not Handling Deletions

```c
// BAD: Set to NULL in open addressing
table[index] = NULL;
// Breaks lookup for other keys!

// GOOD: Use DELETED marker
table[index] = DELETED;
```

## Quiz

1. What is the main advantage of hash tables?
   - **A)** Sorted data
   - **B)** Average O(1) insertion, deletion, and lookup
   - **C)** No collisions
   - **D)** Simple implementation

2. What is collision resolution?
   - **A)** Avoiding collisions
   - **B)** Handling when multiple keys hash to same index
   - **C)** Preventing hashing
   - **D)** Removing keys

3. What is the load factor?
   - **A)** Number of collisions
   - **B)** Ratio of elements to table size (n/m)
   - **C)** Hash function quality
   - **D)** Table size

**Answers:**
1. **B** - Hash tables provide average O(1) time complexity for insertion, deletion, and lookup operations, making them very efficient
2. **B** - Collision resolution handles the situation when multiple keys hash to the same index, using techniques like chaining or open addressing
3. **B** - Load factor α = n/m is the ratio of number of elements (n) to table size (m), indicating how full the table is

## Next Steps

- [String Algorithms - KMP & Z-Algorithm](../data_structures_algorithms/04.%20String%20Algorithms.md) - String matching
- [Advanced Data Structures](../data_structures_algorithms/05.%20Advanced%20Data%20Structures.md) - Tries, segment trees

