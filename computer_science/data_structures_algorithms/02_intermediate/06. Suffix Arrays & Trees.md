---
number: 6
title: "Suffix Arrays & Trees"
slug: "suffix-arrays-trees"
level: "intermediate"
tags: ["data-structures", "suffix-arrays", "suffix-trees", "string-algorithms", "advanced"]
prerequisites: ["string-algorithms-kmp-z-algorithm"]
estimated_minutes: 130
contributors: []
diagrams: []
examples: []
canonical_id: "cs-dsa-06"
---

# Suffix Arrays & Trees

## Overview

Suffix arrays and suffix trees are powerful data structures for string processing, enabling efficient pattern matching, longest common substring, and many other string operations. Understanding their construction and applications is essential for advanced string algorithms and bioinformatics.

## Table of Contents

1. [What are Suffixes?](#what-are-suffixes)
2. [Suffix Arrays](#suffix-arrays)
3. [Suffix Array Construction](#suffix-array-construction)
4. [Suffix Trees](#suffix-trees)
5. [Suffix Tree Construction](#suffix-tree-construction)
6. [Pattern Matching](#pattern-matching)
7. [Longest Common Substring](#lcs)
8. [Applications](#applications)

## What are Suffixes?

### Definition

**Suffix**: Substring starting at position i to end

**Example**: String "banana"
```
Suffixes:
  banana (position 0)
  anana (position 1)
  nana (position 2)
  ana (position 3)
  na (position 4)
  a (position 5)
```

**Total**: n suffixes for string of length n

## Suffix Arrays

### What is a Suffix Array?

**Suffix Array**: Array of sorted suffix indices

**Purpose**: Efficient string operations

**Space**: O(n) (vs O(n²) for suffix tree)

**Construction**: O(n log n) or O(n)

### Suffix Array Example

**String**: "banana"

**Suffixes**:
```
0: banana
1: anana
2: nana
3: ana
4: na
5: a
```

**Sorted**:
```
5: a
3: ana
1: anana
0: banana
4: na
2: nana
```

**Suffix Array**: [5, 3, 1, 0, 4, 2]

## Suffix Array Construction

### Naive Construction

**Algorithm**:
```
1. Generate all suffixes
2. Sort suffixes
3. Store indices
```

**Time**: O(n² log n) (sorting n strings of length up to n)

**Space**: O(n²)

### Efficient Construction

**Methods**:
- **Doubling**: O(n log² n)
- **DC3**: O(n) (complex)
- **SA-IS**: O(n) (simpler than DC3)

### Doubling Algorithm

**Idea**: Sort by prefixes of increasing length

**Process**:
```
1. Sort by first character
2. Sort by first 2 characters (using previous sort)
3. Sort by first 4 characters
4. Continue doubling
```

**Time**: O(n log² n)

## Suffix Trees

### What is a Suffix Tree?

**Suffix Tree**: Compressed trie of all suffixes

**Structure**: 
- **Edges**: Labeled with substrings
- **Nodes**: Branching points
- **Leaves**: Suffix indices

**Space**: O(n) with compression

**Construction**: O(n)

### Suffix Tree Example

**String**: "banana$" ($ = terminator)

**Tree**:
```
        root
       /    \
      b      a
     /      / \
    a      n   n
   /      /   / \
  n      a   a   a
 /      /   /   /
a      $   $   $
$
```

**Compressed**: Common prefixes shared

## Suffix Tree Construction

### Ukkonen's Algorithm

**Algorithm**: Online construction

**Time**: O(n)

**Process**:
```
1. Build tree incrementally
2. Add characters one by one
3. Maintain active point
4. Use suffix links for efficiency
```

**Complexity**: Linear time

### Key Concepts

**1. Active Point**:
```
Current position in tree
```

**2. Suffix Links**:
```
Links for efficient traversal
```

**3. Implicit/Explicit Nodes**:
```
Handle edge cases
```

## Pattern Matching

### Pattern Matching with Suffix Array

**Process**:
```
1. Binary search in suffix array
2. Find range of suffixes with prefix = pattern
3. All matches in that range
```

**Time**: O(m log n) where m = pattern length

**Example**:
```
Pattern: "ana"
Suffix Array: [5, 3, 1, 0, 4, 2]
Binary search → Range [1, 2]
Matches at positions 1, 3
```

### Pattern Matching with Suffix Tree

**Process**:
```
1. Traverse tree following pattern
2. If path exists: Pattern found
3. Collect all leaves in subtree
```

**Time**: O(m + k) where k = number of matches

**Faster**: Than suffix array for multiple queries

## Longest Common Substring

### Problem

**LCS**: Longest substring common to multiple strings

**Use**: Bioinformatics, plagiarism detection

### Solution with Suffix Tree

**Process**:
```
1. Build generalized suffix tree
2. Mark nodes with strings they belong to
3. Find deepest node with all strings
4. Path from root = LCS
```

**Time**: O(n) where n = total length

### Solution with Suffix Array

**Process**:
```
1. Build suffix array of concatenated strings
2. Compute LCP (Longest Common Prefix) array
3. Find maximum LCP with strings from different inputs
```

**Time**: O(n log n)

## Applications

### Application 1: Pattern Matching

**Use**: Find all occurrences of pattern

**Time**: O(m + k) with suffix tree

**Benefit**: Very fast

### Application 2: Longest Repeated Substring

**Use**: Find longest substring appearing twice

**Method**: Find deepest internal node in suffix tree

**Time**: O(n)

### Application 3: Bioinformatics

**Use**: DNA/RNA sequence analysis

**Applications**:
- **Pattern matching**: Find sequences
- **LCS**: Common sequences
- **Repeat finding**: Find repeats

### Application 4: Plagiarism Detection

**Use**: Find common text

**Method**: LCS between documents

**Benefit**: Efficient comparison

## Real-World Examples

### Example 1: DNA Sequence Search

**Problem**: Find pattern in DNA

**Solution**: Suffix tree/array

**Benefit**: Fast search in large sequences

### Example 2: Text Search Engine

**Problem**: Search in large text

**Solution**: Suffix array

**Benefit**: Efficient substring search

## Common Pitfalls

### Problem: Not Handling Terminator

```c
// BAD: No terminator
// Suffixes may be prefixes of others

// GOOD: Add unique terminator
string = "banana$"
```

### Problem: Memory Usage

```c
// BAD: Naive suffix tree
// O(n²) space

// GOOD: Compressed suffix tree
// O(n) space
```

## Quiz

1. What is a suffix array?
   - **A)** Array of strings
   - **B)** Array of sorted suffix indices
   - **C)** Array of prefixes
   - **D)** Array of characters

2. What is a suffix tree?
   - **A)** Tree of prefixes
   - **B)** Compressed trie of all suffixes
   - **C)** Binary tree
   - **D)** AVL tree

3. What is the time complexity of pattern matching with suffix tree?
   - **A)** O(n)
   - **B)** O(m + k) where m = pattern length, k = matches
   - **C)** O(n log n)
   - **D)** O(n²)

**Answers:**
1. **B** - A suffix array is an array containing the sorted indices of all suffixes of a string, enabling efficient string operations
2. **B** - A suffix tree is a compressed trie (prefix tree) containing all suffixes of a string, with common prefixes shared to save space
3. **B** - Pattern matching with a suffix tree takes O(m + k) time where m is the pattern length and k is the number of matches, by traversing the tree following the pattern

## Next Steps

- [Bloom Filters & Probabilistic Data Structures](../data_structures_algorithms/07.%20Bloom%20Filters.md) - Probabilistic structures
- [Advanced Graph Algorithms](../data_structures_algorithms/08.%20Advanced%20Graph%20Algorithms.md) - Graph algorithms

