---
number: 2
title: "Graph Algorithms - Dijkstra & A-Star"
slug: "graph-algorithms-dijkstra-astar"
level: "intermediate"
tags: ["algorithms", "graphs", "dijkstra", "a-star", "shortest-path"]
prerequisites: []
estimated_minutes: 120
contributors: []
diagrams: []
examples: []
canonical_id: "cs-dsa-02"
---

# Graph Algorithms - Dijkstra & A-Star

## Overview

Graph algorithms are fundamental to many computer science problems. Understanding Dijkstra's algorithm for shortest paths and A* for informed search is essential for pathfinding, routing, network analysis, and game development. This comprehensive guide covers both algorithms in detail with implementations and optimizations.

## Table of Contents

1. [Graph Basics Review](#graph-basics)
2. [Shortest Path Problem](#shortest-path)
3. [Dijkstra's Algorithm](#dijkstra)
4. [Dijkstra Implementation](#dijkstra-implementation)
5. [A* Algorithm](#astar)
6. [A* Implementation](#astar-implementation)
7. [Dijkstra vs A*](#comparison)
8. [Optimizations](#optimizations)
9. [Real-World Applications](#applications)

## Graph Basics Review

### Weighted Graphs

**Weighted Graph**: Edges have weights (costs)

**Example**:
```
    A
   / \
  3   5
 /     \
B-------C
   2
```

**Representation**:
- **Adjacency List**: `A → [(B, 3), (C, 5)]`
- **Adjacency Matrix**: Matrix with weights

### Path Weight

**Path Weight**: Sum of edge weights in path

**Example**: Path A → B → C
```
Weight = 3 + 2 = 5
```

## Shortest Path Problem

### Problem Definition

**Input**:
- **Graph**: G = (V, E) with weights
- **Source**: Starting vertex s
- **Destination**: Target vertex t (optional)

**Output**: Shortest path from s to t (or all vertices)

### Applications

**1. Navigation**:
- **GPS**: Find shortest route
- **Maps**: Route planning

**2. Network Routing**:
- **Internet**: Packet routing
- **Social networks**: Shortest connection path

**3. Game Development**:
- **Pathfinding**: NPC movement
- **AI**: Finding optimal paths

## Dijkstra's Algorithm

### Algorithm Overview

**Dijkstra**: Finds shortest paths from source to all vertices

**Assumption**: Non-negative edge weights

**Method**: Greedy algorithm

### Algorithm Steps

**1. Initialize**:
```
dist[s] = 0
dist[v] = ∞ for all v ≠ s
visited = {}
```

**2. Main Loop**:
```
While unvisited vertices exist:
  1. Select vertex u with minimum dist[u]
  2. Mark u as visited
  3. For each neighbor v of u:
     if dist[u] + weight(u,v) < dist[v]:
       dist[v] = dist[u] + weight(u,v)
       prev[v] = u
```

**3. Termination**:
```
When all vertices visited (or target reached)
```

### Dijkstra Example

**Graph**:
```
    A
   / \
  3   5
 /     \
B-------C
   2
```

**Find shortest path from A**:

**Step 1**: Initialize
```
dist[A] = 0
dist[B] = ∞
dist[C] = ∞
visited = {}
```

**Step 2**: Visit A
```
A → B: dist[B] = 0 + 3 = 3
A → C: dist[C] = 0 + 5 = 5
visited = {A}
```

**Step 3**: Visit B (min dist)
```
B → C: dist[C] = min(5, 3+2) = 5
visited = {A, B}
```

**Step 4**: Visit C
```
visited = {A, B, C}
Done

Shortest paths:
A → A: 0
A → B: 3
A → C: 5
```

### Dijkstra Properties

**1. Greedy Choice**:
- Always selects closest unvisited vertex
- Optimal locally → Optimal globally

**2. Non-Negative Weights**:
- **Requirement**: All weights ≥ 0
- **Why**: Negative weights break algorithm

**3. Time Complexity**:
- **Naive**: O(V²)
- **With heap**: O((V + E) log V)

## Dijkstra Implementation

### Naive Implementation

```c
void dijkstra_naive(Graph* g, int source, int* dist, int* prev) {
    bool visited[MAX_VERTICES] = {false};
    
    // Initialize
    for (int i = 0; i < g->num_vertices; i++) {
        dist[i] = INT_MAX;
        prev[i] = -1;
    }
    dist[source] = 0;
    
    // Main loop
    for (int count = 0; count < g->num_vertices; count++) {
        // Find minimum distance unvisited vertex
        int u = -1;
        int min_dist = INT_MAX;
        for (int v = 0; v < g->num_vertices; v++) {
            if (!visited[v] && dist[v] < min_dist) {
                min_dist = dist[v];
                u = v;
            }
        }
        
        if (u == -1) break; // No reachable vertices
        
        visited[u] = true;
        
        // Update neighbors
        for (Edge* e = g->adj[u]; e != NULL; e = e->next) {
            int v = e->to;
            int weight = e->weight;
            if (!visited[v] && dist[u] + weight < dist[v]) {
                dist[v] = dist[u] + weight;
                prev[v] = u;
            }
        }
    }
}
```

### Heap-Based Implementation

```c
typedef struct {
    int vertex;
    int distance;
} HeapNode;

void dijkstra_heap(Graph* g, int source, int* dist, int* prev) {
    PriorityQueue* pq = pq_create();
    bool visited[MAX_VERTICES] = {false};
    
    // Initialize
    for (int i = 0; i < g->num_vertices; i++) {
        dist[i] = INT_MAX;
        prev[i] = -1;
    }
    dist[source] = 0;
    pq_push(pq, (HeapNode){source, 0});
    
    // Main loop
    while (!pq_empty(pq)) {
        HeapNode node = pq_pop(pq);
        int u = node.vertex;
        
        if (visited[u]) continue;
        visited[u] = true;
        
        // Update neighbors
        for (Edge* e = g->adj[u]; e != NULL; e = e->next) {
            int v = e->to;
            int weight = e->weight;
            if (!visited[v] && dist[u] + weight < dist[v]) {
                dist[v] = dist[u] + weight;
                prev[v] = u;
                pq_push(pq, (HeapNode){v, dist[v]});
            }
        }
    }
    
    pq_destroy(pq);
}
```

## A* Algorithm

### What is A*?

**A***: Informed search algorithm

**Extension**: Of Dijkstra with heuristic

**Heuristic**: Estimates distance to goal

**Goal**: Find path to specific target (not all vertices)

### A* Overview

**Key Difference**: Uses heuristic h(n) to guide search

**Evaluation Function**: f(n) = g(n) + h(n)
- **g(n)**: Cost from start to n (actual)
- **h(n)**: Estimated cost from n to goal (heuristic)
- **f(n)**: Estimated total cost

### A* Algorithm Steps

**1. Initialize**:
```
open_set = {start}
g[start] = 0
f[start] = h(start)
```

**2. Main Loop**:
```
While open_set not empty:
  1. Select node n with minimum f(n)
  2. If n is goal: Return path
  3. Remove n from open_set, add to closed_set
  4. For each neighbor m of n:
     tentative_g = g[n] + weight(n, m)
     if tentative_g < g[m]:
       g[m] = tentative_g
       f[m] = g[m] + h(m)
       prev[m] = n
       Add m to open_set if not in closed_set
```

### Heuristic Functions

**Admissible**: h(n) ≤ actual cost to goal

**Consistent**: h(n) ≤ weight(n, m) + h(m)

**Common Heuristics**:

**1. Manhattan Distance** (grids):
```
h(n) = |x_n - x_goal| + |y_n - y_goal|
```

**2. Euclidean Distance**:
```
h(n) = √((x_n - x_goal)² + (y_n - y_goal)²)
```

**3. Chebyshev Distance**:
```
h(n) = max(|x_n - x_goal|, |y_n - y_goal|)
```

### A* Example

**Grid** (4-connected):
```
S . . . .
. # . . .
. . . # .
. . . . G
```

**Manhattan heuristic**: h(n) = |x - x_g| + |y - y_g|

**Search**:
```
Start: f(S) = 0 + 8 = 8
Expand S → neighbors
Select node with min f
Continue until goal reached
```

## A* Implementation

### A* Code

```c
typedef struct {
    int x, y;
    int g, h, f;
    int parent_x, parent_y;
} AStarNode;

int heuristic(int x1, int y1, int x2, int y2) {
    // Manhattan distance
    return abs(x1 - x2) + abs(y1 - y2);
}

bool astar(Grid* grid, Point start, Point goal, Point* path) {
    PriorityQueue* open_set = pq_create();
    bool closed_set[MAX_SIZE][MAX_SIZE] = {false};
    AStarNode nodes[MAX_SIZE][MAX_SIZE];
    
    // Initialize
    for (int i = 0; i < grid->height; i++) {
        for (int j = 0; j < grid->width; j++) {
            nodes[i][j].g = INT_MAX;
            nodes[i][j].h = INT_MAX;
            nodes[i][j].f = INT_MAX;
            nodes[i][j].parent_x = -1;
            nodes[i][j].parent_y = -1;
        }
    }
    
    nodes[start.y][start.x].g = 0;
    nodes[start.y][start.x].h = heuristic(start.x, start.y, goal.x, goal.y);
    nodes[start.y][start.x].f = nodes[start.y][start.x].h;
    nodes[start.y][start.x].x = start.x;
    nodes[start.y][start.x].y = start.y;
    
    pq_push(open_set, nodes[start.y][start.x]);
    
    // Main loop
    while (!pq_empty(open_set)) {
        AStarNode current = pq_pop(open_set);
        
        if (current.x == goal.x && current.y == goal.y) {
            // Reconstruct path
            return reconstruct_path(nodes, start, goal, path);
        }
        
        closed_set[current.y][current.x] = true;
        
        // Check neighbors
        int dx[] = {0, 1, 0, -1};
        int dy[] = {1, 0, -1, 0};
        
        for (int i = 0; i < 4; i++) {
            int nx = current.x + dx[i];
            int ny = current.y + dy[i];
            
            if (!is_valid(grid, nx, ny) || closed_set[ny][nx]) {
                continue;
            }
            
            int tentative_g = current.g + 1;
            
            if (tentative_g < nodes[ny][nx].g) {
                nodes[ny][nx].g = tentative_g;
                nodes[ny][nx].h = heuristic(nx, ny, goal.x, goal.y);
                nodes[ny][nx].f = nodes[ny][nx].g + nodes[ny][nx].h;
                nodes[ny][nx].parent_x = current.x;
                nodes[ny][nx].parent_y = current.y;
                nodes[ny][nx].x = nx;
                nodes[ny][nx].y = ny;
                
                if (!pq_contains(open_set, nodes[ny][nx])) {
                    pq_push(open_set, nodes[ny][nx]);
                }
            }
        }
    }
    
    return false; // No path found
}
```

## Dijkstra vs A*

### Comparison

| Aspect | Dijkstra | A* |
|--------|----------|-----|
| **Goal** | All vertices | Specific target |
| **Heuristic** | No | Yes |
| **Nodes Explored** | More | Fewer (with good heuristic) |
| **Optimal** | Yes | Yes (with admissible heuristic) |
| **Use Case** | All shortest paths | Path to goal |

### When to Use What

**Dijkstra**:
- **All shortest paths**: Need distances to all vertices
- **No heuristic**: No good heuristic available
- **Uniform costs**: Similar edge weights

**A***:
- **Single target**: Path to specific goal
- **Good heuristic**: Have admissible heuristic
- **Performance**: Want to explore fewer nodes

## Optimizations

### Bidirectional Search

**Idea**: Search from both start and goal

**Benefits**:
- **Faster**: Explores fewer nodes
- **Meet in middle**: Stop when paths meet

**Implementation**:
```
Search forward from start
Search backward from goal
When frontiers meet: Combine paths
```

### Hierarchical Pathfinding

**Idea**: Use abstraction levels

**Process**:
1. **High level**: Find path through regions
2. **Low level**: Find path within regions

**Benefits**: Much faster for large graphs

### Jump Point Search

**Idea**: Skip unnecessary nodes in grids

**Benefits**: Faster A* for uniform-cost grids

## Real-World Applications

### Example 1: GPS Navigation

**Use**: A* algorithm

**Heuristic**: Straight-line distance to destination

**Implementation**:
```
Road network as graph
Intersections as nodes
Roads as edges (weighted by time/distance)
A* finds fastest route
```

### Example 2: Game Pathfinding

**Use**: A* algorithm

**Heuristic**: Manhattan or Euclidean distance

**Implementation**:
```
Grid-based map
Obstacles as blocked cells
A* finds path avoiding obstacles
```

### Example 3: Network Routing

**Use**: Dijkstra's algorithm

**Implementation**:
```
Network topology as graph
Routers as nodes
Links as edges (weighted by latency)
Dijkstra finds shortest paths
```

## Common Pitfalls

### Problem: Negative Weights

```c
// BAD: Dijkstra with negative weights
Graph with negative edge: A --(-5)--> B
// Dijkstra fails! May not find shortest path

// GOOD: Use Bellman-Ford for negative weights
bellman_ford(graph, source);
```

### Problem: Inadmissible Heuristic

```c
// BAD: Heuristic overestimates
h(n) = 2 * actual_distance; // Not admissible!
// A* may not find optimal path

// GOOD: Admissible heuristic
h(n) = manhattan_distance(n, goal); // Admissible
```

## Quiz

1. What is the main difference between Dijkstra and A*?
   - **A)** No difference
   - **B)** A* uses a heuristic to guide search toward goal
   - **C)** Dijkstra is faster
   - **D)** A* only works on grids

2. What is required for Dijkstra to work correctly?
   - **A)** Negative weights
   - **B)** Non-negative edge weights
   - **C)** Directed graph
   - **D)** Acyclic graph

3. What makes a heuristic admissible?
   - **A)** Always overestimates
   - **B)** Never overestimates the actual cost to goal
   - **C)** Always exact
   - **D)** Random

**Answers:**
1. **B** - A* extends Dijkstra by using a heuristic function to estimate distance to goal, guiding the search and exploring fewer nodes
2. **B** - Dijkstra requires non-negative edge weights; negative weights can cause the algorithm to fail to find the shortest path
3. **B** - A heuristic is admissible if it never overestimates the actual cost to reach the goal, ensuring A* finds optimal paths

## Next Steps

- [Advanced Graph Algorithms](./08.%20Advanced%20Graph%20Algorithms%20-%20Max%20Flow%2C%20Min%20Cut.md) - SCC, flow networks
- [String Algorithms - KMP & Z-Algorithm](./04.%20String%20Algorithms%20-%20KMP%20%26%20Z-Algorithm.md) - String matching

