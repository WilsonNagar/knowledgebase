---
number: 4
title: "Approximation Algorithms"
slug: "approximation-algorithms"
level: "advanced"
tags: ["data-structures", "approximation", "algorithms", "np-hard", "optimization"]
prerequisites: ["complexity-theory-p-vs-np"]
estimated_minutes: 130
contributors: []
diagrams: []
examples: []
canonical_id: "cs-dsa-adv-04"
---

# Approximation Algorithms

## Overview

Approximation algorithms provide near-optimal solutions for NP-hard problems when exact solutions are computationally infeasible. Understanding approximation ratios, greedy algorithms, linear programming relaxations, and randomized algorithms is essential for solving hard optimization problems in practice.

## Table of Contents

1. [Why Approximation?](#why-approximation)
2. [Approximation Ratio](#approximation-ratio)
3. [Greedy Approximation](#greedy)
4. [LP Relaxation](#lp-relaxation)
5. [Randomized Algorithms](#randomized)
6. [PTAS and FPTAS](#ptas-fptas)
7. [Set Cover Approximation](#set-cover)
8. [Applications](#applications)

## Why Approximation?

### The Problem

**NP-Hard Problems**: No known polynomial algorithm

**Options**:
- **Exact**: Exponential time (slow)
- **Heuristic**: No guarantee
- **Approximation**: Guaranteed quality, polynomial time

**Trade-off**: Optimality vs time

### When to Use

**Use When**:
- **NP-Hard**: Problem is NP-hard
- **Large Input**: Input too large for exact
- **Good Enough**: Near-optimal acceptable

**Don't Use When**:
- **Exact Needed**: Must have optimal
- **Polynomial Exists**: Can solve exactly

## Approximation Ratio

### Definition

**Approximation Ratio**: How close to optimal

**For Minimization**:
```
ratio = ALG / OPT ≥ 1
```

**For Maximization**:
```
ratio = OPT / ALG ≥ 1
```

**Example**: 
- **2-approximation**: Solution ≤ 2 × optimal
- **1.5-approximation**: Solution ≤ 1.5 × optimal

### Quality

**Lower Ratio**: Better approximation

**1-approximation**: Optimal (rare)

**Polynomial Ratio**: Usually acceptable

## Greedy Approximation

### Greedy Strategy

**Method**: Make locally optimal choices

**Process**:
```
1. At each step, choose best local option
2. Don't reconsider previous choices
3. Hope global solution is good
```

**Benefit**: Simple, fast

**Limitation**: May not be optimal

### Greedy Example: Set Cover

**Problem**: Cover universe with minimum sets

**Greedy**: 
```
1. Choose set covering most uncovered elements
2. Repeat until all covered
```

**Approximation**: O(log n) approximation

## LP Relaxation

### What is LP Relaxation?

**LP Relaxation**: Relax integer constraints

**Integer Program**: Variables must be integers

**Linear Program**: Variables can be fractional

**Process**:
```
1. Formulate as integer program
2. Relax to linear program
3. Solve LP (polynomial time)
4. Round solution to integers
```

### Rounding Strategies

**1. Round Up/Down**: Simple rounding

**2. Randomized Rounding**: Round probabilistically

**3. Dependent Rounding**: Round with dependencies

## Randomized Algorithms

### Randomized Approximation

**Method**: Use randomness

**Types**:
- **Monte Carlo**: May be wrong
- **Las Vegas**: Always correct, random time

**Benefit**: Often simpler, good performance

### Example: Max Cut

**Problem**: Maximum cut in graph

**Randomized**: 
```
Randomly assign vertices to sets
Expected cut size: |E|/2
```

**Approximation**: 2-approximation

## PTAS and FPTAS

### PTAS

**PTAS**: Polynomial-Time Approximation Scheme

**Definition**: (1+ε)-approximation in polynomial time

**Polynomial**: In input size (may be exponential in 1/ε)

**Example**: Euclidean TSP has PTAS

### FPTAS

**FPTAS**: Fully Polynomial-Time Approximation Scheme

**Definition**: (1+ε)-approximation in polynomial time

**Polynomial**: In both input size and 1/ε

**Better**: Than PTAS

**Example**: Knapsack has FPTAS

## Set Cover Approximation

### Problem

**Set Cover**: Cover universe with minimum sets

**NP-Hard**: No polynomial exact algorithm

**Greedy**: O(log n) approximation

### Greedy Algorithm

**Process**:
```
1. While universe not covered:
   a. Choose set covering most uncovered elements
   b. Add to cover
   c. Remove covered elements
2. Return cover
```

**Approximation**: H(n) ≈ ln(n) + 1

**H(n)**: Harmonic number

## Applications

### Application 1: Traveling Salesman

**Problem**: TSP is NP-hard

**Approximations**:
- **2-approximation**: For metric TSP
- **1.5-approximation**: Christofides algorithm

**Use**: When exact solution too slow

### Application 2: Vertex Cover

**Problem**: Minimum vertex cover

**Approximation**: 2-approximation (greedy)

**Use**: Network design

### Application 3: Knapsack

**Problem**: 0/1 Knapsack

**Approximation**: FPTAS exists

**Use**: Resource allocation

## Real-World Examples

### Example 1: Facility Location

**Problem**: Place facilities optimally

**Solution**: Approximation algorithms

**Benefit**: Good solutions quickly

### Example 2: Scheduling

**Problem**: Schedule jobs optimally

**Solution**: Approximation algorithms

**Benefit**: Near-optimal schedules

## Common Pitfalls

### Problem: Assuming Optimal

```c
// BAD: Assume approximation is optimal
// May not be!

// GOOD: Understand approximation ratio
// Know solution quality
```

### Problem: Wrong Problem Type

```c
// BAD: Use approximation for polynomial problem
// Can solve exactly!

// GOOD: Use approximation only for NP-hard
```

## Quiz

1. What is an approximation algorithm?
   - **A)** Exact algorithm
   - **B)** Algorithm providing near-optimal solution with guaranteed quality
   - **C)** Heuristic algorithm
   - **D)** Random algorithm

2. What is approximation ratio?
   - **A)** Running time
   - **B)** Measure of how close solution is to optimal
   - **C)** Memory usage
   - **D)** Code complexity

3. What is PTAS?
   - **A)** Polynomial algorithm
   - **B)** Polynomial-Time Approximation Scheme - (1+ε)-approximation
   - **C)** Exact algorithm
   - **D)** Heuristic

**Answers:**
1. **B** - An approximation algorithm provides a solution with guaranteed quality (approximation ratio) in polynomial time for NP-hard problems
2. **B** - Approximation ratio measures how close the approximate solution is to the optimal solution (e.g., 2-approximation means solution is at most 2× optimal)
3. **B** - PTAS (Polynomial-Time Approximation Scheme) provides (1+ε)-approximation in polynomial time (polynomial in input size, may be exponential in 1/ε)

## Next Steps

- [Advanced Algorithm Design](../data_structures_algorithms/05.%20Advanced%20Algorithm%20Design.md) - Algorithm techniques
- [Competitive Programming Techniques](../data_structures_algorithms/06.%20Competitive%20Programming.md) - CP strategies

