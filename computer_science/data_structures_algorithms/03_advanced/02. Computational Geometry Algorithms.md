---
number: 2
title: "Computational Geometry Algorithms"
slug: "computational-geometry-algorithms"
level: "advanced"
tags: ["data-structures", "computational-geometry", "algorithms", "convex-hull", "line-intersection"]
prerequisites: ["advanced-graph-algorithms-max-flow-min-cut"]
estimated_minutes: 140
contributors: []
diagrams: []
examples: []
canonical_id: "cs-dsa-adv-02"
---

# Computational Geometry Algorithms

## Overview

Computational geometry algorithms solve geometric problems efficiently. Understanding convex hull algorithms, line intersection, point location, and geometric data structures is essential for graphics, robotics, GIS, and many applications involving spatial data.

## Table of Contents

1. [Geometric Primitives](#primitives)
2. [Convex Hull](#convex-hull)
3. [Line Intersection](#line-intersection)
4. [Point in Polygon](#point-in-polygon)
5. [Closest Pair of Points](#closest-pair)
6. [Voronoi Diagrams](#voronoi)
7. [Delaunay Triangulation](#delaunay)
8. [Applications](#applications)

## Geometric Primitives

### Point Representation

**2D Point**: (x, y)

**3D Point**: (x, y, z)

**Operations**: 
- **Distance**: Euclidean distance
- **Vector**: Difference between points

### Cross Product

**2D Cross Product**:
```
cross(p1, p2) = p1.x × p2.y - p1.y × p2.x
```

**Use**: 
- **Orientation**: Clockwise/counterclockwise
- **Area**: Signed area of triangle

**Orientation**:
```
cross > 0: Counterclockwise
cross < 0: Clockwise
cross = 0: Collinear
```

### Dot Product

**Dot Product**:
```
dot(p1, p2) = p1.x × p2.x + p1.y × p2.y
```

**Use**: 
- **Angle**: Between vectors
- **Projection**: Project one vector on another

## Convex Hull

### What is Convex Hull?

**Convex Hull**: Smallest convex polygon containing all points

**Properties**: 
- **Convex**: All interior angles < 180°
- **Smallest**: Minimum area polygon

**Use**: Shape approximation, collision detection

### Graham Scan Algorithm

**Process**:
```
1. Find bottommost point (or leftmost)
2. Sort points by polar angle
3. Build hull using stack
4. For each point:
   While last 3 points make right turn:
     Remove middle point
   Add current point
```

**Time**: O(n log n)

**Code**:
```c
typedef struct Point {
    int x, y;
} Point;

int cross_product(Point O, Point A, Point B) {
    return (A.x - O.x) * (B.y - O.y) - (A.y - O.y) * (B.x - O.x);
}

vector<Point> graham_scan(vector<Point>& points) {
    int n = points.size();
    if (n < 3) return points;
    
    // Find bottommost point
    int bottom = 0;
    for (int i = 1; i < n; i++) {
        if (points[i].y < points[bottom].y ||
            (points[i].y == points[bottom].y && points[i].x < points[bottom].x)) {
            bottom = i;
        }
    }
    swap(points[0], points[bottom]);
    
    // Sort by polar angle
    sort(points.begin() + 1, points.end(), [&](Point a, Point b) {
        int cross = cross_product(points[0], a, b);
        if (cross == 0) {
            return distance(points[0], a) < distance(points[0], b);
        }
        return cross > 0;
    });
    
    // Build hull
    vector<Point> hull;
    hull.push_back(points[0]);
    hull.push_back(points[1]);
    
    for (int i = 2; i < n; i++) {
        while (hull.size() > 1 && 
               cross_product(hull[hull.size()-2], hull.back(), points[i]) <= 0) {
            hull.pop_back();
        }
        hull.push_back(points[i]);
    }
    
    return hull;
}
```

### Jarvis March (Gift Wrapping)

**Process**:
```
1. Find leftmost point
2. For each point on hull:
   Find next point (rightmost turn)
3. Repeat until back to start
```

**Time**: O(n × h) where h = hull size

**Use**: When h is small

## Line Intersection

### Line Segment Intersection

**Problem**: Do two line segments intersect?

**Method**: 
1. Check if endpoints on opposite sides
2. Check bounding boxes

**Code**:
```c
bool segments_intersect(Point p1, Point p2, Point p3, Point p4) {
    int d1 = cross_product(p3, p4, p1);
    int d2 = cross_product(p3, p4, p2);
    int d3 = cross_product(p1, p2, p3);
    int d4 = cross_product(p1, p2, p4);
    
    // Check if on opposite sides
    if (((d1 > 0 && d2 < 0) || (d1 < 0 && d2 > 0)) &&
        ((d3 > 0 && d4 < 0) || (d3 < 0 && d4 > 0))) {
        return true;
    }
    
    // Check collinear cases
    if (d1 == 0 && on_segment(p3, p4, p1)) return true;
    if (d2 == 0 && on_segment(p3, p4, p2)) return true;
    if (d3 == 0 && on_segment(p1, p2, p3)) return true;
    if (d4 == 0 && on_segment(p1, p2, p4)) return true;
    
    return false;
}
```

## Point in Polygon

### Ray Casting Algorithm

**Method**: 
1. Cast ray from point
2. Count intersections with polygon edges
3. Odd = inside, Even = outside

**Time**: O(n)

**Code**:
```c
bool point_in_polygon(Point p, vector<Point>& polygon) {
    int n = polygon.size();
    bool inside = false;
    
    for (int i = 0, j = n - 1; i < n; j = i++) {
        if (((polygon[i].y > p.y) != (polygon[j].y > p.y)) &&
            (p.x < (polygon[j].x - polygon[i].x) * (p.y - polygon[i].y) / 
                   (polygon[j].y - polygon[i].y) + polygon[i].x)) {
            inside = !inside;
        }
    }
    
    return inside;
}
```

## Closest Pair of Points

### Divide and Conquer

**Algorithm**:
```
1. Divide points into two halves
2. Recursively find closest in each half
3. Find closest across boundary
4. Return minimum
```

**Time**: O(n log² n)

**Optimization**: O(n log n) with careful implementation

## Voronoi Diagrams

### What is Voronoi Diagram?

**Voronoi Diagram**: Partition plane into regions

**Regions**: Points closer to one site than others

**Use**: Nearest neighbor queries, facility location

### Properties

**Dual**: Delaunay triangulation

**Complexity**: O(n log n)

**Applications**: Many geometric problems

## Delaunay Triangulation

### What is Delaunay Triangulation?

**Delaunay**: Triangulation maximizing minimum angle

**Properties**: 
- **Empty Circle**: No point inside circumcircle
- **Max-Min Angle**: Maximizes minimum angle

**Use**: Mesh generation, interpolation

## Applications

### Application 1: Computer Graphics

**Use**: Rendering, collision detection

**Algorithms**: Convex hull, line intersection

### Application 2: Robotics

**Use**: Path planning, obstacle avoidance

**Algorithms**: Visibility graphs, Voronoi diagrams

### Application 3: GIS

**Use**: Spatial queries, map processing

**Algorithms**: Point location, range queries

### Application 4: Game Development

**Use**: Collision detection, pathfinding

**Algorithms**: Convex hull, line intersection

## Real-World Examples

### Example 1: Collision Detection

**Problem**: Detect if objects collide

**Solution**: Convex hull + intersection tests

### Example 2: Facility Location

**Problem**: Place facilities optimally

**Solution**: Voronoi diagrams

## Common Pitfalls

### Problem: Floating Point Precision

```c
// BAD: Direct comparison
if (cross == 0) {  // May fail due to precision

// GOOD: Use epsilon
if (abs(cross) < EPSILON) {
```

### Problem: Degenerate Cases

```c
// BAD: Assume non-degenerate
// May fail on collinear points

// GOOD: Handle degenerate cases
// Check for collinearity, etc.
```

## Quiz

1. What is a convex hull?
   - **A)** All points
   - **B)** Smallest convex polygon containing all points
   - **C)** Largest polygon
   - **D)** Random polygon

2. What is the time complexity of Graham Scan?
   - **A)** O(n)
   - **B)** O(n log n)
   - **C)** O(n²)
   - **D)** O(log n)

3. What is a Voronoi diagram?
   - **A)** Triangulation
   - **B)** Partition of plane into regions based on nearest site
   - **C)** Convex hull
   - **D)** Line intersection

**Answers:**
1. **B** - A convex hull is the smallest convex polygon that contains all given points, with all interior angles less than 180 degrees
2. **B** - Graham Scan algorithm takes O(n log n) time due to the sorting step, then O(n) to build the hull
3. **B** - A Voronoi diagram partitions the plane into regions where each region contains points closer to one site (point) than to any other site

## Next Steps

- [Advanced Dynamic Programming](../data_structures_algorithms/03.%20Advanced%20Dynamic%20Programming.md) - DP advanced
- [Approximation Algorithms](../data_structures_algorithms/04.%20Approximation%20Algorithms.md) - Approximation methods

