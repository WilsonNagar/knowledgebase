---
number: 3
title: "Branch Prediction & Speculation"
slug: "branch-prediction-speculation"
level: "intermediate"
tags: ["computer-architecture", "branch-prediction", "speculation", "performance", "cpu"]
prerequisites: ["cpu-pipelines-superscalar-execution"]
estimated_minutes: 110
contributors: []
diagrams: []
examples: []
canonical_id: "cs-arch-03"
---

# Branch Prediction & Speculation

## Overview

Branch prediction and speculative execution are critical CPU optimizations that enable high performance despite control flow dependencies. Understanding how CPUs predict branches, handle mispredictions, and perform speculative execution is essential for understanding modern processor performance and security implications like Spectre and Meltdown.

## Table of Contents

1. [The Branch Problem](#branch-problem)
2. [Branch Prediction Basics](#basics)
3. [Static Branch Prediction](#static)
4. [Dynamic Branch Prediction](#dynamic)
5. [Branch Target Buffer](#btb)
6. [Speculative Execution](#speculation)
7. [Misprediction Handling](#misprediction)
8. [Spectre & Meltdown](#spectre-meltdown)
9. [Performance Impact](#performance)

## The Branch Problem

### Why Branches are Problematic

**Pipeline Stalls**:
```
Instruction: if (condition) { ... }
Pipeline: Must wait for condition to resolve
Stall: 3-5 cycles wasted
```

**Frequency**: 15-20% of instructions are branches

**Impact**: Significant performance loss if not handled

### Branch Penalty

**Without Prediction**:
```
Pipeline must stall until branch resolved
Cost: 3-5 cycles per branch
```

**With Prediction**:
```
Predict branch outcome
Continue execution speculatively
If correct: No penalty
If wrong: Flush pipeline, restart
Cost: 0 cycles (correct), 10-20 cycles (wrong)
```

## Branch Prediction Basics

### What is Branch Prediction?

**Branch Prediction**: Guess branch outcome before known

**Purpose**: Keep pipeline full

**Accuracy**: Modern predictors: 90-99%

### Prediction Types

**1. Not Taken**:
- **Predict**: Branch not taken
- **Continue**: Execute next instruction
- **Simple**: No hardware needed

**2. Taken**:
- **Predict**: Branch taken
- **Jump**: To target address
- **Requires**: Target address known

**3. Dynamic**:
- **Predict**: Based on history
- **Adaptive**: Learns from behavior
- **Complex**: Requires hardware

## Static Branch Prediction

### Always Not Taken

**Strategy**: Predict all branches not taken

**Rationale**: Most branches not taken (loops exit)

**Hardware**: None needed

**Accuracy**: ~60-70%

### Always Taken

**Strategy**: Predict all branches taken

**Rationale**: Some code patterns

**Hardware**: Minimal

**Accuracy**: ~50-60%

### Backward Taken, Forward Not Taken

**Strategy**: 
- **Backward branches**: Usually taken (loops)
- **Forward branches**: Usually not taken (if-else)

**Rationale**: Matches common patterns

**Accuracy**: ~70-80%

### Profile-Guided

**Strategy**: Use execution profile

**Process**:
1. **Profile**: Run program, collect branch statistics
2. **Compile**: Use profile to predict
3. **Optimize**: Reorder code based on predictions

**Accuracy**: ~85-95%

## Dynamic Branch Prediction

### 1-Bit Predictor

**State**: Last outcome

**States**:
```
Not Taken → Predict Not Taken
Taken → Predict Taken
```

**Problem**: Alternating branches mispredicted

**Example**:
```
Branch alternates: T, N, T, N, T, N...
Predictor: Always predicts last outcome
Accuracy: 50% (worse than always not taken!)
```

### 2-Bit Predictor

**States**: 
```
Strongly Not Taken (00) → Predict Not Taken
Weakly Not Taken (01) → Predict Not Taken
Weakly Taken (10) → Predict Taken
Strongly Taken (11) → Predict Taken
```

**State Machine**:
```
Strongly Not Taken → Not Taken → Weakly Not Taken
Weakly Not Taken → Not Taken → Strongly Not Taken
Weakly Taken → Taken → Strongly Taken
Strongly Taken → Taken → Strongly Taken
```

**Hysteresis**: Requires 2 mispredictions to change

**Accuracy**: ~90-95%

### Pattern-Based Prediction

**Idea**: Predict based on pattern history

**Example**: T, T, N, T, T, N, ...

**Pattern**: T, T, N repeats

**Predictor**: Recognizes pattern

**Accuracy**: ~95%+ for patterned branches

### Tournament Predictor

**Idea**: Combine multiple predictors

**Components**:
- **Local predictor**: Per-branch history
- **Global predictor**: Global branch history
- **Selector**: Chooses best predictor

**Accuracy**: ~97-99%

## Branch Target Buffer

### What is BTB?

**BTB**: Cache for branch targets

**Purpose**: Predict target address

**Structure**:
```
Entry: [PC, Target Address, Prediction]
```

**Process**:
```
1. Fetch instruction
2. Check BTB for PC
3. If hit: Use predicted target
4. If miss: Predict not taken
```

### BTB Benefits

**Target Prediction**:
- **Known target**: Can fetch target immediately
- **No delay**: Don't wait for target calculation
- **Performance**: Faster branch handling

### Return Address Stack

**Purpose**: Predict return addresses

**Problem**: Indirect branches (function returns)

**Solution**: Stack of return addresses

**Process**:
```
Call: Push return address
Return: Pop return address (predict)
```

**Accuracy**: ~99%+ (very predictable)

## Speculative Execution

### What is Speculation?

**Speculation**: Execute instructions before knowing if needed

**Purpose**: Hide latency

**Risk**: May need to discard work

### Speculative Execution Process

**Steps**:
```
1. Predict branch outcome
2. Execute speculatively along predicted path
3. When branch resolved:
   a. If correct: Commit results
   b. If wrong: Discard results, restart
```

### Speculation Example

**Code**:
```c
if (x > 0) {
    y = compute_expensive(x);
} else {
    y = 0;
}
```

**Speculative Execution**:
```
1. Predict: x > 0 (taken)
2. Speculatively execute: y = compute_expensive(x)
3. Branch resolves: x > 0 is true
4. Commit: y value (speculation correct)
```

**If Wrong**:
```
1. Predict: x > 0 (taken)
2. Speculatively execute: y = compute_expensive(x)
3. Branch resolves: x > 0 is false
4. Discard: y value, flush pipeline
5. Execute: y = 0
```

## Misprediction Handling

### Misprediction Cost

**When Wrong**:
```
1. Flush pipeline (discard speculative work)
2. Restart from correct path
3. Cost: 10-20 cycles
```

**Factors**:
- **Pipeline depth**: Deeper = more cost
- **Speculation depth**: More speculation = more to discard

### Reducing Misprediction Cost

**1. Better Predictors**:
- **Higher accuracy**: Fewer mispredictions
- **Modern predictors**: 97-99% accurate

**2. Shallow Pipelines**:
- **Less to flush**: Lower cost
- **Trade-off**: Lower peak performance

**3. Early Resolution**:
- **Resolve branches early**: Less speculation
- **Hardware**: Branch prediction units

## Spectre & Meltdown

### Spectre Vulnerability

**What**: Speculative execution leaks data

**How**:
```
1. Attacker trains branch predictor
2. Predictor mispredicts
3. Speculative execution accesses secret data
4. Secret data affects cache
5. Attacker measures cache timing
6. Infers secret data
```

**Impact**: Can leak data across security boundaries

**Mitigation**: 
- **Fence instructions**: Prevent speculation
- **Retpoline**: Indirect branch mitigation
- **Compiler flags**: -mretpoline

### Meltdown Vulnerability

**What**: Speculative execution + out-of-order execution

**How**:
```
1. Speculatively load kernel memory
2. Use value to index array
3. Array access affects cache
4. Measure cache timing
5. Infer kernel memory contents
```

**Impact**: Can read kernel memory from user space

**Mitigation**:
- **KPTI**: Kernel Page Table Isolation
- **Separate page tables**: User and kernel

### Security Implications

**Problem**: Speculation leaks information

**Challenge**: Balancing performance and security

**Solutions**: 
- **Hardware**: New CPU features
- **Software**: Mitigations (performance cost)

## Performance Impact

### Branch Prediction Accuracy

**Impact on Performance**:
```
Accuracy  Misprediction Rate  Performance Impact
90%       10%                ~10% slowdown
95%       5%                 ~5% slowdown
99%       1%                 ~1% slowdown
```

**Critical**: For performance-sensitive code

### Optimizing Branches

**1. Reduce Branches**:
```c
// BAD: Many branches
if (a) x++;
if (b) x++;
if (c) x++;

// GOOD: Fewer branches
x += (a ? 1 : 0) + (b ? 1 : 0) + (c ? 1 : 0);
```

**2. Predictable Patterns**:
```c
// BAD: Unpredictable
if (random() > 0.5) { ... }

// GOOD: Predictable
if (likely_condition) { ... }
```

**3. Branch-Free Code**:
```c
// BAD: Branch
if (x > 0) y = 1; else y = 0;

// GOOD: Branch-free
y = (x > 0) ? 1 : 0; // May compile to conditional move
```

## Real-World Examples

### Example 1: Loop Optimization

**Code**:
```c
for (int i = 0; i < n; i++) {
    if (array[i] > threshold) {
        count++;
    }
}
```

**Branch Prediction**:
- **Loop branch**: Highly predictable (taken until end)
- **Conditional**: May be predictable if threshold consistent
- **Performance**: Good if predictable

### Example 2: Hash Table Lookup

**Code**:
```c
if (table[bucket] != NULL) {
    // Search chain
}
```

**Branch Prediction**:
- **May be unpredictable**: Depends on hash distribution
- **Performance**: Can be slow if unpredictable

**Optimization**: Use branch-free techniques

## Common Pitfalls

### Problem: Unpredictable Branches

```c
// BAD: Unpredictable pattern
for (int i = 0; i < n; i++) {
    if (data[i] % 2 == 0) { // Random pattern
        process(data[i]);
    }
}

// GOOD: Make predictable or branch-free
// Sort data first, or use branch-free code
```

### Problem: Ignoring Branch Prediction

```c
// BAD: Assume branches are free
// Branches have cost, especially if mispredicted

// GOOD: Profile and optimize hot branches
// Use likely/unlikely hints if available
```

## Quiz

1. What is the main purpose of branch prediction?
   - **A)** Reduce code size
   - **B)** Keep pipeline full by predicting branch outcomes
   - **C)** Encrypt branches
   - **D)** Simplify code

2. What is speculative execution?
   - **A)** Executing instructions after branch resolves
   - **B)** Executing instructions before knowing if they're needed, based on prediction
   - **C)** Only executing safe instructions
   - **D)** Not executing branches

3. What vulnerability is related to speculative execution?
   - **A)** SQL injection
   - **B)** Spectre and Meltdown (information leakage through speculation)
   - **C)** Buffer overflow
   - **D)** XSS

**Answers:**
1. **B** - Branch prediction keeps the CPU pipeline full by predicting branch outcomes and continuing execution speculatively, avoiding pipeline stalls
2. **B** - Speculative execution executes instructions along a predicted path before the branch is resolved, committing results if correct or discarding if wrong
3. **B** - Spectre and Meltdown are vulnerabilities where speculative execution can leak sensitive data through cache timing attacks, exploiting the side effects of speculative execution

## Next Steps

- [Caches & Cache Coherence](../computer_architecture/02.%20Caches%20%26%20Cache%20Coherence.md) - Memory hierarchy
- [SIMD & Vectorization](../computer_architecture/04.%20SIMD%20%26%20Vectorization.md) - Parallel processing

