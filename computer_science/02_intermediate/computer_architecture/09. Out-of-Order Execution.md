---
number: 9
title: "Out-of-Order Execution"
slug: "out-of-order-execution"
level: "intermediate"
tags: ["computer-architecture", "out-of-order", "execution", "cpu", "performance"]
prerequisites: ["assembly-language-fundamentals-x86-arm"]
estimated_minutes: 135
contributors: []
diagrams: []
examples: []
canonical_id: "cs-arch-09"
---

# Out-of-Order Execution

## Overview

Out-of-order (OoO) execution allows processors to execute instructions in a different order than program order to improve performance. Understanding OoO execution, instruction scheduling, register renaming, and performance implications is essential for understanding modern CPU performance.

## Table of Contents

1. [What is Out-of-Order Execution?](#what-is-ooo)
2. [In-Order vs Out-of-Order](#in-order-vs-ooo)
3. [OoO Execution Pipeline](#pipeline)
4. [Instruction Scheduling](#scheduling)
5. [Register Renaming](#register-renaming)
6. [Reorder Buffer](#reorder-buffer)
7. [Performance Benefits](#performance)
8. [Real-World Examples](#examples)

## What is Out-of-Order Execution?

### Definition

**Out-of-Order Execution**: Execute instructions out of program order

**Purpose**: Improve performance

**Method**: Execute ready instructions while waiting for others

**Benefit**: Better CPU utilization

**Challenge**: Maintain program semantics

### Why Out-of-Order?

**Problem**: Dependencies stall execution

**Solution**: Execute independent instructions

**Benefit**: Hide latency, improve throughput

**Example**:
```
Instruction 1: Load R1, [addr]    ; Slow (cache miss)
Instruction 2: Add R2, R3, R4     ; Fast, independent
Instruction 3: Mul R5, R6, R7     ; Fast, independent

OoO: Execute 2 and 3 while waiting for 1
```

## In-Order vs Out-of-Order

### In-Order Execution

**In-Order**: Execute in program order

**Process**:
```
1. Fetch instruction
2. Decode instruction
3. Execute instruction (if ready)
4. Wait if not ready
5. Write back
```

**Limitation**: Stalls on dependencies

**Use**: Simple processors, low power

### Out-of-Order Execution

**Out-of-Order**: Execute ready instructions

**Process**:
```
1. Fetch instructions
2. Decode instructions
3. Rename registers
4. Dispatch to reservation stations
5. Execute when ready (out of order)
6. Reorder buffer maintains order
7. Commit in program order
```

**Benefit**: Better performance

**Use**: High-performance processors

## OoO Execution Pipeline

### Pipeline Stages

**1. Fetch**:
```
Fetch instructions
```

**2. Decode**:
```
Decode instructions
```

**3. Rename**:
```
Rename registers
```

**4. Dispatch**:
```
Dispatch to reservation stations
```

**5. Issue**:
```
Issue when operands ready
```

**6. Execute**:
```
Execute out of order
```

**7. Write Back**:
```
Write to reorder buffer
```

**8. Commit**:
```
Commit in program order
```

### Key Components

**1. Reservation Stations**:
```
Hold instructions waiting for operands
```

**2. Register Renaming**:
```
Map architectural to physical registers
```

**3. Reorder Buffer**:
```
Maintain program order
```

**4. Load/Store Queue**:
```
Track memory operations
```

## Instruction Scheduling

### Scheduling Process

**1. Identify Dependencies**:
```
Data dependencies
Control dependencies
```

**2. Find Ready Instructions**:
```
Instructions with ready operands
```

**3. Execute Ready Instructions**:
```
Execute out of order
```

**4. Maintain Order**:
```
Commit in program order
```

### Dependency Types

**1. Data Dependencies**:
```
Read after write (RAW)
Write after read (WAR)
Write after write (WAW)
```

**2. Control Dependencies**:
```
Branch dependencies
```

**3. Memory Dependencies**:
```
Memory ordering
```

## Register Renaming

### What is Register Renaming?

**Register Renaming**: Map architectural to physical registers

**Purpose**: Eliminate false dependencies

**Method**: 
```
Architectural registers â†’ Physical registers
```

**Benefit**: More parallelism

### Register Renaming Example

**Before Renaming**:
```assembly
ADD R1, R2, R3     ; R1 = R2 + R3
MUL R1, R1, R4     ; R1 = R1 * R4 (depends on first)
ADD R5, R1, R6     ; R5 = R1 + R6 (depends on second)
```

**After Renaming**:
```assembly
ADD P1, P2, P3     ; P1 = P2 + P3
MUL P7, P1, P4     ; P7 = P1 * P4 (can execute in parallel with next)
ADD P8, P1, P6     ; P8 = P1 + P6 (independent of MUL)
```

**Benefit**: More instructions can execute in parallel

## Reorder Buffer

### What is Reorder Buffer?

**Reorder Buffer**: Maintain program order

**Purpose**: Ensure correct commit order

**Method**: 
```
Store results in reorder buffer
Commit in program order
```

**Benefit**: Correct execution semantics

### Reorder Buffer Process

**1. Dispatch**:
```
Allocate reorder buffer entry
```

**2. Execute**:
```
Execute instruction
Store result in reorder buffer
```

**3. Commit**:
```
Commit in program order
Write to architectural registers
```

## Performance Benefits

### Performance Improvements

**1. Hide Latency**:
```
Hide memory latency
Hide instruction latency
```

**2. Improve Throughput**:
```
Execute more instructions per cycle
```

**3. Better Utilization**:
```
Better execution unit utilization
```

**4. Reduce Stalls**:
```
Reduce pipeline stalls
```

### Performance Example

**In-Order**:
```
Cycle 1: Load R1, [addr]    ; Start load
Cycle 2: (stall)             ; Wait for load
Cycle 3: (stall)             ; Wait for load
Cycle 4: Add R2, R1, R3      ; Execute add
```

**Out-of-Order**:
```
Cycle 1: Load R1, [addr]    ; Start load
Cycle 1: Add R2, R4, R5     ; Execute independent add
Cycle 2: Mul R6, R7, R8     ; Execute independent mul
Cycle 4: Add R2, R1, R3     ; Execute when R1 ready
```

**Benefit**: Better performance

## Real-World Examples

### Example 1: Modern x86 Processors

**OoO**: Deep OoO execution

**Features**: 
- **Wide Issue**: 4-6 instructions per cycle
- **Deep Pipeline**: 14-20 stages
- **Large ROB**: 200+ entries

**Performance**: High performance

### Example 2: ARM Processors

**OoO**: Moderate OoO execution

**Features**: 
- **Wide Issue**: 3-4 instructions per cycle
- **Moderate Pipeline**: 10-15 stages
- **Moderate ROB**: 50-100 entries

**Performance**: Good performance, power efficient

### Example 3: In-Order Processors

**In-Order**: Simple processors

**Features**: 
- **Narrow Issue**: 1-2 instructions per cycle
- **Shallow Pipeline**: 5-8 stages
- **No ROB**: In-order commit

**Performance**: Lower performance, lower power

## Common Pitfalls

### Problem: Assuming Order

```c
// BAD: Assume execution order
// OoO may reorder

// GOOD: Use memory barriers
// When order matters
```

### Problem: Ignoring Dependencies

```c
// BAD: Ignore dependencies
// May cause incorrect results

// GOOD: Understand dependencies
// Write correct code
```

## Quiz

1. What is out-of-order execution?
   - **A)** Executing instructions in program order
   - **B)** Executing instructions out of program order to improve performance
   - **C)** Executing instructions randomly
   - **D)** Executing instructions slowly

2. What is register renaming?
   - **A)** Changing register names
   - **B)** Mapping architectural registers to physical registers to eliminate false dependencies
   - **C)** Removing registers
   - **D)** Adding registers

3. What is the reorder buffer?
   - **A)** Instruction buffer
   - **B)** Buffer that maintains program order for correct commit
   - **C)** Data buffer
   - **D)** Cache buffer

**Answers:**
1. **B** - Out-of-order execution executes instructions when their operands are ready, not necessarily in program order, to improve CPU utilization
2. **B** - Register renaming maps architectural (program-visible) registers to physical registers, eliminating false dependencies (WAR, WAW) and enabling more parallelism
3. **B** - The reorder buffer stores results of out-of-order execution and commits them in program order to maintain correct execution semantics

## Next Steps

- [Speculative Execution & Security](../computer_architecture/10.%20Speculative%20Execution%20%26%20Security.md) - Speculation security
- [GPU Computing Advanced](../computer_architecture/11.%20GPU%20Computing%20Advanced.md) - Advanced GPU

