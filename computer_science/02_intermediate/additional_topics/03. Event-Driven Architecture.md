---
number: 3
title: "Event-Driven Architecture"
slug: "event-driven-architecture"
level: "intermediate"
tags: ["architecture", "event-driven", "events", "messaging", "pub-sub"]
prerequisites: ["microservices-architecture-patterns"]
estimated_minutes: 155
contributors: []
diagrams: []
examples: []
canonical_id: "cs-add-int-03"
---

# Event-Driven Architecture

## Overview

Event-driven architecture uses events to trigger and communicate between services. Understanding event-driven patterns, event sourcing, CQRS, message brokers, and event streaming is essential for building reactive, scalable systems.

## Table of Contents

1. [What is Event-Driven Architecture?](#what-is-event-driven)
2. [Event-Driven Patterns](#patterns)
3. [Event Sourcing](#event-sourcing)
4. [CQRS](#cqrs)
5. [Message Brokers](#message-brokers)
6. [Event Streaming](#event-streaming)
7. [Event-Driven Benefits](#benefits)
8. [Best Practices](#best-practices)

## What is Event-Driven Architecture?

### Definition

**Event-Driven Architecture**: 
```
Architecture based on events
Services react to events
```

**Characteristics**: 
- **Events**: Events as first-class citizens
- **Decoupled**: Loosely coupled services
- **Asynchronous**: Asynchronous communication
- **Reactive**: Reactive systems

**Use**: Real-time systems, microservices

### Event-Driven vs Request-Response

**Request-Response**: 
```
Synchronous
Tight coupling
```

**Event-Driven**: 
```
Asynchronous
Loose coupling
```

**Difference**: Coupling and timing

## Event-Driven Patterns

### Pattern Types

**1. Event Notification**: 
```
Notify about events
```

**2. Event-Carried State Transfer**: 
```
Carry state in events
```

**3. Event Sourcing**: 
```
Store events
```

**4. CQRS**: 
```
Separate read/write
```

### Event Notification

**Pattern**: 
```
Service publishes event
Other services subscribe
```

**Example**: 
```
OrderCreated event
→ Inventory service updates
→ Shipping service notified
→ Email service sends confirmation
```

## Event Sourcing

### What is Event Sourcing?

**Event Sourcing**: 
```
Store events, not state
Reconstruct state from events
```

**Benefits**: 
- **Audit Trail**: Complete history
- **Time Travel**: Replay events
- **Debugging**: Easier debugging

**Use**: Financial systems, audit requirements

### Event Sourcing Example

**Example**: 
```
Events:
- AccountCreated(accountId, balance=0)
- Deposit(accountId, amount=100)
- Withdraw(accountId, amount=30)

State: balance = 70 (reconstructed)
```

## CQRS

### What is CQRS?

**CQRS**: Command Query Responsibility Segregation

**Principle**: 
```
Separate read and write models
```

**Write Side**: 
```
Commands → Events → Write Model
```

**Read Side**: 
```
Events → Projections → Read Model
```

**Use**: High-performance systems

### CQRS Benefits

**Benefits**: 
- **Optimization**: Optimize separately
- **Scalability**: Scale separately
- **Flexibility**: More flexibility

**Trade-off**: More complexity

## Message Brokers

### What are Message Brokers?

**Message Brokers**: 
```
Intermediate messaging layer
```

**Functions**: 
- **Routing**: Route messages
- **Persistence**: Persist messages
- **Delivery**: Guarantee delivery

**Examples**: 
- **RabbitMQ**: Message broker
- **Apache Kafka**: Event streaming
- **Amazon SQS**: Queue service

### RabbitMQ

**RabbitMQ**: 
```
Message broker
AMQP protocol
```

**Features**: 
- **Queues**: Message queues
- **Exchanges**: Routing
- **Durability**: Persistent messages

**Use**: Traditional messaging

### Apache Kafka

**Kafka**: 
```
Event streaming platform
```

**Features**: 
- **Topics**: Event topics
- **Partitions**: Parallel processing
- **Replication**: High availability

**Use**: Event streaming, log aggregation

## Event Streaming

### What is Event Streaming?

**Event Streaming**: 
```
Continuous stream of events
```

**Characteristics**: 
- **Real-Time**: Real-time processing
- **Ordered**: Maintain order
- **Replayable**: Can replay

**Use**: Real-time analytics, event processing

### Stream Processing

**Processing**: 
```
Process events in real-time
```

**Frameworks**: 
- **Kafka Streams**: Stream processing
- **Apache Flink**: Stream processing
- **Apache Storm**: Real-time processing

**Use**: Real-time analytics

## Event-Driven Benefits

### Benefits

**1. Decoupling**: 
```
Services decoupled
```

**2. Scalability**: 
```
Scale independently
```

**3. Resilience**: 
```
Fault tolerance
```

**4. Flexibility**: 
```
Easy to add consumers
```

**5. Real-Time**: 
```
Real-time processing
```

## Best Practices

### Practice 1: Event Design

**Design**: 
```
Design events carefully
Immutable, versioned
```

**Benefit**: Stable events

### Practice 2: Idempotency

**Idempotency**: 
```
Handle duplicate events
```

**Benefit**: Reliability

### Practice 3: Ordering

**Ordering**: 
```
Maintain event order when needed
```

**Benefit**: Consistency

### Practice 4: Monitoring

**Monitoring**: 
```
Monitor event flow
```

**Benefit**: Observability

## Real-World Examples

### Example 1: E-Commerce

**Use**: Order processing

**Events**: 
- **OrderCreated**
- **PaymentProcessed**
- **OrderShipped**
- **OrderDelivered**

**Result**: Decoupled services

### Example 2: Financial Trading

**Use**: Trading system

**Events**: 
- **TradeExecuted**
- **PriceUpdated**
- **OrderFilled**

**Result**: Real-time processing

## Common Pitfalls

### Problem: Event Explosion

```c
// BAD: Too many events
// Overhead

// GOOD: Aggregate events
// Meaningful events
```

### Problem: No Ordering

```c
// BAD: Ignore ordering
// Inconsistencies

// GOOD: Handle ordering
// When needed
```

## Quiz

1. What is event-driven architecture?
   - **A)** Request-response architecture
   - **B)** Architecture based on events with asynchronous communication
   - **C)** Synchronous architecture
   - **D)** Monolithic architecture

2. What is event sourcing?
   - **A)** Store state
   - **B)** Store events and reconstruct state from events
   - **C)** Delete events
   - **D)** Ignore events

3. What is CQRS?
   - **A)** Combined queries
   - **B)** Command Query Responsibility Segregation - separate read/write models
   - **C)** Single model
   - **D)** No separation

**Answers:**
1. **B** - Event-driven architecture uses events for communication, enabling loose coupling and asynchronous processing
2. **B** - Event sourcing stores all state changes as events, allowing state reconstruction and time travel
3. **B** - CQRS separates command (write) and query (read) responsibilities for independent optimization

## Next Steps

- [Design Patterns Advanced](../additional_topics/04.%20Design%20Patterns%20Advanced.md) - Design patterns
- [Large-Scale System Design](../additional_topics/05.%20Large-Scale%20System%20Design.md) - System design

