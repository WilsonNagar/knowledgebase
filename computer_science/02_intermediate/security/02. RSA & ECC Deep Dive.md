---
number: 2
title: "RSA & ECC Deep Dive"
slug: "rsa-ecc-deep-dive"
level: "intermediate"
tags: ["security", "rsa", "ecc", "cryptography", "public-key"]
prerequisites: ["cryptography-fundamentals"]
estimated_minutes: 120
contributors: []
diagrams: []
examples: []
canonical_id: "cs-sec-02"
---

# RSA & ECC Deep Dive

## Overview

RSA and ECC (Elliptic Curve Cryptography) are the two main public-key cryptosystems. Understanding their mathematical foundations, key generation, encryption/decryption algorithms, and security properties in depth is essential for cryptography, security engineering, and understanding modern cryptographic systems.

## Table of Contents

1. [RSA Mathematical Foundation](#rsa-math)
2. [RSA Key Generation](#rsa-keygen)
3. [RSA Encryption/Decryption](#rsa-encrypt)
4. [RSA Security](#rsa-security)
5. [ECC Mathematical Foundation](#ecc-math)
6. [ECC Key Generation](#ecc-keygen)
7. [ECC Operations](#ecc-operations)
8. [ECC Security](#ecc-security)
9. [RSA vs ECC Comparison](#comparison)

## RSA Mathematical Foundation

### Number Theory Basics

**Modular Arithmetic**:
```
a ≡ b (mod n) if n divides (a - b)
```

**Euler's Totient Function** φ(n):
```
φ(n) = number of integers < n coprime to n

For prime p: φ(p) = p - 1
For p × q (primes): φ(pq) = (p-1)(q-1)
```

**Euler's Theorem**:
```
If gcd(a, n) = 1:
  a^φ(n) ≡ 1 (mod n)
```

### RSA Security Basis

**Factoring Problem**: 
- **Hard**: Factoring large composite numbers
- **RSA Security**: Based on difficulty of factoring

**RSA Assumption**:
- **Given**: n = p × q (public), e (public)
- **Hard**: Find d such that e × d ≡ 1 (mod φ(n))

## RSA Key Generation

### Key Generation Process

**Step 1: Choose Primes**:
```
1. Generate two large primes: p, q
2. Typically: 1024-4096 bits each
```

**Step 2: Compute Modulus**:
```
n = p × q
```

**Step 3: Compute Totient**:
```
φ(n) = (p - 1) × (q - 1)
```

**Step 4: Choose Public Exponent**:
```
e: Public exponent
Common: e = 65537 (2^16 + 1)
Requirement: gcd(e, φ(n)) = 1
```

**Step 5: Compute Private Exponent**:
```
d: Private exponent
d × e ≡ 1 (mod φ(n))
d = e^(-1) mod φ(n)
```

**Keys**:
- **Public**: (n, e)
- **Private**: (n, d)

### Key Generation Example

**Small Example**:
```
p = 61, q = 53
n = 61 × 53 = 3233
φ(n) = 60 × 52 = 3120
e = 17 (gcd(17, 3120) = 1)
d = 17^(-1) mod 3120 = 2753

Public key: (3233, 17)
Private key: (3233, 2753)
```

## RSA Encryption/Decryption

### Encryption

**Process**:
```
ciphertext = plaintext^e mod n
c = m^e mod n
```

**Requirements**:
- **Plaintext**: m < n
- **Public key**: (n, e)

### Decryption

**Process**:
```
plaintext = ciphertext^d mod n
m = c^d mod n
```

**Proof**:
```
c^d mod n = (m^e)^d mod n = m^(ed) mod n

Since ed ≡ 1 (mod φ(n)):
  ed = 1 + kφ(n) for some k

By Euler's theorem:
  m^(ed) = m^(1 + kφ(n)) = m × (m^φ(n))^k ≡ m (mod n)
```

### RSA Example

**Encryption**:
```
m = 89
c = 89^17 mod 3233 = 1394
```

**Decryption**:
```
m = 1394^2753 mod 3233 = 89
```

### RSA Padding

**Why Padding**: Prevent attacks

**PKCS#1 v1.5 Padding**:
```
00 02 [random bytes] 00 [message]
```

**OAEP Padding** (Optimal Asymmetric Encryption Padding):
```
More secure, recommended
```

## RSA Security

### Key Size Recommendations

**Security Levels**:
- **1024 bits**: Deprecated (can be broken)
- **2048 bits**: Minimum recommended
- **3072 bits**: High security
- **4096 bits**: Very high security

### Attacks on RSA

**1. Factoring Attack**:
```
Factor n = p × q
Then compute d
```

**2. Small Exponent Attack**:
```
If e is small and message is small:
  m^e < n, so c = m^e (no mod)
  Can compute m = c^(1/e)
```

**3. Timing Attack**:
```
Measure decryption time
Infer private key bits
```

**4. Padding Oracle Attack**:
```
Exploit padding validation
Recover plaintext
```

### RSA Performance

**Encryption**: Fast (public exponent usually small)

**Decryption**: Slow (private exponent large)

**Optimization**: Chinese Remainder Theorem (CRT)

## ECC Mathematical Foundation

### Elliptic Curves

**Equation**: y² = x³ + ax + b

**Properties**:
- **Smooth**: No cusps or self-intersections
- **Group**: Points form abelian group
- **Discrete Log**: Hard problem

### Elliptic Curve Group

**Point Addition**:
```
P + Q = R (on curve)
```

**Point Doubling**:
```
P + P = 2P
```

**Scalar Multiplication**:
```
k × P = P + P + ... + P (k times)
```

### Discrete Logarithm Problem

**ECDLP**: Elliptic Curve Discrete Logarithm Problem

**Given**: P, Q = k × P

**Find**: k

**Hard**: No efficient algorithm known

## ECC Key Generation

### Key Generation Process

**Step 1: Choose Curve**:
```
Select elliptic curve and generator point G
Common: secp256r1, secp384r1, secp521r1
```

**Step 2: Choose Private Key**:
```
d: Random integer (private key)
Range: [1, n-1] where n is curve order
```

**Step 3: Compute Public Key**:
```
Q = d × G (scalar multiplication)
Public key: Q
Private key: d
```

### ECC Key Example

**Curve**: secp256r1

**Private Key**: d (256-bit random)

**Public Key**: Q = d × G

**Size**: 256-bit private key, 512-bit public key (compressed: 257 bits)

## ECC Operations

### Point Addition

**Geometric Method**:
```
1. Draw line through P and Q
2. Find third intersection point R'
3. Reflect R' over x-axis → R
```

**Algebraic Method**:
```
If P ≠ Q:
  λ = (y_Q - y_P) / (x_Q - x_P)
  x_R = λ² - x_P - x_Q
  y_R = λ(x_P - x_R) - y_P

If P = Q (doubling):
  λ = (3x_P² + a) / (2y_P)
  x_R = λ² - 2x_P
  y_R = λ(x_P - x_R) - y_P
```

### Scalar Multiplication

**Binary Method**:
```
k × P:
  Result = O (point at infinity)
  For each bit of k (MSB to LSB):
    Result = 2 × Result
    If bit is 1:
      Result = Result + P
```

**Example**: 13 × P
```
13 = 1101 (binary)
Result = O
Bit 1: Result = 2×O + P = P
Bit 1: Result = 2×P + P = 3P
Bit 0: Result = 2×3P = 6P
Bit 1: Result = 2×6P + P = 13P
```

## ECC Security

### Key Size Comparison

**Equivalent Security**:
```
RSA 1024-bit ≈ ECC 160-bit
RSA 2048-bit ≈ ECC 224-bit
RSA 3072-bit ≈ ECC 256-bit
RSA 7680-bit ≈ ECC 384-bit
```

**ECC Advantage**: Much smaller keys for same security

### ECC Attacks

**1. Pollard's Rho**:
```
Generic discrete log algorithm
O(√n) complexity
```

**2. MOV Attack**:
```
If curve has small embedding degree
May reduce to finite field DLP
```

**3. Side-Channel Attacks**:
```
Timing attacks
Power analysis
```

## RSA vs ECC Comparison

### Comparison Table

| Aspect | RSA | ECC |
|--------|-----|-----|
| **Key Size** | Large (2048+ bits) | Small (256 bits) |
| **Security** | Based on factoring | Based on ECDLP |
| **Performance** | Slower (large keys) | Faster (small keys) |
| **Maturity** | Very mature | Mature |
| **Standardization** | Well-standardized | Well-standardized |

### When to Use What

**RSA**:
- **Legacy systems**: Already using RSA
- **Compatibility**: Wide compatibility
- **Large keys OK**: When key size not concern

**ECC**:
- **Mobile devices**: Smaller keys, less power
- **IoT**: Resource-constrained devices
- **Modern systems**: Better performance
- **High security**: Same security, smaller keys

## Real-World Examples

### Example 1: TLS/SSL

**RSA**: Used for key exchange (legacy)

**ECC**: Increasingly used (ECDHE)

**Benefits**: ECC faster, smaller keys

### Example 2: Bitcoin

**ECC**: Uses secp256k1 curve

**Private Key**: 256 bits

**Public Key**: 512 bits (uncompressed)

**Benefits**: Small keys, fast operations

### Example 3: Digital Signatures

**RSA**: RSA-PSS, RSA-PKCS#1

**ECC**: ECDSA, EdDSA

**Benefits**: ECC faster, smaller signatures

## Common Pitfalls

### Problem: Weak Random Number Generation

```c
// BAD: Predictable random numbers
int private_key = rand(); // Predictable!

// GOOD: Cryptographically secure random
int private_key = generate_secure_random();
```

### Problem: Small Key Sizes

```c
// BAD: Small RSA key
RSA_key = generate_rsa(512); // Too small!

// GOOD: Appropriate key size
RSA_key = generate_rsa(2048); // Minimum
ECC_key = generate_ecc(256); // Equivalent security
```

## Quiz

1. What is the security basis of RSA?
   - **A)** Discrete logarithm
   - **B)** Difficulty of factoring large composite numbers
   - **C)** Elliptic curves
   - **D)** Hash functions

2. What is the main advantage of ECC over RSA?
   - **A)** Simpler math
   - **B)** Smaller keys for equivalent security
   - **C)** Faster encryption
   - **D)** More mature

3. What is ECDLP?
   - **A)** Elliptic Curve Discrete Logarithm Problem
   - **B)** Encryption problem
   - **C)** Key generation problem
   - **D)** Signature problem

**Answers:**
1. **B** - RSA security is based on the difficulty of factoring large composite numbers (n = p × q) into their prime factors
2. **B** - ECC provides equivalent security with much smaller keys (e.g., 256-bit ECC ≈ 3072-bit RSA), making it more efficient
3. **A** - ECDLP (Elliptic Curve Discrete Logarithm Problem) is finding k given P and Q = k×P, which forms the security basis of ECC

## Next Steps

- [Secure Coding Practices](../security/03.%20Secure%20Coding%20Practices.md) - Avoiding vulnerabilities
- [Authentication Protocols](../security/04.%20Authentication%20Protocols.md) - OAuth, JWT

