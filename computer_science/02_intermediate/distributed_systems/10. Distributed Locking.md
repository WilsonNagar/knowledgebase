---
number: 10
title: "Distributed Locking"
slug: "distributed-locking"
level: "intermediate"
tags: ["distributed-systems", "locking", "distributed-locks", "coordination"]
prerequisites: ["distributed-caching-redis-memcached-strategies"]
estimated_minutes: 135
contributors: []
diagrams: []
examples: []
canonical_id: "cs-dist-10"
---

# Distributed Locking

## Overview

Distributed locking coordinates access to shared resources across distributed systems. Understanding distributed lock implementations, lock algorithms, lock expiration, and coordination services is essential for building correct distributed systems.

## Table of Contents

1. [What is Distributed Locking?](#what-is-distributed-locking)
2. [Distributed Lock Challenges](#challenges)
3. [Lock Algorithms](#lock-algorithms)
4. [Redis Distributed Locks](#redis-locks)
5. [ZooKeeper Locks](#zookeeper-locks)
6. [etcd Locks](#etcd-locks)
7. [Lock Patterns](#lock-patterns)
8. [Best Practices](#best-practices)

## What is Distributed Locking?

### Definition

**Distributed Lock**: Lock across distributed nodes

**Purpose**: Coordinate access to shared resources

**Use Cases**: 
- **Critical Sections**: Protect critical sections
- **Resource Access**: Coordinate resource access
- **Leader Election**: Leader election
- **Distributed Transactions**: Distributed transactions

**Challenge**: Network partitions, failures

### Distributed Lock Requirements

**1. Mutual Exclusion**:
```
Only one holder at a time
```

**2. Deadlock Freedom**:
```
No deadlocks
```

**3. Fault Tolerance**:
```
Handle failures
```

**4. Performance**:
```
Low latency
```

## Distributed Lock Challenges

### Challenges

**1. Network Partitions**:
```
Network partitions
```

**2. Clock Skew**:
```
Clock synchronization
```

**3. Failures**:
```
Node failures
```

**4. Lock Expiration**:
```
Lock expiration
```

### The Problem

**Problem**: Ensure only one holder

**Challenge**: 
- **Network**: Network delays
- **Failures**: Node failures
- **Partitions**: Network partitions

**Solution**: Distributed lock algorithms

## Lock Algorithms

### Algorithm 1: Simple Lock

**Simple Lock**: Basic lock with expiration

**Method**:
```
SET lock_key value NX EX timeout
```

**Problem**: May release wrong lock if expired

**Use**: Simple cases

### Algorithm 2: Redlock

**Redlock**: Distributed lock algorithm

**Method**:
```
1. Acquire lock on majority of nodes
2. If majority: Lock acquired
3. If not: Release all locks
```

**Benefit**: More reliable

**Use**: When need strong guarantees

### Algorithm 3: Fencing Token

**Fencing Token**: Monotonically increasing token

**Method**:
```
1. Acquire lock
2. Get fencing token
3. Include token in requests
4. Reject requests with old token
```

**Benefit**: Prevents wrong lock release

## Redis Distributed Locks

### Redis Lock Implementation

**Basic Lock**:
```python
import redis
import uuid
import time

def acquire_lock(conn, lockname, acquire_timeout=10):
    identifier = str(uuid.uuid4())
    end = time.time() + acquire_timeout
    
    while time.time() < end:
        if conn.set(lockname, identifier, nx=True, ex=10):
            return identifier
        time.sleep(0.001)
    return False

def release_lock(conn, lockname, identifier):
    pipe = conn.pipeline(True)
    while True:
        try:
            pipe.watch(lockname)
            if pipe.get(lockname) == identifier:
                pipe.multi()
                pipe.delete(lockname)
                pipe.execute()
                return True
            pipe.unwatch()
            break
        except redis.WatchError:
            pass
    return False
```

### Redis Lock Features

**1. NX Option**:
```
Only if not exists
```

**2. EX Option**:
```
Expiration time
```

**3. Lua Scripts**:
```
Atomic operations
```

**4. Watch**:
```
Optimistic locking
```

## ZooKeeper Locks

### ZooKeeper Lock Implementation

**Ephemeral Sequential Nodes**:
```python
def acquire_lock(zk, lock_path):
    # Create ephemeral sequential node
    lock_node = zk.create(
        lock_path + "/lock-",
        ephemeral=True,
        sequence=True
    )
    
    # Get all lock nodes
    children = zk.get_children(lock_path)
    children.sort()
    
    # If this is the smallest, lock acquired
    if lock_node.endswith(children[0]):
        return lock_node
    
    # Otherwise, watch previous node
    prev_node = children[children.index(lock_node.split('/')[-1]) - 1]
    zk.exists(lock_path + "/" + prev_node, watch=True)
    return lock_node
```

### ZooKeeper Lock Features

**1. Ephemeral Nodes**:
```
Auto-delete on disconnect
```

**2. Sequential Nodes**:
```
Ordered nodes
```

**3. Watches**:
```
Watch for changes
```

**4. Fairness**:
```
Fair lock acquisition
```

## etcd Locks

### etcd Lock Implementation

**Lease-Based Lock**:
```python
def acquire_lock(etcd_client, lock_key):
    # Create lease
    lease = etcd_client.lease(10)  # 10 second TTL
    
    # Try to acquire lock
    try:
        etcd_client.put(lock_key, "locked", lease=lease)
        return lease
    except etcd3.exceptions.PreconditionFailed:
        # Lock already held
        return None

def release_lock(etcd_client, lease):
    lease.revoke()
```

### etcd Lock Features

**1. Leases**:
```
Time-based leases
```

**2. TTL**:
```
Time-to-live
```

**3. Watch**:
```
Watch for changes
```

**4. Transactions**:
```
Atomic operations
```

## Lock Patterns

### Pattern 1: Mutex Lock

**Mutex**: Mutual exclusion

**Use**: Protect critical sections

**Example**: 
```
Acquire lock
// Critical section
Release lock
```

### Pattern 2: Read-Write Lock

**Read-Write Lock**: Multiple readers, single writer

**Use**: Read-heavy workloads

**Example**: 
```
Acquire read lock (multiple)
// Read operations
Release read lock

Acquire write lock (exclusive)
// Write operations
Release write lock
```

### Pattern 3: Distributed Semaphore

**Semaphore**: Limit concurrent access

**Use**: Rate limiting, resource pools

**Example**: 
```
Acquire semaphore (up to N)
// Use resource
Release semaphore
```

## Best Practices

### Practice 1: Use Timeouts

**Timeouts**: 
```
Set lock timeouts
Prevent deadlocks
```

**Benefit**: Automatic release

### Practice 2: Renew Locks

**Renewal**: 
```
Renew locks before expiration
For long operations
```

**Benefit**: Prevent premature release

### Practice 3: Handle Failures

**Failures**: 
```
Handle lock acquisition failures
Retry with backoff
```

**Benefit**: Resilience

### Practice 4: Use Fencing Tokens

**Fencing Tokens**: 
```
Use fencing tokens
Prevent wrong lock release
```

**Benefit**: Correctness

## Real-World Examples

### Example 1: Distributed Task Processing

**Use**: Process tasks once

**Lock**: Distributed lock

**Method**: 
```
Acquire lock
Process task
Release lock
```

**Result**: Tasks processed once

### Example 2: Leader Election

**Use**: Elect single leader

**Lock**: Distributed lock

**Method**: 
```
Acquire lock = become leader
Hold lock = remain leader
Lose lock = step down
```

**Result**: Single leader

## Common Pitfalls

### Problem: Lock Expiration

```c
// BAD: Lock expires during operation
// Another process acquires lock

// GOOD: Renew locks
// Or use fencing tokens
```

### Problem: Wrong Lock Release

```c
// BAD: Release wrong lock
// If lock expired and reacquired

// GOOD: Use unique identifiers
// Verify before release
```

## Quiz

1. What is distributed locking?
   - **A)** Local locking
   - **B)** Coordinating access to shared resources across distributed nodes
   - **C)** Database locking
   - **D)** File locking

2. What is Redlock?
   - **A)** Simple lock
   - **B)** Distributed lock algorithm requiring majority of nodes
   - **C)** Local lock
   - **D)** Database lock

3. What is a fencing token?
   - **A)** Lock key
   - **B)** Monotonically increasing token to prevent wrong lock release
   - **C)** Lock value
   - **D)** Lock timeout

**Answers:**
1. **B** - Distributed locking coordinates access to shared resources across distributed nodes, ensuring mutual exclusion
2. **B** - Redlock requires acquiring locks on a majority of nodes, making it more reliable than single-node locks
3. **B** - A fencing token is a monotonically increasing token included with requests to prevent processing requests after lock expiration

## Next Steps

- [Leader Election Algorithms](../distributed_systems/11.%20Leader%20Election%20Algorithms.md) - Leader election
- [Distributed Transactions](../distributed_systems/12.%20Distributed%20Transactions.md) - Distributed transactions

