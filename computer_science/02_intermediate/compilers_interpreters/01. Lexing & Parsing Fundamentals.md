---
number: 1
title: "Lexing & Parsing Fundamentals"
slug: "lexing-parsing-fundamentals"
level: "intermediate"
tags: ["compilers", "lexing", "parsing", "lexer", "parser", "grammar"]
prerequisites: []
estimated_minutes: 110
contributors: []
diagrams: []
examples: []
canonical_id: "cs-comp-01"
---

# Lexing & Parsing Fundamentals

## Overview

Lexing and parsing are the first stages of compilation, converting source code into structured representations. Understanding lexical analysis, parsing algorithms (LL, LR, recursive descent), and grammar design is essential for building compilers, interpreters, and language processing tools.

## Table of Contents

1. [Compilation Pipeline Overview](#pipeline)
2. [Lexical Analysis (Lexing)](#lexing)
3. [Regular Expressions & Finite Automata](#regex-fa)
4. [Parsing Overview](#parsing)
5. [Context-Free Grammars](#grammars)
6. [LL Parsing](#ll-parsing)
7. [LR Parsing](#lr-parsing)
8. [Recursive Descent Parsing](#recursive-descent)

## Compilation Pipeline Overview

### Stages of Compilation

**Pipeline**:
```
Source Code
    ↓
Lexer (Tokenization)
    ↓
Parser (Syntax Analysis)
    ↓
AST (Abstract Syntax Tree)
    ↓
Semantic Analysis
    ↓
Code Generation / Interpretation
```

**Key Stages**:
1. **Lexing**: Characters → Tokens
2. **Parsing**: Tokens → AST
3. **Semantic Analysis**: Type checking, etc.
4. **Code Generation**: AST → Machine code

## Lexical Analysis (Lexing)

### What is Lexing?

**Lexing**: Convert character stream to token stream

**Input**: `"x = 10 + 20"`

**Output**: `[IDENTIFIER("x"), EQUALS, NUMBER(10), PLUS, NUMBER(20)]`

### Tokens

**Token**: Smallest meaningful unit

**Types**:
- **Keywords**: `if`, `while`, `return`
- **Identifiers**: `x`, `myVariable`
- **Literals**: `10`, `"hello"`, `3.14`
- **Operators**: `+`, `-`, `*`, `=`
- **Punctuation**: `(`, `)`, `{`, `}`, `;`

### Lexer Implementation

**Simple Lexer**:
```c
typedef enum {
    TOKEN_IDENTIFIER,
    TOKEN_NUMBER,
    TOKEN_PLUS,
    TOKEN_EQUALS,
    TOKEN_EOF
} TokenType;

typedef struct {
    TokenType type;
    char* value;
    int line;
    int column;
} Token;

Token* lex(const char* input) {
    Token* tokens = malloc(sizeof(Token) * 100);
    int pos = 0;
    int line = 1, col = 1;
    
    while (*input) {
        // Skip whitespace
        if (isspace(*input)) {
            if (*input == '\n') {
                line++;
                col = 1;
            } else {
                col++;
            }
            input++;
            continue;
        }
        
        // Identifier or keyword
        if (isalpha(*input)) {
            char* start = input;
            while (isalnum(*input)) input++;
            int len = input - start;
            char* ident = strndup(start, len);
            tokens[pos++] = create_token(TOKEN_IDENTIFIER, ident, line, col);
            col += len;
            continue;
        }
        
        // Number
        if (isdigit(*input)) {
            char* start = input;
            while (isdigit(*input)) input++;
            int len = input - start;
            char* num = strndup(start, len);
            tokens[pos++] = create_token(TOKEN_NUMBER, num, line, col);
            col += len;
            continue;
        }
        
        // Operators
        if (*input == '+') {
            tokens[pos++] = create_token(TOKEN_PLUS, "+", line, col);
            input++;
            col++;
            continue;
        }
        
        // ... handle other tokens
    }
    
    tokens[pos] = create_token(TOKEN_EOF, NULL, line, col);
    return tokens;
}
```

## Regular Expressions & Finite Automata

### Regular Expressions

**Definition**: Pattern matching language

**Basic Operations**:
- **Concatenation**: `ab` (a followed by b)
- **Alternation**: `a|b` (a or b)
- **Kleene star**: `a*` (zero or more a's)

**Examples**:
- **Identifier**: `[a-zA-Z][a-zA-Z0-9]*`
- **Number**: `[0-9]+`
- **Whitespace**: `\s+`

### Finite Automata

**DFA (Deterministic Finite Automaton)**:
- **States**: Set of states
- **Transitions**: State → State on input
- **Start state**: Initial state
- **Accept states**: Final states

**Example** (Identifier):
```
States: {start, identifier, error}
Start: start
Accept: identifier

Transitions:
start --[a-z]--> identifier
identifier --[a-z0-9]--> identifier
identifier --[other]--> error
```

**NFA (Nondeterministic Finite Automaton)**:
- **Multiple transitions**: From same state on same input
- **Epsilon transitions**: No input needed
- **Convertible**: To DFA

### RE → NFA → DFA

**Process**:
1. **RE → NFA**: Thompson's construction
2. **NFA → DFA**: Subset construction
3. **DFA → Code**: Generate lexer code

**Tools**: `lex`, `flex` automate this

## Parsing Overview

### What is Parsing?

**Parsing**: Convert token stream to syntax tree

**Input**: `[IDENTIFIER("x"), EQUALS, NUMBER(10), PLUS, NUMBER(20)]`

**Output**: AST (Abstract Syntax Tree)
```
    =
   / \
  x   +
     / \
   10  20
```

### Parse Trees vs AST

**Parse Tree**:
- **Complete**: Every grammar rule represented
- **Verbose**: Includes all details
- **Use**: Understanding grammar

**AST (Abstract Syntax Tree)**:
- **Simplified**: Only essential structure
- **Compact**: Removes syntactic sugar
- **Use**: Compilation, interpretation

## Context-Free Grammars

### What is a Grammar?

**Grammar**: Rules defining valid syntax

**Components**:
- **Terminals**: Tokens (leaf nodes)
- **Non-terminals**: Grammar rules (internal nodes)
- **Productions**: Rules (A → α)
- **Start symbol**: Root of parse tree

### Grammar Notation

**BNF (Backus-Naur Form)**:
```
expression → term
expression → expression + term
term → factor
term → term * factor
factor → NUMBER
factor → ( expression )
```

**EBNF (Extended BNF)**:
```
expression → term ( '+' term )*
term → factor ( '*' factor )*
factor → NUMBER | '(' expression ')'
```

### Grammar Example

**Simple Arithmetic**:
```
expr   → expr '+' term
expr   → expr '-' term
expr   → term
term   → term '*' factor
term   → term '/' factor
term   → factor
factor → NUMBER
factor → '(' expr ')'
```

**Parse Tree** for `10 + 20 * 30`:
```
      expr
     / | \
  expr + term
   |      |
 term   factor
   |      |
factor  NUMBER(30)
   |
NUMBER(10)
```

## LL Parsing

### What is LL?

**LL**: Left-to-right, Leftmost derivation

**Characteristics**:
- **Top-down**: Start from start symbol
- **Predictive**: Predict which rule to use
- **Left-recursive**: Cannot handle left recursion directly

### LL(1) Parser

**LL(1)**: 1 token lookahead

**Parse Table**:
```
        NUMBER  +     *     (     )     EOF
expr   term    -     -     term  -     -
term   factor  -     -     factor -     -
factor NUMBER  -     -     (expr) -     -
```

**Algorithm**:
```
1. Start with start symbol on stack
2. Match input token with top of stack
3. If terminal: Pop and consume token
4. If non-terminal: Replace with production
5. Repeat until stack empty
```

### LL Parser Example

**Grammar**:
```
expr → term ('+' term)*
term → factor ('*' factor)*
factor → NUMBER
```

**Parse** `10 + 20`:
```
Stack:        Input:         Action:
expr          10 + 20        Expand: expr → term ('+' term)*
term ('+' term)*  10 + 20    Expand: term → factor ('*' factor)*
factor ('*' factor)* ('+' term)*  10 + 20  Expand: factor → NUMBER
NUMBER ('*' factor)* ('+' term)*  10 + 20  Match NUMBER
('*' factor)* ('+' term)*  + 20    Skip (empty)
('+' term)*  + 20          Match +
term ('+' term)*  20        Expand: term → factor ('*' factor)*
factor ('*' factor)* ('+' term)*  20      Expand: factor → NUMBER
NUMBER ('*' factor)* ('+' term)*  20      Match NUMBER
('*' factor)* ('+' term)*  EOF    Skip (empty)
('+' term)*  EOF            Skip (empty)
Done
```

## LR Parsing

### What is LR?

**LR**: Left-to-right, Rightmost derivation (reverse)

**Characteristics**:
- **Bottom-up**: Start from input, reduce to start symbol
- **More powerful**: Handles more grammars than LL
- **Complex**: More complex to implement

### LR(1) Parser

**LR(1)**: 1 token lookahead

**States**: Set of items (rules with positions)

**Actions**:
- **Shift**: Move input token to stack
- **Reduce**: Replace handle with non-terminal
- **Accept**: Successfully parsed
- **Error**: Syntax error

### LR Parser Example

**Grammar**:
```
S → E
E → E + T
E → T
T → NUMBER
```

**Parse** `10 + 20`:
```
Stack:     Input:      Action:
[]         10 + 20     Shift
[10]       + 20        Reduce: T → NUMBER
[T]        + 20        Reduce: E → T
[E]        + 20        Shift
[E +]      20          Shift
[E + 20]   EOF         Reduce: T → NUMBER
[E + T]    EOF         Reduce: E → E + T
[E]        EOF         Reduce: S → E
[S]        EOF         Accept
```

## Recursive Descent Parsing

### What is Recursive Descent?

**Recursive Descent**: Write parser as recursive functions

**Characteristics**:
- **Intuitive**: One function per non-terminal
- **Easy to implement**: Direct translation from grammar
- **LL(1)**: Typically implements LL(1) parsing

### Recursive Descent Parser

**Grammar**:
```
expr → term ('+' term | '-' term)*
term → factor ('*' factor | '/' factor)*
factor → NUMBER | '(' expr ')'
```

**Parser**:
```c
Token* tokens;
int pos = 0;

Token peek() {
    return tokens[pos];
}

Token consume() {
    return tokens[pos++];
}

Node* parse_expr() {
    Node* left = parse_term();
    
    while (peek().type == TOKEN_PLUS || peek().type == TOKEN_MINUS) {
        Token op = consume();
        Node* right = parse_term();
        left = create_binary_node(op.type, left, right);
    }
    
    return left;
}

Node* parse_term() {
    Node* left = parse_factor();
    
    while (peek().type == TOKEN_MULTIPLY || peek().type == TOKEN_DIVIDE) {
        Token op = consume();
        Node* right = parse_factor();
        left = create_binary_node(op.type, left, right);
    }
    
    return left;
}

Node* parse_factor() {
    if (peek().type == TOKEN_NUMBER) {
        return create_number_node(consume().value);
    }
    
    if (peek().type == TOKEN_LPAREN) {
        consume(); // '('
        Node* expr = parse_expr();
        consume(); // ')'
        return expr;
    }
    
    error("Expected number or '('");
}
```

### Left Recursion Problem

**Problem**: Left-recursive grammar causes infinite recursion

**Grammar**:
```
expr → expr '+' term  // Left recursive!
```

**Parser**:
```c
Node* parse_expr() {
    Node* left = parse_expr(); // Infinite recursion!
    // ...
}
```

**Solution**: Transform grammar (remove left recursion)

**Transformed**:
```
expr → term expr'
expr' → '+' term expr' | ε
```

## Real-World Examples

### Example 1: JSON Parser

**Grammar**:
```
json → object | array
object → '{' (pair (',' pair)*)? '}'
pair → STRING ':' value
array → '[' (value (',' value)*)? ']'
value → STRING | NUMBER | object | array | 'true' | 'false' | 'null'
```

**Implementation**: Recursive descent parser

### Example 2: SQL Parser

**Grammar**:
```
select → SELECT columns FROM table (WHERE condition)?
columns → '*' | column (',' column)*
condition → expr op expr
```

**Implementation**: LR parser (handles complex SQL)

## Common Pitfalls

### Problem: Ambiguous Grammar

```c
// BAD: Ambiguous grammar
expr → expr '+' expr | expr '*' expr | NUMBER
// Is 1 + 2 * 3 parsed as (1+2)*3 or 1+(2*3)?

// GOOD: Unambiguous grammar
expr → expr '+' term | term
term → term '*' factor | factor
factor → NUMBER
// Clear precedence: * before +
```

### Problem: Left Recursion

```c
// BAD: Left recursion
expr → expr '+' term

// GOOD: Remove left recursion
expr → term expr'
expr' → '+' term expr' | ε
```

## Quiz

1. What is the difference between lexing and parsing?
   - **A)** No difference
   - **B)** Lexing converts characters to tokens, parsing converts tokens to AST
   - **C)** Parsing is faster
   - **D)** Lexing handles semantics

2. What is a key limitation of LL parsers?
   - **A)** Cannot handle left recursion directly
   - **B)** Too fast
   - **C)** Cannot handle right recursion
   - **D)** Too simple

3. What is recursive descent parsing?
   - **A)** Bottom-up parsing
   - **B)** Top-down parsing using recursive functions
   - **C)** LR parsing
   - **D)** Table-driven parsing

**Answers:**
1. **B** - Lexing converts the character stream into tokens, while parsing converts the token stream into an Abstract Syntax Tree (AST)
2. **A** - LL parsers cannot handle left recursion directly because it causes infinite recursion in recursive descent implementations
3. **B** - Recursive descent parsing is a top-down parsing technique where each non-terminal in the grammar corresponds to a recursive function

## Next Steps

- [AST & Intermediate Representation](../compilers_interpreters/02.%20AST%20%26%20Intermediate%20Representation.md) - AST design
- [Optimization Passes](../compilers_interpreters/03.%20Optimization%20Passes.md) - Code optimization

