---
number: 6
title: "Garbage Collection Design"
slug: "garbage-collection-design"
level: "intermediate"
tags: ["compilers", "garbage-collection", "gc", "memory-management", "algorithms"]
prerequisites: ["jit-compilation"]
estimated_minutes: 140
contributors: []
diagrams: []
examples: []
canonical_id: "cs-comp-06"
---

# Garbage Collection Design

## Overview

Garbage collection automatically manages memory by reclaiming unused objects. Understanding different GC algorithms like mark-sweep, generational GC, G1, ZGC, and their trade-offs is essential for language runtime design and understanding how modern languages manage memory.

## Table of Contents

1. [What is Garbage Collection?](#what-is-gc)
2. [GC Design Goals](#goals)
3. [Mark-Sweep Algorithm](#mark-sweep)
4. [Mark-Compact Algorithm](#mark-compact)
5. [Copying/Generational GC](#generational)
6. [G1 Garbage Collector](#g1)
7. [ZGC & Shenandoah](#zgc-shenandoah)
8. [GC Tuning](#gc-tuning)

## What is Garbage Collection?

### Definition

**Garbage Collection**: Automatic memory management

**Purpose**: Reclaim unused memory

**Process**: 
1. Identify live objects
2. Reclaim dead objects

**Benefit**: Prevents memory leaks

### GC vs Manual Memory Management

**Manual**:
- **Control**: Full control
- **Overhead**: Low overhead
- **Risk**: Memory leaks, use-after-free

**GC**:
- **Safety**: Prevents leaks
- **Overhead**: GC pauses
- **Trade-off**: Safety vs performance

## GC Design Goals

### Goals

**1. Throughput**:
```
Maximize application time
Minimize GC time
```

**2. Latency**:
```
Minimize pause times
```

**3. Memory**:
```
Minimize memory overhead
```

**4. Scalability**:
```
Handle large heaps
```

## Mark-Sweep Algorithm

### Algorithm

**Phase 1: Mark**:
```
1. Start from roots
2. Mark all reachable objects
3. Traverse object graph
```

**Phase 2: Sweep**:
```
1. Scan entire heap
2. Free unmarked objects
```

### Mark-Sweep Example

**Heap**:
```
[A] → [B] → [C]
[D] (unreachable)
[E] → [F]
```

**Mark**: A, B, C, E, F marked

**Sweep**: D freed

### Mark-Sweep Properties

**Advantages**:
- **Simple**: Easy to implement
- **No Moving**: Objects don't move

**Disadvantages**:
- **Fragmentation**: Memory fragmentation
- **Stop-the-World**: Pauses application

## Mark-Compact Algorithm

### Algorithm

**Phase 1: Mark**:
```
Same as mark-sweep
```

**Phase 2: Compact**:
```
1. Move live objects together
2. Update references
3. Free end of heap
```

### Mark-Compact Properties

**Advantages**:
- **No Fragmentation**: Eliminates fragmentation
- **Locality**: Better cache locality

**Disadvantages**:
- **Moving**: Objects move (update references)
- **Slower**: More overhead than mark-sweep

## Copying/Generational GC

### Generational Hypothesis

**Observation**: Most objects die young

**Implication**: 
- **Young Generation**: Small, collect frequently
- **Old Generation**: Large, collect infrequently

**Benefit**: Most collections are fast

### Generational GC

**Young Generation**:
```
New objects allocated here
Collected frequently (minor GC)
```

**Old Generation**:
```
Long-lived objects promoted here
Collected infrequently (major GC)
```

**Promotion**: Objects surviving young GC promoted

### Copying Collector

**Method**: 
```
1. Divide heap into two spaces
2. Allocate in one space
3. When full: Copy live objects to other space
4. Swap spaces
```

**Benefit**: Fast allocation, no fragmentation

**Cost**: Uses only half of heap

## G1 Garbage Collector

### What is G1?

**G1**: Garbage-First collector

**Design**: Low-latency GC

**Method**: 
- **Heap Partitioning**: Divide into regions
- **Incremental**: Collect regions incrementally
- **Predictable**: Predictable pause times

### G1 Process

**1. Young Collection**:
```
Collect young regions
```

**2. Concurrent Marking**:
```
Mark live objects concurrently
```

**3. Mixed Collection**:
```
Collect young + some old regions
```

**4. Full GC**:
```
Fallback if needed
```

### G1 Benefits

**1. Low Latency**:
```
Predictable pause times
```

**2. Scalability**:
```
Handles large heaps
```

**3. Incremental**:
```
Collects incrementally
```

## ZGC & Shenandoah

### ZGC

**ZGC**: Z Garbage Collector

**Goal**: Ultra-low latency

**Features**:
- **Concurrent**: Most work concurrent
- **Colored Pointers**: Mark in pointers
- **Low Pause**: < 10ms pauses

**Use**: Low-latency applications

### Shenandoah

**Shenandoah**: Low-pause GC

**Features**:
- **Concurrent**: Concurrent evacuation
- **Low Pause**: Independent of heap size
- **Throughput**: Good throughput

**Use**: Large heap applications

## GC Tuning

### Tuning Parameters

**1. Heap Size**:
```
-Xms: Initial heap size
-Xmx: Maximum heap size
```

**2. Generation Sizes**:
```
Young generation size
Old generation size
```

**3. GC Algorithm**:
```
Choose appropriate GC
```

### Tuning Strategy

**1. Measure**:
```
Measure GC metrics
Pause times, throughput
```

**2. Analyze**:
```
Identify bottlenecks
```

**3. Tune**:
```
Adjust parameters
```

**4. Verify**:
```
Measure again
```

## Real-World Examples

### Example 1: Java GC

**Options**: 
- **Serial GC**: Single-threaded
- **Parallel GC**: Multi-threaded
- **G1 GC**: Low latency
- **ZGC**: Ultra-low latency

**Choice**: Depends on requirements

### Example 2: Go GC

**GC**: Concurrent mark-sweep

**Features**: Low latency, good throughput

**Use**: Go runtime

## Common Pitfalls

### Problem: Too Frequent GC

```java
// BAD: Too small heap
// Frequent GC, poor performance

// GOOD: Appropriate heap size
// Balance memory and GC frequency
```

### Problem: Long Pauses

```java
// BAD: Wrong GC for latency-sensitive app
// Long pauses unacceptable

// GOOD: Use low-latency GC (G1, ZGC)
// For latency-sensitive applications
```

## Quiz

1. What is garbage collection?
   - **A)** Manual memory management
   - **B)** Automatic memory management that reclaims unused objects
   - **C)** Memory allocation
   - **D)** Memory deallocation

2. What is the generational hypothesis?
   - **A)** All objects live long
   - **B)** Most objects die young, enabling efficient generational GC
   - **C)** Objects never die
   - **D)** Objects always die

3. What is G1 GC?
   - **A)** First generation GC
   - **B)** Garbage-First collector designed for low latency and large heaps
   - **C)** General GC
   - **D)** Generic GC

**Answers:**
1. **B** - Garbage collection automatically identifies and reclaims memory occupied by objects that are no longer reachable, preventing memory leaks
2. **B** - The generational hypothesis states that most objects die young, enabling efficient GC by frequently collecting the young generation (where most objects die) and infrequently collecting the old generation
3. **B** - G1 (Garbage-First) is a low-latency garbage collector that partitions the heap into regions and collects them incrementally to provide predictable pause times

## Next Steps

- [Escape Analysis](../compilers_interpreters/07.%20Escape%20Analysis.md) - Stack allocation
- [Type Systems & Type Inference](../compilers_interpreters/08.%20Type%20Systems.md) - Type checking

