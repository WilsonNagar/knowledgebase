---
number: 11
title: "Fenwick Trees & Binary Indexed Trees"
slug: "fenwick-trees-binary-indexed-trees"
level: "intermediate"
tags: ["data-structures", "fenwick-tree", "binary-indexed-tree", "range-queries", "prefix-sums"]
prerequisites: ["advanced-data-structures-tries-segment-trees"]
estimated_minutes: 105
contributors: []
diagrams: []
examples: []
canonical_id: "cs-dsa-11"
---

# Fenwick Trees & Binary Indexed Trees

## Overview

Fenwick Trees (Binary Indexed Trees) are efficient data structures for prefix sum queries and point updates. Understanding Fenwick trees, their bit manipulation tricks, and when to use them over segment trees is essential for competitive programming and efficient range query problems.

## Table of Contents

1. [Prefix Sum Problem](#prefix-sum)
2. [What is Fenwick Tree?](#what-is-fenwick)
3. [Bit Manipulation Tricks](#bit-tricks)
4. [Fenwick Tree Operations](#operations)
5. [Range Updates](#range-updates)
6. [2D Fenwick Tree](#2d-fenwick)
7. [Fenwick vs Segment Tree](#comparison)
8. [Applications](#applications)

## Prefix Sum Problem

### Problem Statement

**Problem**: 
- **Query**: Sum from index 0 to i
- **Update**: Update element at index i

**Naive**: 
- **Query**: O(n) - sum elements
- **Update**: O(1) - update element

**Goal**: Both O(log n)

**Solution**: Fenwick Tree

### Prefix Sum Example

**Array**: [1, 3, 5, 7, 9, 11]

**Prefix Sums**: [1, 4, 9, 16, 25, 36]

**Query(3)**: Sum from 0 to 3 = 16

**Update(2, 10)**: Change element at 2 to 10

## What is Fenwick Tree?

### Definition

**Fenwick Tree**: Binary Indexed Tree (BIT)

**Purpose**: Efficient prefix sums

**Operations**: 
- **Query**: O(log n)
- **Update**: O(log n)

**Space**: O(n)

**Advantage**: Simpler than segment tree

### Structure

**Array**: Stores prefix sums

**Indexing**: Uses binary representation tricks

**Size**: Same as input array

## Bit Manipulation Tricks

### Least Significant Bit (LSB)

**LSB**: Rightmost set bit

**Example**: 
```
12 = 1100 (binary)
LSB = 4 (100)
```

**Formula**: `i & -i`

**Why**: Two's complement property

### Parent and Next

**Parent**: Remove LSB
```
parent(i) = i - (i & -i)
```

**Next**: Add LSB
```
next(i) = i + (i & -i)
```

**Use**: Navigate tree

## Fenwick Tree Operations

### Update Operation

**Process**:
```
1. Update element at index i
2. Update all affected prefix sums
3. Move to next index (add LSB)
```

**Code**:
```c
void update(int* fenwick, int n, int idx, int delta) {
    idx++;  // 1-indexed
    while (idx <= n) {
        fenwick[idx] += delta;
        idx += idx & -idx;  // Move to next
    }
}
```

**Example**:
```
Update index 2 with delta +5
fenwick[3] += 5  (3 = 2+1)
fenwick[4] += 5  (4 = 3 + 1)
fenwick[8] += 5  (8 = 4 + 4)
```

### Query Operation

**Process**:
```
1. Start at index i
2. Sum values
3. Move to parent (remove LSB)
4. Repeat until 0
```

**Code**:
```c
int query(int* fenwick, int idx) {
    idx++;  // 1-indexed
    int sum = 0;
    while (idx > 0) {
        sum += fenwick[idx];
        idx -= idx & -idx;  // Move to parent
    }
    return sum;
}
```

**Example**:
```
Query index 5 (prefix sum 0..5)
sum += fenwick[6]  (6 = 5+1)
sum += fenwick[4]  (4 = 6 - 2)
sum += fenwick[0]  (0 = 4 - 4, stop)
```

### Initialization

**Process**: Build from array

**Code**:
```c
void build(int* arr, int* fenwick, int n) {
    for (int i = 0; i < n; i++) {
        update(fenwick, n, i, arr[i]);
    }
}
```

## Range Updates

### Point Update, Range Query

**Standard**: Point update, prefix query

**Range Query**: 
```
query_range(l, r) = query(r) - query(l-1)
```

### Range Update, Point Query

**Problem**: Update range [l, r], query point

**Solution**: Difference array + Fenwick

**Process**:
```
1. Update l: +delta
2. Update r+1: -delta
3. Query point: Prefix sum
```

## 2D Fenwick Tree

### Extension to 2D

**2D Array**: Matrix

**Operations**: 
- **Update**: Update point
- **Query**: Sum in rectangle [0..x, 0..y]

**Implementation**: Nested loops

**Code**:
```c
void update_2d(int** fenwick, int n, int m, int x, int y, int delta) {
    x++; y++;
    for (int i = x; i <= n; i += i & -i) {
        for (int j = y; j <= m; j += j & -j) {
            fenwick[i][j] += delta;
        }
    }
}

int query_2d(int** fenwick, int x, int y) {
    x++; y++;
    int sum = 0;
    for (int i = x; i > 0; i -= i & -i) {
        for (int j = y; j > 0; j -= j & -j) {
            sum += fenwick[i][j];
        }
    }
    return sum;
}
```

## Fenwick vs Segment Tree

### Comparison

| Aspect | Fenwick Tree | Segment Tree |
|--------|--------------|--------------|
| **Code** | Simpler | More complex |
| **Space** | O(n) | O(4n) |
| **Prefix Query** | O(log n) | O(log n) |
| **Range Query** | O(log n) | O(log n) |
| **Range Update** | Complex | Easier |
| **Flexibility** | Less | More |

### When to Use What

**Fenwick Tree**:
- **Prefix sums**: Perfect for prefix queries
- **Simplicity**: When code simplicity matters
- **Memory**: When memory constrained

**Segment Tree**:
- **Range queries**: Any range, not just prefix
- **Range updates**: When need range updates
- **Flexibility**: More operations needed

## Applications

### Application 1: Inversion Count

**Problem**: Count inversions in array

**Solution**: Fenwick Tree

**Process**: 
```
1. Coordinate compression
2. Process from right to left
3. Query prefix sum
4. Update count
```

### Application 2: Range Sum Queries

**Problem**: Sum in range [l, r]

**Solution**: Fenwick Tree

**Query**: `query(r) - query(l-1)`

### Application 3: Order Statistics

**Problem**: Kth smallest element

**Solution**: Fenwick Tree + Binary search

**Process**: Binary search on prefix sums

## Real-World Examples

### Example 1: Stock Prices

**Problem**: Track stock price changes

**Solution**: Fenwick Tree

**Query**: Total change over period

### Example 2: Frequency Counting

**Problem**: Count frequencies, query range

**Solution**: Fenwick Tree

**Update**: Increment frequency

**Query**: Sum frequencies in range

## Common Pitfalls

### Problem: 0-Indexed vs 1-Indexed

```c
// BAD: Confusion between 0-indexed and 1-indexed
fenwick[idx] += delta;  // Wrong if 0-indexed!

// GOOD: Convert to 1-indexed
idx++;
fenwick[idx] += delta;
```

### Problem: Wrong LSB Calculation

```c
// BAD: Wrong LSB
idx += idx & (~idx + 1);  // Complex

// GOOD: Use two's complement
idx += idx & -idx;  // Simple and correct
```

## Quiz

1. What is a Fenwick Tree?
   - **A)** Binary tree
   - **B)** Binary Indexed Tree for efficient prefix sum queries
   - **C)** Segment tree
   - **D)** Hash table

2. What is the time complexity of Fenwick Tree operations?
   - **A)** O(1)
   - **B)** O(log n) for both query and update
   - **C)** O(n)
   - **D)** O(n log n)

3. What is the main advantage of Fenwick Tree over Segment Tree?
   - **A)** Faster
   - **B)** Simpler code and less memory
   - **C)** More features
   - **D)** Better range updates

**Answers:**
1. **B** - Fenwick Tree (Binary Indexed Tree) is a data structure designed for efficient prefix sum queries and point updates using bit manipulation tricks
2. **B** - Both query and update operations in Fenwick Tree take O(log n) time by navigating the tree using least significant bit operations
3. **B** - Fenwick Tree has simpler implementation code and uses O(n) space compared to Segment Tree's O(4n), though it's less flexible for range operations

## Next Steps

- [Advanced String Algorithms](../data_structures_algorithms/12.%20Advanced%20String%20Algorithms.md) - Aho-Corasick
- [Computational Geometry](../data_structures_algorithms/13.%20Computational%20Geometry.md) - Geometric algorithms

