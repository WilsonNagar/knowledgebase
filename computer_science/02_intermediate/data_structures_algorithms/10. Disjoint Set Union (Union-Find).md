---
number: 10
title: "Disjoint Set Union (Union-Find)"
slug: "disjoint-set-union-union-find"
level: "intermediate"
tags: ["data-structures", "union-find", "disjoint-sets", "dsu", "algorithms"]
prerequisites: []
estimated_minutes: 110
contributors: []
diagrams: []
examples: []
canonical_id: "cs-dsa-10"
---

# Disjoint Set Union (Union-Find)

## Overview

Disjoint Set Union (DSU), also known as Union-Find, is a data structure that efficiently manages disjoint sets and supports union and find operations. Understanding DSU with path compression and union by rank is essential for solving connectivity problems, Kruskal's algorithm, and many graph algorithms.

## Table of Contents

1. [What is Union-Find?](#what-is-union-find)
2. [Basic Operations](#basic-operations)
3. [Naive Implementation](#naive)
4. [Union by Rank](#union-by-rank)
5. [Path Compression](#path-compression)
6. [Optimized Union-Find](#optimized)
7. [Applications](#applications)
8. [Complexity Analysis](#complexity)

## What is Union-Find?

### Definition

**Union-Find**: Data structure for disjoint sets

**Operations**:
- **Find**: Find representative of set
- **Union**: Merge two sets

**Use**: Connectivity problems, dynamic connectivity

### Disjoint Sets

**Disjoint**: Sets with no common elements

**Example**:
```
Set 1: {1, 2, 3}
Set 2: {4, 5}
Set 3: {6}
```

**Union**: Merge sets
**Find**: Check if elements in same set

## Basic Operations

### Find Operation

**Purpose**: Find representative of element's set

**Representative**: Unique identifier for set

**Example**:
```
Find(2) → 1 (representative)
Find(5) → 4 (representative)
```

### Union Operation

**Purpose**: Merge two sets

**Process**: Make representatives same

**Example**:
```
Union(2, 5) → Merge sets {1,2,3} and {4,5}
New sets: {1,2,3,4,5}
```

## Naive Implementation

### Simple Approach

**Structure**: Array parent[i] = parent of i

**Find**: Follow parent pointers to root

**Union**: Make one root point to other

**Code**:
```c
int parent[MAX];

void make_set(int n) {
    for (int i = 0; i < n; i++) {
        parent[i] = i;
    }
}

int find(int x) {
    if (parent[x] != x) {
        return find(parent[x]);
    }
    return x;
}

void union_sets(int x, int y) {
    int root_x = find(x);
    int root_y = find(y);
    if (root_x != root_y) {
        parent[root_x] = root_y;
    }
}
```

### Problem

**Worst Case**: O(n) per operation

**Example**: Linear chain
```
1 → 2 → 3 → 4 → 5
Find(1) traverses entire chain
```

**Solution**: Optimizations

## Union by Rank

### What is Rank?

**Rank**: Upper bound on tree height

**Heuristic**: Attach smaller tree to larger

**Benefit**: Keeps trees balanced

### Implementation

**Structure**: 
- **parent[]**: Parent pointers
- **rank[]**: Rank of each element

**Code**:
```c
int parent[MAX];
int rank[MAX];

void make_set(int n) {
    for (int i = 0; i < n; i++) {
        parent[i] = i;
        rank[i] = 0;
    }
}

int find(int x) {
    if (parent[x] != x) {
        return find(parent[x]);
    }
    return x;
}

void union_sets(int x, int y) {
    int root_x = find(x);
    int root_y = find(y);
    
    if (root_x == root_y) return;
    
    if (rank[root_x] < rank[root_y]) {
        parent[root_x] = root_y;
    } else if (rank[root_x] > rank[root_y]) {
        parent[root_y] = root_x;
    } else {
        parent[root_y] = root_x;
        rank[root_x]++;
    }
}
```

### Benefits

**Balanced Trees**: Prevents linear chains

**Complexity**: O(log n) per operation

## Path Compression

### What is Path Compression?

**Path Compression**: Flatten tree during find

**Process**: Make all nodes point directly to root

**Benefit**: Faster future finds

### Implementation

**Code**:
```c
int find(int x) {
    if (parent[x] != x) {
        parent[x] = find(parent[x]);  // Path compression
    }
    return parent[x];
}
```

### Example

**Before**:
```
1 → 2 → 3 → 4 (root)
```

**After Find(1)**:
```
1 → 4 (root)
2 → 4 (root)
3 → 4 (root)
```

**Result**: All point directly to root

## Optimized Union-Find

### Combined Optimizations

**Both**: Union by rank + Path compression

**Complexity**: Nearly O(1) amortized

**Inverse Ackermann**: α(n) - extremely slow growing

**Practical**: Effectively constant time

### Complete Implementation

```c
class UnionFind {
    vector<int> parent;
    vector<int> rank;
    
public:
    UnionFind(int n) {
        parent.resize(n);
        rank.resize(n, 0);
        for (int i = 0; i < n; i++) {
            parent[i] = i;
        }
    }
    
    int find(int x) {
        if (parent[x] != x) {
            parent[x] = find(parent[x]);  // Path compression
        }
        return parent[x];
    }
    
    void unite(int x, int y) {
        int root_x = find(x);
        int root_y = find(y);
        
        if (root_x == root_y) return;
        
        // Union by rank
        if (rank[root_x] < rank[root_y]) {
            parent[root_x] = root_y;
        } else if (rank[root_x] > rank[root_y]) {
            parent[root_y] = root_x;
        } else {
            parent[root_y] = root_x;
            rank[root_x]++;
        }
    }
    
    bool connected(int x, int y) {
        return find(x) == find(y);
    }
};
```

## Applications

### Application 1: Kruskal's Algorithm

**Use**: Minimum spanning tree

**Process**:
```
1. Sort edges by weight
2. For each edge:
   if endpoints in different sets:
       add edge
       union sets
```

**Benefit**: Efficient cycle detection

### Application 2: Connected Components

**Problem**: Find connected components in graph

**Solution**: Union-Find

**Process**:
```
For each edge (u, v):
    union(u, v)
```

**Result**: Each set = one component

### Application 3: Dynamic Connectivity

**Problem**: Check connectivity as edges added/removed

**Solution**: Union-Find

**Benefit**: Efficient updates

### Application 4: Image Processing

**Problem**: Label connected regions

**Solution**: Union-Find

**Process**: Union adjacent pixels

## Complexity Analysis

### Time Complexity

**Without Optimization**: O(n) per operation

**With Union by Rank**: O(log n) per operation

**With Both**: O(α(n)) amortized per operation

**α(n)**: Inverse Ackermann function (effectively constant)

### Space Complexity

**Space**: O(n)

**Storage**: parent[] and rank[] arrays

## Real-World Examples

### Example 1: Social Networks

**Problem**: Find if two people connected

**Solution**: Union-Find

**Process**: Union friends, find connection

### Example 2: Network Connectivity

**Problem**: Check if network nodes connected

**Solution**: Union-Find

**Process**: Union connected nodes

## Common Pitfalls

### Problem: Not Using Path Compression

```c
// BAD: No path compression
int find(int x) {
    if (parent[x] != x) {
        return find(parent[x]);  // No compression
    }
    return x;
}

// GOOD: With path compression
int find(int x) {
    if (parent[x] != x) {
        parent[x] = find(parent[x]);  // Compress
    }
    return parent[x];
}
```

### Problem: Not Using Union by Rank

```c
// BAD: Always attach to second
void union_sets(int x, int y) {
    parent[find(x)] = find(y);  // May create chains
}

// GOOD: Union by rank
void union_sets(int x, int y) {
    // Use rank to balance trees
}
```

## Quiz

1. What is Union-Find used for?
   - **A)** Sorting
   - **B)** Managing disjoint sets and checking connectivity
   - **C)** Searching
   - **D)** Hashing

2. What is path compression?
   - **A)** Reducing memory
   - **B)** Flattening tree during find to make future finds faster
   - **C)** Compressing data
   - **D)** Reducing operations

3. What is union by rank?
   - **A)** Sorting by rank
   - **B)** Attaching smaller tree to larger to keep trees balanced
   - **C)** Ranking unions
   - **D)** Ordering by rank

**Answers:**
1. **B** - Union-Find efficiently manages disjoint sets and supports operations to check if elements are in the same set (connectivity) and merge sets
2. **B** - Path compression flattens the tree structure during find operations by making all nodes point directly to the root, speeding up future find operations
3. **B** - Union by rank attaches the smaller tree to the larger tree's root, keeping trees balanced and preventing linear chains that would slow down operations

## Next Steps

- [Fenwick Trees & Binary Indexed Trees](../data_structures_algorithms/11.%20Fenwick%20Trees.md) - Range queries
- [Advanced String Algorithms](../data_structures_algorithms/12.%20Advanced%20String%20Algorithms.md) - Aho-Corasick

