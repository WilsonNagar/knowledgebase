---
number: 4
title: "String Algorithms - KMP & Z-Algorithm"
slug: "string-algorithms-kmp-z-algorithm"
level: "intermediate"
tags: ["algorithms", "strings", "kmp", "z-algorithm", "pattern-matching"]
prerequisites: []
estimated_minutes: 110
contributors: []
diagrams: []
examples: []
canonical_id: "cs-dsa-04"
---

# String Algorithms - KMP & Z-Algorithm

## Overview

String matching algorithms are fundamental for text processing, search engines, and bioinformatics. Understanding the Knuth-Morris-Pratt (KMP) algorithm and Z-algorithm for efficient pattern matching is essential for handling large text data efficiently.

## Table of Contents

1. [String Matching Problem](#problem)
2. [Naive Algorithm](#naive)
3. [KMP Algorithm](#kmp)
4. [KMP Implementation](#kmp-implementation)
5. [Z-Algorithm](#z-algorithm)
6. [Z-Algorithm Implementation](#z-implementation)
7. [Algorithm Comparison](#comparison)
8. [Applications](#applications)

## String Matching Problem

### Problem Definition

**Input**: 
- **Text**: T[0..n-1]
- **Pattern**: P[0..m-1]

**Output**: All positions where P occurs in T

**Example**:
```
Text: "ababcababa"
Pattern: "aba"
Output: [0, 5, 7] (positions where pattern found)
```

### Complexity Goals

**Naive**: O(n × m)

**Goal**: O(n + m)

**Algorithms**: KMP, Z-algorithm achieve O(n + m)

## Naive Algorithm

### Naive Approach

**Algorithm**:
```
For each position i in text:
    Try to match pattern starting at i
    If match: Record position
```

**Code**:
```c
void naive_search(char* text, char* pattern) {
    int n = strlen(text);
    int m = strlen(pattern);
    
    for (int i = 0; i <= n - m; i++) {
        int j = 0;
        while (j < m && text[i + j] == pattern[j]) {
            j++;
        }
        if (j == m) {
            printf("Found at position %d\n", i);
        }
    }
}
```

### Naive Complexity

**Time**: O(n × m)

**Example**: Worst case
```
Text: "aaaaaaaaab"
Pattern: "aaaab"
Every position tries to match, fails at end
```

## KMP Algorithm

### What is KMP?

**KMP**: Knuth-Morris-Pratt algorithm

**Key Idea**: Use information from previous matches

**Avoid**: Re-checking characters already matched

### KMP Insight

**Observation**: When mismatch occurs, we know what we've matched

**Example**:
```
Text: "ababcababa"
Pattern: "abab"
At position 2: Match "ab", mismatch at 'c'
We know text[0..1] = "ab"
Can skip checking text[1] again
```

### Failure Function (LPS)

**LPS**: Longest Proper Prefix which is also Suffix

**Definition**: For each position, longest prefix that's also suffix

**Example**: Pattern "abab"
```
Position: 0  1  2  3
Pattern:  a  b  a  b
LPS:      0  0  1  2

LPS[3] = 2: "ab" is prefix and suffix
```

### LPS Construction

**Algorithm**:
```c
void compute_lps(char* pattern, int* lps) {
    int m = strlen(pattern);
    lps[0] = 0;
    int len = 0;
    int i = 1;
    
    while (i < m) {
        if (pattern[i] == pattern[len]) {
            len++;
            lps[i] = len;
            i++;
        } else {
            if (len != 0) {
                len = lps[len - 1];
            } else {
                lps[i] = 0;
                i++;
            }
        }
    }
}
```

### KMP Search Algorithm

**Process**:
```
1. Precompute LPS array
2. Match pattern with text
3. On mismatch: Use LPS to skip characters
```

**Code**:
```c
void kmp_search(char* text, char* pattern) {
    int n = strlen(text);
    int m = strlen(pattern);
    int lps[m];
    
    compute_lps(pattern, lps);
    
    int i = 0; // Text index
    int j = 0; // Pattern index
    
    while (i < n) {
        if (text[i] == pattern[j]) {
            i++;
            j++;
        }
        
        if (j == m) {
            printf("Found at position %d\n", i - j);
            j = lps[j - 1];
        } else if (i < n && text[i] != pattern[j]) {
            if (j != 0) {
                j = lps[j - 1];
            } else {
                i++;
            }
        }
    }
}
```

## KMP Implementation

### Complete KMP Example

**Pattern**: "abab"

**LPS Array**:
```
Pattern: a  b  a  b
LPS:     0  0  1  2
```

**Search**:
```
Text: "ababcababa"
i=0, j=0: 'a'=='a' → i=1, j=1
i=1, j=1: 'b'=='b' → i=2, j=2
i=2, j=2: 'a'=='a' → i=3, j=3
i=3, j=3: 'b'=='b' → i=4, j=4 (match!)
Found at position 0
j = lps[3] = 2
i=4, j=2: 'c'!='a' → j = lps[1] = 0
i=4, j=0: 'c'!='a' → i=5
...
```

## Z-Algorithm

### What is Z-Algorithm?

**Z-Algorithm**: Find all occurrences of pattern

**Z-Array**: Z[i] = longest substring starting at i that's also prefix

**Example**: String "abababab"
```
Index:  0  1  2  3  4  5  6  7
String: a  b  a  b  a  b  a  b
Z:      8  0  6  0  4  0  2  0

Z[0] = 8: Entire string matches prefix
Z[2] = 6: "ababab" matches prefix "ababab"
```

### Z-Array Construction

**Algorithm**:
```c
void compute_z(char* s, int* z) {
    int n = strlen(s);
    int l = 0, r = 0;
    
    for (int i = 1; i < n; i++) {
        if (i > r) {
            l = r = i;
            while (r < n && s[r - l] == s[r]) {
                r++;
            }
            z[i] = r - l;
            r--;
        } else {
            int k = i - l;
            if (z[k] < r - i + 1) {
                z[i] = z[k];
            } else {
                l = i;
                while (r < n && s[r - l] == s[r]) {
                    r++;
                }
                z[i] = r - l;
                r--;
            }
        }
    }
}
```

### Z-Algorithm for Pattern Matching

**Process**:
```
1. Create string: pattern + '$' + text
2. Compute Z-array
3. Find positions where Z[i] == pattern_length
```

**Code**:
```c
void z_search(char* text, char* pattern) {
    int m = strlen(pattern);
    int n = strlen(text);
    char* s = malloc(m + 1 + n + 1);
    
    strcpy(s, pattern);
    strcat(s, "$");
    strcat(s, text);
    
    int len = strlen(s);
    int z[len];
    compute_z(s, z);
    
    for (int i = m + 1; i < len; i++) {
        if (z[i] == m) {
            printf("Found at position %d\n", i - m - 1);
        }
    }
    
    free(s);
}
```

## Z-Algorithm Implementation

### Z-Algorithm Example

**Pattern**: "ab"

**Text**: "ababab"

**Combined**: "ab$ababab"

**Z-Array**:
```
Index:  0  1  2  3  4  5  6  7  8
String: a  b  $  a  b  a  b  a  b
Z:      2  0  0  2  0  4  0  2  0

Z[3] = 2: Matches pattern length → Found at position 0
Z[5] = 4: But starts at position 5, pattern length 2
Actually: Z[5] = 4 means "abab" matches prefix
But we want positions where Z[i] == 2 (pattern length)
```

## Algorithm Comparison

### Comparison Table

| Algorithm | Time | Space | Preprocessing |
|-----------|------|-------|---------------|
| **Naive** | O(n×m) | O(1) | None |
| **KMP** | O(n+m) | O(m) | O(m) |
| **Z-Algorithm** | O(n+m) | O(n+m) | O(n+m) |

### When to Use What

**Naive**:
- **Short patterns**: When pattern very short
- **Simple**: When simplicity needed

**KMP**:
- **General**: Good general-purpose algorithm
- **Memory**: When memory constrained

**Z-Algorithm**:
- **Multiple patterns**: Can find all patterns
- **String analysis**: When need Z-array

## Applications

### Application 1: Text Search

**Use**: Search engines, text editors

**Algorithm**: KMP or Z-algorithm

**Benefit**: Fast pattern matching

### Application 2: DNA Sequence Matching

**Use**: Bioinformatics

**Algorithm**: KMP or specialized algorithms

**Benefit**: Efficient sequence search

### Application 3: String Compression

**Use**: Data compression

**Algorithm**: Z-algorithm for finding repetitions

**Benefit**: Identify repeated substrings

## Real-World Examples

### Example 1: grep Implementation

**grep**: Uses efficient string matching

**Algorithm**: Boyer-Moore or similar

**Benefit**: Fast text search

### Example 2: Text Editor Search

**Find**: Pattern matching in editor

**Algorithm**: KMP or optimized naive

**Benefit**: Fast search in large documents

## Common Pitfalls

### Problem: Off-by-One Errors

```c
// BAD: Off-by-one
for (int i = 0; i < n; i++) {
    // May access out of bounds
}

// GOOD: Careful bounds checking
for (int i = 0; i <= n - m; i++) {
    // Safe
}
```

### Problem: Not Handling Empty Pattern

```c
// BAD: Assume pattern not empty
int m = strlen(pattern);
// May crash if pattern is empty

// GOOD: Check empty pattern
if (m == 0) {
    return; // Handle empty pattern
}
```

## Quiz

1. What is the time complexity of KMP algorithm?
   - **A)** O(n × m)
   - **B)** O(n + m)
   - **C)** O(n²)
   - **D)** O(m²)

2. What is the LPS array in KMP?
   - **A)** Longest Proper Prefix which is also Suffix
   - **B)** Longest pattern string
   - **C)** Last position string
   - **D)** Linear prefix string

3. What does Z-algorithm compute?
   - **A)** Pattern length
   - **B)** Z-array where Z[i] is longest substring starting at i that's also prefix
   - **C)** Text length
   - **D)** Match count

**Answers:**
1. **B** - KMP algorithm achieves O(n + m) time complexity by preprocessing the pattern and using the LPS array to avoid re-checking characters
2. **A** - LPS (Longest Proper Prefix which is also Suffix) array stores for each position the length of the longest prefix that is also a suffix, used to skip unnecessary comparisons
3. **B** - Z-algorithm computes a Z-array where Z[i] represents the length of the longest substring starting at position i that matches the prefix of the string

## Next Steps

- [Advanced Data Structures](../data_structures_algorithms/05.%20Advanced%20Data%20Structures.md) - Tries, segment trees
- [Suffix Arrays & Trees](../data_structures_algorithms/06.%20Suffix%20Arrays%20%26%20Trees.md) - Advanced string structures

