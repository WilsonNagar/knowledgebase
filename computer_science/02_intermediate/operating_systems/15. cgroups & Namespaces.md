---
number: 15
title: "cgroups & Namespaces"
slug: "cgroups-namespaces"
level: "intermediate"
tags: ["operating-systems", "cgroups", "namespaces", "containers", "isolation"]
prerequisites: ["power-management"]
estimated_minutes: 120
contributors: []
diagrams: []
examples: []
canonical_id: "cs-os-15"
---

# cgroups & Namespaces

## Overview

cgroups and namespaces are Linux kernel features that enable resource isolation and process isolation, forming the foundation of containerization. Understanding how cgroups limit resources and namespaces provide isolation is essential for understanding containers, Docker, and modern system architecture.

## Table of Contents

1. [What are cgroups?](#what-are-cgroups)
2. [cgroup Controllers](#controllers)
3. [cgroup Hierarchy](#hierarchy)
4. [What are Namespaces?](#what-are-namespaces)
5. [Namespace Types](#namespace-types)
6. [Container Technology](#containers)
7. [cgroups v2](#cgroups-v2)
8. [Real-World Examples](#examples)

## What are cgroups?

### Definition

**cgroups**: Control Groups

**Purpose**: Limit and account for resource usage

**Resources**: CPU, memory, I/O, network

**Use**: Resource isolation, containers

### cgroups Benefits

**1. Resource Limiting**:
```
Limit CPU, memory, I/O
Prevent resource exhaustion
```

**2. Prioritization**:
```
Prioritize certain processes
```

**3. Accounting**:
```
Track resource usage
Monitor consumption
```

**4. Control**:
```
Freeze processes
Checkpoint/restore
```

## cgroup Controllers

### CPU Controller

**Purpose**: Control CPU usage

**Features**:
- **CPU Shares**: Relative CPU allocation
- **CPU Quota**: Absolute CPU limit
- **CPU Set**: Pin to specific CPUs

**Example**:
```
cpu.shares = 1024
cpu.cfs_quota_us = 50000  # 50% CPU
cpu.cfs_period_us = 100000
```

### Memory Controller

**Purpose**: Control memory usage

**Features**:
- **Memory Limit**: Hard limit
- **Memory+Swap Limit**: Total limit
- **OOM Killer**: Kill when limit exceeded

**Example**:
```
memory.limit_in_bytes = 1G
memory.memsw.limit_in_bytes = 2G
```

### I/O Controller

**Purpose**: Control I/O bandwidth

**Features**:
- **Read/Write Limits**: Bandwidth limits
- **IOPS Limits**: I/O operations per second

**Example**:
```
blkio.throttle.read_bps_device = 10M
blkio.throttle.write_bps_device = 5M
```

### Network Controller

**Purpose**: Control network bandwidth

**Features**:
- **Bandwidth Limits**: Network speed
- **Class-based**: Traffic classes

## cgroup Hierarchy

### Tree Structure

**Hierarchy**: Tree of cgroups

**Root**: Root cgroup

**Children**: Child cgroups inherit limits

**Processes**: Assigned to cgroups

### cgroup Example

```
/ (root)
├── systemd
│   ├── user.slice
│   └── system.slice
└── docker
    ├── container1
    └── container2
```

**Inheritance**: Child inherits parent limits

## What are Namespaces?

### Definition

**Namespaces**: Isolate system resources

**Purpose**: Provide process isolation

**Types**: PID, network, mount, UTS, IPC, user

**Use**: Containers, virtualization

### Namespace Benefits

**1. Isolation**:
```
Isolate processes
Separate views of system
```

**2. Security**:
```
Prevent access to other namespaces
```

**3. Resource Management**:
```
Separate resource views
```

## Namespace Types

### PID Namespace

**Purpose**: Isolate process IDs

**Effect**: Processes see different PID space

**Use**: Containers see PID 1 as their init

**Example**:
```
Host: PID 1000, 1001, 1002
Container: PID 1, 2, 3 (different processes)
```

### Network Namespace

**Purpose**: Isolate network stack

**Effect**: Separate network interfaces, routing tables

**Use**: Containers have own network

**Example**:
```
Host: eth0, lo
Container: eth0, lo (different interfaces)
```

### Mount Namespace

**Purpose**: Isolate file system mounts

**Effect**: Separate mount points

**Use**: Containers see different file system

**Example**:
```
Host: /, /home, /usr
Container: / (rootfs), /app
```

### UTS Namespace

**Purpose**: Isolate hostname

**Effect**: Different hostname per namespace

**Use**: Containers have own hostname

**Example**:
```
Host: hostname = "server1"
Container: hostname = "container1"
```

### IPC Namespace

**Purpose**: Isolate inter-process communication

**Effect**: Separate shared memory, semaphores

**Use**: Containers isolated IPC

### User Namespace

**Purpose**: Isolate user IDs

**Effect**: Map UIDs/GIDs

**Use**: Root in container ≠ root on host

**Example**:
```
Container: UID 0 (root)
Host: UID 1000 (mapped)
```

## Container Technology

### Containers = cgroups + Namespaces

**cgroups**: Resource limits

**Namespaces**: Process isolation

**Together**: Complete container

### Container Creation

**Process**:
```
1. Create namespaces
2. Create cgroup
3. Set resource limits
4. Start process in namespaces
5. Process isolated and limited
```

### Docker Example

**Docker Uses**:
- **PID namespace**: Process isolation
- **Network namespace**: Network isolation
- **Mount namespace**: File system isolation
- **UTS namespace**: Hostname isolation
- **IPC namespace**: IPC isolation
- **User namespace**: User ID mapping
- **cgroups**: Resource limits

## cgroups v2

### What is cgroups v2?

**cgroups v2**: Unified hierarchy

**Improvement**: Single hierarchy (v1 had multiple)

**Benefits**: Simpler, more consistent

### cgroups v2 Features

**1. Unified Hierarchy**:
```
Single tree structure
All controllers in one hierarchy
```

**2. Improved Interface**:
```
Simpler API
Better control
```

**3. Enhanced Controllers**:
```
Better memory controller
Improved I/O controller
```

## Real-World Examples

### Example 1: Docker Containers

**cgroups**: Limit CPU, memory, I/O

**Namespaces**: Isolate processes, network, file system

**Result**: Isolated, resource-limited containers

### Example 2: Systemd Services

**cgroups**: Limit service resources

**Example**:
```
[Service]
MemoryLimit=1G
CPUQuota=50%
```

**Benefit**: Prevent service from exhausting resources

### Example 3: Kubernetes Pods

**cgroups**: Limit pod resources

**Namespaces**: Isolate pods

**Result**: Multi-container pods with resource limits

## Common Pitfalls

### Problem: Not Setting Limits

```bash
# BAD: No resource limits
# Container can exhaust resources

# GOOD: Set appropriate limits
docker run --memory=1g --cpus=2 container
```

### Problem: Namespace Leakage

```bash
# BAD: Not cleaning up namespaces
# Namespaces remain after container stops

# GOOD: Proper cleanup
# Container runtime handles cleanup
```

## Quiz

1. What are cgroups used for?
   - **A)** Process scheduling
   - **B)** Limiting and accounting for resource usage (CPU, memory, I/O)
   - **C)** Network routing
   - **D)** File system management

2. What are namespaces used for?
   - **A)** Resource limiting
   - **B)** Isolating system resources to provide process isolation
   - **C)** Memory management
   - **D)** CPU scheduling

3. What do containers use?
   - **A)** Only cgroups
   - **B)** Both cgroups (resource limits) and namespaces (isolation)
   - **C)** Only namespaces
   - **D)** Neither

**Answers:**
1. **B** - cgroups (control groups) are used to limit and account for resource usage including CPU, memory, I/O, and network bandwidth
2. **B** - Namespaces isolate system resources (PID, network, mount, etc.) to provide process isolation, allowing processes to have separate views of the system
3. **B** - Containers use both cgroups for resource limiting (CPU, memory limits) and namespaces for isolation (separate process, network, file system views)

## Next Steps

- [File System Internals Advanced](./16.%20File%20System%20Internals%20Advanced.md) - Advanced file systems
- [Process Scheduling Advanced](./17.%20Process%20Scheduling%20Advanced.md) - Advanced scheduling

