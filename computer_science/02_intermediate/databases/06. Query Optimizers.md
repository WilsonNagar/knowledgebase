---
number: 6
title: "Query Optimizers"
slug: "query-optimizers"
level: "intermediate"
tags: ["databases", "query-optimization", "sql", "execution-plans", "cost-based"]
prerequisites: ["b-tree-vs-lsm-trees"]
estimated_minutes: 120
contributors: []
diagrams: []
examples: []
canonical_id: "cs-db-06"
---

# Query Optimizers

## Overview

Query optimizers are critical components of database systems that transform SQL queries into efficient execution plans. Understanding how optimizers work, cost-based optimization, join algorithms, and execution plan analysis is essential for database performance tuning and understanding database internals.

## Table of Contents

1. [What is Query Optimization?](#what-is-optimization)
2. [Query Processing Pipeline](#pipeline)
3. [Query Parsing & Analysis](#parsing)
4. [Cost-Based Optimization](#cost-based)
5. [Join Algorithms](#join-algorithms)
6. [Index Selection](#index-selection)
7. [Execution Plans](#execution-plans)
8. [Optimization Techniques](#techniques)

## What is Query Optimization?

### The Problem

**SQL Query**: High-level declarative language

**Execution**: Must translate to low-level operations

**Challenge**: Many ways to execute same query

**Goal**: Find most efficient execution plan

### Example

**Query**:
```sql
SELECT * FROM users u
JOIN orders o ON u.id = o.user_id
WHERE u.age > 30 AND o.total > 100;
```

**Possible Plans**:
```
Plan 1: Scan users → Filter age > 30 → Join → Filter total > 100
Plan 2: Scan orders → Filter total > 100 → Join → Filter age > 30
Plan 3: Use index on users.age → Join → Filter total > 100
Plan 4: Use index on orders.total → Join → Filter age > 30
```

**Optimizer**: Chooses best plan

## Query Processing Pipeline

### Stages

**1. Parsing**:
```
SQL → Parse tree
```

**2. Analysis**:
```
Parse tree → Validated query
Check: Syntax, semantics, permissions
```

**3. Optimization**:
```
Query → Execution plan
Choose: Best plan based on cost
```

**4. Execution**:
```
Execution plan → Results
Execute: Physical operations
```

## Query Parsing & Analysis

### Parsing

**Input**: SQL query string

**Output**: Parse tree (AST)

**Process**: Similar to compiler parsing

**Example**:
```sql
SELECT name FROM users WHERE age > 30
```

**Parse Tree**:
```
SELECT
  ├── name (column)
  ├── FROM users (table)
  └── WHERE age > 30 (predicate)
```

### Analysis

**Semantic Analysis**:
- **Table existence**: Check tables exist
- **Column existence**: Check columns exist
- **Type checking**: Verify types match
- **Permissions**: Check access rights

**Output**: Validated query tree

## Cost-Based Optimization

### What is Cost-Based Optimization?

**CBO**: Cost-Based Optimizer

**Approach**: Estimate cost of each plan, choose cheapest

**Cost Factors**:
- **I/O**: Disk reads/writes
- **CPU**: Processing time
- **Memory**: Memory usage
- **Network**: Data transfer (distributed)

### Cost Estimation

**Statistics**:
- **Table size**: Number of rows
- **Column cardinality**: Distinct values
- **Index statistics**: Selectivity
- **Data distribution**: Histograms

**Selectivity**: Fraction of rows matching predicate

**Example**:
```
Table: 1,000,000 rows
Predicate: age > 30
Selectivity: 0.6 (60% match)
Rows: 600,000
```

### Cost Model

**Cost Function**:
```
Cost = I/O_cost + CPU_cost + Memory_cost
```

**I/O Cost**:
```
Sequential scan: N pages × cost_per_page
Index scan: log(N) + matching_rows × cost_per_row
```

**CPU Cost**:
```
Predicate evaluation: rows × cost_per_predicate
Join: rows1 × rows2 × cost_per_join
```

## Join Algorithms

### Nested Loop Join

**Algorithm**:
```
For each row in outer table:
    For each row in inner table:
        If join condition matches:
            Output row
```

**Cost**: O(n × m)

**Use**: Small tables, one table fits in memory

### Hash Join

**Algorithm**:
```
1. Build hash table from smaller table
2. Probe hash table with larger table
```

**Cost**: O(n + m) (average case)

**Use**: Equi-joins, when one table fits in memory

**Example**:
```
Build: Hash table from users (smaller)
Probe: For each order, hash user_id, lookup in hash table
```

### Sort-Merge Join

**Algorithm**:
```
1. Sort both tables on join key
2. Merge sorted tables
```

**Cost**: O(n log n + m log m)

**Use**: When tables already sorted, or need sorted output

### Join Algorithm Selection

**Factors**:
- **Table sizes**: Relative sizes matter
- **Memory**: Available memory
- **Indexes**: Existing indexes
- **Join type**: Equi-join vs other

**Decision Tree**:
```
If small table fits in memory:
    Use hash join
Else if tables sorted:
    Use sort-merge join
Else:
    Use nested loop (with index if available)
```

## Index Selection

### When to Use Indexes

**Benefits**:
- **Fast lookup**: O(log n) vs O(n)
- **Avoids scan**: Don't scan entire table

**Costs**:
- **Storage**: Extra space
- **Maintenance**: Update on inserts/updates

### Index Selection Criteria

**1. Selectivity**:
```
High selectivity → Use index
Low selectivity → May not help
```

**2. Query Pattern**:
```
Frequent queries → Use index
Rare queries → May not be worth it
```

**3. Update Frequency**:
```
Frequent updates → Index maintenance cost
Infrequent updates → Index worth it
```

### Index Types

**1. B-Tree Index**:
```
Range queries: WHERE age BETWEEN 20 AND 30
Equality: WHERE id = 123
```

**2. Hash Index**:
```
Equality only: WHERE id = 123
Faster: O(1) lookup
```

**3. Bitmap Index**:
```
Low cardinality: Gender (M/F)
Efficient: For many OR conditions
```

## Execution Plans

### What is an Execution Plan?

**Execution Plan**: Tree of operations

**Nodes**: Operations (scan, join, filter, sort)

**Edges**: Data flow

### Plan Representation

**Text Format**:
```
Hash Join
  ├── Seq Scan on users (cost=0..1000)
  └── Seq Scan on orders (cost=0..5000)
```

**Tree Format**:
```
        Hash Join
       /         \
Seq Scan users  Seq Scan orders
```

### Plan Analysis

**Cost**: Estimated cost

**Rows**: Estimated rows

**Width**: Average row width

**Example**:
```
Hash Join (cost=100..500 rows=1000 width=50)
  Hash Cond: (users.id = orders.user_id)
  -> Seq Scan on users (cost=0..100 rows=10000 width=20)
  -> Hash (cost=50..50 rows=5000 width=30)
      -> Seq Scan on orders (cost=0..50 rows=5000 width=30)
```

## Optimization Techniques

### Predicate Pushdown

**Idea**: Apply filters as early as possible

**Before**:
```
Join → Filter age > 30
```

**After**:
```
Filter age > 30 → Join
```

**Benefit**: Fewer rows in join

### Projection Pushdown

**Idea**: Select only needed columns early

**Before**:
```
Join (all columns) → Select name, total
```

**After**:
```
Select name → Join → Select total
```

**Benefit**: Less data to process

### Join Reordering

**Idea**: Reorder joins for efficiency

**Factors**:
- **Table sizes**: Join smaller tables first
- **Selectivity**: More selective joins first
- **Indexes**: Use indexed joins

### Subquery Optimization

**1. Subquery Flattening**:
```
Convert correlated subquery to join
```

**2. Materialization**:
```
Materialize subquery result
Reuse for multiple references
```

**3. Inlining**:
```
Inline simple subqueries
```

## Real-World Examples

### Example 1: PostgreSQL EXPLAIN

**Query**:
```sql
EXPLAIN SELECT * FROM users WHERE age > 30;
```

**Plan**:
```
Seq Scan on users (cost=0..1000 rows=50000 width=50)
  Filter: (age > 30)
```

**With Index**:
```
Index Scan using idx_age on users (cost=0..500 rows=50000 width=50)
  Index Cond: (age > 30)
```

### Example 2: MySQL EXPLAIN

**Query**:
```sql
EXPLAIN SELECT * FROM users u
JOIN orders o ON u.id = o.user_id;
```

**Plan**:
```
1. SIMPLE  u  ALL  NULL  NULL  NULL  NULL  1000
2. SIMPLE  o  ref  user_id  user_id  4  u.id  100
```

## Common Pitfalls

### Problem: Missing Statistics

```sql
-- BAD: Outdated statistics
-- Optimizer makes poor decisions

-- GOOD: Update statistics regularly
ANALYZE TABLE users;
```

### Problem: Ignoring Execution Plans

```sql
-- BAD: Write query without checking plan
SELECT * FROM users WHERE age > 30;

-- GOOD: Check execution plan
EXPLAIN SELECT * FROM users WHERE age > 30;
-- Verify index is used
```

### Problem: Over-Indexing

```sql
-- BAD: Too many indexes
CREATE INDEX idx1 ON users(name);
CREATE INDEX idx2 ON users(email);
CREATE INDEX idx3 ON users(phone);
-- Slows down inserts/updates

-- GOOD: Index strategically
CREATE INDEX idx_name_email ON users(name, email);
-- Composite index, fewer indexes
```

## Quiz

1. What is the main purpose of a query optimizer?
   - **A)** Parse SQL
   - **B)** Find the most efficient execution plan for a query
   - **C)** Execute queries
   - **D)** Store data

2. What is cost-based optimization?
   - **A)** Optimize based on query complexity
   - **B)** Estimate cost of execution plans and choose the cheapest
   - **C)** Optimize based on table size
   - **D)** Optimize based on index count

3. What is predicate pushdown?
   - **A)** Remove predicates
   - **B)** Apply filters as early as possible to reduce data processed
   - **C)** Add more predicates
   - **D)** Delay predicates

**Answers:**
1. **B** - Query optimizers analyze different ways to execute a query and select the most efficient execution plan based on cost estimates
2. **B** - Cost-based optimization estimates the cost (I/O, CPU, memory) of different execution plans and chooses the one with the lowest estimated cost
3. **B** - Predicate pushdown applies filters (predicates) as early as possible in the execution plan to reduce the amount of data that needs to be processed in later operations

## Next Steps

- [Database Replication](../databases/07.%20Database%20Replication.md) - Replication strategies
- [Sharding & Partitioning](../databases/08.%20Sharding%20%26%20Partitioning.md) - Horizontal scaling

