---
number: 5
title: "B-Tree vs LSM Trees"
slug: "b-tree-vs-lsm-trees"
level: "intermediate"
tags: ["databases", "b-tree", "lsm", "storage", "indexing"]
prerequisites: ["advanced-trees-avl-red-black-b-trees"]
estimated_minutes: 120
contributors: []
diagrams: []
examples: []
canonical_id: "cs-db-05"
---

# B-Tree vs LSM Trees

## Overview

B-trees and LSM (Log-Structured Merge) trees are the two dominant storage structures in modern databases. Understanding their trade-offs, when to use each, and how they're implemented is essential for database design, performance optimization, and choosing the right storage engine.

## Table of Contents

1. [Storage Engine Overview](#overview)
2. [B-Tree Deep Dive](#b-tree)
3. [LSM Tree Overview](#lsm-overview)
4. [LSM Tree Structure](#lsm-structure)
5. [LSM Tree Operations](#lsm-operations)
6. [Comparison](#comparison)
7. [When to Use What](#when-to-use)
8. [Real-World Examples](#examples)

## Storage Engine Overview

### What is a Storage Engine?

**Storage Engine**: How data is stored and accessed

**Responsibilities**:
- **Storage**: How data stored on disk
- **Indexing**: How data indexed
- **Transactions**: How changes handled
- **Recovery**: How to recover from crashes

### Two Main Approaches

**1. B-Tree Based**:
- **Examples**: MySQL InnoDB, PostgreSQL, Oracle
- **Structure**: Balanced tree
- **Access**: Random reads/writes

**2. LSM Tree Based**:
- **Examples**: RocksDB, Cassandra, LevelDB
- **Structure**: Log-structured merge
- **Access**: Sequential writes, random reads

## B-Tree Deep Dive

### B-Tree Structure

**Organization**: Pages on disk

**Structure**:
```
Root Page
  ├── Internal Page 1
  │   ├── Leaf Page 1
  │   ├── Leaf Page 2
  │   └── Leaf Page 3
  └── Internal Page 2
      ├── Leaf Page 4
      └── Leaf Page 5
```

**Pages**: Typically 4KB-16KB

### B-Tree Operations

**Read**:
```
1. Start at root
2. Navigate to leaf
3. Read leaf page
4. Find key
Time: O(log_t n) disk accesses
```

**Write**:
```
1. Navigate to leaf
2. Update leaf page
3. If page full: Split page
4. Update parent (recursive)
5. Write pages to disk
Time: O(log_t n) disk writes
```

**Update**:
```
1. Read page
2. Modify in memory
3. Write page back
Random I/O: One page read, one page write
```

### B-Tree Characteristics

**Advantages**:
- **Fast reads**: O(log n) disk accesses
- **Predictable**: Consistent performance
- **Mature**: Well-understood, optimized

**Disadvantages**:
- **Random writes**: Each update = random I/O
- **Write amplification**: Page splits cause extra writes
- **Fragmentation**: Updates cause fragmentation

## LSM Tree Overview

### What is LSM Tree?

**LSM**: Log-Structured Merge Tree

**Idea**: Optimize for writes

**Principle**: Write sequentially, merge later

### LSM Tree Concept

**Write-Optimized**:
- **Append-only**: Writes are sequential
- **No in-place updates**: New data appended
- **Merge later**: Combine sorted runs

**Benefits**:
- **Fast writes**: Sequential I/O
- **High throughput**: Can handle many writes
- **SSD-friendly**: Sequential writes efficient

## LSM Tree Structure

### Components

**1. MemTable** (in-memory):
- **Structure**: Sorted data structure
- **Size**: Limited (e.g., 64MB)
- **When full**: Flushed to disk

**2. SSTables** (on disk):
- **Structure**: Sorted String Tables
- **Immutable**: Once written, never modified
- **Levels**: Multiple levels (L0, L1, L2, ...)

**3. WAL** (Write-Ahead Log):
- **Purpose**: Durability
- **Process**: Write to WAL before memtable

### LSM Tree Levels

**Structure**:
```
MemTable (memory)
    ↓ (flush)
L0: [SSTable1] [SSTable2] [SSTable3] (many small)
    ↓ (merge)
L1: [SSTable4] [SSTable5] (fewer, larger)
    ↓ (merge)
L2: [SSTable6] [SSTable7] (fewer, larger)
    ↓
...
```

**Level Sizes**:
- **L0**: Small, many files
- **L1**: 10x L0 size
- **L2**: 10x L1 size
- **Exponential**: Each level 10x larger

## LSM Tree Operations

### Write Operation

**Process**:
```
1. Write to WAL (durability)
2. Insert into MemTable (sorted)
3. If MemTable full:
   a. Flush MemTable to L0 (create SSTable)
   b. Clear MemTable
   c. Continue
```

**Characteristics**:
- **Fast**: Sequential write to WAL + memory insert
- **No random I/O**: Sequential writes
- **High throughput**: Can handle many writes

### Read Operation

**Process**:
```
1. Check MemTable
2. If not found: Check L0 SSTables (newest first)
3. If not found: Check L1 SSTables
4. If not found: Check L2 SSTables
5. Continue until found or all levels checked
```

**Characteristics**:
- **May check multiple files**: Slower than B-tree
- **Bloom filters**: Can skip files quickly
- **Compaction**: Merges reduce files to check

### Compaction

**Purpose**: Merge SSTables, remove duplicates

**Process**:
```
1. Select SSTables to merge (same level)
2. Merge sorted files
3. Remove duplicates (keep newest)
4. Write to next level
5. Delete old SSTables
```

**Types**:

**1. Leveled Compaction**:
- **Merge**: All files in level
- **Result**: One file per level (except L0)
- **Reads**: Check one file per level

**2. Size-Tiered Compaction**:
- **Merge**: Files of similar size
- **Result**: Multiple files per level
- **Reads**: May check multiple files

**Benefits**:
- **Reduces files**: Fewer files to check
- **Removes duplicates**: Keeps data current
- **Improves reads**: Faster subsequent reads

## Comparison

### Read Performance

**B-Tree**:
- **Fast**: O(log n) disk accesses
- **Predictable**: Consistent performance
- **Index**: Direct navigation to data

**LSM Tree**:
- **Slower**: May check multiple files
- **Variable**: Depends on level
- **Bloom filters**: Help skip files

**Winner**: B-Tree (for reads)

### Write Performance

**B-Tree**:
- **Random I/O**: Each update = random write
- **Page splits**: Extra writes
- **Slower**: On spinning disks

**LSM Tree**:
- **Sequential I/O**: Append-only writes
- **High throughput**: Many writes/second
- **Faster**: Especially on SSDs

**Winner**: LSM Tree (for writes)

### Write Amplification

**B-Tree**:
- **Low**: ~1-2x (page updates)
- **Splits**: Occasional extra writes

**LSM Tree**:
- **High**: 5-20x (compaction overhead)
- **Compaction**: Rewrites data multiple times

**Winner**: B-Tree (lower write amplification)

### Space Amplification

**B-Tree**:
- **Low**: Data stored once
- **Fragmentation**: Some overhead

**LSM Tree**:
- **Higher**: Multiple versions during compaction
- **Temporary**: Resolved by compaction

**Winner**: B-Tree (less space)

## When to Use What

### Use B-Tree When

**1. Read-Heavy Workloads**:
- **Many reads**: B-tree faster
- **Consistent latency**: Predictable performance
- **Examples**: OLTP systems, web applications

**2. Point Queries**:
- **Lookup by key**: B-tree optimal
- **Index access**: Direct navigation

**3. Update-Heavy**:
- **In-place updates**: B-tree handles well
- **Low write amplification**: Efficient

### Use LSM Tree When

**1. Write-Heavy Workloads**:
- **Many writes**: LSM tree handles better
- **High throughput**: Sequential writes
- **Examples**: Time-series data, logging

**2. Append-Only**:
- **No updates**: Perfect for LSM
- **Time-series**: Natural fit

**3. SSD Storage**:
- **Sequential writes**: Efficient on SSD
- **High IOPS**: Can handle many writes

## Real-World Examples

### Example 1: MySQL InnoDB (B-Tree)

**Storage**: B+ trees

**Characteristics**:
- **Fast reads**: Excellent for OLTP
- **ACID**: Full ACID support
- **Use**: General-purpose database

**Trade-offs**:
- **Writes**: Slower than LSM
- **Random I/O**: On spinning disks

### Example 2: RocksDB (LSM Tree)

**Storage**: LSM trees

**Characteristics**:
- **Fast writes**: High write throughput
- **Use**: Embedded database, caching

**Trade-offs**:
- **Reads**: Slower than B-tree
- **Compaction**: Background overhead

### Example 3: Cassandra (LSM Tree)

**Storage**: LSM trees

**Characteristics**:
- **High write throughput**: Handles many writes
- **Distributed**: Across nodes
- **Use**: Time-series, logging, high-volume writes

**Trade-offs**:
- **Reads**: May be slower
- **Consistency**: Eventually consistent

## Common Pitfalls

### Problem: Wrong Choice for Workload

```sql
-- BAD: Use B-tree for write-heavy time-series
-- Many random writes → Poor performance

-- GOOD: Use LSM tree for write-heavy
-- Sequential writes → Better performance
```

### Problem: Ignoring Compaction

```c
// BAD: Disable compaction
// LSM tree performance degrades
// Many files to check on reads

// GOOD: Tune compaction
// Balance write and read performance
```

## Quiz

1. What is the main advantage of LSM trees over B-trees?
   - **A)** Faster reads
   - **B)** Higher write throughput through sequential writes
   - **C)** Lower memory usage
   - **D)** Simpler implementation

2. What is compaction in LSM trees?
   - **A)** Compressing data
   - **B)** Merging SSTables to remove duplicates and reduce files
   - **C)** Deleting old data
   - **D)** Encrypting data

3. When should you use B-trees?
   - **A)** Always
   - **B)** For read-heavy workloads and point queries
   - **C)** Never
   - **D)** Only for small datasets

**Answers:**
1. **B** - LSM trees provide higher write throughput because writes are sequential (append-only), making them much faster than B-trees which require random I/O for updates
2. **B** - Compaction merges multiple SSTables, removes duplicate/deleted entries (keeping the newest), and reduces the number of files that need to be checked during reads
3. **B** - B-trees are better for read-heavy workloads and point queries because they provide faster, more predictable read performance with direct navigation to data

## Next Steps

- [Query Optimizers](../databases/06.%20Query%20Optimizers.md) - Query optimization
- [Storage Engines - InnoDB & RocksDB](../databases/07.%20Storage%20Engines.md) - Engine details

