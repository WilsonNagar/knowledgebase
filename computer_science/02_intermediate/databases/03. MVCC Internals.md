---
number: 3
title: "MVCC Internals"
slug: "mvcc-internals"
level: "intermediate"
tags: ["databases", "mvcc", "concurrency", "isolation", "versioning"]
prerequisites: ["transaction-isolation-levels"]
estimated_minutes: 115
contributors: []
diagrams: []
examples: []
canonical_id: "cs-db-03"
---

# MVCC Internals

## Overview

Multi-Version Concurrency Control (MVCC) is a concurrency control method that allows multiple transactions to access the same data simultaneously by maintaining multiple versions of each data item. Understanding MVCC is essential for understanding how modern databases like PostgreSQL, MySQL InnoDB, and Oracle achieve high concurrency and performance.

## Table of Contents

1. [What is MVCC?](#what-is-mvcc)
2. [MVCC Benefits](#benefits)
3. [Version Storage](#version-storage)
4. [Snapshot Isolation](#snapshot-isolation)
5. [Read Operations](#read-operations)
6. [Write Operations](#write-operations)
7. [Visibility Rules](#visibility-rules)
8. [Vacuum & Cleanup](#vacuum)
9. [MVCC in PostgreSQL](#postgresql)
10. [MVCC in MySQL InnoDB](#mysql)

## What is MVCC?

### Traditional Locking Problem

**Locking Approach**:
```
Transaction 1: Read row (acquires shared lock)
Transaction 2: Write row (waits for lock)
Transaction 1: Commits (releases lock)
Transaction 2: Writes (acquires exclusive lock)
```

**Problems**:
- **Blocking**: Readers block writers
- **Low concurrency**: Limited parallelism
- **Deadlocks**: Possible

### MVCC Solution

**MVCC Approach**:
```
Transaction 1: Read version 1 (no lock needed)
Transaction 2: Write → Creates version 2 (no blocking)
Transaction 1: Still sees version 1
Transaction 2: Sees version 2
Both transactions proceed concurrently
```

**Key Idea**: Multiple versions coexist

## MVCC Benefits

### 1. High Concurrency

**Readers Don't Block Writers**:
- **Reads**: From snapshot (no locks)
- **Writes**: Create new versions (minimal locking)
- **Parallel**: Many readers + writers

### 2. Consistent Snapshots

**Snapshot Isolation**:
- **Transaction**: Sees consistent snapshot
- **No changes**: From other transactions
- **Repeatable**: Same reads return same values

### 3. No Deadlocks (for reads)

**Read Operations**:
- **No locks**: Readers don't acquire locks
- **No deadlocks**: Cannot deadlock on reads
- **Safe**: Concurrent reads always safe

### 4. Better Performance

**Under Contention**:
- **Locking**: Degrades under contention
- **MVCC**: Maintains performance
- **Scalable**: Better scalability

## Version Storage

### How Versions are Stored

**Row Structure** (PostgreSQL example):
```
┌─────────────┬─────────────┬─────────────┬─────────────┐
│ xmin        │ xmax        │ ctid        │ data        │
│ (creator)   │ (deleter)   │ (pointer)   │ (actual)    │
└─────────────┴─────────────┴─────────────┴─────────────┘
```

**Fields**:
- **xmin**: Transaction ID that created version
- **xmax**: Transaction ID that deleted version (or 0)
- **ctid**: Physical location (for updates)
- **data**: Actual row data

### Version Chain

**Multiple Versions**:
```
Row ID 100:
  Version 1: xmin=10, xmax=0, data="Alice"
  Version 2: xmin=20, xmax=0, data="Bob" (update)
  Version 3: xmin=30, xmax=0, data="Charlie" (update)
```

**Chain**: Versions linked together

**Access**: Traverse chain to find visible version

## Snapshot Isolation

### What is Snapshot Isolation?

**Snapshot**: Consistent view of database at transaction start

**Isolation**: Transaction sees only committed data from before it started

**Properties**:
- **Consistent**: Same data throughout transaction
- **Isolated**: Changes from other transactions not visible
- **Repeatable**: Same reads return same values

### Snapshot Creation

**When**: Transaction starts

**What**: List of active transactions

**How**: 
```
Snapshot = {
  xmin: Smallest active transaction ID
  xmax: Largest committed transaction ID
  active: Set of active transaction IDs
}
```

**Example**:
```
Transaction 100 starts
Active transactions: [95, 98, 99]
Snapshot: {
  xmin: 95,
  xmax: 99,
  active: {95, 98, 99}
}
```

## Read Operations

### How Reads Work

**Process**:
```
1. Get snapshot (transaction start time)
2. Find row versions
3. Check visibility for each version:
   a. Version created before snapshot? (xmin < snapshot.xmin)
   b. Version not deleted? (xmax = 0 or xmax > snapshot.xmax)
   c. Creator committed? (xmin not in active set)
4. Return visible version
```

### Visibility Check

**Rules**:
```
Version visible if:
  1. xmin < snapshot.xmin AND
  2. (xmax = 0 OR xmax > snapshot.xmax) AND
  3. xmin committed (not in active set)
```

**Example**:
```
Snapshot: xmin=100, active={98, 99}
Version: xmin=95, xmax=0

Check:
  1. 95 < 100 ✓
  2. xmax = 0 ✓
  3. 95 not in {98, 99} ✓
Result: Visible
```

## Write Operations

### INSERT

**Process**:
```
1. Create new version
2. Set xmin = current transaction ID
3. Set xmax = 0 (not deleted)
4. Insert into table
```

**Example**:
```
Transaction 100: INSERT INTO users VALUES ('Alice')
Creates: xmin=100, xmax=0, data='Alice'
```

### UPDATE

**Process**:
```
1. Create new version (copy of old)
2. Modify data
3. Set xmin = current transaction ID
4. Set xmax = 0
5. Set old version's xmax = current transaction ID
```

**Example**:
```
Transaction 100: UPDATE users SET name='Bob' WHERE id=1

Old version: xmin=50, xmax=100, data='Alice'
New version: xmin=100, xmax=0, data='Bob'
```

### DELETE

**Process**:
```
1. Set xmax = current transaction ID
2. Don't delete physical row
3. Mark as deleted
```

**Example**:
```
Transaction 100: DELETE FROM users WHERE id=1

Version: xmin=50, xmax=100, data='Alice'
(Marked as deleted, not physically removed)
```

## Visibility Rules

### Read Committed

**Snapshot**: Taken at each statement

**Behavior**:
```
Transaction starts
Statement 1: Snapshot at statement start
  - Sees committed data up to statement start
Statement 2: New snapshot at statement start
  - Sees committed data up to statement start
  - May see different data than Statement 1
```

**Result**: Non-repeatable reads possible

### Repeatable Read

**Snapshot**: Taken at transaction start

**Behavior**:
```
Transaction starts: Snapshot created
Statement 1: Uses snapshot
  - Sees data from snapshot time
Statement 2: Uses same snapshot
  - Sees same data as Statement 1
```

**Result**: Repeatable reads (consistent snapshot)

## Vacuum & Cleanup

### The Problem

**Old Versions Accumulate**:
```
Row updated many times:
  Version 1: xmin=10
  Version 2: xmin=20
  Version 3: xmin=30
  Version 4: xmin=40
  
If all transactions > 40 committed:
  Versions 1-3 are dead (not visible to anyone)
  But still taking space!
```

### Vacuum Process

**Purpose**: Remove dead versions

**When**: Periodically or on demand

**Process**:
```
1. Find dead versions (not visible to any transaction)
2. Mark space as free
3. Optionally: Physically remove (VACUUM FULL)
```

**Types**:
- **Auto-vacuum**: Automatic (PostgreSQL)
- **Manual vacuum**: VACUUM command
- **Vacuum full**: Reclaim space (locks table)

### Vacuum Considerations

**Trade-offs**:
- **Space**: Dead versions waste space
- **Performance**: Vacuum uses resources
- **Timing**: When to vacuum?

**Best Practices**:
- **Auto-vacuum**: Enable for most cases
- **Monitor**: Track dead tuple count
- **Tune**: Adjust vacuum parameters

## MVCC in PostgreSQL

### PostgreSQL Implementation

**System Columns**:
- **xmin**: Inserting transaction ID
- **xmax**: Deleting transaction ID
- **ctid**: Physical row location

**Transaction IDs**:
- **32-bit**: Wraps around (2^32 transactions)
- **Freeze**: Old transactions frozen
- **XID wraparound**: Special handling needed

### Visibility Check (PostgreSQL)

**Function**: `HeapTupleSatisfiesMVCC()`

**Logic**:
```c
bool visible = 
    (xmin < snapshot.xmin || xmin == current_xid) &&
    (xmax == 0 || xmax > snapshot.xmax) &&
    (xmin committed);
```

### Vacuum (PostgreSQL)

**Auto-vacuum**:
- **Enabled**: By default
- **Frequency**: Based on table activity
- **Tunable**: Many parameters

**Manual**:
```sql
VACUUM; -- Mark space as free
VACUUM FULL; -- Reclaim space (locks table)
VACUUM ANALYZE; -- Update statistics
```

## MVCC in MySQL InnoDB

### InnoDB Implementation

**Undo Logs**:
- **Stores**: Previous versions
- **Purpose**: Rollback and MVCC reads
- **Structure**: Linked list of versions

**Read View**:
- **Snapshot**: At transaction start
- **Contains**: Active transaction IDs
- **Used**: For visibility checks

### Undo Log Structure

**Versions**:
```
Current row → Undo log entry 1 → Undo log entry 2 → ...
```

**Access**:
```
Read: Traverse undo log to find visible version
```

### Purge Process

**Purpose**: Remove old undo log entries

**When**: After all transactions that could see them commit

**Process**:
```
1. Find old undo log entries
2. Check if visible to any transaction
3. If not: Remove entry
```

## Real-World Examples

### Example 1: Concurrent Reads and Writes

**Scenario**:
```
Transaction A (starts at T=100): SELECT * FROM users
Transaction B (starts at T=101): UPDATE users SET name='Bob'
Transaction A: Still sees old name (snapshot isolation)
Transaction B: Sees new name
Both proceed concurrently
```

**MVCC Benefit**: No blocking, high concurrency

### Example 2: Long-Running Transaction

**Scenario**:
```
Transaction A (starts at T=100): Long-running transaction
Transaction B (T=200): Updates many rows
Transaction C (T=300): Updates many rows
Transaction A: Still sees snapshot from T=100
```

**MVCC Benefit**: Consistent view, but may see stale data

## Common Pitfalls

### Problem: Transaction ID Wraparound

```sql
-- BAD: Ignore XID wraparound
-- PostgreSQL: 32-bit XID wraps around
-- Must freeze old transactions

-- GOOD: Monitor and handle
SELECT datfrozenxid FROM pg_database;
-- Freeze old transactions before wraparound
```

### Problem: Too Many Versions

```sql
-- BAD: Frequent updates without vacuum
UPDATE table SET col = col + 1; -- Creates new version
-- Many versions accumulate

-- GOOD: Regular vacuum
VACUUM table; -- Clean up old versions
```

### Problem: Long Transactions

```sql
-- BAD: Long transaction holds old versions
BEGIN;
-- Long operation
-- Prevents vacuum from cleaning versions
COMMIT;

-- GOOD: Keep transactions short
-- Or use appropriate isolation level
```

## Quiz

1. What is the main advantage of MVCC?
   - **A)** Simpler implementation
   - **B)** High concurrency (readers don't block writers)
   - **C)** Smaller storage
   - **D)** Faster writes

2. How does MVCC achieve snapshot isolation?
   - **A)** Locks all data
   - **B)** Maintains multiple versions and shows transaction a consistent snapshot
   - **C)** Slows down writes
   - **D)** Uses timestamps only

3. What is the purpose of vacuum in MVCC systems?
   - **A)** Compress data
   - **B)** Remove dead versions that are no longer visible to any transaction
   - **C)** Create new versions
   - **D)** Lock tables

**Answers:**
1. **B** - MVCC provides high concurrency by allowing readers to access snapshots without blocking writers, who create new versions
2. **B** - MVCC maintains multiple versions of each row and uses visibility rules to show each transaction a consistent snapshot based on when it started
3. **B** - Vacuum removes dead versions (old versions no longer visible to any active transaction) to reclaim storage space

## Next Steps

- [Write-Ahead Logging](../databases/04.%20Write-Ahead%20Logging.md) - WAL implementation
- [B-Tree vs LSM Trees](../databases/05.%20B-Tree%20vs%20LSM%20Trees.md) - Storage structures

