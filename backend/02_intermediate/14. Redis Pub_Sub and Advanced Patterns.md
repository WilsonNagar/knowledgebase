---
number: 14
title: "Redis Pub/Sub and Advanced Patterns"
slug: "redis-pub-sub-and-advanced-patterns"
level: "intermediate"
tags: ["backend", "redis", "pub-sub", "messaging", "real-time"]
prerequisites: ["redis-caching-strategies"]
estimated_minutes: 110
contributors: []
diagrams: []
examples: []
canonical_id: "backend-intermediate-14"
---

# Redis Pub/Sub and Advanced Patterns

## Overview

Redis Pub/Sub enables real-time messaging and event distribution. This guide covers publish-subscribe patterns, Redis Streams, advanced Redis data structures, Lua scripting, transactions, and building real-time systems with Redis.

## Deep Explanation

### Pub/Sub Pattern

**Publish**: Send message to channel
**Subscribe**: Listen to channel
**Pattern Subscribe**: Subscribe to multiple channels

**Commands**:
```redis
PUBLISH channel "message"
SUBSCRIBE channel1 channel2
PSUBSCRIBE news.*
UNSUBSCRIBE channel
```

### Redis Streams

**Modern Alternative**: More reliable than Pub/Sub
**Consumer Groups**: Multiple consumers processing messages
**Message Persistence**: Messages stored, not lost

**Commands**:
```redis
XADD mystream * field1 value1 field2 value2
XREAD STREAMS mystream 0
XGROUP CREATE mystream mygroup 0
XREADGROUP GROUP mygroup consumer1 STREAMS mystream >
```

### Advanced Patterns

**Distributed Lock**:
```redis
SET lock:resource "value" NX EX 10
```

**Rate Limiting**:
```redis
INCR rate_limit:user:123
EXPIRE rate_limit:user:123 60
```

**Leaderboard**:
```redis
ZADD leaderboard 100 "player1"
ZRANGE leaderboard 0 -1 WITHSCORES
```

## Real Code Examples

### Example: Real-Time Notifications

```python
import redis
import threading

r = redis.Redis()

def publisher():
    while True:
        r.publish('notifications', 'New message')
        time.sleep(5)

def subscriber():
    pubsub = r.pubsub()
    pubsub.subscribe('notifications')
    for message in pubsub.listen():
        if message['type'] == 'message':
            print(f"Received: {message['data']}")

# Start publisher and subscriber
threading.Thread(target=publisher).start()
threading.Thread(target=subscriber).start()
```

### Example: Redis Streams Consumer Group

```python
import redis

r = redis.Redis()

# Create consumer group
r.xgroup_create('events', 'processors', id='0', mkstream=True)

# Read messages
while True:
    messages = r.xreadgroup(
        'processors', 'consumer1',
        {'events': '>'},
        count=10,
        block=1000
    )
    for stream, msgs in messages:
        for msg_id, data in msgs:
            process_message(data)
            # Acknowledge message
            r.xack('events', 'processors', msg_id)
```

## Pros and Cons

### Pros

✅ **Fast**: In-memory, sub-millisecond latency
✅ **Simple**: Easy to use Pub/Sub
✅ **Flexible**: Multiple data structures
✅ **Reliable**: Redis Streams with persistence
✅ **Scalable**: Can cluster for high throughput

### Cons

❌ **Memory Limit**: Limited by RAM
❌ **Pub/Sub Limitations**: No message persistence (use Streams instead)
❌ **Single Point**: Without clustering, single point of failure
❌ **No Guarantees**: Pub/Sub doesn't guarantee delivery

## Hard Use-Case: Real-Time Chat System

### Problem Statement

Build a real-time chat system using Redis Pub/Sub for message distribution.

### Solution

**Architecture**:
```
User sends message → API Server → Redis PUBLISH chat:room1
                                              ↓
                                    Multiple subscribers receive
                                              ↓
                                    WebSocket connections → Clients
```

**Implementation**:
```python
# Publisher (API endpoint)
@app.post('/chat/send')
def send_message(room_id: str, message: str):
    r.publish(f'chat:{room_id}', json.dumps({
        'user': current_user,
        'message': message,
        'timestamp': time.time()
    }))

# Subscriber (WebSocket handler)
def websocket_handler(ws, room_id):
    pubsub = r.pubsub()
    pubsub.subscribe(f'chat:{room_id}')
    for message in pubsub.listen():
        if message['type'] == 'message':
            ws.send(message['data'])
```

## Edge Cases and Pitfalls

### Common Mistakes

1. **Using Pub/Sub for Critical Messages**
   - Pub/Sub doesn't guarantee delivery
   - Use Redis Streams for reliable messaging
   - Consider message queues (RabbitMQ, Kafka)

2. **Not Handling Disconnections**
   - Clients may miss messages
   - Use Streams with consumer groups
   - Implement reconnection logic

3. **Memory Management**
   - Monitor memory usage
   - Set maxmemory policy
   - Use TTL for temporary data

## References and Further Reading

- Redis Pub/Sub Documentation
- Redis Streams Guide
- Redis Patterns

## Quiz

### Question 1
What is the main limitation of Redis Pub/Sub?

**A)** Slow performance  
**B)** No message persistence  
**C)** Limited channels  
**D)** High memory usage

**Answer: B** - Redis Pub/Sub doesn't persist messages. Use Redis Streams for persistence.

## Related Topics

- [Redis Caching Strategies](./03.%20Redis%20Caching%20Strategies.md)
- [WebSocket Real-Time Communication](./15.%20WebSocket%20Real-Time%20Communication.md)

