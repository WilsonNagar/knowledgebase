---
number: 17
title: "JWT Authentication and Authorization"
slug: "jwt-authentication-and-authorization"
level: "intermediate"
tags: ["backend", "jwt", "authentication", "authorization", "security"]
prerequisites: ["api-design-principles"]
estimated_minutes: 105
contributors: []
diagrams: []
examples: []
canonical_id: "backend-intermediate-17"
---

# JWT Authentication and Authorization

## Overview

JSON Web Tokens (JWT) are a standard for securely transmitting information. This guide covers JWT structure, signing algorithms, token generation and validation, refresh tokens, security best practices, and implementing authentication/authorization.

## Deep Explanation

### JWT Structure

**Header**: Algorithm and token type
**Payload**: Claims (data)
**Signature**: Verification signature

**Format**: `header.payload.signature`

### Claims

**Registered Claims**: Standard claims (iss, exp, sub)
**Public Claims**: Custom claims
**Private Claims**: Application-specific claims

### Token Types

**Access Token**: Short-lived, for API access
**Refresh Token**: Long-lived, for obtaining new access tokens

## Real Code Examples

### Example: Token Generation

```python
import jwt
import datetime

def generate_access_token(user_id: int):
    payload = {
        'user_id': user_id,
        'exp': datetime.datetime.utcnow() + datetime.timedelta(hours=1),
        'iat': datetime.datetime.utcnow(),
        'type': 'access'
    }
    return jwt.encode(payload, SECRET_KEY, algorithm='HS256')

def generate_refresh_token(user_id: int):
    payload = {
        'user_id': user_id,
        'exp': datetime.datetime.utcnow() + datetime.timedelta(days=30),
        'type': 'refresh'
    }
    return jwt.encode(payload, REFRESH_SECRET_KEY, algorithm='HS256')
```

### Example: Token Validation

```python
def verify_token(token: str):
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=['HS256'])
        return payload
    except jwt.ExpiredSignatureError:
        raise Exception('Token expired')
    except jwt.InvalidTokenError:
        raise Exception('Invalid token')

def refresh_access_token(refresh_token: str):
    try:
        payload = jwt.decode(refresh_token, REFRESH_SECRET_KEY, algorithms=['HS256'])
        if payload['type'] != 'refresh':
            raise Exception('Invalid token type')
        return generate_access_token(payload['user_id'])
    except jwt.InvalidTokenError:
        raise Exception('Invalid refresh token')
```

## Pros and Cons

### Pros

✅ **Stateless**: No server-side session storage
✅ **Scalable**: Works across multiple servers
✅ **Self-Contained**: Contains all necessary information
✅ **Standard**: Widely supported
✅ **Flexible**: Can include custom claims

### Cons

❌ **Size**: Larger than session IDs
❌ **Cannot Revoke**: Hard to invalidate before expiration
❌ **Security**: If compromised, valid until expiration
❌ **No Refresh**: Without refresh tokens, users must re-login
❌ **Storage**: Client-side storage risks (XSS)

## Hard Use-Case: Token Refresh Flow

### Problem Statement

Implement secure token refresh mechanism with token rotation.

### Solution

```python
# Login endpoint
@app.post('/auth/login')
def login(credentials: LoginRequest):
    user = authenticate(credentials.username, credentials.password)
    access_token = generate_access_token(user.id)
    refresh_token = generate_refresh_token(user.id)
    
    # Store refresh token hash in database
    store_refresh_token(user.id, hash_token(refresh_token))
    
    return {
        'access_token': access_token,
        'refresh_token': refresh_token,
        'expires_in': 3600
    }

# Refresh endpoint
@app.post('/auth/refresh')
def refresh(refresh_token: str):
    try:
        payload = jwt.decode(refresh_token, REFRESH_SECRET_KEY, algorithms=['HS256'])
        user_id = payload['user_id']
        
        # Verify refresh token exists in database
        if not verify_refresh_token(user_id, refresh_token):
            raise Exception('Invalid refresh token')
        
        # Generate new tokens
        new_access_token = generate_access_token(user_id)
        new_refresh_token = generate_refresh_token(user_id)
        
        # Revoke old refresh token
        revoke_refresh_token(user_id, refresh_token)
        
        # Store new refresh token
        store_refresh_token(user_id, hash_token(new_refresh_token))
        
        return {
            'access_token': new_access_token,
            'refresh_token': new_refresh_token,
            'expires_in': 3600
        }
    except jwt.InvalidTokenError:
        raise HTTPException(status_code=401, detail='Invalid refresh token')
```

## Edge Cases and Pitfalls

### Common Mistakes

1. **Storing Sensitive Data**
   - JWT is base64 encoded, not encrypted
   - Don't store passwords or secrets
   - Only store necessary claims

2. **Not Validating Expiration**
   - Always check 'exp' claim
   - Handle expired tokens gracefully
   - Implement refresh token flow

3. **Weak Secret Keys**
   - Use strong, random secret keys
   - Rotate keys periodically
   - Use different keys for access/refresh tokens

4. **Not Implementing Refresh Tokens**
   - Short-lived access tokens require refresh
   - Store refresh tokens securely
   - Implement token rotation

## References and Further Reading

- JWT.io
- OAuth 2.0 Specification
- JWT Best Practices

## Quiz

### Question 1
What is the main security concern with JWTs?

**A)** They're too large  
**B)** Cannot be revoked before expiration  
**C)** They're slow  
**D)** They require encryption

**Answer: B** - JWTs cannot be easily revoked before expiration, which is a security concern.

## Related Topics

- [API Design Principles](../01_beginners/02.%20API%20Design%20Principles.md)
- [OAuth 2.0 and SSO](./18.%20OAuth%202.0%20and%20SSO.md)

