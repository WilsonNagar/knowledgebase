---
number: 18
title: "OAuth 2.0 and SSO"
slug: "oauth-2-0-and-sso"
level: "intermediate"
tags: ["backend", "oauth", "sso", "authentication", "authorization"]
prerequisites: ["jwt-authentication-and-authorization"]
estimated_minutes: 125
contributors: []
diagrams: []
examples: []
canonical_id: "backend-intermediate-18"
---

# OAuth 2.0 and SSO

## Overview

OAuth 2.0 is an authorization framework, and SSO enables single sign-on across multiple applications. This guide covers OAuth 2.0 flows, authorization codes, client credentials, resource owner password, OpenID Connect, and implementing SSO.

## Deep Explanation

### OAuth 2.0 Roles

**Resource Owner**: User
**Client**: Application requesting access
**Authorization Server**: Issues tokens
**Resource Server**: API that protects resources

### Grant Types

**Authorization Code**: Web applications
**Implicit**: Mobile/SPA (deprecated)
**Client Credentials**: Server-to-server
**Resource Owner Password**: Trusted applications
**Refresh Token**: Obtain new access tokens

### Authorization Code Flow

1. User authorizes client
2. Client receives authorization code
3. Client exchanges code for access token
4. Client uses access token to access resources

## Real Code Examples

### Example: Authorization Server

```python
from fastapi import FastAPI, HTTPException
import secrets

app = FastAPI()

# Store authorization codes temporarily
auth_codes = {}

@app.get('/authorize')
def authorize(client_id: str, redirect_uri: str, response_type: str, state: str):
    # Verify client
    if not verify_client(client_id, redirect_uri):
        raise HTTPException(status_code=400, detail='Invalid client')
    
    # Generate authorization code
    code = secrets.token_urlsafe(32)
    auth_codes[code] = {
        'client_id': client_id,
        'redirect_uri': redirect_uri,
        'expires_at': time.time() + 600  # 10 minutes
    }
    
    # Redirect with code
    return RedirectResponse(
        url=f"{redirect_uri}?code={code}&state={state}"
    )

@app.post('/token')
def token(grant_type: str, code: str, client_id: str, client_secret: str, redirect_uri: str):
    if grant_type != 'authorization_code':
        raise HTTPException(status_code=400, detail='Invalid grant type')
    
    # Verify client credentials
    if not verify_client_credentials(client_id, client_secret):
        raise HTTPException(status_code=401, detail='Invalid credentials')
    
    # Verify authorization code
    if code not in auth_codes:
        raise HTTPException(status_code=400, detail='Invalid code')
    
    auth_code = auth_codes.pop(code)
    if auth_code['expires_at'] < time.time():
        raise HTTPException(status_code=400, detail='Code expired')
    
    # Generate tokens
    access_token = generate_access_token(auth_code['client_id'])
    refresh_token = generate_refresh_token(auth_code['client_id'])
    
    return {
        'access_token': access_token,
        'refresh_token': refresh_token,
        'token_type': 'Bearer',
        'expires_in': 3600
    }
```

## Pros and Cons

### Pros

✅ **Standard**: Widely adopted standard
✅ **Secure**: Multiple flows for different use cases
✅ **Delegated Access**: Users grant specific permissions
✅ **SSO**: Single sign-on across applications
✅ **Flexible**: Multiple grant types

### Cons

❌ **Complexity**: More complex than basic auth
❌ **Implementation**: Easy to implement incorrectly
❌ **Security**: Requires careful implementation
❌ **Token Management**: Need to handle refresh tokens
❌ **User Experience**: Redirect flows can be confusing

## Hard Use-Case: SSO Implementation

### Problem Statement

Implement SSO allowing users to sign in once and access multiple applications.

### Solution

**Architecture**:
```
User → App A → Authorization Server (login)
              ↓
         Generate tokens
              ↓
    App A, App B, App C (share session)
```

**Implementation**:
```python
# Central authorization server
@app.post('/sso/login')
def sso_login(credentials: LoginRequest):
    user = authenticate(credentials.username, credentials.password)
    
    # Generate SSO token
    sso_token = generate_sso_token(user.id)
    
    # Store SSO session
    store_sso_session(user.id, sso_token)
    
    return {'sso_token': sso_token}

# Application validates SSO token
@app.get('/api/user')
def get_user(sso_token: str):
    user_id = validate_sso_token(sso_token)
    if not user_id:
        raise HTTPException(status_code=401)
    
    return get_user_data(user_id)
```

## Edge Cases and Pitfalls

### Common Mistakes

1. **Not Validating Redirect URIs**
   - Always validate redirect_uri
   - Prevent open redirects
   - Use whitelist of allowed URIs

2. **Weak Authorization Codes**
   - Use cryptographically random codes
   - Short expiration time
   - Single-use codes

3. **Not Implementing PKCE**
   - Use PKCE for public clients
   - Prevents authorization code interception
   - Required for mobile/SPA apps

## References and Further Reading

- OAuth 2.0 RFC 6749
- OpenID Connect Specification
- OAuth 2.0 Security Best Practices

## Quiz

### Question 1
Which OAuth 2.0 grant type is recommended for web applications?

**A)** Implicit  
**B)** Authorization Code  
**C)** Client Credentials  
**D)** Resource Owner Password

**Answer: B** - Authorization Code flow is recommended for web applications.

## Related Topics

- [JWT Authentication and Authorization](./17.%20JWT%20Authentication%20and%20Authorization.md)
- [API Security Best Practices](../03_advanced/08.%20API%20Security%20Best%20Practices.md)

