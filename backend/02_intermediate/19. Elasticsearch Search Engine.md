---
number: 19
title: "Elasticsearch Search Engine"
slug: "elasticsearch-search-engine"
level: "intermediate"
tags: ["backend", "elasticsearch", "search", "lucene", "full-text-search"]
prerequisites: ["database-fundamentals"]
estimated_minutes: 130
contributors: []
diagrams: []
examples: []
canonical_id: "backend-intermediate-19"
---

# Elasticsearch Search Engine

## Overview

Elasticsearch is a distributed search and analytics engine. This guide covers indexing, querying, aggregations, full-text search, relevance scoring, cluster management, and building powerful search capabilities.

## Deep Explanation

### Core Concepts

**Index**: Collection of documents (like database)
**Document**: JSON object (like row)
**Type**: Document category (deprecated in 7.x)
**Mapping**: Schema definition
**Shard**: Partition of index
**Replica**: Copy of shard

### Query Types

**Match**: Full-text search
**Term**: Exact match
**Range**: Range queries
**Bool**: Boolean combinations
**Aggregations**: Analytics

## Real Code Examples

### Example: Indexing Documents

```python
from elasticsearch import Elasticsearch

es = Elasticsearch(['localhost:9200'])

# Create index
es.indices.create(
    index='products',
    body={
        'mappings': {
            'properties': {
                'name': {'type': 'text'},
                'price': {'type': 'float'},
                'category': {'type': 'keyword'}
            }
        }
    }
)

# Index document
es.index(
    index='products',
    id=1,
    body={
        'name': 'Laptop',
        'price': 999.99,
        'category': 'Electronics'
    }
)
```

### Example: Searching

```python
# Simple search
results = es.search(
    index='products',
    body={
        'query': {
            'match': {
                'name': 'laptop'
            }
        }
    }
)

# Complex search with filters
results = es.search(
    index='products',
    body={
        'query': {
            'bool': {
                'must': [
                    {'match': {'name': 'laptop'}}
                ],
                'filter': [
                    {'range': {'price': {'gte': 500, 'lte': 1500}}}
                ]
            }
        },
        'aggs': {
            'categories': {
                'terms': {'field': 'category'}
            }
        }
    }
)
```

## Pros and Cons

### Pros

✅ **Fast**: Near real-time search
✅ **Scalable**: Distributed architecture
✅ **Flexible**: Schema-less, flexible queries
✅ **Powerful**: Full-text search, aggregations
✅ **Analytics**: Built-in analytics capabilities
✅ **REST API**: Easy to integrate

### Cons

❌ **Resource Intensive**: Requires significant RAM
❌ **Complexity**: Steep learning curve
❌ **Data Loss Risk**: Not ACID compliant
❌ **Cost**: Can be expensive at scale
❌ **Maintenance**: Requires cluster management

## Hard Use-Case: E-Commerce Search

### Problem Statement

Build a product search with filters, sorting, and faceted navigation.

### Solution

```python
def search_products(query: str, filters: dict, sort: str):
    search_body = {
        'query': {
            'bool': {
                'must': [
                    {'multi_match': {
                        'query': query,
                        'fields': ['name^3', 'description'],
                        'type': 'best_fields'
                    }}
                ],
                'filter': []
            }
        },
        'aggs': {
            'categories': {'terms': {'field': 'category'}},
            'price_ranges': {
                'range': {
                    'field': 'price',
                    'ranges': [
                        {'to': 100},
                        {'from': 100, 'to': 500},
                        {'from': 500}
                    ]
                }
            }
        },
        'sort': [
            {sort: {'order': 'desc'}}
        ]
    }
    
    # Add filters
    if filters.get('category'):
        search_body['query']['bool']['filter'].append(
            {'term': {'category': filters['category']}}
        )
    
    if filters.get('min_price'):
        search_body['query']['bool']['filter'].append(
            {'range': {'price': {'gte': filters['min_price']}}}
        )
    
    return es.search(index='products', body=search_body)
```

## Edge Cases and Pitfalls

### Common Mistakes

1. **Not Mapping Fields Properly**
   - Use 'text' for full-text search
   - Use 'keyword' for exact matches
   - Define analyzers appropriately

2. **Over-Sharding**
   - Too many shards hurt performance
   - Follow shard size guidelines
   - Monitor shard count

3. **Not Using Aggregations**
   - Use aggregations for analytics
   - More efficient than application-side processing
   - Built-in faceting support

## References and Further Reading

- Elasticsearch Official Documentation
- Elasticsearch: The Definitive Guide

## Quiz

### Question 1
What is the main difference between 'text' and 'keyword' field types in Elasticsearch?

**A)** Text is faster  
**B)** Text is analyzed for full-text search, keyword is for exact matches  
**C)** Keyword supports aggregations  
**D)** No difference

**Answer: B** - Text fields are analyzed for full-text search, while keyword fields store exact values for filtering and aggregations.

## Related Topics

- [Database Fundamentals](../01_beginners/03.%20Database%20Fundamentals.md)
- [Full-Text Search Strategies](../03_advanced/09.%20Full-Text%20Search%20Strategies.md)

