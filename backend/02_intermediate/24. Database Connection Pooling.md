---
number: 24
title: "Database Connection Pooling"
slug: "database-connection-pooling"
level: "intermediate"
tags: ["backend", "database", "connection-pooling", "performance", "optimization"]
prerequisites: ["postgresql-deep-dive"]
estimated_minutes: 105
contributors: []
diagrams: []
examples: []
canonical_id: "backend-intermediate-24"
---

# Database Connection Pooling

## Overview

Connection pooling manages database connections efficiently. This guide covers pool configuration, connection lifecycle, pool sizing strategies, connection health checks, and optimizing database performance.

## Deep Explanation

### Why Connection Pooling?

**Problem**: Creating connections is expensive
**Solution**: Reuse connections from pool
**Benefit**: Faster queries, better resource usage

### Pool Configuration

**Min Size**: Minimum connections in pool
**Max Size**: Maximum connections
**Idle Timeout**: Close idle connections
**Max Lifetime**: Maximum connection age

## Real Code Examples

### Example: PostgreSQL Connection Pool

```python
from sqlalchemy import create_engine
from sqlalchemy.pool import QueuePool

engine = create_engine(
    'postgresql://user:pass@localhost/db',
    poolclass=QueuePool,
    pool_size=10,           # Number of connections to maintain
    max_overflow=20,        # Additional connections allowed
    pool_pre_ping=True,     # Verify connections before using
    pool_recycle=3600,      # Recycle connections after 1 hour
    echo=False
)

# Usage
with engine.connect() as conn:
    result = conn.execute("SELECT * FROM users")
```

### Example: Connection Pool Monitoring

```python
from sqlalchemy import event
from sqlalchemy.pool import Pool

@event.listens_for(Pool, "connect")
def receive_connect(dbapi_conn, connection_record):
    print("Connection created")

@event.listens_for(Pool, "checkout")
def receive_checkout(dbapi_conn, connection_record, connection_proxy):
    print("Connection checked out")

@event.listens_for(Pool, "checkin")
def receive_checkin(dbapi_conn, connection_record):
    print("Connection checked in")

# Monitor pool stats
pool = engine.pool
print(f"Size: {pool.size()}")
print(f"Checked out: {pool.checkedout()}")
print(f"Overflow: {pool.overflow()}")
```

## Pros and Cons

### Pros

✅ **Performance**: Faster query execution
✅ **Resource Efficiency**: Reuse connections
✅ **Scalability**: Handle concurrent requests
✅ **Connection Management**: Automatic cleanup
✅ **Health Checks**: Verify connection health

### Cons

❌ **Memory Usage**: Each connection uses memory
❌ **Configuration**: Requires tuning
❌ **Complexity**: More complex than direct connections
❌ **Connection Limits**: Database connection limits
❌ **Stale Connections**: Need to handle stale connections

## Hard Use-Case: Multi-Database Pooling

### Problem Statement

Manage connection pools for multiple databases with different requirements.

### Solution

```python
# Read replica pool (more connections)
read_engine = create_engine(
    'postgresql://user:pass@read-replica/db',
    pool_size=20,
    max_overflow=30
)

# Write database pool (fewer connections)
write_engine = create_engine(
    'postgresql://user:pass@primary/db',
    pool_size=5,
    max_overflow=10
)

# Usage
def get_user(user_id):
    # Use read replica
    with read_engine.connect() as conn:
        return conn.execute("SELECT * FROM users WHERE id = ?", user_id)

def create_user(user_data):
    # Use primary database
    with write_engine.connect() as conn:
        conn.execute("INSERT INTO users ...", user_data)
        conn.commit()
```

## Edge Cases and Pitfalls

### Common Mistakes

1. **Pool Size Too Small**
   - Causes connection wait times
   - Monitor pool wait times
   - Adjust based on load

2. **Pool Size Too Large**
   - Wastes resources
   - May exceed database limits
   - Monitor connection usage

3. **Not Handling Stale Connections**
   - Use pool_pre_ping
   - Set pool_recycle
   - Handle connection errors

## References and Further Reading

- SQLAlchemy Connection Pooling
- Database Connection Pool Best Practices

## Quiz

### Question 1
What is the main purpose of connection pooling?

**A)** Encrypt connections  
**B)** Reuse database connections for better performance  
**C)** Limit database access  
**D)** Simplify queries

**Answer: B** - Connection pooling reuses database connections to improve performance and resource efficiency.

## Related Topics

- [PostgreSQL Deep Dive](./01.%20PostgreSQL%20Deep%20Dive.md)
- [Performance Optimization](../04_overachiever/03.%20Performance%20Optimization.md)

