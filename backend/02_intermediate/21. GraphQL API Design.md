---
number: 21
title: "GraphQL API Design"
slug: "graphql-api-design"
level: "intermediate"
tags: ["backend", "graphql", "api", "query-language", "schema"]
prerequisites: ["api-design-principles"]
estimated_minutes: 120
contributors: []
diagrams: []
examples: []
canonical_id: "backend-intermediate-21"
---

# GraphQL API Design

## Overview

GraphQL is a query language and runtime for APIs. This guide covers GraphQL schema design, queries and mutations, resolvers, subscriptions, N+1 problem solutions (DataLoader), and building efficient GraphQL APIs.

## Deep Explanation

### Core Concepts

**Schema**: Type definitions
**Query**: Read data
**Mutation**: Modify data
**Subscription**: Real-time updates
**Resolver**: Function that resolves field

### Schema Example

```graphql
type User {
  id: ID!
  name: String!
  email: String!
  posts: [Post!]!
}

type Post {
  id: ID!
  title: String!
  content: String!
  author: User!
}

type Query {
  user(id: ID!): User
  posts: [Post!]!
}

type Mutation {
  createUser(name: String!, email: String!): User!
  updateUser(id: ID!, name: String): User!
}
```

## Real Code Examples

### Example: GraphQL Server

```python
from ariadne import QueryType, MutationType, make_executable_schema
from ariadne.asgi import GraphQL

type_defs = """
    type User {
        id: ID!
        name: String!
        email: String!
    }
    
    type Query {
        user(id: ID!): User
        users: [User!]!
    }
    
    type Mutation {
        createUser(name: String!, email: String!): User!
    }
"""

query = QueryType()
mutation = MutationType()

@query.field("user")
def resolve_user(*_, id):
    return get_user_by_id(id)

@query.field("users")
def resolve_users(*_):
    return get_all_users()

@mutation.field("createUser")
def resolve_create_user(*_, name, email):
    return create_user(name, email)

schema = make_executable_schema(type_defs, query, mutation)
app = GraphQL(schema, debug=True)
```

### Example: Solving N+1 Problem with DataLoader

```python
from promise import Promise
from promise.dataloader import DataLoader

class UserLoader(DataLoader):
    def batch_load_fn(self, keys):
        users = get_users_by_ids(keys)
        user_map = {user.id: user for user in users}
        return [user_map.get(key) for key in keys]

user_loader = UserLoader()

@query.field("posts")
def resolve_posts(*_):
    posts = get_all_posts()
    # Batch load authors
    author_ids = [post.author_id for post in posts]
    authors = user_loader.load_many(author_ids)
    # Attach authors to posts
    for post, author in zip(posts, authors):
        post.author = author
    return posts
```

## Pros and Cons

### Pros

✅ **Flexible**: Clients request only needed data
✅ **Single Endpoint**: One endpoint for all operations
✅ **Strongly Typed**: Type system prevents errors
✅ **Introspection**: Self-documenting API
✅ **Real-Time**: Subscriptions for live updates

### Cons

❌ **Complexity**: More complex than REST
❌ **Caching**: Harder to cache than REST
❌ **Over-fetching Prevention**: Can lead to under-fetching
❌ **Learning Curve**: Requires learning GraphQL
❌ **Performance**: Complex queries can be slow

## Hard Use-Case: Nested Queries Optimization

### Problem Statement

Optimize GraphQL queries that fetch nested data efficiently.

### Solution

**Use DataLoader for Batching**:
```python
class PostLoader(DataLoader):
    def batch_load_fn(self, user_ids):
        posts = get_posts_by_user_ids(user_ids)
        posts_by_user = {}
        for post in posts:
            if post.user_id not in posts_by_user:
                posts_by_user[post.user_id] = []
            posts_by_user[post.user_id].append(post)
        return [posts_by_user.get(user_id, []) for user_id in user_ids]

post_loader = PostLoader()

@query.field("user")
def resolve_user(*_, id):
    user = get_user_by_id(id)
    user.posts_loader = post_loader.load(user.id)
    return user

@query.field("posts")
def resolve_posts(user, *_):
    return user.posts_loader
```

## Edge Cases and Pitfalls

### Common Mistakes

1. **Not Using DataLoader**
   - Causes N+1 query problem
   - Always batch database queries
   - Use DataLoader pattern

2. **Allowing Deep Nesting**
   - Limit query depth
   - Implement query complexity analysis
   - Set maximum depth limits

3. **Not Implementing Caching**
   - Cache resolvers appropriately
   - Use HTTP caching headers
   - Consider Redis for caching

## References and Further Reading

- GraphQL Official Documentation
- GraphQL Best Practices
- DataLoader Pattern

## Quiz

### Question 1
What is the main advantage of GraphQL over REST?

**A)** Simpler implementation  
**B)** Clients request only needed data  
**C)** Better caching  
**D)** Faster performance

**Answer: B** - GraphQL allows clients to request exactly the data they need, reducing over-fetching.

## Related Topics

- [API Design Principles](../01_beginners/02.%20API%20Design%20Principles.md)
- [gRPC Service Communication](./22.%20gRPC%20Service%20Communication.md)

