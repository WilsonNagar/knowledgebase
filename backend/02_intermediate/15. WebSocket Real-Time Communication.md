---
number: 15
title: "WebSocket Real-Time Communication"
slug: "websocket-real-time-communication"
level: "intermediate"
tags: ["backend", "websocket", "real-time", "bidirectional", "communication"]
prerequisites: ["api-design-principles"]
estimated_minutes: 115
contributors: []
diagrams: []
examples: []
canonical_id: "backend-intermediate-15"
---

# WebSocket Real-Time Communication

## Overview

WebSockets provide full-duplex communication channels over a single TCP connection. This guide covers WebSocket protocol, handshake process, message framing, connection management, scaling strategies, and building real-time applications.

## Deep Explanation

### WebSocket vs HTTP

**HTTP**: Request-response, stateless
**WebSocket**: Persistent connection, bidirectional

### Handshake Process

1. Client sends HTTP upgrade request
2. Server responds with 101 Switching Protocols
3. Connection upgraded to WebSocket
4. Full-duplex communication begins

### Message Types

**Text**: UTF-8 encoded strings
**Binary**: Binary data
**Control**: Ping/Pong, Close

## Real Code Examples

### Example: WebSocket Server

```python
from fastapi import FastAPI, WebSocket
import asyncio

app = FastAPI()

@app.websocket("/ws")
async def websocket_endpoint(websocket: WebSocket):
    await websocket.accept()
    try:
        while True:
            data = await websocket.receive_text()
            # Echo back
            await websocket.send_text(f"Echo: {data}")
    except:
        await websocket.close()
```

### Example: Broadcasting Messages

```python
class ConnectionManager:
    def __init__(self):
        self.active_connections: List[WebSocket] = []
    
    async def connect(self, websocket: WebSocket):
        await websocket.accept()
        self.active_connections.append(websocket)
    
    def disconnect(self, websocket: WebSocket):
        self.active_connections.remove(websocket)
    
    async def broadcast(self, message: str):
        for connection in self.active_connections:
            await connection.send_text(message)

manager = ConnectionManager()

@app.websocket("/ws")
async def websocket_endpoint(websocket: WebSocket):
    await manager.connect(websocket)
    try:
        while True:
            data = await websocket.receive_text()
            await manager.broadcast(data)
    except:
        manager.disconnect(websocket)
```

## Pros and Cons

### Pros

✅ **Real-Time**: Instant bidirectional communication
✅ **Efficient**: Lower overhead than HTTP polling
✅ **Persistent**: Single connection, no handshake overhead
✅ **Full-Duplex**: Both sides can send simultaneously
✅ **Standard**: Well-supported protocol

### Cons

❌ **Stateful**: Requires connection management
❌ **Scaling**: Harder to scale horizontally
❌ **Load Balancing**: Requires sticky sessions or shared state
❌ **Firewall Issues**: Some proxies block WebSockets
❌ **Resource Usage**: Each connection consumes resources

## Hard Use-Case: Scalable Chat System

### Problem Statement

Build a scalable chat system with WebSockets that works across multiple servers.

### Solution

**Architecture**:
```
Client → Load Balancer (sticky sessions)
          ↓
    WebSocket Server 1 → Redis Pub/Sub
    WebSocket Server 2 → Redis Pub/Sub
    WebSocket Server 3 → Redis Pub/Sub
```

**Implementation**:
```python
import redis
import json

r = redis.Redis()

@app.websocket("/ws/{room_id}")
async def websocket_endpoint(websocket: WebSocket, room_id: str):
    await websocket.accept()
    
    # Subscribe to Redis channel
    pubsub = r.pubsub()
    pubsub.subscribe(f'chat:{room_id}')
    
    async def receive_messages():
        for message in pubsub.listen():
            if message['type'] == 'message':
                await websocket.send_text(message['data'])
    
    async def send_messages():
        while True:
            data = await websocket.receive_text()
            # Publish to Redis
            r.publish(f'chat:{room_id}', data)
    
    await asyncio.gather(
        receive_messages(),
        send_messages()
    )
```

## Edge Cases and Pitfalls

### Common Mistakes

1. **Not Handling Disconnections**
   - Always implement reconnection logic
   - Clean up resources on disconnect
   - Handle connection timeouts

2. **Scaling Without Shared State**
   - Use Redis Pub/Sub or message queue
   - Implement sticky sessions or shared state
   - Consider using Socket.IO with Redis adapter

3. **Not Implementing Heartbeats**
   - Use Ping/Pong frames
   - Detect dead connections
   - Close stale connections

## References and Further Reading

- WebSocket RFC 6455
- Socket.IO Documentation
- Scaling WebSockets Guide

## Quiz

### Question 1
What HTTP status code indicates a successful WebSocket upgrade?

**A)** 200 OK  
**B)** 101 Switching Protocols  
**C)** 201 Created  
**D)** 204 No Content

**Answer: B** - 101 Switching Protocols indicates successful WebSocket upgrade.

## Related Topics

- [API Design Principles](../01_beginners/02.%20API%20Design%20Principles.md)
- [Redis Pub/Sub and Advanced Patterns](./14.%20Redis%20Pub_Sub%20and%20Advanced%20Patterns.md)

